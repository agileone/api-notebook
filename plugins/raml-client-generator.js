!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var n;"undefined"!=typeof window?n=window:"undefined"!=typeof global?n=global:"undefined"!=typeof self&&(n=self),n.ramlClientGeneratorPlugin=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        throw TypeError('Uncaught, unspecified "error" event.');
      }
      return false;
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],3:[function(require,module,exports){
var http = module.exports;
var EventEmitter = require('events').EventEmitter;
var Request = require('./lib/request');
var url = require('url')

http.request = function (params, cb) {
    if (typeof params === 'string') {
        params = url.parse(params)
    }
    if (!params) params = {};
    if (!params.host && !params.port) {
        params.port = parseInt(window.location.port, 10);
    }
    if (!params.host && params.hostname) {
        params.host = params.hostname;
    }
    
    if (!params.scheme) params.scheme = window.location.protocol.split(':')[0];
    if (!params.host) {
        params.host = window.location.hostname || window.location.host;
    }
    if (/:/.test(params.host)) {
        if (!params.port) {
            params.port = params.host.split(':')[1];
        }
        params.host = params.host.split(':')[0];
    }
    if (!params.port) params.port = params.scheme == 'https' ? 443 : 80;
    
    var req = new Request(new xhrHttp, params);
    if (cb) req.on('response', cb);
    return req;
};

http.get = function (params, cb) {
    params.method = 'GET';
    var req = http.request(params, cb);
    req.end();
    return req;
};

http.Agent = function () {};
http.Agent.defaultMaxSockets = 4;

var xhrHttp = (function () {
    if (typeof window === 'undefined') {
        throw new Error('no window object present');
    }
    else if (window.XMLHttpRequest) {
        return window.XMLHttpRequest;
    }
    else if (window.ActiveXObject) {
        var axs = [
            'Msxml2.XMLHTTP.6.0',
            'Msxml2.XMLHTTP.3.0',
            'Microsoft.XMLHTTP'
        ];
        for (var i = 0; i < axs.length; i++) {
            try {
                var ax = new(window.ActiveXObject)(axs[i]);
                return function () {
                    if (ax) {
                        var ax_ = ax;
                        ax = null;
                        return ax_;
                    }
                    else {
                        return new(window.ActiveXObject)(axs[i]);
                    }
                };
            }
            catch (e) {}
        }
        throw new Error('ajax not supported in this browser')
    }
    else {
        throw new Error('ajax not supported in this browser');
    }
})();

},{"./lib/request":4,"events":2,"url":25}],4:[function(require,module,exports){
var Stream = require('stream');
var Response = require('./response');
var Base64 = require('Base64');
var inherits = require('inherits');

var Request = module.exports = function (xhr, params) {
    var self = this;
    self.writable = true;
    self.xhr = xhr;
    self.body = [];
    
    self.uri = (params.scheme || 'http') + '://'
        + params.host
        + (params.port ? ':' + params.port : '')
        + (params.path || '/')
    ;
    
    try { xhr.withCredentials = true }
    catch (e) {}
    
    xhr.open(
        params.method || 'GET',
        self.uri,
        true
    );
    
    if (params.headers) {
        var keys = objectKeys(params.headers);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!self.isSafeRequestHeader(key)) continue;
            var value = params.headers[key];
            if (isArray(value)) {
                for (var j = 0; j < value.length; j++) {
                    xhr.setRequestHeader(key, value[j]);
                }
            }
            else xhr.setRequestHeader(key, value)
        }
    }
    
    if (params.auth) {
        //basic auth
        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
    }

    var res = new Response;
    res.on('close', function () {
        self.emit('close');
    });
    
    res.on('ready', function () {
        self.emit('response', res);
    });
    
    xhr.onreadystatechange = function () {
        res.handle(xhr);
    };
};

inherits(Request, Stream);

Request.prototype.setHeader = function (key, value) {
    if (isArray(value)) {
        for (var i = 0; i < value.length; i++) {
            this.xhr.setRequestHeader(key, value[i]);
        }
    }
    else {
        this.xhr.setRequestHeader(key, value);
    }
};

Request.prototype.write = function (s) {
    this.body.push(s);
};

Request.prototype.destroy = function (s) {
    this.xhr.abort();
    this.emit('close');
};

Request.prototype.end = function (s) {
    if (s !== undefined) this.body.push(s);
    if (this.body.length === 0) {
        this.xhr.send('');
    }
    else if (typeof this.body[0] === 'string') {
        this.xhr.send(this.body.join(''));
    }
    else if (isArray(this.body[0])) {
        var body = [];
        for (var i = 0; i < this.body.length; i++) {
            body.push.apply(body, this.body[i]);
        }
        this.xhr.send(body);
    }
    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
        var len = 0;
        for (var i = 0; i < this.body.length; i++) {
            len += this.body[i].length;
        }
        var body = new(this.body[0].constructor)(len);
        var k = 0;
        
        for (var i = 0; i < this.body.length; i++) {
            var b = this.body[i];
            for (var j = 0; j < b.length; j++) {
                body[k++] = b[j];
            }
        }
        this.xhr.send(body);
    }
    else {
        var body = '';
        for (var i = 0; i < this.body.length; i++) {
            body += this.body[i].toString();
        }
        this.xhr.send(body);
    }
};

// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
Request.unsafeHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "content-transfer-encoding",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "user-agent",
    "via"
];

Request.prototype.isSafeRequestHeader = function (headerName) {
    if (!headerName) return false;
    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
};

var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var indexOf = function (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (xs[i] === x) return i;
    }
    return -1;
};

},{"./response":5,"Base64":6,"inherits":8,"stream":18}],5:[function(require,module,exports){
var Stream = require('stream');
var util = require('util');

var Response = module.exports = function (res) {
    this.offset = 0;
    this.readable = true;
};

util.inherits(Response, Stream);

var capable = {
    streaming : true,
    status2 : true
};

function parseHeaders (res) {
    var lines = res.getAllResponseHeaders().split(/\r?\n/);
    var headers = {};
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (line === '') continue;
        
        var m = line.match(/^([^:]+):\s*(.*)/);
        if (m) {
            var key = m[1].toLowerCase(), value = m[2];
            
            if (headers[key] !== undefined) {
            
                if (isArray(headers[key])) {
                    headers[key].push(value);
                }
                else {
                    headers[key] = [ headers[key], value ];
                }
            }
            else {
                headers[key] = value;
            }
        }
        else {
            headers[line] = true;
        }
    }
    return headers;
}

Response.prototype.getResponse = function (xhr) {
    var respType = String(xhr.responseType).toLowerCase();
    if (respType === 'blob') return xhr.responseBlob || xhr.response;
    if (respType === 'arraybuffer') return xhr.response;
    return xhr.responseText;
}

Response.prototype.getHeader = function (key) {
    return this.headers[key.toLowerCase()];
};

Response.prototype.handle = function (res) {
    if (res.readyState === 2 && capable.status2) {
        try {
            this.statusCode = res.status;
            this.headers = parseHeaders(res);
        }
        catch (err) {
            capable.status2 = false;
        }
        
        if (capable.status2) {
            this.emit('ready');
        }
    }
    else if (capable.streaming && res.readyState === 3) {
        try {
            if (!this.statusCode) {
                this.statusCode = res.status;
                this.headers = parseHeaders(res);
                this.emit('ready');
            }
        }
        catch (err) {}
        
        try {
            this._emitData(res);
        }
        catch (err) {
            capable.streaming = false;
        }
    }
    else if (res.readyState === 4) {
        if (!this.statusCode) {
            this.statusCode = res.status;
            this.emit('ready');
        }
        this._emitData(res);
        
        if (res.error) {
            this.emit('error', this.getResponse(res));
        }
        else this.emit('end');
        
        this.emit('close');
    }
};

Response.prototype._emitData = function (res) {
    var respBody = this.getResponse(res);
    if (respBody.toString().match(/ArrayBuffer/)) {
        this.emit('data', new Uint8Array(respBody, this.offset));
        this.offset = respBody.byteLength;
        return;
    }
    if (respBody.length > this.offset) {
        this.emit('data', respBody.slice(this.offset));
        this.offset = respBody.length;
    }
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},{"stream":18,"util":27}],6:[function(require,module,exports){
;(function () {

  var object = typeof exports != 'undefined' ? exports : this; // #8: web workers
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  function InvalidCharacterError(message) {
    this.message = message;
  }
  InvalidCharacterError.prototype = new Error;
  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

  // encoder
  // [https://gist.github.com/999166] by [https://github.com/nignag]
  object.btoa || (
  object.btoa = function (input) {
    for (
      // initialize result and counter
      var block, charCode, idx = 0, map = chars, output = '';
      // if the next input index does not exist:
      //   change the mapping table to "="
      //   check if d has no fractional digits
      input.charAt(idx | 0) || (map = '=', idx % 1);
      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
    ) {
      charCode = input.charCodeAt(idx += 3/4);
      if (charCode > 0xFF) {
        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
      }
      block = block << 8 | charCode;
    }
    return output;
  });

  // decoder
  // [https://gist.github.com/1020396] by [https://github.com/atk]
  object.atob || (
  object.atob = function (input) {
    input = input.replace(/=+$/, '');
    if (input.length % 4 == 1) {
      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
    }
    for (
      // initialize result and counters
      var bc = 0, bs, buffer, idx = 0, output = '';
      // get next character
      buffer = input.charAt(idx++);
      // character found in table? initialize bit storage and add its ascii value;
      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
        // and if not first of each 4 characters,
        // convert the first 8 bits to one ascii character
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
    ) {
      // try to find character in table (0-63, not found => -1)
      buffer = chars.indexOf(buffer);
    }
    return output;
  });

}());

},{}],7:[function(require,module,exports){
var http = require('http');

var https = module.exports;

for (var key in http) {
    if (http.hasOwnProperty(key)) https[key] = http[key];
};

https.request = function (params, cb) {
    if (!params) params = {};
    params.scheme = 'https';
    return http.request.call(this, params, cb);
}

},{"http":3}],8:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],9:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],10:[function(require,module,exports){
var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
   // Detect if browser supports Typed Arrays. Supported browsers are IE 10+,
   // Firefox 4+, Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+.
   if (typeof Uint8Array === 'undefined' || typeof ArrayBuffer === 'undefined')
      return false

  // Does the browser support adding properties to `Uint8Array` instances? If
  // not, then that's the same as no `Uint8Array` support. We need to be able to
  // add all the node Buffer API methods.
  // Relevant Firefox bug: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var arr = new Uint8Array(0)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // Assume object is an array
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof Uint8Array === 'function' &&
      subject instanceof Uint8Array) {
    // Speed optimization -- use set if we're copying from a Uint8Array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  switch (encoding) {
    case 'hex':
      return _hexWrite(this, string, offset, length)
    case 'utf8':
    case 'utf-8':
    case 'ucs2': // TODO: No support for ucs2 or utf16le encodings yet
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return _utf8Write(this, string, offset, length)
    case 'ascii':
      return _asciiWrite(this, string, offset, length)
    case 'binary':
      return _binaryWrite(this, string, offset, length)
    case 'base64':
      return _base64Write(this, string, offset, length)
    default:
      throw new Error('Unknown encoding')
  }
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  switch (encoding) {
    case 'hex':
      return _hexSlice(self, start, end)
    case 'utf8':
    case 'utf-8':
    case 'ucs2': // TODO: No support for ucs2 or utf16le encodings yet
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return _utf8Slice(self, start, end)
    case 'ascii':
      return _asciiSlice(self, start, end)
    case 'binary':
      return _binarySlice(self, start, end)
    case 'base64':
      return _base64Slice(self, start, end)
    default:
      throw new Error('Unknown encoding')
  }
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  // copy!
  for (var i = 0; i < end - start; i++)
    target[i + target_start] = this[i + start]
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

// http://nodejs.org/api/buffer.html#buffer_buf_slice_start_end
Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array === 'function') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment the Uint8Array *instance* (not the class!) with Buffer methods
 */
function augment (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value == 'number', 'cannot write a non-number as a number')
  assert(value >= 0,
      'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint(value, max, min) {
  assert(typeof value == 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754(value, max, min) {
  assert(typeof value == 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":11,"ieee754":12}],11:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var ZERO   = '0'.charCodeAt(0)
	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	module.exports.toByteArray = b64ToByteArray
	module.exports.fromByteArray = uint8ToBase64
}())

},{}],12:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],13:[function(require,module,exports){
(function (global){
/*! http://mths.be/punycode v1.2.4 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports;
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		while (length--) {
			array[length] = fn(array[length]);
		}
		return array;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings.
	 * @private
	 * @param {String} domain The domain name.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		return map(string.split(regexSeparators), fn).join('.');
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols to a Punycode string of ASCII-only
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name to Unicode. Only the
	 * Punycoded parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it on a string that has already been converted to
	 * Unicode.
	 * @memberOf punycode
	 * @param {String} domain The Punycode domain name to convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(domain) {
		return mapDomain(domain, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name to Punycode. Only the
	 * non-ASCII parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it with a domain that's already in ASCII.
	 * @memberOf punycode
	 * @param {String} domain The domain name to convert, as a Unicode string.
	 * @returns {String} The Punycode representation of the given domain name.
	 */
	function toASCII(domain) {
		return mapDomain(domain, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.2.4',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],14:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],15:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],16:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":14,"./encode":15}],17:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;
var inherits = require('inherits');
var setImmediate = require('process/browser.js').nextTick;
var Readable = require('./readable.js');
var Writable = require('./writable.js');

inherits(Duplex, Readable);

Duplex.prototype.write = Writable.prototype.write;
Duplex.prototype.end = Writable.prototype.end;
Duplex.prototype._write = Writable.prototype._write;

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  var self = this;
  setImmediate(function () {
    self.end();
  });
}

},{"./readable.js":21,"./writable.js":23,"inherits":8,"process/browser.js":19}],18:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('./readable.js');
Stream.Writable = require('./writable.js');
Stream.Duplex = require('./duplex.js');
Stream.Transform = require('./transform.js');
Stream.PassThrough = require('./passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"./duplex.js":17,"./passthrough.js":20,"./readable.js":21,"./transform.js":22,"./writable.js":23,"events":2,"inherits":8}],19:[function(require,module,exports){
module.exports=require(9)
},{}],20:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./transform.js');
var inherits = require('inherits');
inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./transform.js":22,"inherits":8}],21:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;
Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;
var Stream = require('./index.js');
var Buffer = require('buffer').Buffer;
var setImmediate = require('process/browser.js').nextTick;
var StringDecoder;

var inherits = require('inherits');
inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || n === null) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode &&
      !er) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    setImmediate(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    setImmediate(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    setImmediate(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  // check for listeners before emit removes one-time listeners.
  var errListeners = EE.listenerCount(dest, 'error');
  function onerror(er) {
    unpipe();
    if (errListeners === 0 && EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  dest.once('error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    setImmediate(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      setImmediate(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, function (x) {
      return self.emit.apply(self, ev, x);
    });
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    setImmediate(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require("/Users/blakeembrey/Projects/api-notebook/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"./index.js":18,"/Users/blakeembrey/Projects/api-notebook/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":9,"buffer":10,"events":2,"inherits":8,"process/browser.js":19,"string_decoder":24}],22:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./duplex.js');
var inherits = require('inherits');
inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./duplex.js":17,"inherits":8}],23:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;
Writable.WritableState = WritableState;

var isUint8Array = typeof Uint8Array !== 'undefined'
  ? function (x) { return x instanceof Uint8Array }
  : function (x) {
    return x && x.constructor && x.constructor.name === 'Uint8Array'
  }
;
var isArrayBuffer = typeof ArrayBuffer !== 'undefined'
  ? function (x) { return x instanceof ArrayBuffer }
  : function (x) {
    return x && x.constructor && x.constructor.name === 'ArrayBuffer'
  }
;

var inherits = require('inherits');
var Stream = require('./index.js');
var setImmediate = require('process/browser.js').nextTick;
var Buffer = require('buffer').Buffer;

inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];
}

function Writable(options) {
  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Stream.Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  setImmediate(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    setImmediate(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (!Buffer.isBuffer(chunk) && isUint8Array(chunk))
    chunk = new Buffer(chunk);
  if (isArrayBuffer(chunk) && typeof Uint8Array !== 'undefined')
    chunk = new Buffer(new Uint8Array(chunk));
  
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  state.needDrain = !ret;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    setImmediate(function() {
      cb(er);
    });
  else
    cb(er);

  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      setImmediate(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      setImmediate(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

},{"./index.js":18,"buffer":10,"inherits":8,"process/browser.js":19}],24:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

function assertEncoding(encoding) {
  if (encoding && !Buffer.isEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  this.charBuffer = new Buffer(6);
  this.charReceived = 0;
  this.charLength = 0;
};


StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  var offset = 0;

  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var i = (buffer.length >= this.charLength - this.charReceived) ?
                this.charLength - this.charReceived :
                buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, offset, i);
    this.charReceived += (i - offset);
    offset = i;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (i == buffer.length) return charStr;

    // otherwise cut off the characters end from the beginning of this buffer
    buffer = buffer.slice(i, buffer.length);
    break;
  }

  var lenIncomplete = this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - lenIncomplete, end);
    this.charReceived = lenIncomplete;
    end -= lenIncomplete;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    this.charBuffer.write(charStr.charAt(charStr.length - 1), this.encoding);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }

  return i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 2;
  this.charLength = incomplete ? 2 : 0;
  return incomplete;
}

function base64DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 3;
  this.charLength = incomplete ? 3 : 0;
  return incomplete;
}

},{"buffer":10}],25:[function(require,module,exports){
/*jshint strict:true node:true es5:true onevar:true laxcomma:true laxbreak:true eqeqeq:true immed:true latedef:true*/
(function () {
  "use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '~', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(delims),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#']
      .concat(unwise).concat(autoEscape),
    nonAuthChars = ['/', '@', '?', '#'].concat(delims),
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-zA-Z0-9][a-z0-9A-Z_-]{0,62}$/,
    hostnamePartStart = /^([a-zA-Z0-9][a-z0-9A-Z_-]{0,62})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always have a path component.
    pathedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && typeof(url) === 'object' && url.href) return url;

  if (typeof url !== 'string') {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var out = {},
      rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    out.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      out.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    // don't enforce full RFC correctness, just be unstupid about it.

    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the first @ sign, unless some non-auth character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    var atSign = rest.indexOf('@');
    if (atSign !== -1) {
      var auth = rest.slice(0, atSign);

      // there *may be* an auth
      var hasAuth = true;
      for (var i = 0, l = nonAuthChars.length; i < l; i++) {
        if (auth.indexOf(nonAuthChars[i]) !== -1) {
          // not a valid auth.  Something like http://foo.com/bar@baz/
          hasAuth = false;
          break;
        }
      }

      if (hasAuth) {
        // pluck off the auth portion.
        out.auth = decodeURIComponent(auth);
        rest = rest.substr(atSign + 1);
      }
    }

    var firstNonHost = -1;
    for (var i = 0, l = nonHostChars.length; i < l; i++) {
      var index = rest.indexOf(nonHostChars[i]);
      if (index !== -1 &&
          (firstNonHost < 0 || index < firstNonHost)) firstNonHost = index;
    }

    if (firstNonHost !== -1) {
      out.host = rest.substr(0, firstNonHost);
      rest = rest.substr(firstNonHost);
    } else {
      out.host = rest;
      rest = '';
    }

    // pull out port.
    var p = parseHost(out.host);
    var keys = Object.keys(p);
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      out[key] = p[key];
    }

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    out.hostname = out.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = out.hostname[0] === '[' &&
        out.hostname[out.hostname.length - 1] === ']';

    // validate a little.
    if (out.hostname.length > hostnameMaxLen) {
      out.hostname = '';
    } else if (!ipv6Hostname) {
      var hostparts = out.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            out.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    // hostnames are always lower case.
    out.hostname = out.hostname.toLowerCase();

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = out.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      out.hostname = newOut.join('.');
    }

    out.host = (out.hostname || '') +
        ((out.port) ? ':' + out.port : '');
    out.href += out.host;

    // strip [ and ] from the hostname
    if (ipv6Hostname) {
      out.hostname = out.hostname.substr(1, out.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    out.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    out.search = rest.substr(qm);
    out.query = rest.substr(qm + 1);
    if (parseQueryString) {
      out.query = querystring.parse(out.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    out.search = '';
    out.query = {};
  }
  if (rest) out.pathname = rest;
  if (slashedProtocol[proto] &&
      out.hostname && !out.pathname) {
    out.pathname = '/';
  }

  //to support http.request
  if (out.pathname || out.search) {
    out.path = (out.pathname ? out.pathname : '') +
               (out.search ? out.search : '');
  }

  // finally, reconstruct the href based on what has been validated.
  out.href = urlFormat(out);
  return out;
}

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (typeof(obj) === 'string') obj = urlParse(obj);

  var auth = obj.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = obj.protocol || '',
      pathname = obj.pathname || '',
      hash = obj.hash || '',
      host = false,
      query = '';

  if (obj.host !== undefined) {
    host = auth + obj.host;
  } else if (obj.hostname !== undefined) {
    host = auth + (obj.hostname.indexOf(':') === -1 ?
        obj.hostname :
        '[' + obj.hostname + ']');
    if (obj.port) {
      host += ':' + obj.port;
    }
  }

  if (obj.query && typeof obj.query === 'object' &&
      Object.keys(obj.query).length) {
    query = querystring.stringify(obj.query);
  }

  var search = obj.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (obj.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  return protocol + host + pathname + search + hash;
}

function urlResolve(source, relative) {
  return urlFormat(urlResolveObject(source, relative));
}

function urlResolveObject(source, relative) {
  if (!source) return relative;

  source = urlParse(urlFormat(source), false, true);
  relative = urlParse(urlFormat(relative), false, true);

  // hash is always overridden, no matter what.
  source.hash = relative.hash;

  if (relative.href === '') {
    source.href = urlFormat(source);
    return source;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    relative.protocol = source.protocol;
    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[relative.protocol] &&
        relative.hostname && !relative.pathname) {
      relative.path = relative.pathname = '/';
    }
    relative.href = urlFormat(relative);
    return relative;
  }

  if (relative.protocol && relative.protocol !== source.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      relative.href = urlFormat(relative);
      return relative;
    }
    source.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      relative.pathname = relPath.join('/');
    }
    source.pathname = relative.pathname;
    source.search = relative.search;
    source.query = relative.query;
    source.host = relative.host || '';
    source.auth = relative.auth;
    source.hostname = relative.hostname || relative.host;
    source.port = relative.port;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.slashes = source.slashes || relative.slashes;
    source.href = urlFormat(source);
    return source;
  }

  var isSourceAbs = (source.pathname && source.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host !== undefined ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (source.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = source.pathname && source.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = source.protocol &&
          !slashedProtocol[source.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // source.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {

    delete source.hostname;
    delete source.port;
    if (source.host) {
      if (srcPath[0] === '') srcPath[0] = source.host;
      else srcPath.unshift(source.host);
    }
    delete source.host;
    if (relative.protocol) {
      delete relative.hostname;
      delete relative.port;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      delete relative.host;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    source.host = (relative.host || relative.host === '') ?
                      relative.host : source.host;
    source.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : source.hostname;
    source.search = relative.search;
    source.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    source.search = relative.search;
    source.query = relative.query;
  } else if ('search' in relative) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      source.hostname = source.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = source.host && source.host.indexOf('@') > 0 ?
                       source.host.split('@') : false;
      if (authInHost) {
        source.auth = authInHost.shift();
        source.host = source.hostname = authInHost.shift();
      }
    }
    source.search = relative.search;
    source.query = relative.query;
    //to support http.request
    if (source.pathname !== undefined || source.search !== undefined) {
      source.path = (source.pathname ? source.pathname : '') +
                    (source.search ? source.search : '');
    }
    source.href = urlFormat(source);
    return source;
  }
  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    delete source.pathname;
    //to support http.request
    if (!source.search) {
      source.path = '/' + source.search;
    } else {
      delete source.path;
    }
    source.href = urlFormat(source);
    return source;
  }
  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (source.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    source.hostname = source.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = source.host && source.host.indexOf('@') > 0 ?
                     source.host.split('@') : false;
    if (authInHost) {
      source.auth = authInHost.shift();
      source.host = source.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (source.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  source.pathname = srcPath.join('/');
  //to support request.http
  if (source.pathname !== undefined || source.search !== undefined) {
    source.path = (source.pathname ? source.pathname : '') +
                  (source.search ? source.search : '');
  }
  source.auth = relative.auth || source.auth;
  source.slashes = source.slashes || relative.slashes;
  source.href = urlFormat(source);
  return source;
}

function parseHost(host) {
  var out = {};
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      out.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) out.hostname = host;
  return out;
}

}());

},{"punycode":13,"querystring":16}],26:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],27:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require("/Users/blakeembrey/Projects/api-notebook/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":26,"/Users/blakeembrey/Projects/api-notebook/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":9,"inherits":8}],28:[function(require,module,exports){

/**
 * Escape regexp special characters in `str`.
 *
 * @param {String} str
 * @return {String}
 * @api public
 */

module.exports = function(str){
  return String(str).replace(/([.*+?=^!:${}()|[\]\/\\])/g, '\\$1');
};
},{}],29:[function(require,module,exports){

/**
 * Module dependencies.
 */

var types = require('./types');

/**
 * Expose the types.
 */

exports.types = types;

/**
 * Lookup with `ext`.
 *
 * @param {String} ext
 * @return {String}
 * @api public
 */

exports.lookup = function(ext){
  if ('.' == ext[0]) ext = ext.slice(1);
  return types[ext];
};
},{"./types":30}],30:[function(require,module,exports){
module.exports = { '123': 'application/vnd.lotus-1-2-3',
  ez: 'application/andrew-inset',
  aw: 'application/applixware',
  atom: 'application/atom+xml',
  atomcat: 'application/atomcat+xml',
  atomsvc: 'application/atomsvc+xml',
  ccxml: 'application/ccxml+xml',
  cdmia: 'application/cdmi-capability',
  cdmic: 'application/cdmi-container',
  cdmid: 'application/cdmi-domain',
  cdmio: 'application/cdmi-object',
  cdmiq: 'application/cdmi-queue',
  cu: 'application/cu-seeme',
  davmount: 'application/davmount+xml',
  dbk: 'application/docbook+xml',
  dssc: 'application/dssc+der',
  xdssc: 'application/dssc+xml',
  ecma: 'application/ecmascript',
  emma: 'application/emma+xml',
  epub: 'application/epub+zip',
  exi: 'application/exi',
  pfr: 'application/font-tdpfr',
  gml: 'application/gml+xml',
  gpx: 'application/gpx+xml',
  gxf: 'application/gxf',
  stk: 'application/hyperstudio',
  ink: 'application/inkml+xml',
  inkml: 'application/inkml+xml',
  ipfix: 'application/ipfix',
  jar: 'application/java-archive',
  ser: 'application/java-serialized-object',
  class: 'application/java-vm',
  js: 'application/javascript',
  json: 'application/json',
  jsonml: 'application/jsonml+json',
  lostxml: 'application/lost+xml',
  hqx: 'application/mac-binhex40',
  cpt: 'application/mac-compactpro',
  mads: 'application/mads+xml',
  mrc: 'application/marc',
  mrcx: 'application/marcxml+xml',
  ma: 'application/mathematica',
  nb: 'application/mathematica',
  mb: 'application/mathematica',
  mathml: 'application/mathml+xml',
  mbox: 'application/mbox',
  mscml: 'application/mediaservercontrol+xml',
  metalink: 'application/metalink+xml',
  meta4: 'application/metalink4+xml',
  mets: 'application/mets+xml',
  mods: 'application/mods+xml',
  m21: 'application/mp21',
  mp21: 'application/mp21',
  mp4s: 'application/mp4',
  doc: 'application/msword',
  dot: 'application/msword',
  mxf: 'application/mxf',
  bin: 'application/octet-stream',
  dms: 'application/octet-stream',
  lrf: 'application/octet-stream',
  mar: 'application/octet-stream',
  so: 'application/octet-stream',
  dist: 'application/octet-stream',
  distz: 'application/octet-stream',
  pkg: 'application/octet-stream',
  bpk: 'application/octet-stream',
  dump: 'application/octet-stream',
  elc: 'application/octet-stream',
  deploy: 'application/octet-stream',
  oda: 'application/oda',
  opf: 'application/oebps-package+xml',
  ogx: 'application/ogg',
  omdoc: 'application/omdoc+xml',
  onetoc: 'application/onenote',
  onetoc2: 'application/onenote',
  onetmp: 'application/onenote',
  onepkg: 'application/onenote',
  oxps: 'application/oxps',
  xer: 'application/patch-ops-error+xml',
  pdf: 'application/pdf',
  pgp: 'application/pgp-encrypted',
  asc: 'application/pgp-signature',
  sig: 'application/pgp-signature',
  prf: 'application/pics-rules',
  p10: 'application/pkcs10',
  p7m: 'application/pkcs7-mime',
  p7c: 'application/pkcs7-mime',
  p7s: 'application/pkcs7-signature',
  p8: 'application/pkcs8',
  ac: 'application/pkix-attr-cert',
  cer: 'application/pkix-cert',
  crl: 'application/pkix-crl',
  pkipath: 'application/pkix-pkipath',
  pki: 'application/pkixcmp',
  pls: 'application/pls+xml',
  ai: 'application/postscript',
  eps: 'application/postscript',
  ps: 'application/postscript',
  cww: 'application/prs.cww',
  pskcxml: 'application/pskc+xml',
  rdf: 'application/rdf+xml',
  rif: 'application/reginfo+xml',
  rnc: 'application/relax-ng-compact-syntax',
  rl: 'application/resource-lists+xml',
  rld: 'application/resource-lists-diff+xml',
  rs: 'application/rls-services+xml',
  gbr: 'application/rpki-ghostbusters',
  mft: 'application/rpki-manifest',
  roa: 'application/rpki-roa',
  rsd: 'application/rsd+xml',
  rss: 'application/rss+xml',
  rtf: 'application/rtf',
  sbml: 'application/sbml+xml',
  scq: 'application/scvp-cv-request',
  scs: 'application/scvp-cv-response',
  spq: 'application/scvp-vp-request',
  spp: 'application/scvp-vp-response',
  sdp: 'application/sdp',
  setpay: 'application/set-payment-initiation',
  setreg: 'application/set-registration-initiation',
  shf: 'application/shf+xml',
  smi: 'application/smil+xml',
  smil: 'application/smil+xml',
  rq: 'application/sparql-query',
  srx: 'application/sparql-results+xml',
  gram: 'application/srgs',
  grxml: 'application/srgs+xml',
  sru: 'application/sru+xml',
  ssdl: 'application/ssdl+xml',
  ssml: 'application/ssml+xml',
  tei: 'application/tei+xml',
  teicorpus: 'application/tei+xml',
  tfi: 'application/thraud+xml',
  tsd: 'application/timestamped-data',
  plb: 'application/vnd.3gpp.pic-bw-large',
  psb: 'application/vnd.3gpp.pic-bw-small',
  pvb: 'application/vnd.3gpp.pic-bw-var',
  tcap: 'application/vnd.3gpp2.tcap',
  pwn: 'application/vnd.3m.post-it-notes',
  aso: 'application/vnd.accpac.simply.aso',
  imp: 'application/vnd.accpac.simply.imp',
  acu: 'application/vnd.acucobol',
  atc: 'application/vnd.acucorp',
  acutc: 'application/vnd.acucorp',
  air: 'application/vnd.adobe.air-application-installer-package+zip',
  fcdt: 'application/vnd.adobe.formscentral.fcdt',
  fxp: 'application/vnd.adobe.fxp',
  fxpl: 'application/vnd.adobe.fxp',
  xdp: 'application/vnd.adobe.xdp+xml',
  xfdf: 'application/vnd.adobe.xfdf',
  ahead: 'application/vnd.ahead.space',
  azf: 'application/vnd.airzip.filesecure.azf',
  azs: 'application/vnd.airzip.filesecure.azs',
  azw: 'application/vnd.amazon.ebook',
  acc: 'application/vnd.americandynamics.acc',
  ami: 'application/vnd.amiga.ami',
  apk: 'application/vnd.android.package-archive',
  cii: 'application/vnd.anser-web-certificate-issue-initiation',
  fti: 'application/vnd.anser-web-funds-transfer-initiation',
  atx: 'application/vnd.antix.game-component',
  mpkg: 'application/vnd.apple.installer+xml',
  m3u8: 'application/vnd.apple.mpegurl',
  swi: 'application/vnd.aristanetworks.swi',
  iota: 'application/vnd.astraea-software.iota',
  aep: 'application/vnd.audiograph',
  mpm: 'application/vnd.blueice.multipass',
  bmi: 'application/vnd.bmi',
  rep: 'application/vnd.businessobjects',
  cdxml: 'application/vnd.chemdraw+xml',
  mmd: 'application/vnd.chipnuts.karaoke-mmd',
  cdy: 'application/vnd.cinderella',
  cla: 'application/vnd.claymore',
  rp9: 'application/vnd.cloanto.rp9',
  c4g: 'application/vnd.clonk.c4group',
  c4d: 'application/vnd.clonk.c4group',
  c4f: 'application/vnd.clonk.c4group',
  c4p: 'application/vnd.clonk.c4group',
  c4u: 'application/vnd.clonk.c4group',
  c11amc: 'application/vnd.cluetrust.cartomobile-config',
  c11amz: 'application/vnd.cluetrust.cartomobile-config-pkg',
  csp: 'application/vnd.commonspace',
  cdbcmsg: 'application/vnd.contact.cmsg',
  cmc: 'application/vnd.cosmocaller',
  clkx: 'application/vnd.crick.clicker',
  clkk: 'application/vnd.crick.clicker.keyboard',
  clkp: 'application/vnd.crick.clicker.palette',
  clkt: 'application/vnd.crick.clicker.template',
  clkw: 'application/vnd.crick.clicker.wordbank',
  wbs: 'application/vnd.criticaltools.wbs+xml',
  pml: 'application/vnd.ctc-posml',
  ppd: 'application/vnd.cups-ppd',
  car: 'application/vnd.curl.car',
  pcurl: 'application/vnd.curl.pcurl',
  dart: 'application/vnd.dart',
  rdz: 'application/vnd.data-vision.rdz',
  uvf: 'application/vnd.dece.data',
  uvvf: 'application/vnd.dece.data',
  uvd: 'application/vnd.dece.data',
  uvvd: 'application/vnd.dece.data',
  uvt: 'application/vnd.dece.ttml+xml',
  uvvt: 'application/vnd.dece.ttml+xml',
  uvx: 'application/vnd.dece.unspecified',
  uvvx: 'application/vnd.dece.unspecified',
  uvz: 'application/vnd.dece.zip',
  uvvz: 'application/vnd.dece.zip',
  fe_launch: 'application/vnd.denovo.fcselayout-link',
  dna: 'application/vnd.dna',
  mlp: 'application/vnd.dolby.mlp',
  dpg: 'application/vnd.dpgraph',
  dfac: 'application/vnd.dreamfactory',
  kpxx: 'application/vnd.ds-keypoint',
  ait: 'application/vnd.dvb.ait',
  svc: 'application/vnd.dvb.service',
  geo: 'application/vnd.dynageo',
  mag: 'application/vnd.ecowin.chart',
  nml: 'application/vnd.enliven',
  esf: 'application/vnd.epson.esf',
  msf: 'application/vnd.epson.msf',
  qam: 'application/vnd.epson.quickanime',
  slt: 'application/vnd.epson.salt',
  ssf: 'application/vnd.epson.ssf',
  es3: 'application/vnd.eszigno3+xml',
  et3: 'application/vnd.eszigno3+xml',
  ez2: 'application/vnd.ezpix-album',
  ez3: 'application/vnd.ezpix-package',
  fdf: 'application/vnd.fdf',
  mseed: 'application/vnd.fdsn.mseed',
  seed: 'application/vnd.fdsn.seed',
  dataless: 'application/vnd.fdsn.seed',
  gph: 'application/vnd.flographit',
  ftc: 'application/vnd.fluxtime.clip',
  fm: 'application/vnd.framemaker',
  frame: 'application/vnd.framemaker',
  maker: 'application/vnd.framemaker',
  book: 'application/vnd.framemaker',
  fnc: 'application/vnd.frogans.fnc',
  ltf: 'application/vnd.frogans.ltf',
  fsc: 'application/vnd.fsc.weblaunch',
  oas: 'application/vnd.fujitsu.oasys',
  oa2: 'application/vnd.fujitsu.oasys2',
  oa3: 'application/vnd.fujitsu.oasys3',
  fg5: 'application/vnd.fujitsu.oasysgp',
  bh2: 'application/vnd.fujitsu.oasysprs',
  ddd: 'application/vnd.fujixerox.ddd',
  xdw: 'application/vnd.fujixerox.docuworks',
  xbd: 'application/vnd.fujixerox.docuworks.binder',
  fzs: 'application/vnd.fuzzysheet',
  txd: 'application/vnd.genomatix.tuxedo',
  ggb: 'application/vnd.geogebra.file',
  ggt: 'application/vnd.geogebra.tool',
  gex: 'application/vnd.geometry-explorer',
  gre: 'application/vnd.geometry-explorer',
  gxt: 'application/vnd.geonext',
  g2w: 'application/vnd.geoplan',
  g3w: 'application/vnd.geospace',
  gmx: 'application/vnd.gmx',
  kml: 'application/vnd.google-earth.kml+xml',
  kmz: 'application/vnd.google-earth.kmz',
  gqf: 'application/vnd.grafeq',
  gqs: 'application/vnd.grafeq',
  gac: 'application/vnd.groove-account',
  ghf: 'application/vnd.groove-help',
  gim: 'application/vnd.groove-identity-message',
  grv: 'application/vnd.groove-injector',
  gtm: 'application/vnd.groove-tool-message',
  tpl: 'application/vnd.groove-tool-template',
  vcg: 'application/vnd.groove-vcard',
  hal: 'application/vnd.hal+xml',
  zmm: 'application/vnd.handheld-entertainment+xml',
  hbci: 'application/vnd.hbci',
  les: 'application/vnd.hhe.lesson-player',
  hpgl: 'application/vnd.hp-hpgl',
  hpid: 'application/vnd.hp-hpid',
  hps: 'application/vnd.hp-hps',
  jlt: 'application/vnd.hp-jlyt',
  pcl: 'application/vnd.hp-pcl',
  pclxl: 'application/vnd.hp-pclxl',
  'sfd-hdstx': 'application/vnd.hydrostatix.sof-data',
  mpy: 'application/vnd.ibm.minipay',
  afp: 'application/vnd.ibm.modcap',
  listafp: 'application/vnd.ibm.modcap',
  list3820: 'application/vnd.ibm.modcap',
  irm: 'application/vnd.ibm.rights-management',
  sc: 'application/vnd.ibm.secure-container',
  icc: 'application/vnd.iccprofile',
  icm: 'application/vnd.iccprofile',
  igl: 'application/vnd.igloader',
  ivp: 'application/vnd.immervision-ivp',
  ivu: 'application/vnd.immervision-ivu',
  igm: 'application/vnd.insors.igm',
  xpw: 'application/vnd.intercon.formnet',
  xpx: 'application/vnd.intercon.formnet',
  i2g: 'application/vnd.intergeo',
  qbo: 'application/vnd.intu.qbo',
  qfx: 'application/vnd.intu.qfx',
  rcprofile: 'application/vnd.ipunplugged.rcprofile',
  irp: 'application/vnd.irepository.package+xml',
  xpr: 'application/vnd.is-xpr',
  fcs: 'application/vnd.isac.fcs',
  jam: 'application/vnd.jam',
  rms: 'application/vnd.jcp.javame.midlet-rms',
  jisp: 'application/vnd.jisp',
  joda: 'application/vnd.joost.joda-archive',
  ktz: 'application/vnd.kahootz',
  ktr: 'application/vnd.kahootz',
  karbon: 'application/vnd.kde.karbon',
  chrt: 'application/vnd.kde.kchart',
  kfo: 'application/vnd.kde.kformula',
  flw: 'application/vnd.kde.kivio',
  kon: 'application/vnd.kde.kontour',
  kpr: 'application/vnd.kde.kpresenter',
  kpt: 'application/vnd.kde.kpresenter',
  ksp: 'application/vnd.kde.kspread',
  kwd: 'application/vnd.kde.kword',
  kwt: 'application/vnd.kde.kword',
  htke: 'application/vnd.kenameaapp',
  kia: 'application/vnd.kidspiration',
  kne: 'application/vnd.kinar',
  knp: 'application/vnd.kinar',
  skp: 'application/vnd.koan',
  skd: 'application/vnd.koan',
  skt: 'application/vnd.koan',
  skm: 'application/vnd.koan',
  sse: 'application/vnd.kodak-descriptor',
  lasxml: 'application/vnd.las.las+xml',
  lbd: 'application/vnd.llamagraphics.life-balance.desktop',
  lbe: 'application/vnd.llamagraphics.life-balance.exchange+xml',
  apr: 'application/vnd.lotus-approach',
  pre: 'application/vnd.lotus-freelance',
  nsf: 'application/vnd.lotus-notes',
  org: 'application/vnd.lotus-organizer',
  scm: 'application/vnd.lotus-screencam',
  lwp: 'application/vnd.lotus-wordpro',
  portpkg: 'application/vnd.macports.portpkg',
  mcd: 'application/vnd.mcd',
  mc1: 'application/vnd.medcalcdata',
  cdkey: 'application/vnd.mediastation.cdkey',
  mwf: 'application/vnd.mfer',
  mfm: 'application/vnd.mfmp',
  flo: 'application/vnd.micrografx.flo',
  igx: 'application/vnd.micrografx.igx',
  mif: 'application/vnd.mif',
  daf: 'application/vnd.mobius.daf',
  dis: 'application/vnd.mobius.dis',
  mbk: 'application/vnd.mobius.mbk',
  mqy: 'application/vnd.mobius.mqy',
  msl: 'application/vnd.mobius.msl',
  plc: 'application/vnd.mobius.plc',
  txf: 'application/vnd.mobius.txf',
  mpn: 'application/vnd.mophun.application',
  mpc: 'application/vnd.mophun.certificate',
  xul: 'application/vnd.mozilla.xul+xml',
  cil: 'application/vnd.ms-artgalry',
  cab: 'application/vnd.ms-cab-compressed',
  xls: 'application/vnd.ms-excel',
  xlm: 'application/vnd.ms-excel',
  xla: 'application/vnd.ms-excel',
  xlc: 'application/vnd.ms-excel',
  xlt: 'application/vnd.ms-excel',
  xlw: 'application/vnd.ms-excel',
  xlam: 'application/vnd.ms-excel.addin.macroenabled.12',
  xlsb: 'application/vnd.ms-excel.sheet.binary.macroenabled.12',
  xlsm: 'application/vnd.ms-excel.sheet.macroenabled.12',
  xltm: 'application/vnd.ms-excel.template.macroenabled.12',
  eot: 'application/vnd.ms-fontobject',
  chm: 'application/vnd.ms-htmlhelp',
  ims: 'application/vnd.ms-ims',
  lrm: 'application/vnd.ms-lrm',
  thmx: 'application/vnd.ms-officetheme',
  cat: 'application/vnd.ms-pki.seccat',
  stl: 'application/vnd.ms-pki.stl',
  ppt: 'application/vnd.ms-powerpoint',
  pps: 'application/vnd.ms-powerpoint',
  pot: 'application/vnd.ms-powerpoint',
  ppam: 'application/vnd.ms-powerpoint.addin.macroenabled.12',
  pptm: 'application/vnd.ms-powerpoint.presentation.macroenabled.12',
  sldm: 'application/vnd.ms-powerpoint.slide.macroenabled.12',
  ppsm: 'application/vnd.ms-powerpoint.slideshow.macroenabled.12',
  potm: 'application/vnd.ms-powerpoint.template.macroenabled.12',
  mpp: 'application/vnd.ms-project',
  mpt: 'application/vnd.ms-project',
  docm: 'application/vnd.ms-word.document.macroenabled.12',
  dotm: 'application/vnd.ms-word.template.macroenabled.12',
  wps: 'application/vnd.ms-works',
  wks: 'application/vnd.ms-works',
  wcm: 'application/vnd.ms-works',
  wdb: 'application/vnd.ms-works',
  wpl: 'application/vnd.ms-wpl',
  xps: 'application/vnd.ms-xpsdocument',
  mseq: 'application/vnd.mseq',
  mus: 'application/vnd.musician',
  msty: 'application/vnd.muvee.style',
  taglet: 'application/vnd.mynfc',
  nlu: 'application/vnd.neurolanguage.nlu',
  ntf: 'application/vnd.nitf',
  nitf: 'application/vnd.nitf',
  nnd: 'application/vnd.noblenet-directory',
  nns: 'application/vnd.noblenet-sealer',
  nnw: 'application/vnd.noblenet-web',
  ngdat: 'application/vnd.nokia.n-gage.data',
  'n-gage': 'application/vnd.nokia.n-gage.symbian.install',
  rpst: 'application/vnd.nokia.radio-preset',
  rpss: 'application/vnd.nokia.radio-presets',
  edm: 'application/vnd.novadigm.edm',
  edx: 'application/vnd.novadigm.edx',
  ext: 'application/vnd.novadigm.ext',
  odc: 'application/vnd.oasis.opendocument.chart',
  otc: 'application/vnd.oasis.opendocument.chart-template',
  odb: 'application/vnd.oasis.opendocument.database',
  odf: 'application/vnd.oasis.opendocument.formula',
  odft: 'application/vnd.oasis.opendocument.formula-template',
  odg: 'application/vnd.oasis.opendocument.graphics',
  otg: 'application/vnd.oasis.opendocument.graphics-template',
  odi: 'application/vnd.oasis.opendocument.image',
  oti: 'application/vnd.oasis.opendocument.image-template',
  odp: 'application/vnd.oasis.opendocument.presentation',
  otp: 'application/vnd.oasis.opendocument.presentation-template',
  ods: 'application/vnd.oasis.opendocument.spreadsheet',
  ots: 'application/vnd.oasis.opendocument.spreadsheet-template',
  odt: 'application/vnd.oasis.opendocument.text',
  odm: 'application/vnd.oasis.opendocument.text-master',
  ott: 'application/vnd.oasis.opendocument.text-template',
  oth: 'application/vnd.oasis.opendocument.text-web',
  xo: 'application/vnd.olpc-sugar',
  dd2: 'application/vnd.oma.dd2+xml',
  oxt: 'application/vnd.openofficeorg.extension',
  pptx: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
  sldx: 'application/vnd.openxmlformats-officedocument.presentationml.slide',
  ppsx: 'application/vnd.openxmlformats-officedocument.presentationml.slideshow',
  potx: 'application/vnd.openxmlformats-officedocument.presentationml.template',
  xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  xltx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',
  docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  dotx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',
  mgp: 'application/vnd.osgeo.mapguide.package',
  dp: 'application/vnd.osgi.dp',
  esa: 'application/vnd.osgi.subsystem',
  pdb: 'application/vnd.palm',
  pqa: 'application/vnd.palm',
  oprc: 'application/vnd.palm',
  paw: 'application/vnd.pawaafile',
  str: 'application/vnd.pg.format',
  ei6: 'application/vnd.pg.osasli',
  efif: 'application/vnd.picsel',
  wg: 'application/vnd.pmi.widget',
  plf: 'application/vnd.pocketlearn',
  pbd: 'application/vnd.powerbuilder6',
  box: 'application/vnd.previewsystems.box',
  mgz: 'application/vnd.proteus.magazine',
  qps: 'application/vnd.publishare-delta-tree',
  ptid: 'application/vnd.pvi.ptid1',
  qxd: 'application/vnd.quark.quarkxpress',
  qxt: 'application/vnd.quark.quarkxpress',
  qwd: 'application/vnd.quark.quarkxpress',
  qwt: 'application/vnd.quark.quarkxpress',
  qxl: 'application/vnd.quark.quarkxpress',
  qxb: 'application/vnd.quark.quarkxpress',
  bed: 'application/vnd.realvnc.bed',
  mxl: 'application/vnd.recordare.musicxml',
  musicxml: 'application/vnd.recordare.musicxml+xml',
  cryptonote: 'application/vnd.rig.cryptonote',
  cod: 'application/vnd.rim.cod',
  rm: 'application/vnd.rn-realmedia',
  rmvb: 'application/vnd.rn-realmedia-vbr',
  link66: 'application/vnd.route66.link66+xml',
  st: 'application/vnd.sailingtracker.track',
  see: 'application/vnd.seemail',
  sema: 'application/vnd.sema',
  semd: 'application/vnd.semd',
  semf: 'application/vnd.semf',
  ifm: 'application/vnd.shana.informed.formdata',
  itp: 'application/vnd.shana.informed.formtemplate',
  iif: 'application/vnd.shana.informed.interchange',
  ipk: 'application/vnd.shana.informed.package',
  twd: 'application/vnd.simtech-mindmapper',
  twds: 'application/vnd.simtech-mindmapper',
  mmf: 'application/vnd.smaf',
  teacher: 'application/vnd.smart.teacher',
  sdkm: 'application/vnd.solent.sdkm+xml',
  sdkd: 'application/vnd.solent.sdkm+xml',
  dxp: 'application/vnd.spotfire.dxp',
  sfs: 'application/vnd.spotfire.sfs',
  sdc: 'application/vnd.stardivision.calc',
  sda: 'application/vnd.stardivision.draw',
  sdd: 'application/vnd.stardivision.impress',
  smf: 'application/vnd.stardivision.math',
  sdw: 'application/vnd.stardivision.writer',
  vor: 'application/vnd.stardivision.writer',
  sgl: 'application/vnd.stardivision.writer-global',
  smzip: 'application/vnd.stepmania.package',
  sm: 'application/vnd.stepmania.stepchart',
  sxc: 'application/vnd.sun.xml.calc',
  stc: 'application/vnd.sun.xml.calc.template',
  sxd: 'application/vnd.sun.xml.draw',
  std: 'application/vnd.sun.xml.draw.template',
  sxi: 'application/vnd.sun.xml.impress',
  sti: 'application/vnd.sun.xml.impress.template',
  sxm: 'application/vnd.sun.xml.math',
  sxw: 'application/vnd.sun.xml.writer',
  sxg: 'application/vnd.sun.xml.writer.global',
  stw: 'application/vnd.sun.xml.writer.template',
  sus: 'application/vnd.sus-calendar',
  susp: 'application/vnd.sus-calendar',
  svd: 'application/vnd.svd',
  sis: 'application/vnd.symbian.install',
  sisx: 'application/vnd.symbian.install',
  xsm: 'application/vnd.syncml+xml',
  bdm: 'application/vnd.syncml.dm+wbxml',
  xdm: 'application/vnd.syncml.dm+xml',
  tao: 'application/vnd.tao.intent-module-archive',
  pcap: 'application/vnd.tcpdump.pcap',
  cap: 'application/vnd.tcpdump.pcap',
  dmp: 'application/vnd.tcpdump.pcap',
  tmo: 'application/vnd.tmobile-livetv',
  tpt: 'application/vnd.trid.tpt',
  mxs: 'application/vnd.triscape.mxs',
  tra: 'application/vnd.trueapp',
  ufd: 'application/vnd.ufdl',
  ufdl: 'application/vnd.ufdl',
  utz: 'application/vnd.uiq.theme',
  umj: 'application/vnd.umajin',
  unityweb: 'application/vnd.unity',
  uoml: 'application/vnd.uoml+xml',
  vcx: 'application/vnd.vcx',
  vsd: 'application/vnd.visio',
  vst: 'application/vnd.visio',
  vss: 'application/vnd.visio',
  vsw: 'application/vnd.visio',
  vis: 'application/vnd.visionary',
  vsf: 'application/vnd.vsf',
  wbxml: 'application/vnd.wap.wbxml',
  wmlc: 'application/vnd.wap.wmlc',
  wmlsc: 'application/vnd.wap.wmlscriptc',
  wtb: 'application/vnd.webturbo',
  nbp: 'application/vnd.wolfram.player',
  wpd: 'application/vnd.wordperfect',
  wqd: 'application/vnd.wqd',
  stf: 'application/vnd.wt.stf',
  xar: 'application/vnd.xara',
  xfdl: 'application/vnd.xfdl',
  hvd: 'application/vnd.yamaha.hv-dic',
  hvs: 'application/vnd.yamaha.hv-script',
  hvp: 'application/vnd.yamaha.hv-voice',
  osf: 'application/vnd.yamaha.openscoreformat',
  osfpvg: 'application/vnd.yamaha.openscoreformat.osfpvg+xml',
  saf: 'application/vnd.yamaha.smaf-audio',
  spf: 'application/vnd.yamaha.smaf-phrase',
  cmp: 'application/vnd.yellowriver-custom-menu',
  zir: 'application/vnd.zul',
  zirz: 'application/vnd.zul',
  zaz: 'application/vnd.zzazz.deck+xml',
  vxml: 'application/voicexml+xml',
  wgt: 'application/widget',
  hlp: 'application/winhlp',
  wsdl: 'application/wsdl+xml',
  wspolicy: 'application/wspolicy+xml',
  '7z': 'application/x-7z-compressed',
  abw: 'application/x-abiword',
  ace: 'application/x-ace-compressed',
  dmg: 'application/x-apple-diskimage',
  aab: 'application/x-authorware-bin',
  x32: 'application/x-authorware-bin',
  u32: 'application/x-authorware-bin',
  vox: 'application/x-authorware-bin',
  aam: 'application/x-authorware-map',
  aas: 'application/x-authorware-seg',
  bcpio: 'application/x-bcpio',
  torrent: 'application/x-bittorrent',
  blb: 'application/x-blorb',
  blorb: 'application/x-blorb',
  bz: 'application/x-bzip',
  bz2: 'application/x-bzip2',
  boz: 'application/x-bzip2',
  cbr: 'application/x-cbr',
  cba: 'application/x-cbr',
  cbt: 'application/x-cbr',
  cbz: 'application/x-cbr',
  cb7: 'application/x-cbr',
  vcd: 'application/x-cdlink',
  cfs: 'application/x-cfs-compressed',
  chat: 'application/x-chat',
  pgn: 'application/x-chess-pgn',
  nsc: 'application/x-conference',
  cpio: 'application/x-cpio',
  csh: 'application/x-csh',
  deb: 'application/x-debian-package',
  udeb: 'application/x-debian-package',
  dgc: 'application/x-dgc-compressed',
  dir: 'application/x-director',
  dcr: 'application/x-director',
  dxr: 'application/x-director',
  cst: 'application/x-director',
  cct: 'application/x-director',
  cxt: 'application/x-director',
  w3d: 'application/x-director',
  fgd: 'application/x-director',
  swa: 'application/x-director',
  wad: 'application/x-doom',
  ncx: 'application/x-dtbncx+xml',
  dtb: 'application/x-dtbook+xml',
  res: 'application/x-dtbresource+xml',
  dvi: 'application/x-dvi',
  evy: 'application/x-envoy',
  eva: 'application/x-eva',
  bdf: 'application/x-font-bdf',
  gsf: 'application/x-font-ghostscript',
  psf: 'application/x-font-linux-psf',
  otf: 'application/x-font-otf',
  pcf: 'application/x-font-pcf',
  snf: 'application/x-font-snf',
  ttf: 'application/x-font-ttf',
  ttc: 'application/x-font-ttf',
  pfa: 'application/x-font-type1',
  pfb: 'application/x-font-type1',
  pfm: 'application/x-font-type1',
  afm: 'application/x-font-type1',
  woff: 'application/x-font-woff',
  arc: 'application/x-freearc',
  spl: 'application/x-futuresplash',
  gca: 'application/x-gca-compressed',
  ulx: 'application/x-glulx',
  gnumeric: 'application/x-gnumeric',
  gramps: 'application/x-gramps-xml',
  gtar: 'application/x-gtar',
  hdf: 'application/x-hdf',
  install: 'application/x-install-instructions',
  iso: 'application/x-iso9660-image',
  jnlp: 'application/x-java-jnlp-file',
  latex: 'application/x-latex',
  lzh: 'application/x-lzh-compressed',
  lha: 'application/x-lzh-compressed',
  mie: 'application/x-mie',
  prc: 'application/x-mobipocket-ebook',
  mobi: 'application/x-mobipocket-ebook',
  application: 'application/x-ms-application',
  lnk: 'application/x-ms-shortcut',
  wmd: 'application/x-ms-wmd',
  wmz: 'application/x-msmetafile',
  xbap: 'application/x-ms-xbap',
  mdb: 'application/x-msaccess',
  obd: 'application/x-msbinder',
  crd: 'application/x-mscardfile',
  clp: 'application/x-msclip',
  exe: 'application/x-msdownload',
  dll: 'application/x-msdownload',
  com: 'application/x-msdownload',
  bat: 'application/x-msdownload',
  msi: 'application/x-msdownload',
  mvb: 'application/x-msmediaview',
  m13: 'application/x-msmediaview',
  m14: 'application/x-msmediaview',
  wmf: 'application/x-msmetafile',
  emf: 'application/x-msmetafile',
  emz: 'application/x-msmetafile',
  mny: 'application/x-msmoney',
  pub: 'application/x-mspublisher',
  scd: 'application/x-msschedule',
  trm: 'application/x-msterminal',
  wri: 'application/x-mswrite',
  nc: 'application/x-netcdf',
  cdf: 'application/x-netcdf',
  nzb: 'application/x-nzb',
  p12: 'application/x-pkcs12',
  pfx: 'application/x-pkcs12',
  p7b: 'application/x-pkcs7-certificates',
  spc: 'application/x-pkcs7-certificates',
  p7r: 'application/x-pkcs7-certreqresp',
  rar: 'application/x-rar-compressed',
  ris: 'application/x-research-info-systems',
  sh: 'application/x-sh',
  shar: 'application/x-shar',
  swf: 'application/x-shockwave-flash',
  xap: 'application/x-silverlight-app',
  sql: 'application/x-sql',
  sit: 'application/x-stuffit',
  sitx: 'application/x-stuffitx',
  srt: 'application/x-subrip',
  sv4cpio: 'application/x-sv4cpio',
  sv4crc: 'application/x-sv4crc',
  t3: 'application/x-t3vm-image',
  gam: 'application/x-tads',
  tar: 'application/x-tar',
  tcl: 'application/x-tcl',
  tex: 'application/x-tex',
  tfm: 'application/x-tex-tfm',
  texinfo: 'application/x-texinfo',
  texi: 'application/x-texinfo',
  obj: 'application/x-tgif',
  ustar: 'application/x-ustar',
  src: 'application/x-wais-source',
  der: 'application/x-x509-ca-cert',
  crt: 'application/x-x509-ca-cert',
  fig: 'application/x-xfig',
  xlf: 'application/x-xliff+xml',
  xpi: 'application/x-xpinstall',
  xz: 'application/x-xz',
  z1: 'application/x-zmachine',
  z2: 'application/x-zmachine',
  z3: 'application/x-zmachine',
  z4: 'application/x-zmachine',
  z5: 'application/x-zmachine',
  z6: 'application/x-zmachine',
  z7: 'application/x-zmachine',
  z8: 'application/x-zmachine',
  xaml: 'application/xaml+xml',
  xdf: 'application/xcap-diff+xml',
  xenc: 'application/xenc+xml',
  xhtml: 'application/xhtml+xml',
  xht: 'application/xhtml+xml',
  xml: 'application/xml',
  xsl: 'application/xml',
  dtd: 'application/xml-dtd',
  xop: 'application/xop+xml',
  xpl: 'application/xproc+xml',
  xslt: 'application/xslt+xml',
  xspf: 'application/xspf+xml',
  mxml: 'application/xv+xml',
  xhvml: 'application/xv+xml',
  xvml: 'application/xv+xml',
  xvm: 'application/xv+xml',
  yang: 'application/yang',
  yin: 'application/yin+xml',
  zip: 'application/zip',
  adp: 'audio/adpcm',
  au: 'audio/basic',
  snd: 'audio/basic',
  mid: 'audio/midi',
  midi: 'audio/midi',
  kar: 'audio/midi',
  rmi: 'audio/midi',
  mp4a: 'audio/mp4',
  mpga: 'audio/mpeg',
  mp2: 'audio/mpeg',
  mp2a: 'audio/mpeg',
  mp3: 'audio/mpeg',
  m2a: 'audio/mpeg',
  m3a: 'audio/mpeg',
  oga: 'audio/ogg',
  ogg: 'audio/ogg',
  spx: 'audio/ogg',
  s3m: 'audio/s3m',
  sil: 'audio/silk',
  uva: 'audio/vnd.dece.audio',
  uvva: 'audio/vnd.dece.audio',
  eol: 'audio/vnd.digital-winds',
  dra: 'audio/vnd.dra',
  dts: 'audio/vnd.dts',
  dtshd: 'audio/vnd.dts.hd',
  lvp: 'audio/vnd.lucent.voice',
  pya: 'audio/vnd.ms-playready.media.pya',
  ecelp4800: 'audio/vnd.nuera.ecelp4800',
  ecelp7470: 'audio/vnd.nuera.ecelp7470',
  ecelp9600: 'audio/vnd.nuera.ecelp9600',
  rip: 'audio/vnd.rip',
  weba: 'audio/webm',
  aac: 'audio/x-aac',
  aif: 'audio/x-aiff',
  aiff: 'audio/x-aiff',
  aifc: 'audio/x-aiff',
  caf: 'audio/x-caf',
  flac: 'audio/x-flac',
  mka: 'audio/x-matroska',
  m3u: 'audio/x-mpegurl',
  wax: 'audio/x-ms-wax',
  wma: 'audio/x-ms-wma',
  ram: 'audio/x-pn-realaudio',
  ra: 'audio/x-pn-realaudio',
  rmp: 'audio/x-pn-realaudio-plugin',
  wav: 'audio/x-wav',
  xm: 'audio/xm',
  cdx: 'chemical/x-cdx',
  cif: 'chemical/x-cif',
  cmdf: 'chemical/x-cmdf',
  cml: 'chemical/x-cml',
  csml: 'chemical/x-csml',
  xyz: 'chemical/x-xyz',
  bmp: 'image/bmp',
  cgm: 'image/cgm',
  g3: 'image/g3fax',
  gif: 'image/gif',
  ief: 'image/ief',
  jpeg: 'image/jpeg',
  jpg: 'image/jpeg',
  jpe: 'image/jpeg',
  ktx: 'image/ktx',
  png: 'image/png',
  btif: 'image/prs.btif',
  sgi: 'image/sgi',
  svg: 'image/svg+xml',
  svgz: 'image/svg+xml',
  tiff: 'image/tiff',
  tif: 'image/tiff',
  psd: 'image/vnd.adobe.photoshop',
  uvi: 'image/vnd.dece.graphic',
  uvvi: 'image/vnd.dece.graphic',
  uvg: 'image/vnd.dece.graphic',
  uvvg: 'image/vnd.dece.graphic',
  sub: 'text/vnd.dvb.subtitle',
  djvu: 'image/vnd.djvu',
  djv: 'image/vnd.djvu',
  dwg: 'image/vnd.dwg',
  dxf: 'image/vnd.dxf',
  fbs: 'image/vnd.fastbidsheet',
  fpx: 'image/vnd.fpx',
  fst: 'image/vnd.fst',
  mmr: 'image/vnd.fujixerox.edmics-mmr',
  rlc: 'image/vnd.fujixerox.edmics-rlc',
  mdi: 'image/vnd.ms-modi',
  wdp: 'image/vnd.ms-photo',
  npx: 'image/vnd.net-fpx',
  wbmp: 'image/vnd.wap.wbmp',
  xif: 'image/vnd.xiff',
  webp: 'image/webp',
  '3ds': 'image/x-3ds',
  ras: 'image/x-cmu-raster',
  cmx: 'image/x-cmx',
  fh: 'image/x-freehand',
  fhc: 'image/x-freehand',
  fh4: 'image/x-freehand',
  fh5: 'image/x-freehand',
  fh7: 'image/x-freehand',
  ico: 'image/x-icon',
  sid: 'image/x-mrsid-image',
  pcx: 'image/x-pcx',
  pic: 'image/x-pict',
  pct: 'image/x-pict',
  pnm: 'image/x-portable-anymap',
  pbm: 'image/x-portable-bitmap',
  pgm: 'image/x-portable-graymap',
  ppm: 'image/x-portable-pixmap',
  rgb: 'image/x-rgb',
  tga: 'image/x-tga',
  xbm: 'image/x-xbitmap',
  xpm: 'image/x-xpixmap',
  xwd: 'image/x-xwindowdump',
  eml: 'message/rfc822',
  mime: 'message/rfc822',
  igs: 'model/iges',
  iges: 'model/iges',
  msh: 'model/mesh',
  mesh: 'model/mesh',
  silo: 'model/mesh',
  dae: 'model/vnd.collada+xml',
  dwf: 'model/vnd.dwf',
  gdl: 'model/vnd.gdl',
  gtw: 'model/vnd.gtw',
  mts: 'model/vnd.mts',
  vtu: 'model/vnd.vtu',
  wrl: 'model/vrml',
  vrml: 'model/vrml',
  x3db: 'model/x3d+binary',
  x3dbz: 'model/x3d+binary',
  x3dv: 'model/x3d+vrml',
  x3dvz: 'model/x3d+vrml',
  x3d: 'model/x3d+xml',
  x3dz: 'model/x3d+xml',
  appcache: 'text/cache-manifest',
  ics: 'text/calendar',
  ifb: 'text/calendar',
  css: 'text/css',
  csv: 'text/csv',
  html: 'text/html',
  htm: 'text/html',
  n3: 'text/n3',
  txt: 'text/plain',
  text: 'text/plain',
  conf: 'text/plain',
  def: 'text/plain',
  list: 'text/plain',
  log: 'text/plain',
  in: 'text/plain',
  dsc: 'text/prs.lines.tag',
  rtx: 'text/richtext',
  sgml: 'text/sgml',
  sgm: 'text/sgml',
  tsv: 'text/tab-separated-values',
  t: 'text/troff',
  tr: 'text/troff',
  roff: 'text/troff',
  man: 'text/troff',
  me: 'text/troff',
  ms: 'text/troff',
  ttl: 'text/turtle',
  uri: 'text/uri-list',
  uris: 'text/uri-list',
  urls: 'text/uri-list',
  vcard: 'text/vcard',
  curl: 'text/vnd.curl',
  dcurl: 'text/vnd.curl.dcurl',
  scurl: 'text/vnd.curl.scurl',
  mcurl: 'text/vnd.curl.mcurl',
  fly: 'text/vnd.fly',
  flx: 'text/vnd.fmi.flexstor',
  gv: 'text/vnd.graphviz',
  '3dml': 'text/vnd.in3d.3dml',
  spot: 'text/vnd.in3d.spot',
  jad: 'text/vnd.sun.j2me.app-descriptor',
  wml: 'text/vnd.wap.wml',
  wmls: 'text/vnd.wap.wmlscript',
  s: 'text/x-asm',
  asm: 'text/x-asm',
  c: 'text/x-c',
  cc: 'text/x-c',
  cxx: 'text/x-c',
  cpp: 'text/x-c',
  h: 'text/x-c',
  hh: 'text/x-c',
  dic: 'text/x-c',
  f: 'text/x-fortran',
  for: 'text/x-fortran',
  f77: 'text/x-fortran',
  f90: 'text/x-fortran',
  java: 'text/x-java-source',
  opml: 'text/x-opml',
  p: 'text/x-pascal',
  pas: 'text/x-pascal',
  nfo: 'text/x-nfo',
  etx: 'text/x-setext',
  sfv: 'text/x-sfv',
  uu: 'text/x-uuencode',
  vcs: 'text/x-vcalendar',
  vcf: 'text/x-vcard',
  '3gp': 'video/3gpp',
  '3g2': 'video/3gpp2',
  h261: 'video/h261',
  h263: 'video/h263',
  h264: 'video/h264',
  jpgv: 'video/jpeg',
  jpm: 'video/jpm',
  jpgm: 'video/jpm',
  mj2: 'video/mj2',
  mjp2: 'video/mj2',
  mp4: 'video/mp4',
  mp4v: 'video/mp4',
  mpg4: 'video/mp4',
  mpeg: 'video/mpeg',
  mpg: 'video/mpeg',
  mpe: 'video/mpeg',
  m1v: 'video/mpeg',
  m2v: 'video/mpeg',
  ogv: 'video/ogg',
  qt: 'video/quicktime',
  mov: 'video/quicktime',
  uvh: 'video/vnd.dece.hd',
  uvvh: 'video/vnd.dece.hd',
  uvm: 'video/vnd.dece.mobile',
  uvvm: 'video/vnd.dece.mobile',
  uvp: 'video/vnd.dece.pd',
  uvvp: 'video/vnd.dece.pd',
  uvs: 'video/vnd.dece.sd',
  uvvs: 'video/vnd.dece.sd',
  uvv: 'video/vnd.dece.video',
  uvvv: 'video/vnd.dece.video',
  dvb: 'video/vnd.dvb.file',
  fvt: 'video/vnd.fvt',
  mxu: 'video/vnd.mpegurl',
  m4u: 'video/vnd.mpegurl',
  pyv: 'video/vnd.ms-playready.media.pyv',
  uvu: 'video/vnd.uvvu.mp4',
  uvvu: 'video/vnd.uvvu.mp4',
  viv: 'video/vnd.vivo',
  webm: 'video/webm',
  f4v: 'video/x-f4v',
  fli: 'video/x-fli',
  flv: 'video/x-flv',
  m4v: 'video/x-m4v',
  mkv: 'video/x-matroska',
  mk3d: 'video/x-matroska',
  mks: 'video/x-matroska',
  mng: 'video/x-mng',
  asf: 'video/x-ms-asf',
  asx: 'video/x-ms-asf',
  vob: 'video/x-ms-vob',
  wm: 'video/x-ms-wm',
  wmv: 'video/x-ms-wmv',
  wmx: 'video/x-ms-wmx',
  wvx: 'video/x-ms-wvx',
  avi: 'video/x-msvideo',
  movie: 'video/x-sgi-movie',
  smv: 'video/x-smv',
  ice: 'x-conference/x-cooltalk' }

},{}],31:[function(require,module,exports){
(function() {
  var MarkedYAMLError, events, nodes, raml, util, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  events = require('./events');

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  raml = require('./raml');

  util = require('./util');

  this.ComposerError = (function(_super) {
    __extends(ComposerError, _super);

    function ComposerError() {
      _ref = ComposerError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ComposerError;

  })(MarkedYAMLError);

  this.Composer = (function() {
    function Composer() {
      this.composeRamlTree = __bind(this.composeRamlTree, this);
      this.anchors = {};
      this.filesToRead = [];
    }

    Composer.prototype.check_node = function() {
      if (this.check_event(events.StreamStartEvent)) {
        this.get_event();
      }
      return !this.check_event(events.StreamEndEvent);
    };

    /*
    Get the root node of the next document.
    */


    Composer.prototype.get_node = function() {
      if (!this.check_event(events.StreamEndEvent)) {
        return this.compose_document();
      }
    };

    Composer.prototype.getYamlRoot = function() {
      var document, event;
      this.get_event();
      document = null;
      if (!this.check_event(events.StreamEndEvent)) {
        document = this.compose_document();
      }
      if (!this.check_event(events.StreamEndEvent)) {
        event = this.get_event();
        throw new exports.ComposerError('document scan', document.start_mark, 'expected a single document in the stream but found another document', event.start_mark);
      }
      this.get_event();
      return document;
    };

    Composer.prototype.composeRamlTree = function(node, settings) {
      if (settings.validate || settings.transform) {
        this.load_schemas(node);
        this.load_traits(node);
        this.load_types(node);
        this.load_security_schemes(node);
      }
      if (settings.validate) {
        this.validate_document(node);
      }
      if (settings.transform) {
        this.apply_types(node);
        this.apply_traits(node);
        this.apply_schemas(node);
        this.apply_protocols(node);
        this.join_resources(node);
      }
      return node;
    };

    Composer.prototype.compose_document = function() {
      var node;
      this.get_event();
      node = this.compose_node();
      this.get_event();
      this.anchors = {};
      return node;
    };

    Composer.prototype.getPendingFilesList = function() {
      return this.filesToRead;
    };

    Composer.prototype.compose_node = function(parent, index) {
      var anchor, event, node;
      if (this.check_event(events.AliasEvent)) {
        event = this.get_event();
        anchor = event.anchor;
        if (!(anchor in this.anchors)) {
          throw new exports.ComposerError(null, null, "found undefined alias " + anchor, event.start_mark);
        }
        return this.anchors[anchor].clone();
      }
      event = this.peek_event();
      anchor = event.anchor;
      if (anchor !== null && anchor in this.anchors) {
        throw new exports.ComposerError("found duplicate anchor " + anchor + "; first occurence", this.anchors[anchor].start_mark, 'second occurrence', event.start_mark);
      }
      this.descend_resolver(parent, index);
      if (this.check_event(events.ScalarEvent)) {
        node = this.compose_scalar_node(anchor, parent, index);
      } else if (this.check_event(events.SequenceStartEvent)) {
        node = this.compose_sequence_node(anchor);
      } else if (this.check_event(events.MappingStartEvent)) {
        node = this.compose_mapping_node(anchor);
      }
      this.ascend_resolver();
      return node;
    };

    Composer.prototype.compose_fixed_scalar_node = function(anchor, value) {
      var event, node;
      event = this.get_event();
      node = new nodes.ScalarNode('tag:yaml.org,2002:str', value, event.start_mark, event.end_mark, event.style);
      if (anchor !== null) {
        this.anchors[anchor] = node;
      }
      return node;
    };

    Composer.prototype.compose_scalar_node = function(anchor, parent, key) {
      var event, extension, fileType, node, tag;
      event = this.get_event();
      tag = event.tag;
      node = {};
      if (tag === null || tag === '!') {
        tag = this.resolve(nodes.ScalarNode, event.value, event.implicit);
      }
      if (event.tag === '!include') {
        if (event.value.match(/^\s*$/)) {
          throw new exports.ComposerError('while composing scalar out of !include', null, "file name/URL cannot be null", event.start_mark);
        }
        extension = event.value.split('.').pop();
        if (extension === 'yaml' || extension === 'yml' || extension === 'raml') {
          fileType = 'fragment';
        } else {
          fileType = 'scalar';
        }
        this.filesToRead.push({
          targetUri: event.value,
          type: fileType,
          parentNode: parent,
          parentKey: key,
          event: event,
          includingContext: this.src,
          targetFileUri: event.value
        });
        node = void 0;
      } else {
        node = new nodes.ScalarNode(tag, event.value, event.start_mark, event.end_mark, event.style);
      }
      if (anchor && node) {
        this.anchors[anchor] = node;
      }
      return node;
    };

    Composer.prototype.compose_sequence_node = function(anchor) {
      var end_event, index, node, start_event, tag, value;
      start_event = this.get_event();
      tag = start_event.tag;
      if (tag === null || tag === '!') {
        tag = this.resolve(nodes.SequenceNode, null, start_event.implicit);
      }
      node = new nodes.SequenceNode(tag, [], start_event.start_mark, null, start_event.flow_style);
      index = 0;
      if (anchor) {
        this.anchors[anchor] = node;
      }
      while (!this.check_event(events.SequenceEndEvent)) {
        if (value = this.compose_node(node, index)) {
          node.value[index] = value;
        }
        index++;
      }
      end_event = this.get_event();
      node.end_mark = end_event.end_mark;
      return node;
    };

    Composer.prototype.compose_mapping_node = function(anchor) {
      var end_event, item_key, item_value, node, start_event, tag;
      start_event = this.get_event();
      tag = start_event.tag;
      if (tag === null || tag === '!') {
        tag = this.resolve(nodes.MappingNode, null, start_event.implicit);
      }
      node = new nodes.MappingNode(tag, [], start_event.start_mark, null, start_event.flow_style);
      if (anchor !== null) {
        this.anchors[anchor] = node;
      }
      while (!this.check_event(events.MappingEndEvent)) {
        item_key = this.compose_node(node);
        if (!util.isScalar(item_key)) {
          throw new exports.ComposerError('while composing mapping key', null, "only scalar map keys are allowed in RAML", item_key.start_mark);
        }
        if (item_value = this.compose_node(node, item_key)) {
          node.value.push([item_key, item_value]);
        }
      }
      end_event = this.get_event();
      node.end_mark = end_event.end_mark;
      return node;
    };

    return Composer;

  })();

}).call(this);

},{"./errors":33,"./events":34,"./nodes":37,"./raml":40,"./util":50}],32:[function(require,module,exports){
(function (Buffer){
(function() {
  var MarkedYAMLError, nodes, util, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  util = require('./util');

  this.ConstructorError = (function(_super) {
    __extends(ConstructorError, _super);

    function ConstructorError() {
      _ref = ConstructorError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ConstructorError;

  })(MarkedYAMLError);

  this.BaseConstructor = (function() {
    BaseConstructor.prototype.yaml_constructors = {};

    BaseConstructor.prototype.yaml_multi_constructors = {};

    BaseConstructor.add_constructor = function(tag, constructor) {
      if (!this.prototype.hasOwnProperty('yaml_constructors')) {
        this.prototype.yaml_constructors = util.extend({}, this.prototype.yaml_constructors);
      }
      return this.prototype.yaml_constructors[tag] = constructor;
    };

    BaseConstructor.add_multi_constructor = function(tag_prefix, multi_constructor) {
      if (!this.prototype.hasOwnProperty('yaml_multi_constructors')) {
        this.prototype.yaml_multi_constructors = util.extend({}, this.prototype.yaml_multi_constructors);
      }
      return this.prototype.yaml_multi_constructors[tag_prefix] = multi_constructor;
    };

    function BaseConstructor() {
      this.constructed_objects = {};
      this.constructing_nodes = [];
      this.deferred_constructors = [];
    }

    BaseConstructor.prototype.construct_document = function(node) {
      var data;
      this.applyAstTransformations(node);
      data = this.construct_object(node);
      while (!util.is_empty(this.deferred_constructors)) {
        this.deferred_constructors.pop()();
      }
      this.applyTransformations(data);
      return data;
    };

    BaseConstructor.prototype.defer = function(f) {
      return this.deferred_constructors.push(f);
    };

    BaseConstructor.prototype.construct_object = function(node) {
      var constructor, object, tag_prefix, tag_suffix, _ref1;
      if (node.unique_id in this.constructed_objects) {
        return this.constructed_objects[node.unique_id];
      }
      if (_ref1 = node.unique_id, __indexOf.call(this.constructing_nodes, _ref1) >= 0) {
        throw new exports.ConstructorError(null, null, 'found unconstructable recursive node', node.start_mark);
      }
      this.constructing_nodes.push(node.unique_id);
      constructor = null;
      tag_suffix = null;
      if (node.tag in this.yaml_constructors) {
        constructor = this.yaml_constructors[node.tag];
      } else {
        for (tag_prefix in this.yaml_multi_constructors) {
          if (node.tag.indexOf(tag_prefix === 0)) {
            tag_suffix = node.tag.slice(tag_prefix.length);
            constructor = this.yaml_multi_constructors[tag_prefix];
            break;
          }
        }
        if (constructor == null) {
          if (null in this.yaml_multi_constructors) {
            tag_suffix = node.tag;
            constructor = this.yaml_multi_constructors[null];
          } else if (null in this.yaml_constructors) {
            constructor = this.yaml_constructors[null];
          } else if (node instanceof nodes.ScalarNode) {
            constructor = this.construct_scalar;
          } else if (node instanceof nodes.SequenceNode) {
            constructor = this.construct_sequence;
          } else if (node instanceof nodes.MappingNode) {
            constructor = this.construct_mapping;
          }
        }
      }
      object = constructor.call(this, tag_suffix != null ? tag_suffix : node, node);
      this.constructed_objects[node.unique_id] = object;
      this.constructing_nodes.pop();
      return object;
    };

    BaseConstructor.prototype.construct_scalar = function(node) {
      if (!(node instanceof nodes.ScalarNode)) {
        throw new exports.ConstructorError(null, null, "expected a scalar node but found " + node.id, node.start_mark);
      }
      return node.value;
    };

    BaseConstructor.prototype.construct_sequence = function(node) {
      var child, _i, _len, _ref1, _results;
      if (!(node instanceof nodes.SequenceNode)) {
        throw new exports.ConstructorError(null, null, "expected an array node but found " + node.id, node.start_mark);
      }
      _ref1 = node.value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        child = _ref1[_i];
        _results.push(this.construct_object(child));
      }
      return _results;
    };

    BaseConstructor.prototype.construct_mapping = function(node) {
      var key, key_item, key_item_value, key_node, mapping, value, value_node, _i, _j, _len, _len1, _ref1, _ref2, _ref3;
      if (!(node instanceof nodes.MappingNode)) {
        throw new exports.ConstructorError(null, null, "expected a map node but found " + node.id, node.start_mark);
      }
      mapping = {};
      _ref1 = node.value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        _ref2 = _ref1[_i], key_node = _ref2[0], value_node = _ref2[1];
        key = this.construct_object(key_node);
        value = this.construct_object(value_node);
        if (typeof key === 'object' && key_node.tag === 'tag:yaml.org,2002:seq') {
          _ref3 = key_node.value;
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            key_item = _ref3[_j];
            key_item_value = this.construct_object(key_item);
            mapping[key_item_value] = value;
          }
        } else if (typeof key === 'object') {
          throw new exports.ConstructorError('while constructing a map', node.start_mark, 'found unhashable key', key_node.start_mark);
        } else {
          mapping[key] = value;
        }
      }
      return mapping;
    };

    BaseConstructor.prototype.construct_pairs = function(node) {
      var key, key_node, pairs, value, value_node, _i, _len, _ref1, _ref2;
      if (!(node instanceof nodes.MappingNode)) {
        throw new exports.ConstructorError(null, null, "expected a map node but found " + node.id, node.start_mark);
      }
      pairs = [];
      _ref1 = node.value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        _ref2 = _ref1[_i], key_node = _ref2[0], value_node = _ref2[1];
        key = this.construct_object(key_node);
        value = this.construct_object(value_node);
        pairs.push([key, value]);
      }
      return pairs;
    };

    return BaseConstructor;

  })();

  this.Constructor = (function(_super) {
    var BOOL_VALUES, TIMESTAMP_PARTS, TIMESTAMP_REGEX;

    __extends(Constructor, _super);

    function Constructor() {
      _ref1 = Constructor.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    BOOL_VALUES = {
      "true": true,
      "false": false
    };

    TIMESTAMP_REGEX = /^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:(?:[Tt]|[\x20\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\.([0-9]*))?(?:[\x20\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?)?$/;

    TIMESTAMP_PARTS = {
      year: 1,
      month: 2,
      day: 3,
      hour: 4,
      minute: 5,
      second: 6,
      fraction: 7,
      tz: 8,
      tz_sign: 9,
      tz_hour: 10,
      tz_minute: 11
    };

    Constructor.prototype.yaml_constructors = {};

    Constructor.prototype.yaml_multi_constructors = {};

    Constructor.prototype.construct_scalar = function(node) {
      var key_node, value_node, _i, _len, _ref2, _ref3;
      if (node instanceof nodes.MappingNode) {
        _ref2 = node.value;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          _ref3 = _ref2[_i], key_node = _ref3[0], value_node = _ref3[1];
          if (key_node.tag === 'tag:yaml.org,2002:value') {
            return this.construct_scalar(value_node);
          }
        }
      }
      return Constructor.__super__.construct_scalar.call(this, node);
    };

    Constructor.prototype.flatten_mapping = function(node) {
      var index, key_node, merge, submerge, subnode, value, value_node, _i, _j, _len, _len1, _ref2, _ref3;
      merge = [];
      index = 0;
      while (index < node.value.length) {
        _ref2 = node.value[index], key_node = _ref2[0], value_node = _ref2[1];
        if (key_node.tag === 'tag:yaml.org,2002:merge') {
          node.value.splice(index, 1);
          if (value_node instanceof nodes.MappingNode) {
            this.flatten_mapping(value_node);
            merge = merge.concat(value_node.value);
          } else if (value_node instanceof nodes.SequenceNode) {
            submerge = [];
            _ref3 = value_node.value;
            for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
              subnode = _ref3[_i];
              if (!(subnode instanceof nodes.MappingNode)) {
                throw new exports.ConstructorError('while constructing a map', node.start_mark, "expected a map for merging, but found " + subnode.id, subnode.start_mark);
              }
              this.flatten_mapping(subnode);
              submerge.push(subnode.value);
            }
            submerge.reverse();
            for (_j = 0, _len1 = submerge.length; _j < _len1; _j++) {
              value = submerge[_j];
              merge = merge.concat(value);
            }
          } else {
            throw new exports.ConstructorError('while constructing a map', node.start_mark, "expected a map or an array of maps for            merging but found " + value_node.id, value_node.start_mark);
          }
        } else if (key_node.tag === 'tag:yaml.org,2002:value') {
          key_node.tag = 'tag:yaml.org,2002:str';
          index++;
        } else {
          index++;
        }
      }
      if (merge.length) {
        return node.value = merge.concat(node.value);
      }
    };

    Constructor.prototype.construct_mapping = function(node) {
      if (node instanceof nodes.MappingNode) {
        this.flatten_mapping(node);
      }
      return Constructor.__super__.construct_mapping.call(this, node);
    };

    Constructor.prototype.construct_yaml_null = function(node) {
      this.construct_scalar(node);
      return null;
    };

    Constructor.prototype.construct_yaml_bool = function(node) {
      var value;
      value = this.construct_scalar(node);
      return BOOL_VALUES[value.toLowerCase()];
    };

    Constructor.prototype.construct_yaml_int = function(node) {
      var base, digit, digits, part, sign, value, _i, _len, _ref2;
      value = this.construct_scalar(node);
      value = value.replace(/_/g, '');
      sign = value[0] === '-' ? -1 : 1;
      if (_ref2 = value[0], __indexOf.call('+-', _ref2) >= 0) {
        value = value.slice(1);
      }
      if (value === '0') {
        return 0;
      } else if (value.indexOf('0b') === 0) {
        return sign * parseInt(value.slice(2), 2);
      } else if (value.indexOf('0x') === 0) {
        return sign * parseInt(value.slice(2), 16);
      } else if (value.indexOf('0o') === 0) {
        return sign * parseInt(value.slice(2), 8);
      } else if (value[0] === '0') {
        return sign * parseInt(value, 8);
      } else if (__indexOf.call(value, ':') >= 0) {
        digits = (function() {
          var _i, _len, _ref3, _results;
          _ref3 = value.split(/:/g);
          _results = [];
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            part = _ref3[_i];
            _results.push(parseInt(part));
          }
          return _results;
        })();
        digits.reverse();
        base = 1;
        value = 0;
        for (_i = 0, _len = digits.length; _i < _len; _i++) {
          digit = digits[_i];
          value += digit * base;
          base *= 60;
        }
        return sign * value;
      } else {
        return sign * parseInt(value);
      }
    };

    Constructor.prototype.construct_yaml_float = function(node) {
      var base, digit, digits, part, sign, value, _i, _len, _ref2;
      value = this.construct_scalar(node);
      value = value.replace(/_/g, '').toLowerCase();
      sign = value[0] === '-' ? -1 : 1;
      if (_ref2 = value[0], __indexOf.call('+-', _ref2) >= 0) {
        value = value.slice(1);
      }
      if (value === '.inf') {
        return sign * Infinity;
      } else if (value === '.nan') {
        return NaN;
      } else if (__indexOf.call(value, ':') >= 0) {
        digits = (function() {
          var _i, _len, _ref3, _results;
          _ref3 = value.split(/:/g);
          _results = [];
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            part = _ref3[_i];
            _results.push(parseFloat(part));
          }
          return _results;
        })();
        digits.reverse();
        base = 1;
        value = 0.0;
        for (_i = 0, _len = digits.length; _i < _len; _i++) {
          digit = digits[_i];
          value += digit * base;
          base *= 60;
        }
        return sign * value;
      } else {
        return sign * parseFloat(value);
      }
    };

    Constructor.prototype.construct_yaml_binary = function(node) {
      var error, value;
      value = this.construct_scalar(node);
      try {
        if (typeof window !== "undefined" && window !== null) {
          return atob(value);
        }
        return new Buffer(value, 'base64').toString('ascii');
      } catch (_error) {
        error = _error;
        throw new exports.ConstructorError(null, null, "failed to decode base64 data: " + error, node.start_mark);
      }
    };

    Constructor.prototype.construct_yaml_timestamp = function(node) {
      var date, day, fraction, hour, index, key, match, millisecond, minute, month, second, tz_hour, tz_minute, tz_sign, value, values, year;
      value = this.construct_scalar(node);
      match = node.value.match(TIMESTAMP_REGEX);
      values = {};
      for (key in TIMESTAMP_PARTS) {
        index = TIMESTAMP_PARTS[key];
        values[key] = match[index];
      }
      year = parseInt(values.year);
      month = parseInt(values.month) - 1;
      day = parseInt(values.day);
      if (!values.hour) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = parseInt(values.hour);
      minute = parseInt(values.minute);
      second = parseInt(values.second);
      millisecond = 0;
      if (values.fraction) {
        fraction = values.fraction.slice(0, 6);
        while (fraction.length < 6) {
          fraction += '0';
        }
        fraction = parseInt(fraction);
        millisecond = Math.round(fraction / 1000);
      }
      if (values.tz_sign) {
        tz_sign = values.tz_sign === '-' ? 1 : -1;
        if (tz_hour = parseInt(values.tz_hour)) {
          hour += tz_sign * tz_hour;
        }
        if (tz_minute = parseInt(values.tz_minute)) {
          minute += tz_sign * tz_minute;
        }
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, millisecond));
      return date;
    };

    Constructor.prototype.construct_yaml_pair_list = function(type, node) {
      var list,
        _this = this;
      list = [];
      if (!(node instanceof nodes.SequenceNode)) {
        throw new exports.ConstructorError("while constructing " + type, node.start_mark, "expected an array but found " + node.id, node.start_mark);
      }
      this.defer(function() {
        var key, key_node, subnode, value, value_node, _i, _len, _ref2, _ref3, _results;
        _ref2 = node.value;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          subnode = _ref2[_i];
          if (!(subnode instanceof nodes.MappingNode)) {
            throw new exports.ConstructorError("while constructing " + type, node.start_mark, "expected a map of length 1 but found " + subnode.id, subnode.start_mark);
          }
          if (subnode.value.length !== 1) {
            throw new exports.ConstructorError("while constructing " + type, node.start_mark, "expected a map of length 1 but found " + subnode.id, subnode.start_mark);
          }
          _ref3 = subnode.value[0], key_node = _ref3[0], value_node = _ref3[1];
          key = _this.construct_object(key_node);
          value = _this.construct_object(value_node);
          _results.push(list.push([key, value]));
        }
        return _results;
      });
      return list;
    };

    Constructor.prototype.construct_yaml_omap = function(node) {
      return this.construct_yaml_pair_list('an ordered map', node);
    };

    Constructor.prototype.construct_yaml_pairs = function(node) {
      return this.construct_yaml_pair_list('pairs', node);
    };

    Constructor.prototype.construct_yaml_set = function(node) {
      var data,
        _this = this;
      data = [];
      this.defer(function() {
        var item, _results;
        _results = [];
        for (item in _this.construct_mapping(node)) {
          _results.push(data.push(item));
        }
        return _results;
      });
      return data;
    };

    Constructor.prototype.construct_yaml_str = function(node) {
      return this.construct_scalar(node);
    };

    Constructor.prototype.construct_yaml_seq = function(node) {
      var data,
        _this = this;
      data = [];
      this.defer(function() {
        var item, _i, _len, _ref2, _results;
        _ref2 = _this.construct_sequence(node);
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          item = _ref2[_i];
          _results.push(data.push(item));
        }
        return _results;
      });
      return data;
    };

    Constructor.prototype.construct_yaml_map = function(node) {
      var data,
        _this = this;
      data = {};
      this.defer(function() {
        var key, value, _ref2, _results;
        _ref2 = _this.construct_mapping(node);
        _results = [];
        for (key in _ref2) {
          value = _ref2[key];
          _results.push(data[key] = value);
        }
        return _results;
      });
      return data;
    };

    Constructor.prototype.construct_yaml_object = function(node, klass) {
      var data,
        _this = this;
      data = new klass;
      this.defer(function() {
        var key, value, _ref2, _results;
        _ref2 = _this.construct_mapping(node, true);
        _results = [];
        for (key in _ref2) {
          value = _ref2[key];
          _results.push(data[key] = value);
        }
        return _results;
      });
      return data;
    };

    Constructor.prototype.construct_undefined = function(node) {
      throw new exports.ConstructorError(null, null, "could not determine a constructor for the tag " + node.tag, node.start_mark);
    };

    return Constructor;

  })(this.BaseConstructor);

  this.Constructor.add_constructor('tag:yaml.org,2002:null', this.Constructor.prototype.construct_yaml_null);

  this.Constructor.add_constructor('tag:yaml.org,2002:bool', this.Constructor.prototype.construct_yaml_bool);

  this.Constructor.add_constructor('tag:yaml.org,2002:int', this.Constructor.prototype.construct_yaml_int);

  this.Constructor.add_constructor('tag:yaml.org,2002:float', this.Constructor.prototype.construct_yaml_float);

  this.Constructor.add_constructor('tag:yaml.org,2002:binary', this.Constructor.prototype.construct_yaml_binary);

  this.Constructor.add_constructor('tag:yaml.org,2002:timestamp', this.Constructor.prototype.construct_yaml_timestamp);

  this.Constructor.add_constructor('tag:yaml.org,2002:omap', this.Constructor.prototype.construct_yaml_omap);

  this.Constructor.add_constructor('tag:yaml.org,2002:pairs', this.Constructor.prototype.construct_yaml_pairs);

  this.Constructor.add_constructor('tag:yaml.org,2002:set', this.Constructor.prototype.construct_yaml_set);

  this.Constructor.add_constructor('tag:yaml.org,2002:str', this.Constructor.prototype.construct_yaml_str);

  this.Constructor.add_constructor('tag:yaml.org,2002:seq', this.Constructor.prototype.construct_yaml_seq);

  this.Constructor.add_constructor('tag:yaml.org,2002:map', this.Constructor.prototype.construct_yaml_map);

  this.Constructor.add_constructor(null, this.Constructor.prototype.construct_undefined);

  module.exports.Constructor = this.Constructor;

  module.exports.ConstructorError = this.ConstructorError;

}).call(this);

}).call(this,require("buffer").Buffer)
},{"./errors":33,"./nodes":37,"./util":50,"buffer":10}],33:[function(require,module,exports){
(function() {
  var _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.Mark = (function() {
    function Mark(name, line, column, buffer, pointer) {
      this.name = name;
      this.line = line;
      this.column = column;
      this.buffer = buffer;
      this.pointer = pointer;
    }

    Mark.prototype.get_snippet = function(indent, max_length) {
      var break_chars, end, head, start, tail, _ref, _ref1;
      if (indent == null) {
        indent = 4;
      }
      if (max_length == null) {
        max_length = 75;
      }
      if (this.buffer == null) {
        return null;
      }
      break_chars = '\x00\r\n\x85\u2028\u2029';
      head = '';
      start = this.pointer;
      while (start > 0 && (_ref = this.buffer[start - 1], __indexOf.call(break_chars, _ref) < 0)) {
        start--;
        if (this.pointer - start > max_length / 2 - 1) {
          head = ' ... ';
          start += 5;
          break;
        }
      }
      tail = '';
      end = this.pointer;
      while (end < this.buffer.length && (_ref1 = this.buffer[end], __indexOf.call(break_chars, _ref1) < 0)) {
        end++;
        if (end - this.pointer > max_length / 2 - 1) {
          tail = ' ... ';
          end -= 5;
          break;
        }
      }
      return "" + ((new Array(indent)).join(' ')) + head + this.buffer.slice(start, end) + tail + "\n" + ((new Array(indent + this.pointer - start + head.length)).join(' ')) + "^";
    };

    Mark.prototype.toString = function() {
      var snippet, where;
      snippet = this.get_snippet();
      where = "  in \"" + this.name + "\", line " + (this.line + 1) + ", column " + (this.column + 1);
      if (snippet) {
        return where;
      } else {
        return "" + where + ":\n" + snippet;
      }
    };

    return Mark;

  })();

  this.YAMLError = (function(_super) {
    __extends(YAMLError, _super);

    function YAMLError() {
      YAMLError.__super__.constructor.call(this);
    }

    return YAMLError;

  })(Error);

  this.MarkedYAMLError = (function(_super) {
    __extends(MarkedYAMLError, _super);

    function MarkedYAMLError(context, context_mark, message, problem_mark, note) {
      this.context = context;
      this.context_mark = context_mark;
      this.message = message;
      this.problem_mark = problem_mark;
      this.note = note;
      MarkedYAMLError.__super__.constructor.call(this);
      if (!this.message) {
        this.message = this.context;
      }
      if (!this.problem_mark) {
        this.problem_mark = this.context_mark;
      }
    }

    MarkedYAMLError.prototype.toString = function() {
      var lines;
      lines = [];
      if (this.context != null) {
        lines.push(this.context);
      }
      if ((this.context_mark != null) && ((this.message == null) || (this.problem_mark == null) || this.context_mark.name !== this.problem_mark.name || this.context_mark.line !== this.problem_mark.line || this.context_mark.column !== this.problem_mark.column)) {
        lines.push(this.context_mark.toString());
      }
      if (this.message != null) {
        lines.push(this.message);
      }
      if (this.problem_mark != null) {
        lines.push(this.problem_mark.toString());
      }
      if (this.note != null) {
        lines.push(this.note);
      }
      return lines.join('\n');
    };

    return MarkedYAMLError;

  })(this.YAMLError);

  /*
  The Validator throws these.
  */


  this.ValidationError = (function(_super) {
    __extends(ValidationError, _super);

    function ValidationError() {
      _ref = ValidationError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ValidationError;

  })(this.MarkedYAMLError);

}).call(this);

},{}],34:[function(require,module,exports){
(function() {
  var _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.Event = (function() {
    function Event(start_mark, end_mark) {
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return Event;

  })();

  this.NodeEvent = (function(_super) {
    __extends(NodeEvent, _super);

    function NodeEvent(anchor, start_mark, end_mark) {
      this.anchor = anchor;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return NodeEvent;

  })(this.Event);

  this.CollectionStartEvent = (function(_super) {
    __extends(CollectionStartEvent, _super);

    function CollectionStartEvent(anchor, tag, implicit, start_mark, end_mark) {
      this.anchor = anchor;
      this.tag = tag;
      this.implicit = implicit;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return CollectionStartEvent;

  })(this.NodeEvent);

  this.CollectionEndEvent = (function(_super) {
    __extends(CollectionEndEvent, _super);

    function CollectionEndEvent() {
      _ref = CollectionEndEvent.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return CollectionEndEvent;

  })(this.Event);

  this.StreamStartEvent = (function(_super) {
    __extends(StreamStartEvent, _super);

    function StreamStartEvent(start_mark, end_mark, explicit, version, tags) {
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.explicit = explicit;
      this.version = version;
      this.tags = tags;
    }

    return StreamStartEvent;

  })(this.Event);

  this.StreamEndEvent = (function(_super) {
    __extends(StreamEndEvent, _super);

    function StreamEndEvent() {
      _ref1 = StreamEndEvent.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return StreamEndEvent;

  })(this.Event);

  this.DocumentStartEvent = (function(_super) {
    __extends(DocumentStartEvent, _super);

    function DocumentStartEvent(start_mark, end_mark, explicit, version, tags) {
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.explicit = explicit;
      this.version = version;
      this.tags = tags;
    }

    return DocumentStartEvent;

  })(this.Event);

  this.DocumentEndEvent = (function(_super) {
    __extends(DocumentEndEvent, _super);

    function DocumentEndEvent(start_mark, end_mark, explicit) {
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.explicit = explicit;
    }

    return DocumentEndEvent;

  })(this.Event);

  this.AliasEvent = (function(_super) {
    __extends(AliasEvent, _super);

    function AliasEvent() {
      _ref2 = AliasEvent.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    return AliasEvent;

  })(this.NodeEvent);

  this.ScalarEvent = (function(_super) {
    __extends(ScalarEvent, _super);

    function ScalarEvent(anchor, tag, implicit, value, start_mark, end_mark, style) {
      this.anchor = anchor;
      this.tag = tag;
      this.implicit = implicit;
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.style = style;
    }

    return ScalarEvent;

  })(this.NodeEvent);

  this.SequenceStartEvent = (function(_super) {
    __extends(SequenceStartEvent, _super);

    function SequenceStartEvent() {
      _ref3 = SequenceStartEvent.__super__.constructor.apply(this, arguments);
      return _ref3;
    }

    return SequenceStartEvent;

  })(this.CollectionStartEvent);

  this.SequenceEndEvent = (function(_super) {
    __extends(SequenceEndEvent, _super);

    function SequenceEndEvent() {
      _ref4 = SequenceEndEvent.__super__.constructor.apply(this, arguments);
      return _ref4;
    }

    return SequenceEndEvent;

  })(this.CollectionEndEvent);

  this.MappingStartEvent = (function(_super) {
    __extends(MappingStartEvent, _super);

    function MappingStartEvent() {
      _ref5 = MappingStartEvent.__super__.constructor.apply(this, arguments);
      return _ref5;
    }

    return MappingStartEvent;

  })(this.CollectionStartEvent);

  this.MappingEndEvent = (function(_super) {
    __extends(MappingEndEvent, _super);

    function MappingEndEvent() {
      _ref6 = MappingEndEvent.__super__.constructor.apply(this, arguments);
      return _ref6;
    }

    return MappingEndEvent;

  })(this.CollectionEndEvent);

}).call(this);

},{}],35:[function(require,module,exports){
(function() {
  var MarkedYAMLError, nodes, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  /*
  The Traits throws these.
  */


  this.JoinError = (function(_super) {
    __extends(JoinError, _super);

    function JoinError() {
      _ref = JoinError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return JoinError;

  })(MarkedYAMLError);

  /*
  The Joiner class groups resources under resource property and groups methods under operations property
  */


  this.Joiner = (function() {
    function Joiner() {}

    Joiner.prototype.join_resources = function(node, call) {
      var resources, resourcesArray, resourcesName, resourcesValue,
        _this = this;
      if (call == null) {
        call = 0;
      }
      resources = [];
      if (node != null ? node.value : void 0) {
        resources = node.value.filter(function(childNode) {
          var _ref1;
          return (_ref1 = childNode[0]) != null ? _ref1.value.match(/^\//) : void 0;
        });
      }
      resourcesArray = [];
      if (resources.length > 0) {
        if (node != null ? node.value : void 0) {
          node.value = node.value.filter(function(childNode) {
            return !childNode[0].value.match(/^\//);
          });
        }
        resourcesName = new nodes.ScalarNode('tag:yaml.org,2002:str', 'resources', resources[0][0].start_mark, resources[resources.length - 1][1].end_mark);
        resources.forEach(function(resource) {
          var relativeUriName, relativeUriValue;
          relativeUriName = new nodes.ScalarNode('tag:yaml.org,2002:str', 'relativeUri', resource[0].start_mark, resource[1].end_mark);
          relativeUriValue = new nodes.ScalarNode('tag:yaml.org,2002:str', resource[0].value, resource[0].start_mark, resource[1].end_mark);
          if (resource[1].tag === "tag:yaml.org,2002:null") {
            resource[1] = new nodes.MappingNode('tag:yaml.org,2002:map', [], resource[0].start_mark, resource[1].end_mark);
          }
          resource[1].value.push([relativeUriName, relativeUriValue]);
          resourcesArray.push(resource[1]);
          _this.join_methods(resource[1]);
          return _this.join_resources(resource[1], ++call);
        });
        resourcesValue = new nodes.SequenceNode('tag:yaml.org,2002:seq', resourcesArray, resources[0][0].start_mark, resources[resources.length - 1][1].end_mark);
        return node.value.push([resourcesName, resourcesValue]);
      }
    };

    Joiner.prototype.join_methods = function(node) {
      var methods, methodsArray, methodsName, methodsValue,
        _this = this;
      methods = [];
      if (node && node.value) {
        methods = node.value.filter(function(childNode) {
          var _ref1;
          return _this.isHttpMethod((_ref1 = childNode[0]) != null ? _ref1.value : void 0);
        });
      }
      methodsArray = [];
      if (methods.length > 0) {
        node.value = node.value.filter(function(childNode) {
          return !_this.isHttpMethod(childNode[0].value);
        });
        methodsName = new nodes.ScalarNode('tag:yaml.org,2002:str', 'methods', methods[0][0].start_mark, methods[methods.length - 1][1].end_mark);
        methods.forEach(function(method) {
          var methodName, methodValue;
          methodName = new nodes.ScalarNode('tag:yaml.org,2002:str', 'method', method[0].start_mark, method[1].end_mark);
          methodValue = new nodes.ScalarNode('tag:yaml.org,2002:str', method[0].value, method[0].start_mark, method[1].end_mark);
          if (method[1].tag === 'tag:yaml.org,2002:null') {
            method[1] = new nodes.MappingNode('tag:yaml.org,2002:map', [], method[1].start_mark, method[1].end_mark);
          }
          method[1].value.push([methodName, methodValue]);
          return methodsArray.push(method[1]);
        });
        methodsValue = new nodes.SequenceNode('tag:yaml.org,2002:seq', methodsArray, methods[0][0].start_mark, methods[methods.length - 1][1].end_mark);
        return node.value.push([methodsName, methodsValue]);
      }
    };

    return Joiner;

  })();

}).call(this);

},{"./errors":33,"./nodes":37}],36:[function(require,module,exports){
(function() {
  var composer, construct, joiner, parser, protocols, reader, resolver, scanner, schemas, securitySchemes, traits, transformations, types, util, validator;

  util = require('./util');

  reader = require('./reader');

  scanner = require('./scanner');

  parser = require('./parser');

  composer = require('./composer');

  resolver = require('./resolver');

  construct = require('./construct');

  validator = require('./validator');

  joiner = require('./joiner');

  traits = require('./traits');

  types = require('./resourceTypes');

  schemas = require('./schemas');

  protocols = require('./protocols');

  securitySchemes = require('./securitySchemes');

  transformations = require('./transformations');

  this.make_loader = function(Reader, Scanner, Parser, Composer, Resolver, Validator, ResourceTypes, Traits, Schemas, Protocols, Joiner, SecuritySchemes, Constructor, Transformations) {
    if (Reader == null) {
      Reader = reader.Reader;
    }
    if (Scanner == null) {
      Scanner = scanner.Scanner;
    }
    if (Parser == null) {
      Parser = parser.Parser;
    }
    if (Composer == null) {
      Composer = composer.Composer;
    }
    if (Resolver == null) {
      Resolver = resolver.Resolver;
    }
    if (Validator == null) {
      Validator = validator.Validator;
    }
    if (ResourceTypes == null) {
      ResourceTypes = types.ResourceTypes;
    }
    if (Traits == null) {
      Traits = traits.Traits;
    }
    if (Schemas == null) {
      Schemas = schemas.Schemas;
    }
    if (Protocols == null) {
      Protocols = protocols.Protocols;
    }
    if (Joiner == null) {
      Joiner = joiner.Joiner;
    }
    if (SecuritySchemes == null) {
      SecuritySchemes = securitySchemes.SecuritySchemes;
    }
    if (Constructor == null) {
      Constructor = construct.Constructor;
    }
    if (Transformations == null) {
      Transformations = transformations.Transformations;
    }
    return (function() {
      var component, components;

      components = [Reader, Scanner, Composer, Transformations, Parser, Resolver, Validator, Traits, ResourceTypes, Schemas, Protocols, Joiner, Constructor, SecuritySchemes];

      util.extend.apply(util, [_Class.prototype].concat((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = components.length; _i < _len; _i++) {
          component = components[_i];
          _results.push(component.prototype);
        }
        return _results;
      })()));

      function _Class(stream, location, settings, parent) {
        var _i, _len, _ref;
        this.parent = parent != null ? parent : null;
        components[0].call(this, stream, location);
        components[1].call(this, settings);
        components[2].call(this, settings);
        components[3].call(this, settings);
        _ref = components.slice(4);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          component = _ref[_i];
          component.call(this);
        }
      }

      return _Class;

    })();
  };

  this.Loader = this.make_loader();

}).call(this);

},{"./composer":31,"./construct":32,"./joiner":35,"./parser":38,"./protocols":39,"./reader":41,"./resolver":42,"./resourceTypes":43,"./scanner":44,"./schemas":45,"./securitySchemes":46,"./traits":48,"./transformations":49,"./util":50,"./validator":51}],37:[function(require,module,exports){
(function() {
  var MarkedYAMLError, unique_id, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  unique_id = 0;

  this.ApplicationError = (function(_super) {
    __extends(ApplicationError, _super);

    function ApplicationError() {
      _ref = ApplicationError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ApplicationError;

  })(MarkedYAMLError);

  this.Node = (function() {
    function Node(tag, value, start_mark, end_mark) {
      this.tag = tag;
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.unique_id = "node_" + (unique_id++);
    }

    Node.prototype.clone = function() {
      var temp;
      temp = new this.constructor(this.tag, this.value, this.start_mark, this.end_mark);
      return temp;
    };

    return Node;

  })();

  this.ScalarNode = (function(_super) {
    __extends(ScalarNode, _super);

    ScalarNode.prototype.id = 'scalar';

    function ScalarNode(tag, value, start_mark, end_mark, style) {
      this.tag = tag;
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.style = style;
      ScalarNode.__super__.constructor.apply(this, arguments);
    }

    ScalarNode.prototype.clone = function() {
      var temp;
      temp = new this.constructor(this.tag, this.value, this.start_mark, this.end_mark, this.style);
      return temp;
    };

    ScalarNode.prototype.cloneRemoveIs = function() {
      return this.clone();
    };

    ScalarNode.prototype.combine = function(node) {
      if (this.tag === 'tag:yaml.org,2002:null' && node.tag === 'tag:yaml.org,2002:map') {
        this.value = new exports.MappingNode('tag:yaml.org,2002:map', [], node.start_mark, node.end_mark);
        return this.value.combine(node);
      } else if (!(node instanceof exports.ScalarNode)) {
        throw new exports.ApplicationError('while applying node', null, 'different YAML structures', this.start_mark);
      }
      return this.value = node.value;
    };

    ScalarNode.prototype.remove_question_mark_properties = function() {};

    return ScalarNode;

  })(this.Node);

  this.CollectionNode = (function(_super) {
    __extends(CollectionNode, _super);

    function CollectionNode(tag, value, start_mark, end_mark, flow_style) {
      this.tag = tag;
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.flow_style = flow_style;
      CollectionNode.__super__.constructor.apply(this, arguments);
    }

    return CollectionNode;

  })(this.Node);

  this.SequenceNode = (function(_super) {
    __extends(SequenceNode, _super);

    function SequenceNode() {
      _ref1 = SequenceNode.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    SequenceNode.prototype.id = 'sequence';

    SequenceNode.prototype.clone = function() {
      var item, items, temp, value, _i, _len, _ref2;
      items = [];
      _ref2 = this.value;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        item = _ref2[_i];
        value = item.clone();
        items.push(value);
      }
      temp = new this.constructor(this.tag, items, this.start_mark, this.end_mark, this.flow_style);
      return temp;
    };

    SequenceNode.prototype.cloneRemoveIs = function() {
      return this.clone();
    };

    SequenceNode.prototype.combine = function(node) {
      var property, value, _i, _len, _ref2, _results;
      if (!(node instanceof exports.SequenceNode)) {
        throw new exports.ApplicationError('while applying node', null, 'different YAML structures', this.start_mark);
      }
      _ref2 = node.value;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        property = _ref2[_i];
        value = property.clone();
        _results.push(this.value.push(value));
      }
      return _results;
    };

    SequenceNode.prototype.remove_question_mark_properties = function() {
      var item, _i, _len, _ref2, _results;
      _ref2 = this.value;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        item = _ref2[_i];
        _results.push(item.remove_question_mark_properties());
      }
      return _results;
    };

    return SequenceNode;

  })(this.CollectionNode);

  this.MappingNode = (function(_super) {
    __extends(MappingNode, _super);

    function MappingNode() {
      _ref2 = MappingNode.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    MappingNode.prototype.id = 'mapping';

    MappingNode.prototype.clone = function() {
      var name, properties, property, temp, value, _i, _len, _ref3;
      properties = [];
      _ref3 = this.value;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        property = _ref3[_i];
        name = property[0].clone();
        value = property[1].clone();
        properties.push([name, value]);
      }
      temp = new this.constructor(this.tag, properties, this.start_mark, this.end_mark, this.flow_style);
      return temp;
    };

    MappingNode.prototype.cloneRemoveIs = function() {
      var name, properties, property, temp, value, _i, _len, _ref3, _ref4;
      properties = [];
      _ref3 = this.value;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        property = _ref3[_i];
        name = property[0].cloneRemoveIs();
        value = property[1].cloneRemoveIs();
        if ((_ref4 = name.value) !== 'is') {
          properties.push([name, value]);
        }
      }
      temp = new this.constructor(this.tag, properties, this.start_mark, this.end_mark, this.flow_style);
      return temp;
    };

    MappingNode.prototype.cloneForTrait = function() {
      var name, properties, property, temp, value, _i, _len, _ref3, _ref4;
      properties = [];
      _ref3 = this.value;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        property = _ref3[_i];
        name = property[0].clone();
        value = property[1].clone();
        if ((_ref4 = name.value) !== 'usage' && _ref4 !== 'displayName') {
          properties.push([name, value]);
        }
      }
      temp = new this.constructor(this.tag, properties, this.start_mark, this.end_mark, this.flow_style);
      return temp;
    };

    MappingNode.prototype.cloneForResourceType = function() {
      var name, properties, property, temp, value, _i, _len, _ref3, _ref4;
      properties = [];
      _ref3 = this.value;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        property = _ref3[_i];
        name = property[0].cloneRemoveIs();
        value = property[1].cloneRemoveIs();
        if ((_ref4 = name.value) !== 'is' && _ref4 !== 'type' && _ref4 !== 'usage' && _ref4 !== 'displayName') {
          properties.push([name, value]);
        }
      }
      temp = new this.constructor(this.tag, properties, this.start_mark, this.end_mark, this.flow_style);
      return temp;
    };

    MappingNode.prototype.combine = function(resourceNode) {
      var name, node_has_property, nonNullNode, ownNodeProperty, ownNodePropertyName, resourceProperty, _i, _len, _ref3, _results;
      if (resourceNode.tag === 'tag:yaml.org,2002:null') {
        resourceNode = new exports.MappingNode('tag:yaml.org,2002:map', [], resourceNode.start_mark, resourceNode.end_mark);
      }
      if (!(resourceNode instanceof exports.MappingNode)) {
        throw new exports.ApplicationError('while applying node', null, 'different YAML structures', this.start_mark);
      }
      _ref3 = resourceNode.value;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        resourceProperty = _ref3[_i];
        name = resourceProperty[0].value;
        node_has_property = this.value.some(function(someProperty) {
          return (someProperty[0].value === name) || ((someProperty[0].value + '?') === name) || (someProperty[0].value === (name + '?'));
        });
        if (node_has_property) {
          _results.push((function() {
            var _j, _len1, _ref4, _results1;
            _ref4 = this.value;
            _results1 = [];
            for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
              ownNodeProperty = _ref4[_j];
              ownNodePropertyName = ownNodeProperty[0].value;
              if ((ownNodePropertyName === name) || ((ownNodePropertyName + '?') === name) || (ownNodePropertyName === (name + '?'))) {
                if ((ownNodeProperty[1].tag === 'tag:yaml.org,2002:null') && (resourceProperty[1].tag === 'tag:yaml.org,2002:map')) {
                  nonNullNode = new exports.MappingNode('tag:yaml.org,2002:map', [], ownNodeProperty[1].start_mark, ownNodeProperty[1].end_mark);
                  ownNodeProperty[1] = nonNullNode;
                }
                ownNodeProperty[1].combine(resourceProperty[1]);
                if (!((ownNodeProperty[0].value.slice(-1) === '?') && (resourceProperty[0].value.slice(-1) === '?'))) {
                  if (ownNodeProperty[0].value.slice(-1) === '?') {
                    _results1.push(ownNodeProperty[0].value = ownNodeProperty[0].value.slice(0, -1));
                  } else {
                    _results1.push(void 0);
                  }
                } else {
                  _results1.push(void 0);
                }
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }).call(this));
        } else {
          _results.push(this.value.push([resourceProperty[0].clone(), resourceProperty[1].clone()]));
        }
      }
      return _results;
    };

    MappingNode.prototype.remove_question_mark_properties = function() {
      var property, _i, _len, _ref3, _results;
      this.value = this.value.filter(function(property) {
        return property[0].value.slice(-1) !== '?';
      });
      _ref3 = this.value;
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        property = _ref3[_i];
        _results.push(property[1].remove_question_mark_properties());
      }
      return _results;
    };

    return MappingNode;

  })(this.CollectionNode);

}).call(this);

},{"./errors":33}],38:[function(require,module,exports){
(function() {
  var MarkedYAMLError, events, tokens, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  events = require('./events');

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  tokens = require('./tokens');

  this.ParserError = (function(_super) {
    __extends(ParserError, _super);

    function ParserError() {
      _ref = ParserError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ParserError;

  })(MarkedYAMLError);

  this.Parser = (function() {
    var DEFAULT_TAGS;

    DEFAULT_TAGS = {
      '!': '!',
      '!!': 'tag:yaml.org,2002:'
    };

    function Parser() {
      this.current_event = null;
      this.yaml_version = null;
      this.tag_handles = {};
      this.states = [];
      this.marks = [];
      this.state = 'parse_stream_start';
    }

    /*
    Reset the state attributes.
    */


    Parser.prototype.dispose = function() {
      this.states = [];
      return this.state = null;
    };

    /*
    Check the type of the next event.
    */


    Parser.prototype.check_event = function() {
      var choice, choices, _i, _len;
      choices = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.current_event === null) {
        if (this.state != null) {
          this.current_event = this[this.state]();
        }
      }
      if (this.current_event !== null) {
        if (choices.length === 0) {
          return true;
        }
        for (_i = 0, _len = choices.length; _i < _len; _i++) {
          choice = choices[_i];
          if (this.current_event instanceof choice) {
            return true;
          }
        }
      }
      return false;
    };

    /*
    Get the next event.
    */


    Parser.prototype.peek_event = function() {
      if (this.current_event === null && (this.state != null)) {
        this.current_event = this[this.state]();
      }
      return this.current_event;
    };

    /*
    Get the event and proceed further.
    */


    Parser.prototype.get_event = function() {
      var event;
      if (this.current_event === null && (this.state != null)) {
        this.current_event = this[this.state]();
      }
      event = this.current_event;
      this.current_event = null;
      return event;
    };

    /*
    Parse the stream start.
    */


    Parser.prototype.parse_stream_start = function() {
      var event, token;
      token = this.get_token();
      event = new events.StreamStartEvent(token.start_mark, token.end_mark);
      this.state = 'parse_implicit_document_start';
      return event;
    };

    /*
    Parse an implicit document.
    */


    Parser.prototype.parse_implicit_document_start = function() {
      var end_mark, event, start_mark, token;
      if (!this.check_token(tokens.DirectiveToken, tokens.DocumentStartToken, tokens.StreamEndToken)) {
        this.tag_handles = DEFAULT_TAGS;
        token = this.peek_token();
        start_mark = end_mark = token.start_mark;
        event = new events.DocumentStartEvent(start_mark, end_mark, false);
        this.states.push('parse_document_end');
        this.state = 'parse_block_node';
        return event;
      } else {
        return this.parse_document_start();
      }
    };

    /*
    Parse an explicit document.
    */


    Parser.prototype.parse_document_start = function() {
      var end_mark, event, start_mark, tags, token, version, _ref1;
      while (this.check_token(tokens.DocumentEndToken)) {
        this.get_token();
      }
      if (!this.check_token(tokens.StreamEndToken)) {
        start_mark = this.peek_token().start_mark;
        _ref1 = this.process_directives(), version = _ref1[0], tags = _ref1[1];
        if (!this.check_token(tokens.DocumentStartToken)) {
          throw new exports.ParserError("expected '<document start>', but found " + (this.peek_token().id), this.peek_token().start_mark);
        }
        token = this.get_token();
        end_mark = token.end_mark;
        event = new events.DocumentStartEvent(start_mark, end_mark, true, version, tags);
        this.states.push('parse_document_end');
        this.state = 'parse_document_content';
      } else {
        token = this.get_token();
        event = new events.StreamEndEvent(token.start_mark, token.end_mark);
        if (this.states.length !== 0) {
          throw new Error('assertion error, states should be empty');
        }
        if (this.marks.length !== 0) {
          throw new Error('assertion error, marks should be empty');
        }
        this.state = null;
      }
      return event;
    };

    /*
    Parse the document end.
    */


    Parser.prototype.parse_document_end = function() {
      var end_mark, event, explicit, start_mark, token;
      token = this.peek_token();
      start_mark = end_mark = token.start_mark;
      explicit = false;
      if (this.check_token(tokens.DocumentEndToken)) {
        token = this.get_token();
        end_mark = token.end_mark;
        explicit = true;
      }
      event = new events.DocumentEndEvent(start_mark, end_mark, explicit);
      this.state = 'parse_document_start';
      return event;
    };

    Parser.prototype.parse_document_content = function() {
      var event;
      if (this.check_token(tokens.DirectiveToken, tokens.DocumentStartToken, tokens.DocumentEndToken, tokens.StreamEndToken)) {
        event = this.process_empty_scalar(this.peek_token().start_mark);
        this.state = this.states.pop();
        return event;
      } else {
        return this.parse_block_node();
      }
    };

    Parser.prototype.process_directives = function() {
      var handle, major, minor, prefix, tag_handles_copy, token, value, _ref1, _ref2, _ref3;
      this.yaml_version = null;
      this.tag_handles = {};
      while (this.check_token(tokens.DirectiveToken)) {
        token = this.get_token();
        if (token.name === 'YAML') {
          if (this.yaml_version !== null) {
            throw new exports.ParserError(null, null, 'found duplicate YAML directive', token.start_mark);
          }
          _ref1 = token.value, major = _ref1[0], minor = _ref1[1];
          if (major !== 1 || minor !== 2) {
            throw new exports.ParserError(null, null, 'found incompatible YAML document (version 1.2 is required)', token.start_mark);
          }
          this.yaml_version = token.value;
        } else if (token.name === 'TAG') {
          _ref2 = token.value, handle = _ref2[0], prefix = _ref2[1];
          if (handle in this.tag_handles) {
            throw new exports.ParserError(null, null, "duplicate tag handle " + handle, token.start_mark);
          }
          this.tag_handles[handle] = prefix;
        }
      }
      tag_handles_copy = null;
      _ref3 = this.tag_handles;
      for (handle in _ref3) {
        if (!__hasProp.call(_ref3, handle)) continue;
        prefix = _ref3[handle];
        if (tag_handles_copy == null) {
          tag_handles_copy = {};
        }
        tag_handles_copy[handle] = prefix;
      }
      value = [this.yaml_version, tag_handles_copy];
      for (handle in DEFAULT_TAGS) {
        if (!__hasProp.call(DEFAULT_TAGS, handle)) continue;
        prefix = DEFAULT_TAGS[handle];
        if (!(prefix in this.tag_handles)) {
          this.tag_handles[handle] = prefix;
        }
      }
      return value;
    };

    Parser.prototype.parse_block_node = function() {
      return this.parse_node(true);
    };

    Parser.prototype.parse_flow_node = function() {
      return this.parse_node();
    };

    Parser.prototype.parse_block_node_or_indentless_sequence = function() {
      return this.parse_node(true, true);
    };

    Parser.prototype.parse_node = function(block, indentless_sequence) {
      var anchor, end_mark, event, handle, implicit, node, start_mark, suffix, tag, tag_mark, token;
      if (block == null) {
        block = false;
      }
      if (indentless_sequence == null) {
        indentless_sequence = false;
      }
      if (this.check_token(tokens.AliasToken)) {
        token = this.get_token();
        event = new events.AliasEvent(token.value, token.start_mark, token.end_mark);
        this.state = this.states.pop();
      } else {
        anchor = null;
        tag = null;
        start_mark = end_mark = tag_mark = null;
        if (this.check_token(tokens.AnchorToken)) {
          token = this.get_token();
          start_mark = token.start_mark;
          end_mark = token.end_mark;
          anchor = token.value;
          if (this.check_token(tokens.TagToken)) {
            token = this.get_token();
            tag_mark = token.start_mark;
            end_mark = token.end_mark;
            tag = token.value;
          }
        } else if (this.check_token(tokens.TagToken)) {
          token = this.get_token();
          start_mark = tag_mark = token.start_mark;
          end_mark = token.end_mark;
          tag = token.value;
          if (this.check_token(tokens.AnchorToken)) {
            token = this.get_token();
            end_mark = token.end_mark;
            anchor = token.value;
          }
        }
        if (tag !== null) {
          handle = tag[0], suffix = tag[1];
          if (handle !== null) {
            if (!(handle in this.tag_handles)) {
              throw new exports.ParserError('while parsing a node', start_mark, "found undefined tag handle " + handle, tag_mark);
            }
            tag = this.tag_handles[handle] + suffix;
          } else {
            tag = suffix;
          }
        }
        if (start_mark === null) {
          start_mark = end_mark = this.peek_token().start_mark;
        }
        event = null;
        implicit = tag === null || tag === '!';
        if (indentless_sequence && this.check_token(tokens.BlockEntryToken)) {
          end_mark = this.peek_token().end_mark;
          event = new events.SequenceStartEvent(anchor, tag, implicit, start_mark, end_mark);
          this.state = 'parse_indentless_sequence_entry';
        } else {
          if (this.check_token(tokens.ScalarToken)) {
            token = this.get_token();
            end_mark = token.end_mark;
            if ((token.plain && tag === null) || tag === '!') {
              implicit = [true, false];
            } else if (tag === null) {
              implicit = [false, true];
            } else {
              implicit = [false, false];
            }
            event = new events.ScalarEvent(anchor, tag, implicit, token.value, start_mark, end_mark, token.style);
            this.state = this.states.pop();
          } else if (this.check_token(tokens.FlowSequenceStartToken)) {
            end_mark = this.peek_token().end_mark;
            event = new events.SequenceStartEvent(anchor, tag, implicit, start_mark, end_mark, true);
            this.state = 'parse_flow_sequence_first_entry';
          } else if (this.check_token(tokens.FlowMappingStartToken)) {
            end_mark = this.peek_token().end_mark;
            event = new events.MappingStartEvent(anchor, tag, implicit, start_mark, end_mark, true);
            this.state = 'parse_flow_mapping_first_key';
          } else if (block && this.check_token(tokens.BlockSequenceStartToken)) {
            end_mark = this.peek_token().end_mark;
            event = new events.SequenceStartEvent(anchor, tag, implicit, start_mark, end_mark, false);
            this.state = 'parse_block_sequence_first_entry';
          } else if (block && this.check_token(tokens.BlockMappingStartToken)) {
            end_mark = this.peek_token().end_mark;
            event = new events.MappingStartEvent(anchor, tag, implicit, start_mark, end_mark, false);
            this.state = 'parse_block_mapping_first_key';
          } else if (anchor !== null || tag !== null) {
            event = new events.ScalarEvent(anchor, tag, [implicit, false], '', start_mark, end_mark);
            this.state = this.states.pop();
          } else {
            if (block) {
              node = 'block';
            } else {
              node = 'flow';
            }
            token = this.peek_token();
            throw new exports.ParserError("while parsing a " + node + " node", start_mark, "expected the node content, but found " + token.id, token.start_mark);
          }
        }
      }
      return event;
    };

    Parser.prototype.parse_block_sequence_first_entry = function() {
      var token;
      token = this.get_token();
      this.marks.push(token.start_mark);
      return this.parse_block_sequence_entry();
    };

    Parser.prototype.parse_block_sequence_entry = function() {
      var event, token;
      if (this.check_token(tokens.BlockEntryToken)) {
        token = this.get_token();
        if (!this.check_token(tokens.BlockEntryToken, tokens.BlockEndToken)) {
          this.states.push('parse_block_sequence_entry');
          return this.parse_block_node();
        } else {
          this.state = 'parse_block_sequence_entry';
          return this.process_empty_scalar(token.end_mark);
        }
      }
      if (!this.check_token(tokens.BlockEndToken)) {
        token = this.peek_token();
        throw new exports.ParserError('while parsing a block collection', this.marks.slice(-1)[0], "expected <block end>, but found " + token.id, token.start_mark);
      }
      token = this.get_token();
      event = new events.SequenceEndEvent(token.start_mark, token.end_mark);
      this.state = this.states.pop();
      this.marks.pop();
      return event;
    };

    Parser.prototype.parse_indentless_sequence_entry = function() {
      var event, token;
      if (this.check_token(tokens.BlockEntryToken)) {
        token = this.get_token();
        if (!this.check_token(tokens.BlockEntryToken, tokens.KeyToken, tokens.ValueToken, tokens.BlockEndToken)) {
          this.states.push('parse_indentless_sequence_entry');
          return this.parse_block_node();
        } else {
          this.state = 'parse_indentless_sequence_entry';
          return this.process_empty_scalar(token.end_mark);
        }
      }
      token = this.peek_token();
      event = new events.SequenceEndEvent(token.start_mark, token.start_mark);
      this.state = this.states.pop();
      return event;
    };

    Parser.prototype.parse_block_mapping_first_key = function() {
      var token;
      token = this.get_token();
      this.marks.push(token.start_mark);
      return this.parse_block_mapping_key();
    };

    Parser.prototype.parse_block_mapping_key = function() {
      var event, token;
      if (this.check_token(tokens.KeyToken)) {
        token = this.get_token();
        if (!this.check_token(tokens.KeyToken, tokens.ValueToken, tokens.BlockEndToken)) {
          this.states.push('parse_block_mapping_value');
          return this.parse_block_node_or_indentless_sequence();
        } else {
          this.state = 'parse_block_mapping_value';
          return this.process_empty_scalar(token.end_mark);
        }
      }
      if (!this.check_token(tokens.BlockEndToken)) {
        token = this.peek_token();
        throw new exports.ParserError('while parsing a block mapping', this.marks.slice(-1)[0], "expected <block end>, but found " + token.id, token.start_mark);
      }
      token = this.get_token();
      event = new events.MappingEndEvent(token.start_mark, token.end_mark);
      this.state = this.states.pop();
      this.marks.pop();
      return event;
    };

    Parser.prototype.parse_block_mapping_value = function() {
      var token;
      if (this.check_token(tokens.ValueToken)) {
        token = this.get_token();
        if (!this.check_token(tokens.KeyToken, tokens.ValueToken, tokens.BlockEndToken)) {
          this.states.push('parse_block_mapping_key');
          return this.parse_block_node_or_indentless_sequence();
        } else {
          this.state = 'parse_block_mapping_key';
          return this.process_empty_scalar(token.end_mark);
        }
      } else {
        this.state = 'parse_block_mapping_key';
        token = this.peek_token();
        return this.process_empty_scalar(token.start_mark);
      }
    };

    Parser.prototype.parse_flow_sequence_first_entry = function() {
      var token;
      token = this.get_token();
      this.marks.push(token.start_mark);
      return this.parse_flow_sequence_entry(true);
    };

    Parser.prototype.parse_flow_sequence_entry = function(first) {
      var event, token;
      if (first == null) {
        first = false;
      }
      if (!this.check_token(tokens.FlowSequenceEndToken)) {
        if (!first) {
          if (this.check_token(tokens.FlowEntryToken)) {
            this.get_token();
          } else {
            token = this.peek_token();
            throw new exports.ParserError('while parsing a flow sequence', this.marks.slice(-1)[0], "expected ',' or ']', but got " + token.id, token.start_mark);
          }
        }
        if (this.check_token(tokens.KeyToken)) {
          token = this.peek_token();
          event = new events.MappingStartEvent(null, null, true, token.start_mark, token.end_mark, true);
          this.state = 'parse_flow_sequence_entry_mapping_key';
          return event;
        } else if (!this.check_token(tokens.FlowSequenceEndToken)) {
          this.states.push('parse_flow_sequence_entry');
          return this.parse_flow_node();
        }
      }
      token = this.get_token();
      event = new events.SequenceEndEvent(token.start_mark, token.end_mark);
      this.state = this.states.pop();
      this.marks.pop();
      return event;
    };

    Parser.prototype.parse_flow_sequence_entry_mapping_key = function() {
      var token;
      token = this.get_token();
      if (!this.check_token(tokens.ValueToken, tokens.FlowEntryToken, tokens.FlowSequenceEndToken)) {
        this.states.push('parse_flow_sequence_entry_mapping_value');
        return this.parse_flow_node();
      } else {
        this.state = 'parse_flow_sequence_entry_mapping_value';
        return this.process_empty_scalar(token.end_mark);
      }
    };

    Parser.prototype.parse_flow_sequence_entry_mapping_value = function() {
      var token;
      if (this.check_token(tokens.ValueToken)) {
        token = this.get_token();
        if (!this.check_token(tokens.FlowEntryToken, tokens.FlowSequenceEndToken)) {
          this.states.push('parse_flow_sequence_entry_mapping_end');
          return this.parse_flow_node();
        } else {
          this.state = 'parse_flow_sequence_entry_mapping_end';
          return this.process_empty_scalar(token.end_mark);
        }
      } else {
        this.state = 'parse_flow_sequence_entry_mapping_end';
        token = this.peek_token();
        return this.process_empty_scalar(token.start_mark);
      }
    };

    Parser.prototype.parse_flow_sequence_entry_mapping_end = function() {
      var token;
      this.state = 'parse_flow_sequence_entry';
      token = this.peek_token();
      return new events.MappingEndEvent(token.start_mark, token.start_mark);
    };

    Parser.prototype.parse_flow_mapping_first_key = function() {
      var token;
      token = this.get_token();
      this.marks.push(token.start_mark);
      return this.parse_flow_mapping_key(true);
    };

    Parser.prototype.parse_flow_mapping_key = function(first) {
      var event, token;
      if (first == null) {
        first = false;
      }
      if (!this.check_token(tokens.FlowMappingEndToken)) {
        if (!first) {
          if (this.check_token(tokens.FlowEntryToken)) {
            this.get_token();
          } else {
            token = this.peek_token();
            throw new exports.ParserError('while parsing a flow mapping', this.marks.slice(-1)[0], "expected ',' or '}', but got " + token.id, token.start_mark);
          }
        }
        if (this.check_token(tokens.KeyToken)) {
          token = this.get_token();
          if (!this.check_token(tokens.ValueToken, tokens.FlowEntryToken, tokens.FlowMappingEndToken)) {
            this.states.push('parse_flow_mapping_value');
            return this.parse_flow_node();
          } else {
            this.state = 'parse_flow_mapping_value';
            return this.process_empty_scalar(token.end_mark);
          }
        } else if (!this.check_token(tokens.FlowMappingEndToken)) {
          this.states.push('parse_flow_mapping_empty_value');
          return this.parse_flow_node();
        }
      }
      token = this.get_token();
      event = new events.MappingEndEvent(token.start_mark, token.end_mark);
      this.state = this.states.pop();
      this.marks.pop();
      return event;
    };

    Parser.prototype.parse_flow_mapping_value = function() {
      var token;
      if (this.check_token(tokens.ValueToken)) {
        token = this.get_token();
        if (!this.check_token(tokens.FlowEntryToken, tokens.FlowMappingEndToken)) {
          this.states.push('parse_flow_mapping_key');
          return this.parse_flow_node();
        } else {
          this.state = 'parse_flow_mapping_key';
          return this.process_empty_scalar(token.end_mark);
        }
      } else {
        this.state = 'parse_flow_mapping_key';
        token = this.peek_token();
        return this.process_empty_scalar(token.start_mark);
      }
    };

    Parser.prototype.parse_flow_mapping_empty_value = function() {
      this.state = 'parse_flow_mapping_key';
      return this.process_empty_scalar(this.peek_token().start_mark);
    };

    Parser.prototype.process_empty_scalar = function(mark) {
      return new events.ScalarEvent(null, null, [true, false], '', mark, mark);
    };

    return Parser;

  })();

}).call(this);

},{"./errors":33,"./events":34,"./tokens":47}],39:[function(require,module,exports){
(function() {
  var MarkedYAMLError, nodes, url, util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  url = require('url');

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  util = require('./util');

  /*
  The Protocols class deals with applying protocols to methods according to the spec
  */


  this.Protocols = (function() {
    function Protocols() {
      this.apply_protocols = __bind(this.apply_protocols, this);
    }

    Protocols.prototype.apply_protocols = function(node) {
      var protocols;
      if (protocols = this.apply_protocols_to_root(node)) {
        return this.apply_protocols_to_resources(node, protocols);
      }
    };

    Protocols.prototype.apply_protocols_to_root = function(node) {
      var baseUri, parsedBaseUri, protocol, protocols;
      if (this.has_property(node, 'protocols')) {
        return this.get_property(node, 'protocols');
      }
      if (!(baseUri = this.property_value(node, 'baseUri'))) {
        return;
      }
      parsedBaseUri = url.parse(baseUri);
      protocol = (parsedBaseUri.protocol || 'http:').slice(0, -1).toUpperCase();
      protocols = [new nodes.ScalarNode('tag:yaml.org,2002:str', 'protocols', node.start_mark, node.end_mark), new nodes.SequenceNode('tag:yaml.org,2002:seq', [new nodes.ScalarNode('tag:yaml.org,2002:str', protocol, node.start_mark, node.end_mark)], node.start_mark, node.end_mark)];
      node.value.push(protocols);
      return protocols[1];
    };

    Protocols.prototype.apply_protocols_to_resources = function(node, protocols) {
      var resource, _i, _len, _ref, _results;
      _ref = this.child_resources(node);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        resource = _ref[_i];
        this.apply_protocols_to_resources(resource, protocols);
        _results.push(this.apply_protocols_to_methods(resource, protocols));
      }
      return _results;
    };

    Protocols.prototype.apply_protocols_to_methods = function(node, protocols) {
      var method, _i, _len, _ref, _results;
      _ref = this.child_methods(node[1]);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        method = _ref[_i];
        if (!this.has_property(method[1], 'protocols')) {
          if (!util.isMapping(method[1])) {
            method[1] = new nodes.MappingNode('tag:yaml.org,2002:map', [], method[1].start_mark, method[1].end_mark);
          }
          _results.push(method[1].value.push([new nodes.ScalarNode('tag:yaml.org,2002:str', 'protocols', method[0].start_mark, method[0].end_mark), protocols.clone()]));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return Protocols;

  })();

}).call(this);

},{"./errors":33,"./nodes":37,"./util":50,"url":25}],40:[function(require,module,exports){
(function() {
  var defaultSettings, util, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.errors = require('./errors');

  this.loader = require('./loader');

  util = require('./util');

  this.FileError = (function(_super) {
    __extends(FileError, _super);

    function FileError() {
      _ref = FileError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return FileError;

  })(this.errors.MarkedYAMLError);

  this.FileReader = (function() {
    function FileReader(readFileAsyncOverride) {
      this.q = require('q');
      this.url = require('url');
      if (readFileAsyncOverride) {
        this.readFileAsyncOverride = readFileAsyncOverride;
      }
    }

    /*
    Read file either locally or from the network.
    */


    FileReader.prototype.readFileAsync = function(file) {
      var targerUrl;
      if (this.readFileAsyncOverride) {
        return this.readFileAsyncOverride(file);
      }
      targerUrl = this.url.parse(file);
      if (targerUrl.protocol != null) {
        if (!targerUrl.protocol.match(/^https?/i)) {
          throw new exports.FileError("while reading " + file, null, "unknown protocol " + targerUrl.protocol, this.start_mark);
        } else {
          return this.fetchFileAsync(file);
        }
      } else {
        if (typeof window !== "undefined" && window !== null) {
          return this.fetchFileAsync(file);
        } else {
          return this.fetchLocalFileAsync(file);
        }
      }
    };

    /*
    Read file from the disk.
    */


    FileReader.prototype.fetchLocalFileAsync = function(file) {
      var deferred,
        _this = this;
      deferred = this.q.defer();
      require('fs').readFile(file, function(err, data) {
        if (err) {
          return deferred.reject(new exports.FileError("while reading " + file, null, "cannot read " + file + " (" + err + ")", _this.start_mark));
        } else {
          return deferred.resolve(data.toString());
        }
      });
      return deferred.promise;
    };

    /*
    Read file from the network.
    */


    FileReader.prototype.fetchFileAsync = function(file) {
      var deferred, error, xhr,
        _this = this;
      deferred = this.q.defer();
      if (typeof window !== "undefined" && window !== null) {
        xhr = new XMLHttpRequest();
      } else {
        xhr = new (require('xmlhttprequest').XMLHttpRequest)();
      }
      try {
        xhr.open('GET', file, false);
        xhr.setRequestHeader('Accept', 'application/raml+yaml, */*');
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            if ((typeof xhr.status === 'number' && xhr.status === 200) || (typeof xhr.status === 'string' && xhr.status.match(/^200/i))) {
              return deferred.resolve(xhr.responseText);
            } else {
              return deferred.reject(new exports.FileError("while fetching " + file, null, "cannot fetch " + file + " (" + xhr.statusText + ")", _this.start_mark));
            }
          }
        };
        xhr.send(null);
        return deferred.promise;
      } catch (_error) {
        error = _error;
        throw new exports.FileError("while fetching " + file, null, "cannot fetch " + file + " (" + error + "), check that the server is up and that CORS is enabled", this.start_mark);
      }
    };

    return FileReader;

  })();

  /*
  OO version of the parser, static functions will be removed after consumers move on to use the OO version
  OO will offer caching
  */


  this.RamlParser = (function() {
    function RamlParser(settings) {
      this.settings = settings != null ? settings : defaultSettings;
      this.q = require('q');
      this.url = require('url');
      this.nodes = require('./nodes');
      this.loadDefaultSettings(settings);
    }

    RamlParser.prototype.loadDefaultSettings = function(settings) {
      var _this = this;
      return Object.keys(defaultSettings).forEach(function(settingName) {
        if (!(settingName in settings)) {
          return settings[settingName] = defaultSettings[settingName];
        }
      });
    };

    RamlParser.prototype.loadFile = function(file, settings) {
      var error,
        _this = this;
      if (settings == null) {
        settings = this.settings;
      }
      try {
        return settings.reader.readFileAsync(file).then(function(stream) {
          return _this.load(stream, file, settings);
        });
      } catch (_error) {
        error = _error;
        return this.q.fcall(function() {
          throw new exports.FileError("while fetching " + file, null, "cannot fetch " + file + " (" + error + ")", null);
        });
      }
    };

    RamlParser.prototype.composeFile = function(file, settings, parent) {
      var error,
        _this = this;
      if (settings == null) {
        settings = this.settings;
      }
      try {
        return settings.reader.readFileAsync(file).then(function(stream) {
          return _this.compose(stream, file, settings, parent);
        });
      } catch (_error) {
        error = _error;
        return this.q.fcall(function() {
          throw new exports.FileError("while fetching " + file, null, "cannot fetch " + file + " (" + error + ")", null);
        });
      }
    };

    RamlParser.prototype.compose = function(stream, location, settings, parent) {
      if (settings == null) {
        settings = this.settings;
      }
      if (parent == null) {
        parent = {
          src: location
        };
      }
      settings.compose = false;
      return this.parseStream(stream, location, settings, parent);
    };

    RamlParser.prototype.load = function(stream, location, settings) {
      if (settings == null) {
        settings = this.settings;
      }
      settings.compose = true;
      return this.parseStream(stream, location, settings, {
        src: location
      });
    };

    RamlParser.prototype.parseStream = function(stream, location, settings, parent) {
      var loader,
        _this = this;
      if (settings == null) {
        settings = this.settings;
      }
      loader = new exports.loader.Loader(stream, location, settings, parent);
      return this.q.fcall(function() {
        return loader.getYamlRoot();
      }).then(function(partialTree) {
        var files;
        files = loader.getPendingFilesList();
        return _this.getPendingFiles(loader, partialTree, files);
      }).then(function(fullyAssembledTree) {
        loader.composeRamlTree(fullyAssembledTree, settings);
        if (settings.compose) {
          if (fullyAssembledTree != null) {
            return loader.construct_document(fullyAssembledTree);
          } else {
            return null;
          }
        } else {
          return fullyAssembledTree;
        }
      });
    };

    RamlParser.prototype.getPendingFiles = function(loader, node, files) {
      var file, lastVisitedNode, loc, _i, _len,
        _this = this;
      loc = [];
      lastVisitedNode = void 0;
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        loc.push(this.getPendingFile(loader, file).then(function(overwritingnode) {
          if (overwritingnode && !lastVisitedNode) {
            return lastVisitedNode = overwritingnode;
          }
        }));
      }
      return this.q.all(loc).then(function() {
        if (lastVisitedNode) {
          return lastVisitedNode;
        } else {
          return node;
        }
      });
    };

    RamlParser.prototype.getPendingFile = function(loader, fileInfo) {
      var error, event, fileUri, key, node,
        _this = this;
      node = fileInfo.parentNode;
      event = fileInfo.event;
      key = fileInfo.parentKey;
      fileUri = fileInfo.targetFileUri;
      if (fileInfo.includingContext) {
        fileUri = this.url.resolve(fileInfo.includingContext, fileInfo.targetFileUri);
      }
      if (loader.parent && this.isInIncludeTagsStack(fileUri, loader)) {
        throw new exports.FileError('while composing scalar out of !include', null, "detected circular !include of " + event.value, event.start_mark);
      }
      try {
        if (fileInfo.type === 'fragment') {
          return this.settings.reader.readFileAsync(fileUri).then(function(result) {
            return _this.compose(result, fileUri, {
              validate: false,
              transform: false,
              compose: true
            }, loader);
          }).then(function(value) {
            return _this.appendNewNodeToParent(node, key, value);
          })["catch"](function(error) {
            return _this.addContextToError(error, event);
          });
        } else {
          return this.settings.reader.readFileAsync(fileUri).then(function(result) {
            var value;
            value = new _this.nodes.ScalarNode('tag:yaml.org,2002:str', result, event.start_mark, event.end_mark, event.style);
            return _this.appendNewNodeToParent(node, key, value);
          })["catch"](function(error) {
            return _this.addContextToError(error, event);
          });
        }
      } catch (_error) {
        error = _error;
        return this.addContextToError(error, event);
      }
    };

    RamlParser.prototype.addContextToError = function(error, event) {
      if (error.constructor.name === "FileError") {
        if (!error.problem_mark) {
          error.problem_mark = event.start_mark;
        }
        throw error;
      } else {
        throw new exports.FileError('while reading file', null, "error: " + error, event.start_mark);
      }
    };

    RamlParser.prototype.isInIncludeTagsStack = function(include, parent) {
      while (parent = parent.parent) {
        if (parent.src === include) {
          return true;
        }
      }
      return false;
    };

    RamlParser.prototype.appendNewNodeToParent = function(node, key, value) {
      if (node) {
        if (util.isSequence(node)) {
          node.value[key] = value;
        } else {
          node.value.push([key, value]);
        }
        return null;
      } else {
        return value;
      }
    };

    return RamlParser;

  })();

  /*
    validate controls whether the stream must be processed as a
  */


  defaultSettings = {
    validate: true,
    transform: true,
    compose: true,
    reader: new exports.FileReader(null)
  };

  /*
  Parse the first RAML document in a stream and produce the corresponding
  Javascript object.
  */


  this.loadFile = function(file, settings) {
    var parser;
    if (settings == null) {
      settings = defaultSettings;
    }
    parser = new exports.RamlParser(settings);
    return parser.loadFile(file, settings);
  };

  /*
  Parse the first RAML document in a file and produce the corresponding
  representation tree.
  */


  this.composeFile = function(file, settings, parent) {
    var parser;
    if (settings == null) {
      settings = defaultSettings;
    }
    if (parent == null) {
      parent = file;
    }
    parser = new exports.RamlParser(settings);
    return parser.composeFile(file, settings, parent);
  };

  /*
  Parse the first RAML document in a stream and produce the corresponding
  representation tree.
  */


  this.compose = function(stream, location, settings, parent) {
    var parser;
    if (settings == null) {
      settings = defaultSettings;
    }
    if (parent == null) {
      parent = location;
    }
    parser = new exports.RamlParser(settings);
    return parser.compose(stream, location, settings, parent);
  };

  /*
  Parse the first RAML document in a stream and produce the corresponding
  Javascript object.
  */


  this.load = function(stream, location, settings) {
    var parser;
    if (settings == null) {
      settings = defaultSettings;
    }
    parser = new exports.RamlParser(settings);
    return parser.load(stream, location, settings, null);
  };

}).call(this);

},{"./errors":33,"./loader":36,"./nodes":37,"./util":50,"fs":1,"q":54,"url":25,"xmlhttprequest":55}],41:[function(require,module,exports){
(function() {
  var Mark, MarkedYAMLError, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ref = require('./errors'), Mark = _ref.Mark, MarkedYAMLError = _ref.MarkedYAMLError;

  this.ReaderError = (function(_super) {
    __extends(ReaderError, _super);

    function ReaderError() {
      _ref1 = ReaderError.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return ReaderError;

  })(MarkedYAMLError);

  /*
  Reader:
    checks if characters are within the allowed range
    add '\x00' to the end
  */


  this.Reader = (function() {
    var NON_PRINTABLE;

    NON_PRINTABLE = /[^\x09\x0A\x0D\x20-\x7E\x85\xA0-\uD7FF\uE000-\uFFFD]/;

    function Reader(string, src) {
      this.string = string;
      this.src = src;
      this.line = 0;
      this.column = 0;
      this.index = 0;
      this.string += '\x00';
    }

    Reader.prototype.peek = function(index) {
      if (index == null) {
        index = 0;
      }
      return this.string[this.index + index];
    };

    Reader.prototype.prefix = function(length) {
      if (length == null) {
        length = 1;
      }
      return this.string.slice(this.index, this.index + length);
    };

    Reader.prototype.forward = function(length) {
      var char, _results;
      if (length == null) {
        length = 1;
      }
      _results = [];
      while (length) {
        char = this.string[this.index];
        this.index++;
        if (__indexOf.call('\n\x85\u2082\u2029', char) >= 0 || (char === '\r' && this.string[this.index] !== '\n')) {
          this.line++;
          this.column = 0;
        } else {
          this.check_printable(char);
          this.column++;
        }
        _results.push(length--);
      }
      return _results;
    };

    Reader.prototype.create_mark = function(line, column) {
      if (line == null) {
        line = this.line;
      }
      if (column == null) {
        column = this.column;
      }
      return new Mark(this.src, line, column, this.string, this.index);
    };

    Reader.prototype.get_mark = function() {
      return this.create_mark();
    };

    Reader.prototype.check_printable = function(char) {
      if (NON_PRINTABLE.exec(char)) {
        throw new exports.ReaderError('while reading file', null, "non printable characters are not allowed column: " + (this.get_mark().column), this.get_mark());
      }
    };

    return Reader;

  })();

}).call(this);

},{"./errors":33}],42:[function(require,module,exports){
(function() {
  var YAMLError, nodes, util, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  nodes = require('./nodes');

  util = require('./util');

  YAMLError = require('./errors').YAMLError;

  this.ResolverError = (function(_super) {
    __extends(ResolverError, _super);

    function ResolverError() {
      _ref = ResolverError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ResolverError;

  })(YAMLError);

  this.BaseResolver = (function() {
    var DEFAULT_MAPPING_TAG, DEFAULT_SCALAR_TAG, DEFAULT_SEQUENCE_TAG;

    DEFAULT_SCALAR_TAG = 'tag:yaml.org,2002:str';

    DEFAULT_SEQUENCE_TAG = 'tag:yaml.org,2002:seq';

    DEFAULT_MAPPING_TAG = 'tag:yaml.org,2002:map';

    BaseResolver.prototype.yaml_implicit_resolvers = {};

    BaseResolver.prototype.yaml_path_resolvers = {};

    BaseResolver.add_implicit_resolver = function(tag, regexp, first) {
      var char, _base, _i, _len, _results;
      if (first == null) {
        first = [null];
      }
      if (!this.prototype.hasOwnProperty('yaml_implicit_resolvers')) {
        this.prototype.yaml_implicit_resolvers = util.extend({}, this.prototype.yaml_implicit_resolvers);
      }
      _results = [];
      for (_i = 0, _len = first.length; _i < _len; _i++) {
        char = first[_i];
        _results.push(((_base = this.prototype.yaml_implicit_resolvers)[char] != null ? (_base = this.prototype.yaml_implicit_resolvers)[char] : _base[char] = []).push([tag, regexp]));
      }
      return _results;
    };

    function BaseResolver() {
      this.resolver_exact_paths = [];
      this.resolver_prefix_paths = [];
    }

    BaseResolver.prototype.descend_resolver = function(current_node, current_index) {
      var depth, exact_paths, kind, path, prefix_paths, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4;
      if (util.is_empty(this.yaml_path_resolvers)) {
        return;
      }
      exact_paths = {};
      prefix_paths = [];
      if (current_node) {
        depth = this.resolver_prefix_paths.length;
        _ref1 = this.resolver_prefix_paths.slice(-1)[0];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          _ref2 = _ref1[_i], path = _ref2[0], kind = _ref2[1];
          if (this.check_resolver_prefix(depth, path, kind, current_node, current_index)) {
            if (path.length > depth) {
              prefix_paths.push([path, kind]);
            } else {
              exact_paths[kind] = this.yaml_path_resolvers[path][kind];
            }
          }
        }
      } else {
        _ref3 = this.yaml_path_resolvers;
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          _ref4 = _ref3[_j], path = _ref4[0], kind = _ref4[1];
          if (!path) {
            exact_paths[kind] = this.yaml_path_resolvers[path][kind];
          } else {
            prefix_paths.push([path, kind]);
          }
        }
      }
      this.resolver_exact_paths.push(exact_paths);
      return this.resolver_prefix_paths.push(prefix_paths);
    };

    BaseResolver.prototype.ascend_resolver = function() {
      if (util.is_empty(this.yaml_path_resolvers)) {
        return;
      }
      this.resolver_exact_paths.pop();
      return this.resolver_prefix_paths.pop();
    };

    BaseResolver.prototype.check_resolver_prefix = function(depth, path, kind, current_node, current_index) {
      var index_check, node_check, _ref1;
      _ref1 = path[depth - 1], node_check = _ref1[0], index_check = _ref1[1];
      if (typeof node_check === 'string') {
        if (current_node.tag !== node_check) {
          return;
        }
      } else if (node_check !== null) {
        if (!(current_node instanceof node_check)) {
          return;
        }
      }
      if (index_check === true && current_index !== null) {
        return;
      }
      if ((index_check === false || index_check === null) && current_index === null) {
        return;
      }
      if (typeof index_check === 'string') {
        if (!(current_index instanceof nodes.ScalarNode) && index_check === current_index.value) {
          return;
        }
      } else if (typeof index_check === 'number') {
        if (index_check !== current_index) {
          return;
        }
      }
      return true;
    };

    BaseResolver.prototype.resolve = function(kind, value, implicit) {
      var empty, exact_paths, k, regexp, resolvers, tag, _i, _len, _ref1, _ref2, _ref3, _ref4;
      if (kind === nodes.ScalarNode && implicit[0]) {
        if (value === '') {
          resolvers = (_ref1 = this.yaml_implicit_resolvers['']) != null ? _ref1 : [];
        } else {
          resolvers = (_ref2 = this.yaml_implicit_resolvers[value[0]]) != null ? _ref2 : [];
        }
        resolvers = resolvers.concat((_ref3 = this.yaml_implicit_resolvers[null]) != null ? _ref3 : []);
        for (_i = 0, _len = resolvers.length; _i < _len; _i++) {
          _ref4 = resolvers[_i], tag = _ref4[0], regexp = _ref4[1];
          if (value.match(regexp)) {
            return tag;
          }
        }
        implicit = implicit[1];
      }
      empty = true;
      for (k in this.yaml_path_resolvers) {
        if ({}[k] == null) {
          empty = false;
        }
      }
      if (!empty) {
        exact_paths = this.resolver_exact_paths.slice(-1)[0];
        if (__indexOf.call(exact_paths, kind) >= 0) {
          return exact_paths[kind];
        }
        if (__indexOf.call(exact_paths, null) >= 0) {
          return exact_paths[null];
        }
      }
      if (kind === nodes.ScalarNode) {
        return DEFAULT_SCALAR_TAG;
      }
      if (kind === nodes.SequenceNode) {
        return DEFAULT_SEQUENCE_TAG;
      }
      if (kind === nodes.MappingNode) {
        return DEFAULT_MAPPING_TAG;
      }
    };

    return BaseResolver;

  })();

  this.Resolver = (function(_super) {
    __extends(Resolver, _super);

    function Resolver() {
      _ref1 = Resolver.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return Resolver;

  })(this.BaseResolver);

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:bool', /^(?:true|True|TRUE|false|False|FALSE)$/, 'tTfF');

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:float', /^(?:[-+]?(?:[0-9][0-9_]*)\.[0-9_]*(?:[eE][-+][0-9]+)?|\.[0-9_]+(?:[eE][-+][0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*|[-+]?\.(?:inf|Inf|INF)|\.(?:nan|NaN|NAN))$/, '-+0123456789.');

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:int', /^(?:[-+]?0b[01_]+|[-+]?0[0-7_]+|[-+]?(?:0|[1-9][0-9_]*)|[-+]?0x[0-9a-fA-F_]+|[-+]?0o[0-7_]+|[-+]?[1-9][0-9_]*(?::[0-5]?[0-9])+)$/, '-+0123456789');

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:merge', /^(?:<<)$/, '<');

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:null', /^(?:~|null|Null|NULL|)$/, ['~', 'n', 'N', '']);

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:timestamp', /^(?:[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]|[0-9][0-9][0-9][0-9]-[0-9][0-9]?-[0-9][0-9]?(?:[Tt]|[\x20\t]+)[0-9][0-9]?:[0-9][0-9]:[0-9][0-9](?:\.[0-9]*)?(?:[\x20\t]*(?:Z|[-+][0-9][0-9]?(?::[0-9][0-9])?))?)$/, '0123456789');

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:value', /^(?:=)$/, '=');

  this.Resolver.add_implicit_resolver('tag:yaml.org,2002:yaml', /^(?:!|&|\*)$/, '!&*');

}).call(this);

},{"./errors":33,"./nodes":37,"./util":50}],43:[function(require,module,exports){
(function() {
  var MarkedYAMLError, nodes, util, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  util = require('./util');

  /*
  The ResourceTypes throws these.
  */


  this.ResourceTypeError = (function(_super) {
    __extends(ResourceTypeError, _super);

    function ResourceTypeError() {
      _ref = ResourceTypeError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ResourceTypeError;

  })(MarkedYAMLError);

  /*
  The ResourceTypes class deals with applying ResourceTypes to resources according to the spec
  */


  this.ResourceTypes = (function() {
    function ResourceTypes() {
      this.apply_parameters_to_type = __bind(this.apply_parameters_to_type, this);
      this.apply_type = __bind(this.apply_type, this);
      this.apply_types = __bind(this.apply_types, this);
      this.get_type = __bind(this.get_type, this);
      this.has_types = __bind(this.has_types, this);
      this.load_types = __bind(this.load_types, this);
      this.declaredTypes = {};
    }

    ResourceTypes.prototype.load_types = function(node) {
      var allTypes,
        _this = this;
      this.load_default_media_type(node);
      if (this.has_property(node, 'resourceTypes')) {
        allTypes = this.property_value(node, 'resourceTypes');
        if (allTypes && typeof allTypes === 'object') {
          return allTypes.forEach(function(type_item) {
            if (type_item && typeof type_item === 'object' && typeof type_item.value === 'object') {
              return type_item.value.forEach(function(type) {
                return _this.declaredTypes[type[0].value] = type;
              });
            }
          });
        }
      }
    };

    ResourceTypes.prototype.has_types = function(node) {
      if (Object.keys(this.declaredTypes).length === 0 && this.has_property(node, 'resourceTypes')) {
        this.load_types(node);
      }
      return Object.keys(this.declaredTypes).length > 0;
    };

    ResourceTypes.prototype.get_type = function(typeName) {
      return this.declaredTypes[typeName];
    };

    ResourceTypes.prototype.apply_types = function(node, resourceUri) {
      var resources,
        _this = this;
      if (resourceUri == null) {
        resourceUri = "";
      }
      if (!util.isMapping(node)) {
        return;
      }
      if (this.has_types(node)) {
        resources = this.child_resources(node);
        return resources.forEach(function(resource) {
          var type;
          _this.apply_default_media_type_to_resource(resource[1]);
          if (_this.has_property(resource[1], 'type')) {
            type = _this.get_property(resource[1], 'type');
            _this.apply_type(resourceUri + resource[0].value, resource, type);
          }
          return _this.apply_types(resource[1], resourceUri + resource[0].value);
        });
      } else {
        resources = this.child_resources(node);
        return resources.forEach(function(resource) {
          return _this.apply_default_media_type_to_resource(resource[1]);
        });
      }
    };

    ResourceTypes.prototype.apply_type = function(resourceUri, resource, typeKey) {
      var tempType;
      tempType = this.resolve_inheritance_chain(resourceUri, typeKey);
      tempType.combine(resource[1]);
      resource[1] = tempType;
      return resource[1].remove_question_mark_properties();
    };

    ResourceTypes.prototype.resolve_inheritance_chain = function(resourceUri, typeKey) {
      var baseType, childType, childTypeName, childTypeProperty, compiledTypes, inheritsFrom, parentType, parentTypeName, pathToCircularRef, result, rootType, typesToApply;
      childTypeName = this.key_or_value(typeKey);
      childType = this.apply_parameters_to_type(resourceUri, childTypeName, typeKey);
      typesToApply = [childTypeName];
      compiledTypes = {};
      compiledTypes[childTypeName] = childType;
      this.apply_default_media_type_to_resource(childType);
      this.apply_traits_to_resource(resourceUri, childType, false);
      while (this.has_property(childType, 'type')) {
        typeKey = this.get_property(childType, 'type');
        parentTypeName = this.key_or_value(typeKey);
        if (parentTypeName in compiledTypes) {
          pathToCircularRef = typesToApply.concat(parentTypeName).join(' -> ');
          childTypeProperty = this.get_type(childTypeName)[0];
          throw new exports.ResourceTypeError('while applying resourceTypes', null, "circular reference of \"" + parentTypeName + "\" has been detected: " + pathToCircularRef, childTypeProperty.start_mark);
        }
        parentType = this.apply_parameters_to_type(resourceUri, parentTypeName, typeKey);
        this.apply_default_media_type_to_resource(parentType);
        this.apply_traits_to_resource(resourceUri, parentType, false);
        childTypeName = parentTypeName;
        childType = parentType;
        compiledTypes[childTypeName] = childType;
        typesToApply.push(childTypeName);
      }
      rootType = typesToApply.pop();
      baseType = compiledTypes[rootType].cloneForResourceType();
      result = baseType;
      while (inheritsFrom = typesToApply.pop()) {
        baseType = compiledTypes[inheritsFrom].cloneForResourceType();
        result.combine(baseType);
      }
      return result;
    };

    ResourceTypes.prototype.apply_parameters_to_type = function(resourceUri, typeName, typeKey) {
      var parameters, type;
      if (!(typeName != null ? typeName.trim() : void 0)) {
        throw new exports.ResourceTypeError('while applying resource type', null, 'resource type name must be provided', typeKey.start_mark);
      }
      if (!(type = this.get_type(typeName))) {
        throw new exports.ResourceTypeError('while applying resource type', null, "there is no resource type named " + typeName, typeKey.start_mark);
      }
      type = type[1].clone();
      parameters = this._get_parameters_from_type_key(resourceUri, typeKey);
      this.apply_parameters(type, parameters, typeKey);
      return type;
    };

    ResourceTypes.prototype._get_parameters_from_type_key = function(resourceUri, typeKey) {
      var parameter, parameters, reserved, result, _i, _len, _ref1;
      result = {};
      reserved = {
        resourcePath: resourceUri.replace(/\/\/*/g, '/'),
        resourcePathName: this.extractResourcePathName(resourceUri)
      };
      if (util.isMapping(typeKey)) {
        parameters = this.value_or_undefined(typeKey);
        if (util.isMapping(parameters[0][1])) {
          _ref1 = parameters[0][1].value;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            parameter = _ref1[_i];
            if (parameter[0].value in reserved) {
              throw new exports.ResourceTypeError('while applying parameters', null, "invalid parameter name: " + parameter[0].value + " is reserved", parameter[0].start_mark);
            }
            result[parameter[0].value] = parameter[1].value;
          }
        }
      }
      return util.extend(result, reserved);
    };

    return ResourceTypes;

  })();

}).call(this);

},{"./errors":33,"./nodes":37,"./util":50}],44:[function(require,module,exports){
(function() {
  var MarkedYAMLError, SimpleKey, tokens, util, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  tokens = require('./tokens');

  util = require('./util');

  /*
  The Scanner throws these.
  */


  this.ScannerError = (function(_super) {
    __extends(ScannerError, _super);

    function ScannerError() {
      _ref = ScannerError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ScannerError;

  })(MarkedYAMLError);

  /*
  Represents a possible simple key.
  */


  SimpleKey = (function() {
    function SimpleKey(token_number, required, index, line, column, mark) {
      this.token_number = token_number;
      this.required = required;
      this.index = index;
      this.line = line;
      this.column = column;
      this.mark = mark;
    }

    return SimpleKey;

  })();

  /*
  The Scanner class deals with converting a YAML stream into a token stream.
  */


  this.Scanner = (function() {
    var C_LB, C_NUMBERS, C_WS, ESCAPE_CODES, ESCAPE_REPLACEMENTS, RAML_VERSION, RAML_VERSION_RE;

    C_LB = '\r\n\x85\u2028\u2029';

    C_WS = '\t ';

    C_NUMBERS = '0123456789';

    ESCAPE_REPLACEMENTS = {
      '0': '\x00',
      'a': '\x07',
      'b': '\x08',
      't': '\x09',
      '\t': '\x09',
      'n': '\x0A',
      'v': '\x0B',
      'f': '\x0C',
      'r': '\x0D',
      'e': '\x1B',
      ' ': '\x20',
      '"': '"',
      '\\': '\\',
      'N': '\x85',
      '_': '\xA0',
      'L': '\u2028',
      'P': '\u2029'
    };

    ESCAPE_CODES = {
      'x': 2,
      'u': 4,
      'U': 8
    };

    RAML_VERSION = '#%RAML 0.8';

    RAML_VERSION_RE = /^#%RAML .+$/;

    /*
    Initialise the Scanner
    */


    function Scanner(settings) {
      this.settings = settings;
      this.done = false;
      this.ramlHeaderFound = !this.settings.validate;
      this.flow_level = 0;
      this.tokens = [];
      this.fetch_stream_start();
      this.tokens_taken = 0;
      this.indent = -1;
      this.indents = [];
      this.allow_simple_key = true;
      this.possible_simple_keys = {};
    }

    /*
    Check if the next token is one of the given types.
    */


    Scanner.prototype.check_token = function() {
      var choice, choices, _i, _len;
      choices = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      while (this.need_more_tokens()) {
        this.fetch_more_tokens();
      }
      if (this.tokens.length !== 0) {
        if (choices.length === 0) {
          return true;
        }
        for (_i = 0, _len = choices.length; _i < _len; _i++) {
          choice = choices[_i];
          if (this.tokens[0] instanceof choice) {
            return true;
          }
        }
      }
      return false;
    };

    /*
    Return the next token, but do not delete it from the queue.
    */


    Scanner.prototype.peek_token = function() {
      while (this.need_more_tokens()) {
        this.fetch_more_tokens();
      }
      if (this.tokens.length !== 0) {
        return this.tokens[0];
      }
    };

    /*
    Return the next token, and remove it from the queue.
    */


    Scanner.prototype.get_token = function() {
      while (this.need_more_tokens()) {
        this.fetch_more_tokens();
      }
      if (this.tokens.length !== 0) {
        this.tokens_taken++;
        return this.tokens.shift();
      }
    };

    Scanner.prototype.need_more_tokens = function() {
      if (this.done) {
        return false;
      }
      if (this.tokens.length === 0) {
        return true;
      }
      this.stale_possible_simple_keys();
      if (this.next_possible_simple_key() === this.tokens_taken) {
        return true;
      }
      return false;
    };

    Scanner.prototype.fetch_more_tokens = function() {
      var char;
      this.scan_to_next_token();
      this.stale_possible_simple_keys();
      this.unwind_indent(this.column);
      char = this.peek();
      if (char === '\x00') {
        return this.fetch_stream_end();
      }
      if (char === '%' && this.check_directive()) {
        return this.fetch_directive();
      }
      if (char === '-' && this.check_document_start()) {
        return this.fetch_document_start();
      }
      if (char === '.' && this.check_document_end()) {
        return this.fetch_document_end();
      }
      if (char === '[') {
        return this.fetch_flow_sequence_start();
      }
      if (char === '{') {
        return this.fetch_flow_mapping_start();
      }
      if (char === ']') {
        return this.fetch_flow_sequence_end();
      }
      if (char === '}') {
        return this.fetch_flow_mapping_end();
      }
      if (char === ',') {
        return this.fetch_flow_entry();
      }
      if (char === '-' && this.check_block_entry()) {
        return this.fetch_block_entry();
      }
      if (char === '?' && this.check_key()) {
        return this.fetch_key();
      }
      if (char === ':' && this.check_value()) {
        return this.fetch_value();
      }
      if (char === '*') {
        return this.fetch_alias();
      }
      if (char === '&') {
        return this.fetch_anchor();
      }
      if (char === '!') {
        return this.fetch_tag();
      }
      if (char === '|' && this.flow_level === 0) {
        return this.fetch_literal();
      }
      if (char === '>' && this.flow_level === 0) {
        return this.fetch_folded();
      }
      if (char === '\'') {
        return this.fetch_single();
      }
      if (char === '"') {
        return this.fetch_double();
      }
      if (this.check_plain()) {
        return this.fetch_plain();
      }
      throw new exports.ScannerError('while scanning for the next token', null, "found character " + char + " that cannot start any token", this.get_mark());
    };

    /*
    Return the number of the nearest possible simple key.
    */


    Scanner.prototype.next_possible_simple_key = function() {
      var key, level, min_token_number, _ref1;
      min_token_number = null;
      _ref1 = this.possible_simple_keys;
      for (level in _ref1) {
        if (!__hasProp.call(_ref1, level)) continue;
        key = _ref1[level];
        if (min_token_number === null || key.token_number < min_token_number) {
          min_token_number = key.token_number;
        }
      }
      return min_token_number;
    };

    /*
    Remove entries that are no longer possible simple keys.  According to the
    YAML spec, simple keys:
      should be limited to a single line
      should be no longer than 1024 characters
    Disabling this procedure will allow simple keys of any length and height
    (may cause problems if indentation is broken though).
    */


    Scanner.prototype.stale_possible_simple_keys = function() {
      var key, level, _ref1, _results;
      _ref1 = this.possible_simple_keys;
      _results = [];
      for (level in _ref1) {
        if (!__hasProp.call(_ref1, level)) continue;
        key = _ref1[level];
        if (key.line === this.line && this.index - key.index <= 1024) {
          continue;
        }
        if (!key.required) {
          _results.push(delete this.possible_simple_keys[level]);
        } else {
          throw new exports.ScannerError('while scanning a simple key', key.mark, 'could not find expected \':\'', this.get_mark());
        }
      }
      return _results;
    };

    /*
    The next token may start a simple key.  We check if it's possible and save
    its position.  This function is called for ALIAS, ANCHOR, TAG,
    SCALAR (flow),'[' and '{'.
    */


    Scanner.prototype.save_possible_simple_key = function() {
      var required, token_number;
      required = this.flow_level === 0 && this.indent === this.column;
      if (required && !this.allow_simple_key) {
        throw new Error('logic failure');
      }
      if (!this.allow_simple_key) {
        return;
      }
      this.remove_possible_simple_key();
      token_number = this.tokens_taken + this.tokens.length;
      return this.possible_simple_keys[this.flow_level] = new SimpleKey(token_number, required, this.index, this.line, this.column, this.get_mark());
    };

    /*
    Remove the saved possible simple key at the current flow level.
    */


    Scanner.prototype.remove_possible_simple_key = function() {
      var key;
      if (!(key = this.possible_simple_keys[this.flow_level])) {
        return;
      }
      if (!key.required) {
        return delete this.possible_simple_keys[this.flow_level];
      } else {
        throw new exports.ScannerError('while scanning a simple key', key.mark, 'could not find expected \':\'', this.get_mark());
      }
    };

    /*
    In flow context, tokens should respect indentation.
    Actually the condition should be `self.indent >= column` according to
    the spec. But this condition will prohibit intuitively correct
    constructions such as
      key : {
      }
    */


    Scanner.prototype.unwind_indent = function(column) {
      var mark, _results;
      if (this.flow_level !== 0) {
        return;
      }
      _results = [];
      while (this.indent > column) {
        mark = this.get_mark();
        this.indent = this.indents.pop();
        _results.push(this.tokens.push(new tokens.BlockEndToken(mark, mark)));
      }
      return _results;
    };

    /*
    Check if we need to increase indentation.
    */


    Scanner.prototype.add_indent = function(column) {
      if (!(column > this.indent)) {
        return false;
      }
      this.indents.push(this.indent);
      this.indent = column;
      return true;
    };

    Scanner.prototype.fetch_stream_start = function() {
      var mark;
      mark = this.get_mark();
      return this.tokens.push(new tokens.StreamStartToken(mark, mark, this.encoding));
    };

    Scanner.prototype.fetch_stream_end = function() {
      var mark;
      this.unwind_indent(-1);
      this.remove_possible_simple_key();
      this.allow_possible_simple_key = false;
      this.possible_simple_keys = {};
      mark = this.get_mark();
      this.tokens.push(new tokens.StreamEndToken(mark, mark));
      return this.done = true;
    };

    Scanner.prototype.fetch_directive = function() {
      this.unwind_indent(-1);
      this.remove_possible_simple_key();
      this.allow_simple_key = false;
      return this.tokens.push(this.scan_directive());
    };

    Scanner.prototype.fetch_document_start = function() {
      return this.fetch_document_indicator(tokens.DocumentStartToken);
    };

    Scanner.prototype.fetch_document_end = function() {
      return this.fetch_document_indicator(tokens.DocumentEndToken);
    };

    Scanner.prototype.fetch_document_indicator = function(TokenClass) {
      var start_mark;
      this.unwind_indent(-1);
      this.remove_possible_simple_key();
      this.allow_simple_key = false;
      start_mark = this.get_mark();
      this.forward(3);
      return this.tokens.push(new TokenClass(start_mark, this.get_mark()));
    };

    Scanner.prototype.fetch_flow_sequence_start = function() {
      return this.fetch_flow_collection_start(tokens.FlowSequenceStartToken);
    };

    Scanner.prototype.fetch_flow_mapping_start = function() {
      return this.fetch_flow_collection_start(tokens.FlowMappingStartToken);
    };

    Scanner.prototype.fetch_flow_collection_start = function(TokenClass) {
      var start_mark;
      this.save_possible_simple_key();
      this.flow_level++;
      this.allow_simple_key = true;
      start_mark = this.get_mark();
      this.forward();
      return this.tokens.push(new TokenClass(start_mark, this.get_mark()));
    };

    Scanner.prototype.fetch_flow_sequence_end = function() {
      return this.fetch_flow_collection_end(tokens.FlowSequenceEndToken);
    };

    Scanner.prototype.fetch_flow_mapping_end = function() {
      return this.fetch_flow_collection_end(tokens.FlowMappingEndToken);
    };

    Scanner.prototype.fetch_flow_collection_end = function(TokenClass) {
      var start_mark;
      this.remove_possible_simple_key();
      this.flow_level--;
      this.allow_simple_key = false;
      start_mark = this.get_mark();
      this.forward();
      return this.tokens.push(new TokenClass(start_mark, this.get_mark()));
    };

    Scanner.prototype.fetch_flow_entry = function() {
      var start_mark;
      this.allow_simple_key = true;
      this.remove_possible_simple_key();
      start_mark = this.get_mark();
      this.forward();
      return this.tokens.push(new tokens.FlowEntryToken(start_mark, this.get_mark()));
    };

    Scanner.prototype.fetch_block_entry = function() {
      var mark, start_mark;
      if (this.flow_level === 0) {
        if (!this.allow_simple_key) {
          throw new exports.ScannerError(null, null, 'sequence entries are not allowed here', this.get_mark());
        }
        if (this.add_indent(this.column)) {
          mark = this.get_mark();
          this.tokens.push(new tokens.BlockSequenceStartToken(mark, mark));
        }
      }
      this.allow_simple_key = true;
      this.remove_possible_simple_key();
      start_mark = this.get_mark();
      this.forward();
      return this.tokens.push(new tokens.BlockEntryToken(start_mark, this.get_mark()));
    };

    Scanner.prototype.fetch_key = function() {
      var mark, start_mark;
      if (this.flow_level === 0) {
        if (!this.allow_simple_key) {
          throw new exports.ScannerError(null, null, 'mapping keys are not allowed here', this.get_mark());
        }
        if (this.add_indent(this.column)) {
          mark = this.get_mark();
          this.tokens.push(new tokens.BlockMappingStartToken(mark, mark));
        }
      }
      this.allow_simple_key = !this.flow_level;
      this.remove_possible_simple_key();
      start_mark = this.get_mark();
      this.forward();
      return this.tokens.push(new tokens.KeyToken(start_mark, this.get_mark()));
    };

    Scanner.prototype.fetch_value = function() {
      var key, mark, start_mark;
      if (key = this.possible_simple_keys[this.flow_level]) {
        delete this.possible_simple_keys[this.flow_level];
        this.tokens.splice(key.token_number - this.tokens_taken, 0, new tokens.KeyToken(key.mark, key.mark));
        if (this.flow_level === 0) {
          if (this.add_indent(key.column)) {
            this.tokens.splice(key.token_number - this.tokens_taken, 0, new tokens.BlockMappingStartToken(key.mark, key.mark));
          }
        }
        this.allow_simple_key = false;
      } else {
        if (this.flow_level === 0) {
          if (!this.allow_simple_key) {
            throw new exports.ScannerError(null, null, 'mapping values are not allowed here', this.get_mark());
          }
          if (this.add_indent(this.column)) {
            mark = this.get_mark();
            this.tokens.push(new tokens.BlockMappingStartToken(mark, mark));
          }
        }
        this.allow_simple_key = !this.flow_level;
        this.remove_possible_simple_key();
      }
      start_mark = this.get_mark();
      this.forward();
      return this.tokens.push(new tokens.ValueToken(start_mark, this.get_mark()));
    };

    Scanner.prototype.fetch_alias = function() {
      this.save_possible_simple_key();
      this.allow_simple_key = false;
      return this.tokens.push(this.scan_anchor(tokens.AliasToken));
    };

    Scanner.prototype.fetch_anchor = function() {
      this.save_possible_simple_key();
      this.allow_simple_key = false;
      return this.tokens.push(this.scan_anchor(tokens.AnchorToken));
    };

    Scanner.prototype.fetch_tag = function() {
      this.save_possible_simple_key();
      this.allow_simple_key = false;
      return this.tokens.push(this.scan_tag());
    };

    Scanner.prototype.fetch_literal = function() {
      return this.fetch_block_scalar('|');
    };

    Scanner.prototype.fetch_folded = function() {
      return this.fetch_block_scalar('>');
    };

    Scanner.prototype.fetch_block_scalar = function(style) {
      this.allow_simple_key = true;
      this.remove_possible_simple_key();
      return this.tokens.push(this.scan_block_scalar(style));
    };

    Scanner.prototype.fetch_single = function() {
      return this.fetch_flow_scalar('\'');
    };

    Scanner.prototype.fetch_double = function() {
      return this.fetch_flow_scalar('"');
    };

    Scanner.prototype.fetch_flow_scalar = function(style) {
      this.save_possible_simple_key();
      this.allow_simple_key = false;
      return this.tokens.push(this.scan_flow_scalar(style));
    };

    Scanner.prototype.fetch_plain = function() {
      this.save_possible_simple_key();
      this.allow_simple_key = false;
      return this.tokens.push(this.scan_plain());
    };

    /*
    DIRECTIVE: ^ '%'
    */


    Scanner.prototype.check_directive = function() {
      if (this.column === 0) {
        return true;
      }
      return false;
    };

    /*
    DOCUMENT-START: ^ '---' (' '|'\n')
    */


    Scanner.prototype.check_document_start = function() {
      var _ref1;
      if (this.column === 0 && this.prefix(3) === '---' && (_ref1 = this.peek(3), __indexOf.call(C_LB + C_WS + '\x00', _ref1) >= 0)) {
        return true;
      }
      return false;
    };

    /*
    DOCUMENT-END: ^ '...' (' '|'\n')
    */


    Scanner.prototype.check_document_end = function() {
      var _ref1;
      if (this.column === 0 && this.prefix(3) === '...' && (_ref1 = this.peek(3), __indexOf.call(C_LB + C_WS + '\x00', _ref1) >= 0)) {
        return true;
      }
      return false;
    };

    /*
    BLOCK-ENTRY: '-' (' '|'\n')
    */


    Scanner.prototype.check_block_entry = function() {
      var _ref1;
      return _ref1 = this.peek(1), __indexOf.call(C_LB + C_WS + '\x00', _ref1) >= 0;
    };

    /*
    KEY (flow context):  '?'
    KEY (block context): '?' (' '|'\n')
    */


    Scanner.prototype.check_key = function() {
      var _ref1;
      if (this.flow_level !== 0) {
        return true;
      }
      return _ref1 = this.peek(1), __indexOf.call(C_LB + C_WS + '\x00', _ref1) >= 0;
    };

    /*
    VALUE (flow context):  ':'
    VALUE (block context): ':' (' '|'\n')
    */


    Scanner.prototype.check_value = function() {
      var _ref1;
      if (this.flow_level !== 0) {
        return true;
      }
      return _ref1 = this.peek(1), __indexOf.call(C_LB + C_WS + '\x00', _ref1) >= 0;
    };

    /*
    A plain scalar may start with any non-space character except:
      '-', '?', ':', ',', '[', ']', '{', '}',
      '#', '&', '*', '!', '|', '>', '\'', '"',
      '%', '@', '`'.
    
    It may also start with
      '-', '?', ':'
    if it is followed by a non-space character.
    
    Note that we limit the last rule to the block context (except the '-'
    character) because we want the flow context to be space independent.
    */


    Scanner.prototype.check_plain = function() {
      var char, _ref1;
      char = this.peek();
      return __indexOf.call(C_LB + C_WS + '\x00-?:,[]{}#&*!|>\'"%@`', char) < 0 || ((_ref1 = this.peek(1), __indexOf.call(C_LB + C_WS + '\x00', _ref1) < 0) && (char === '-' || (this.flow_level === 0 && __indexOf.call('?:', char) >= 0)));
    };

    /*
    We ignore spaces, line breaks and comments.
    If we find a line break in the block context, we set the flag
    `allow_simple_key` on.
    The byte order mark is stripped if it's the first character in the stream.
    We do not yet support BOM inside the stream as the specification requires.
    Any such mark will be considered as a part of the document.
    
    TODO: We need to make tab handling rules more sane.  A good rule is
      Tabs cannot precede tokens BLOCK-SEQUENCE-START, BLOCK-MAPPING-START,
      BLOCK-END, KEY (block context), VALUE (block context), BLOCK-ENTRY
    So the tab checking code is
      @allow_simple_key = off if <TAB>
    We also need to add the check for `allow_simple_key is on` to
    `unwind_indent` before issuing BLOCK-END.  Scanners for block, flow and
    plain scalars need to be modified.
    */


    Scanner.prototype.scan_to_next_token = function() {
      var comment, found, trimmedComment, _ref1, _results;
      if (this.index === 0 && this.peek() === '\uFEFF') {
        this.forward();
      }
      found = false;
      _results = [];
      while (!found) {
        while (this.peek() === ' ') {
          this.forward();
        }
        comment = '';
        if (this.peek() === '#') {
          while (_ref1 = this.peek(), __indexOf.call(C_LB + '\x00', _ref1) < 0) {
            if (!this.ramlHeaderFound) {
              comment += this.peek();
            }
            this.forward();
          }
        }
        if (!this.ramlHeaderFound) {
          trimmedComment = comment.trim();
          if (trimmedComment && RAML_VERSION_RE.test(trimmedComment)) {
            if (trimmedComment === RAML_VERSION) {
              this.ramlHeaderFound = true;
            } else {
              throw new exports.ScannerError('version validation', null, "Unsupported RAML version: '" + comment + "'", this.create_mark(0, 0));
            }
          } else {
            throw new exports.ScannerError('version validation', null, "The first line must be: '" + RAML_VERSION + "'", this.create_mark(0, 0));
          }
        }
        if (this.scan_line_break()) {
          if (this.flow_level === 0) {
            _results.push(this.allow_simple_key = true);
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(found = true);
        }
      }
      return _results;
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_directive = function() {
      var end_mark, name, start_mark, value, _ref1;
      start_mark = this.get_mark();
      this.forward();
      name = this.scan_directive_name(start_mark);
      value = null;
      if (name === 'YAML') {
        value = this.scan_yaml_directive_value(start_mark);
        end_mark = this.get_mark();
      } else if (name === 'TAG') {
        value = this.scan_tag_directive_value(start_mark);
        end_mark = this.get_mark();
      } else {
        end_mark = this.get_mark();
        while (_ref1 = this.peek(), __indexOf.call(C_LB + '\x00', _ref1) < 0) {
          this.forward();
        }
      }
      this.scan_directive_ignored_line(start_mark);
      return new tokens.DirectiveToken(name, value, start_mark, end_mark);
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_directive_name = function(start_mark) {
      var char, length, value;
      length = 0;
      char = this.peek(length);
      while (('0' <= char && char <= '9') || ('A' <= char && char <= 'Z') || ('a' <= char && char <= 'z') || __indexOf.call('-_', char) >= 0) {
        length++;
        char = this.peek(length);
      }
      if (length === 0) {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected alphanumeric or numeric character but found " + char, this.get_mark());
      }
      value = this.prefix(length);
      this.forward(length);
      char = this.peek();
      if (__indexOf.call(C_LB + '\x00 ', char) < 0) {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected alphanumeric or numeric character but found " + char, this.get_mark());
      }
      return value;
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_yaml_directive_value = function(start_mark) {
      var major, minor, _ref1;
      while (this.peek() === ' ') {
        this.forward();
      }
      major = this.scan_yaml_directive_number(start_mark);
      if (this.peek() !== '.') {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected a digit or '.' but found " + (this.peek()), this.get_mark());
      }
      this.forward();
      minor = this.scan_yaml_directive_number(start_mark);
      if (_ref1 = this.peek(), __indexOf.call(C_LB + '\x00 ', _ref1) < 0) {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected a digit or ' ' but found " + (this.peek()), this.get_mark());
      }
      return [major, minor];
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_yaml_directive_number = function(start_mark) {
      var char, length, value, _ref1;
      char = this.peek();
      if (!(('0' <= char && char <= '9'))) {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected a digit but found " + char, this.get_mark());
      }
      length = 0;
      while (('0' <= (_ref1 = this.peek(length)) && _ref1 <= '9')) {
        length++;
      }
      value = parseInt(this.prefix(length));
      this.forward(length);
      return value;
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_tag_directive_value = function(start_mark) {
      var handle, prefix;
      while (this.peek() === ' ') {
        this.forward();
      }
      handle = this.scan_tag_directive_handle(start_mark);
      while (this.peek() === ' ') {
        this.forward();
      }
      prefix = this.scan_tag_directive_prefix(start_mark);
      return [handle, prefix];
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_tag_directive_handle = function(start_mark) {
      var char, value;
      value = this.scan_tag_handle('directive', start_mark);
      char = this.peek();
      if (char !== ' ') {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected ' ' but found " + char, this.get_mark());
      }
      return value;
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_tag_directive_prefix = function(start_mark) {
      var char, value;
      value = this.scan_tag_uri('directive', start_mark);
      char = this.peek();
      if (__indexOf.call(C_LB + '\x00 ', char) < 0) {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected ' ' but found " + char, this.get_mark());
      }
      return value;
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_directive_ignored_line = function(start_mark) {
      var char, _ref1;
      while (this.peek() === ' ') {
        this.forward();
      }
      if (this.peek() === '#') {
        while (_ref1 = this.peek(), __indexOf.call(C_LB + '\x00', _ref1) < 0) {
          this.forward();
        }
      }
      char = this.peek();
      if (__indexOf.call(C_LB + '\x00', char) < 0) {
        throw new exports.ScannerError('while scanning a directive', start_mark, "expected a comment or a line break but found " + char, this.get_mark());
      }
      return this.scan_line_break();
    };

    /*
    The specification does not restrict characters for anchors and aliases.
    This may lead to problems, for instance, the document:
      [ *alias, value ]
    can be interpteted in two ways, as
      [ "value" ]
    and
      [ *alias , "value" ]
    Therefore we restrict aliases to numbers and ASCII letters.
    */


    Scanner.prototype.scan_anchor = function(TokenClass) {
      var char, indicator, length, name, start_mark, value;
      start_mark = this.get_mark();
      indicator = this.peek();
      if (indicator === '*') {
        name = 'alias';
      } else {
        name = 'anchor';
      }
      this.forward();
      length = 0;
      char = this.peek(length);
      while (('0' <= char && char <= '9') || ('A' <= char && char <= 'Z') || ('a' <= char && char <= 'z') || __indexOf.call('-_', char) >= 0) {
        length++;
        char = this.peek(length);
      }
      if (length === 0) {
        throw new exports.ScannerError("while scanning an " + name, start_mark, "expected alphabetic or numeric character but found '" + char + "'", this.get_mark());
      }
      value = this.prefix(length);
      this.forward(length);
      char = this.peek();
      if (__indexOf.call(C_LB + C_WS + '\x00' + '?:,]}%@`', char) < 0) {
        throw new exports.ScannerError("while scanning an " + name, start_mark, "expected alphabetic or numeric character but found '" + char + "'", this.get_mark());
      }
      return new TokenClass(value, start_mark, this.get_mark());
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_tag = function() {
      var char, handle, length, start_mark, suffix, use_handle;
      start_mark = this.get_mark();
      char = this.peek(1);
      if (char === '<') {
        handle = null;
        this.forward(2);
        suffix = this.scan_tag_uri('tag', start_mark);
        if (this.peek() !== '>') {
          throw new exports.ScannerError('while parsing a tag', start_mark, "expected '>' but found " + (this.peek()), this.get_mark());
        }
        this.forward();
      } else if (__indexOf.call(C_LB + C_WS + '\x00', char) >= 0) {
        handle = null;
        suffix = '!';
        this.forward();
      } else {
        length = 1;
        use_handle = false;
        while (__indexOf.call(C_LB + '\x00 ', char) < 0) {
          if (char === '!') {
            use_handle = true;
            break;
          }
          length++;
          char = this.peek(length);
        }
        if (use_handle) {
          handle = this.scan_tag_handle('tag', start_mark);
        } else {
          handle = '!';
          this.forward();
        }
        suffix = this.scan_tag_uri('tag', start_mark);
      }
      char = this.peek();
      if (__indexOf.call(C_LB + '\x00 ', char) < 0) {
        throw new exports.ScannerError('while scanning a tag', start_mark, "expected ' ' but found " + char, this.get_mark());
      }
      return new tokens.TagToken([handle, suffix], start_mark, this.get_mark());
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_block_scalar = function(style) {
      var breaks, chomping, chunks, end_mark, folded, increment, indent, leading_non_space, length, line_break, max_indent, min_indent, start_mark, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      folded = style === '>';
      chunks = [];
      start_mark = this.get_mark();
      this.forward();
      _ref1 = this.scan_block_scalar_indicators(start_mark), chomping = _ref1[0], increment = _ref1[1];
      this.scan_block_scalar_ignored_line(start_mark);
      min_indent = this.indent + 1;
      if (min_indent < 1) {
        min_indent = 1;
      }
      if (increment == null) {
        _ref2 = this.scan_block_scalar_indentation(), breaks = _ref2[0], max_indent = _ref2[1], end_mark = _ref2[2];
        indent = Math.max(min_indent, max_indent);
      } else {
        indent = min_indent + increment - 1;
        _ref3 = this.scan_block_scalar_breaks(indent), breaks = _ref3[0], end_mark = _ref3[1];
      }
      line_break = '';
      while (this.column === indent && this.peek() !== '\x00') {
        chunks = chunks.concat(breaks);
        leading_non_space = (_ref4 = this.peek(), __indexOf.call(' \t', _ref4) < 0);
        length = 0;
        while (_ref5 = this.peek(length), __indexOf.call(C_LB + '\x00', _ref5) < 0) {
          length++;
        }
        chunks.push(this.prefix(length));
        this.forward(length);
        line_break = this.scan_line_break();
        _ref6 = this.scan_block_scalar_breaks(indent), breaks = _ref6[0], end_mark = _ref6[1];
        if (this.column === indent && this.peek() !== '\x00') {
          if (folded && line_break === '\n' && leading_non_space && (_ref7 = this.peek(), __indexOf.call(' \t', _ref7) < 0)) {
            if (util.is_empty(breaks)) {
              chunks.push(' ');
            }
          } else {
            chunks.push(line_break);
          }
        } else {
          break;
        }
      }
      if (chomping !== false) {
        chunks.push(line_break);
      }
      if (chomping === true) {
        chunks = chunks.concat(breaks);
      }
      return new tokens.ScalarToken(chunks.join(''), false, start_mark, end_mark, style);
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_block_scalar_indicators = function(start_mark) {
      var char, chomping, increment;
      chomping = null;
      increment = null;
      char = this.peek();
      if (__indexOf.call('+-', char) >= 0) {
        chomping = char === '+';
        this.forward();
        char = this.peek();
        if (__indexOf.call(C_NUMBERS, char) >= 0) {
          increment = parseInt(char);
          if (increment === 0) {
            throw new exports.ScannerError('while scanning a block scalar', start_mark, 'expected indentation indicator in the range 1-9 but found 0', this.get_mark());
          }
          this.forward();
        }
      } else if (__indexOf.call(C_NUMBERS, char) >= 0) {
        increment = parseInt(char);
        if (increment === 0) {
          throw new exports.ScannerError('while scanning a block scalar', start_mark, 'expected indentation indicator in the range 1-9 but found 0', this.get_mark());
        }
        this.forward();
        char = this.peek();
        if (__indexOf.call('+-', char) >= 0) {
          chomping = char === '+';
          this.forward();
        }
      }
      char = this.peek();
      if (__indexOf.call(C_LB + '\x00 ', char) < 0) {
        throw new exports.ScannerError('while scanning a block scalar', start_mark, "expected chomping or indentation indicators, but found " + char, this.get_mark());
      }
      return [chomping, increment];
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_block_scalar_ignored_line = function(start_mark) {
      var char, _ref1;
      while (this.peek() === ' ') {
        this.forward();
      }
      if (this.peek() === '#') {
        while (_ref1 = this.peek(), __indexOf.call(C_LB + '\x00', _ref1) < 0) {
          this.forward();
        }
      }
      char = this.peek();
      if (__indexOf.call(C_LB + '\x00', char) < 0) {
        throw new exports.ScannerError('while scanning a block scalar', start_mark, "expected a comment or a line break but found " + char, this.get_mark());
      }
      return this.scan_line_break();
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_block_scalar_indentation = function() {
      var chunks, end_mark, max_indent, _ref1;
      chunks = [];
      max_indent = 0;
      end_mark = this.get_mark();
      while (_ref1 = this.peek(), __indexOf.call(C_LB + ' ', _ref1) >= 0) {
        if (this.peek() !== ' ') {
          chunks.push(this.scan_line_break());
          end_mark = this.get_mark();
        } else {
          this.forward();
          if (this.column > max_indent) {
            max_indent = this.column;
          }
        }
      }
      return [chunks, max_indent, end_mark];
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_block_scalar_breaks = function(indent) {
      var chunks, end_mark, _ref1;
      chunks = [];
      end_mark = this.get_mark();
      while (this.column < indent && this.peek() === ' ') {
        this.forward();
      }
      while (_ref1 = this.peek(), __indexOf.call(C_LB, _ref1) >= 0) {
        chunks.push(this.scan_line_break());
        end_mark = this.get_mark();
        while (this.column < indent && this.peek() === ' ') {
          this.forward();
        }
      }
      return [chunks, end_mark];
    };

    /*
    See the specification for details.
    Note that we loose indentation rules for quoted scalars. Quoted scalars
    don't need to adhere indentation because " and ' clearly mark the beginning
    and the end of them. Therefore we are less restrictive than the
    specification requires. We only need to check that document separators are
    not included in scalars.
    */


    Scanner.prototype.scan_flow_scalar = function(style) {
      var chunks, double, quote, start_mark;
      double = style === '"';
      chunks = [];
      start_mark = this.get_mark();
      quote = this.peek();
      this.forward();
      chunks = chunks.concat(this.scan_flow_scalar_non_spaces(double, start_mark));
      while (this.peek() !== quote) {
        chunks = chunks.concat(this.scan_flow_scalar_spaces(double, start_mark));
        chunks = chunks.concat(this.scan_flow_scalar_non_spaces(double, start_mark));
      }
      this.forward();
      return new tokens.ScalarToken(chunks.join(''), false, start_mark, this.get_mark(), style);
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_flow_scalar_non_spaces = function(double, start_mark) {
      var char, chunks, code, k, length, _i, _ref1, _ref2;
      chunks = [];
      while (true) {
        length = 0;
        while (_ref1 = this.peek(length), __indexOf.call(C_LB + C_WS + '\'"\\\x00', _ref1) < 0) {
          length++;
        }
        if (length !== 0) {
          chunks.push(this.prefix(length));
          this.forward(length);
        }
        char = this.peek();
        if (!double && char === '\'' && this.peek(1) === '\'') {
          chunks.push('\'');
          this.forward(2);
        } else if ((double && char === '\'') || (!double && __indexOf.call('"\\', char) >= 0)) {
          chunks.push(char);
          this.forward();
        } else if (double && char === '\\') {
          this.forward();
          char = this.peek();
          if (char in ESCAPE_REPLACEMENTS) {
            chunks.push(ESCAPE_REPLACEMENTS[char]);
            this.forward();
          } else if (char in ESCAPE_CODES) {
            length = ESCAPE_CODES[char];
            this.forward();
            for (k = _i = 0; 0 <= length ? _i < length : _i > length; k = 0 <= length ? ++_i : --_i) {
              if (_ref2 = this.peek(k), __indexOf.call(C_NUMBERS + 'ABCDEFabcdef', _ref2) < 0) {
                throw new exports.ScannerError('while scanning a double-quoted scalar', start_mark, "expected escape sequence of " + length + " hexadecimal numbers, but found " + (this.peek(k)), this.get_mark());
              }
            }
            code = parseInt(this.prefix(length), 16);
            chunks.push(String.fromCharCode(code));
            this.forward(length);
          } else if (__indexOf.call(C_LB, char) >= 0) {
            this.scan_line_break();
            chunks = chunks.concat(this.scan_flow_scalar_breaks(double, start_mark));
          } else {
            throw new exports.ScannerError('while scanning a double-quoted scalar', start_mark, "found unknown escape character " + char, this.get_mark());
          }
        } else {
          return chunks;
        }
      }
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_flow_scalar_spaces = function(double, start_mark) {
      var breaks, char, chunks, length, line_break, whitespaces, _ref1;
      chunks = [];
      length = 0;
      while (_ref1 = this.peek(length), __indexOf.call(C_WS, _ref1) >= 0) {
        length++;
      }
      whitespaces = this.prefix(length);
      this.forward(length);
      char = this.peek();
      if (char === '\x00') {
        throw new exports.ScannerError('while scanning a quoted scalar', start_mark, 'found unexpected end of stream', this.get_mark());
      }
      if (__indexOf.call(C_LB, char) >= 0) {
        line_break = this.scan_line_break();
        breaks = this.scan_flow_scalar_breaks(double, start_mark);
        if (line_break !== '\n') {
          chunks.push(line_break);
        } else if (!breaks) {
          chunks.push(' ');
        }
        chunks = chunks.concat(breaks);
      } else {
        chunks.push(whitespaces);
      }
      return chunks;
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_flow_scalar_breaks = function(double, start_mark) {
      var chunks, prefix, _ref1, _ref2, _ref3;
      chunks = [];
      while (true) {
        prefix = this.prefix(3);
        if (prefix === '---' || prefix === '...' && (_ref1 = this.peek(3), __indexOf.call(C_LB + C_WS + '\x00', _ref1) >= 0)) {
          throw new exports.ScannerError('while scanning a quoted scalar', start_mark, 'found unexpected document separator', this.get_mark());
        }
        while (_ref2 = this.peek(), __indexOf.call(C_WS, _ref2) >= 0) {
          this.forward();
        }
        if (_ref3 = this.peek(), __indexOf.call(C_LB, _ref3) >= 0) {
          chunks.push(this.scan_line_break());
        } else {
          return chunks;
        }
      }
    };

    /*
    See the specification for details.
    We add an additional restriction for the flow context:
      plain scalars in the flow context cannot contain ',', ':' and '?'.
    We also keep track of the `allow_simple_key` flag here.
    Indentation rules are loosed for the flow context.
    */


    Scanner.prototype.scan_plain = function() {
      var char, chunks, end_mark, indent, length, spaces, start_mark, _ref1, _ref2;
      chunks = [];
      start_mark = end_mark = this.get_mark();
      indent = this.indent + 1;
      spaces = [];
      while (true) {
        length = 0;
        if (this.peek() === '#') {
          break;
        }
        while (true) {
          char = this.peek(length);
          if (__indexOf.call(C_LB + C_WS + '\x00', char) >= 0 || (this.flow_level === 0 && char === ':' && (_ref1 = this.peek(length + 1), __indexOf.call(C_LB + C_WS + '\x00', _ref1) >= 0)) || (this.flow_level !== 0 && __indexOf.call(',:?[]{}', char) >= 0)) {
            break;
          }
          length++;
        }
        if (this.flow_level !== 0 && char === ':' && (_ref2 = this.peek(length + 1), __indexOf.call(C_LB + C_WS + '\x00,[]{}', _ref2) < 0)) {
          this.forward(length);
          throw new exports.ScannerError('while scanning a plain scalar', start_mark, 'found unexpected \':\'', this.get_mark(), 'Please check http://pyyaml.org/wiki/YAMLColonInFlowContext');
        }
        if (length === 0) {
          break;
        }
        this.allow_simple_key = false;
        chunks = chunks.concat(spaces);
        chunks.push(this.prefix(length));
        this.forward(length);
        end_mark = this.get_mark();
        spaces = this.scan_plain_spaces(indent, start_mark);
        if ((spaces == null) || spaces.length === 0 || this.peek() === '#' || (this.flow_level === 0 && this.column < indent)) {
          break;
        }
      }
      return new tokens.ScalarToken(chunks.join(''), true, start_mark, end_mark);
    };

    /*
    See the specification for details.
    The specification is really confusing about tabs in plain scalars.
    We just forbid them completely. Do not use tabs in YAML!
    */


    Scanner.prototype.scan_plain_spaces = function(indent, start_mark) {
      var breaks, char, chunks, length, line_break, prefix, whitespaces, _ref1, _ref2;
      chunks = [];
      length = 0;
      while (_ref1 = this.peek(length), __indexOf.call(' ', _ref1) >= 0) {
        length++;
      }
      whitespaces = this.prefix(length);
      this.forward(length);
      char = this.peek();
      if (__indexOf.call(C_LB, char) >= 0) {
        line_break = this.scan_line_break();
        this.allow_simple_key = true;
        prefix = this.prefix(3);
        if (prefix === '---' || prefix === '...' && this.peek(__indexOf.call(C_LB + C_WS + '\x00', 3) >= 0)) {
          return;
        }
        breaks = [];
        while (_ref2 = this.peek(), __indexOf.call(C_LB + ' ', _ref2) >= 0) {
          if (this.peek() === ' ') {
            this.forward();
          } else {
            breaks.push(this.scan_line_break());
            prefix = this.prefix(3);
            if (prefix === '---' || prefix === '...' && this.peek(__indexOf.call(C_LB + C_WS + '\x00', 3) >= 0)) {
              return;
            }
          }
        }
        if (line_break !== '\n') {
          chunks.push(line_break);
        } else if (breaks.length === 0) {
          chunks.push(' ');
        }
        chunks = chunks.concat(breaks);
      } else if (whitespaces) {
        chunks.push(whitespaces);
      }
      return chunks;
    };

    /*
    See the specification for details.
    For some strange reasons, the specification does not allow '_' in tag
    handles. I have allowed it anyway.
    */


    Scanner.prototype.scan_tag_handle = function(name, start_mark) {
      var char, length, value;
      char = this.peek();
      if (char !== '!') {
        throw new exports.ScannerError("while scanning a " + name, start_mark, "expected '!' but found " + char, this.get_mark());
      }
      length = 1;
      char = this.peek(length);
      if (char !== ' ') {
        while (('0' <= char && char <= '9') || ('A' <= char && char <= 'Z') || ('a' <= char && char <= 'z') || __indexOf.call('-_', char) >= 0) {
          length++;
          char = this.peek(length);
        }
        if (char !== '!') {
          this.forward(length);
          throw new exports.ScannerError("while scanning a " + name, start_mark, "expected '!' but found " + char, this.get_mark());
        }
        length++;
      }
      value = this.prefix(length);
      this.forward(length);
      return value;
    };

    /*
    See the specification for details.
    Note: we do not check if URI is well-formed.
    */


    Scanner.prototype.scan_tag_uri = function(name, start_mark) {
      var char, chunks, length;
      chunks = [];
      length = 0;
      char = this.peek(length);
      while (('0' <= char && char <= '9') || ('A' <= char && char <= 'Z') || ('a' <= char && char <= 'z') || __indexOf.call('-;/?:@&=+$,_.!~*\'()[]%', char) >= 0) {
        if (char === '%') {
          chunks.push(this.prefix(length));
          this.forward(length);
          length = 0;
          chunks.push(this.scan_uri_escapes(name, start_mark));
        } else {
          length++;
        }
        char = this.peek(length);
      }
      if (length !== 0) {
        chunks.push(this.prefix(length));
        this.forward(length);
        length = 0;
      }
      if (chunks.length === 0) {
        throw new exports.ScannerError("while parsing a " + name, start_mark, "expected URI but found " + char, this.get_mark());
      }
      return chunks.join('');
    };

    /*
    See the specification for details.
    */


    Scanner.prototype.scan_uri_escapes = function(name, start_mark) {
      var bytes, k, mark, _i;
      bytes = [];
      mark = this.get_mark();
      while (this.peek() === '%') {
        this.forward();
        for (k = _i = 0; _i <= 2; k = ++_i) {
          throw new exports.ScannerError("while scanning a " + name, start_mark, "expected URI escape sequence of 2 hexadecimal numbers but found          " + (this.peek(k)), this.get_mark());
        }
        bytes.push(String.fromCharCode(parseInt(this.prefix(2), 16)));
        this.forward(2);
      }
      return bytes.join('');
    };

    /*
    Transforms:
      '\r\n'      :   '\n'
      '\r'        :   '\n'
      '\n'        :   '\n'
      '\x85'      :   '\n'
      '\u2028'    :   '\u2028'
      '\u2029     :   '\u2029'
      default     :   ''
    */


    Scanner.prototype.scan_line_break = function() {
      var char;
      char = this.peek();
      if (__indexOf.call('\r\n\x85', char) >= 0) {
        if (this.prefix(2) === '\r\n') {
          this.forward(2);
        } else {
          this.forward();
        }
        return '\n';
      } else if (__indexOf.call('\u2028\u2029', char) >= 0) {
        this.forward();
        return char;
      }
      return '';
    };

    return Scanner;

  })();

}).call(this);

},{"./errors":33,"./tokens":47,"./util":50}],45:[function(require,module,exports){
(function() {
  var MarkedYAMLError, nodes, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  /*
  The Schemas throws these.
  */


  this.SchemaError = (function(_super) {
    __extends(SchemaError, _super);

    function SchemaError() {
      _ref = SchemaError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return SchemaError;

  })(MarkedYAMLError);

  /*
    The Schemas class deals with applying schemas to resources according to the spec
  */


  this.Schemas = (function() {
    function Schemas() {
      this.get_schemas_used = __bind(this.get_schemas_used, this);
      this.apply_schemas = __bind(this.apply_schemas, this);
      this.get_all_schemas = __bind(this.get_all_schemas, this);
      this.has_schemas = __bind(this.has_schemas, this);
      this.load_schemas = __bind(this.load_schemas, this);
      this.declaredSchemas = {};
    }

    Schemas.prototype.load_schemas = function(node) {
      var allSchemas,
        _this = this;
      if (this.has_property(node, "schemas")) {
        allSchemas = this.property_value(node, 'schemas');
        if (allSchemas && typeof allSchemas === "object") {
          return allSchemas.forEach(function(schema_entry) {
            if (schema_entry && typeof schema_entry === "object" && typeof schema_entry.value === "object") {
              return schema_entry.value.forEach(function(schema) {
                return _this.declaredSchemas[schema[0].value] = schema;
              });
            }
          });
        }
      }
    };

    Schemas.prototype.has_schemas = function(node) {
      if (this.declaredSchemas.length === 0 && this.has_property(node, "schemas")) {
        this.load_schemas(node);
      }
      return Object.keys(this.declaredSchemas).length > 0;
    };

    Schemas.prototype.get_all_schemas = function() {
      return this.declaredSchemas;
    };

    Schemas.prototype.apply_schemas = function(node) {
      var resources, schemas,
        _this = this;
      resources = this.child_resources(node);
      schemas = this.get_schemas_used(resources);
      return schemas.forEach(function(schema) {
        if (schema[1].value in _this.declaredSchemas) {
          return schema[1].value = _this.declaredSchemas[schema[1].value][1].value;
        }
      });
    };

    Schemas.prototype.get_schemas_used = function(resources) {
      var schemas,
        _this = this;
      schemas = [];
      resources.forEach(function(resource) {
        var properties;
        properties = _this.get_properties(resource[1], "schema");
        return schemas = schemas.concat(properties);
      });
      return schemas;
    };

    return Schemas;

  })();

}).call(this);

},{"./errors":33,"./nodes":37}],46:[function(require,module,exports){
(function() {
  var MarkedYAMLError, nodes, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  /*
  The Schemas throws these.
  */


  this.SecuritySchemeError = (function(_super) {
    __extends(SecuritySchemeError, _super);

    /*
      The Schemas class deals with applying schemas to resources according to the spec
    */


    function SecuritySchemeError() {
      _ref = SecuritySchemeError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return SecuritySchemeError;

  })(MarkedYAMLError);

  this.SecuritySchemes = (function() {
    function SecuritySchemes() {
      this.get_security_scheme = __bind(this.get_security_scheme, this);
      this.get_all_schemes = __bind(this.get_all_schemes, this);
      this.load_security_schemes = __bind(this.load_security_schemes, this);
      this.declaredSchemes = {};
    }

    SecuritySchemes.prototype.load_security_schemes = function(node) {
      var allschemes,
        _this = this;
      if (this.has_property(node, "securitySchemes")) {
        allschemes = this.property_value(node, 'securitySchemes');
        if (allschemes && typeof allschemes === "object") {
          return allschemes.forEach(function(scheme_entry) {
            if (scheme_entry.tag === 'tag:yaml.org,2002:map') {
              return scheme_entry.value.forEach(function(scheme) {
                return _this.declaredSchemes[scheme[0].value] = scheme[1].value;
              });
            }
          });
        }
      }
    };

    SecuritySchemes.prototype.get_all_schemes = function() {
      return this.declaredSchemes;
    };

    SecuritySchemes.prototype.get_security_scheme = function(schemaName) {
      return this.declaredSchemes[schemaName];
    };

    return SecuritySchemes;

  })();

}).call(this);

},{"./errors":33,"./nodes":37}],47:[function(require,module,exports){
(function() {
  var _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  this.Token = (function() {
    function Token(start_mark, end_mark) {
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return Token;

  })();

  this.DirectiveToken = (function(_super) {
    __extends(DirectiveToken, _super);

    DirectiveToken.prototype.id = '<directive>';

    function DirectiveToken(name, value, start_mark, end_mark) {
      this.name = name;
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return DirectiveToken;

  })(this.Token);

  this.DocumentStartToken = (function(_super) {
    __extends(DocumentStartToken, _super);

    function DocumentStartToken() {
      _ref = DocumentStartToken.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    DocumentStartToken.prototype.id = '<document start>';

    return DocumentStartToken;

  })(this.Token);

  this.DocumentEndToken = (function(_super) {
    __extends(DocumentEndToken, _super);

    function DocumentEndToken() {
      _ref1 = DocumentEndToken.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    DocumentEndToken.prototype.id = '<document end>';

    return DocumentEndToken;

  })(this.Token);

  this.StreamStartToken = (function(_super) {
    __extends(StreamStartToken, _super);

    StreamStartToken.prototype.id = '<stream start>';

    function StreamStartToken(start_mark, end_mark, encoding) {
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.encoding = encoding;
    }

    return StreamStartToken;

  })(this.Token);

  this.StreamEndToken = (function(_super) {
    __extends(StreamEndToken, _super);

    function StreamEndToken() {
      _ref2 = StreamEndToken.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    StreamEndToken.prototype.id = '<stream end>';

    return StreamEndToken;

  })(this.Token);

  this.BlockSequenceStartToken = (function(_super) {
    __extends(BlockSequenceStartToken, _super);

    function BlockSequenceStartToken() {
      _ref3 = BlockSequenceStartToken.__super__.constructor.apply(this, arguments);
      return _ref3;
    }

    BlockSequenceStartToken.prototype.id = '<block sequence start>';

    return BlockSequenceStartToken;

  })(this.Token);

  this.BlockMappingStartToken = (function(_super) {
    __extends(BlockMappingStartToken, _super);

    function BlockMappingStartToken() {
      _ref4 = BlockMappingStartToken.__super__.constructor.apply(this, arguments);
      return _ref4;
    }

    BlockMappingStartToken.prototype.id = '<block mapping end>';

    return BlockMappingStartToken;

  })(this.Token);

  this.BlockEndToken = (function(_super) {
    __extends(BlockEndToken, _super);

    function BlockEndToken() {
      _ref5 = BlockEndToken.__super__.constructor.apply(this, arguments);
      return _ref5;
    }

    BlockEndToken.prototype.id = '<block end>';

    return BlockEndToken;

  })(this.Token);

  this.FlowSequenceStartToken = (function(_super) {
    __extends(FlowSequenceStartToken, _super);

    function FlowSequenceStartToken() {
      _ref6 = FlowSequenceStartToken.__super__.constructor.apply(this, arguments);
      return _ref6;
    }

    FlowSequenceStartToken.prototype.id = '[';

    return FlowSequenceStartToken;

  })(this.Token);

  this.FlowMappingStartToken = (function(_super) {
    __extends(FlowMappingStartToken, _super);

    function FlowMappingStartToken() {
      _ref7 = FlowMappingStartToken.__super__.constructor.apply(this, arguments);
      return _ref7;
    }

    FlowMappingStartToken.prototype.id = '{';

    return FlowMappingStartToken;

  })(this.Token);

  this.FlowSequenceEndToken = (function(_super) {
    __extends(FlowSequenceEndToken, _super);

    function FlowSequenceEndToken() {
      _ref8 = FlowSequenceEndToken.__super__.constructor.apply(this, arguments);
      return _ref8;
    }

    FlowSequenceEndToken.prototype.id = ']';

    return FlowSequenceEndToken;

  })(this.Token);

  this.FlowMappingEndToken = (function(_super) {
    __extends(FlowMappingEndToken, _super);

    function FlowMappingEndToken() {
      _ref9 = FlowMappingEndToken.__super__.constructor.apply(this, arguments);
      return _ref9;
    }

    FlowMappingEndToken.prototype.id = '}';

    return FlowMappingEndToken;

  })(this.Token);

  this.KeyToken = (function(_super) {
    __extends(KeyToken, _super);

    function KeyToken() {
      _ref10 = KeyToken.__super__.constructor.apply(this, arguments);
      return _ref10;
    }

    KeyToken.prototype.id = '?';

    return KeyToken;

  })(this.Token);

  this.ValueToken = (function(_super) {
    __extends(ValueToken, _super);

    function ValueToken() {
      _ref11 = ValueToken.__super__.constructor.apply(this, arguments);
      return _ref11;
    }

    ValueToken.prototype.id = ':';

    return ValueToken;

  })(this.Token);

  this.BlockEntryToken = (function(_super) {
    __extends(BlockEntryToken, _super);

    function BlockEntryToken() {
      _ref12 = BlockEntryToken.__super__.constructor.apply(this, arguments);
      return _ref12;
    }

    BlockEntryToken.prototype.id = '-';

    return BlockEntryToken;

  })(this.Token);

  this.FlowEntryToken = (function(_super) {
    __extends(FlowEntryToken, _super);

    function FlowEntryToken() {
      _ref13 = FlowEntryToken.__super__.constructor.apply(this, arguments);
      return _ref13;
    }

    FlowEntryToken.prototype.id = ',';

    return FlowEntryToken;

  })(this.Token);

  this.AliasToken = (function(_super) {
    __extends(AliasToken, _super);

    AliasToken.prototype.id = '<alias>';

    function AliasToken(value, start_mark, end_mark) {
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return AliasToken;

  })(this.Token);

  this.AnchorToken = (function(_super) {
    __extends(AnchorToken, _super);

    AnchorToken.prototype.id = '<anchor>';

    function AnchorToken(value, start_mark, end_mark) {
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return AnchorToken;

  })(this.Token);

  this.TagToken = (function(_super) {
    __extends(TagToken, _super);

    TagToken.prototype.id = '<tag>';

    function TagToken(value, start_mark, end_mark) {
      this.value = value;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
    }

    return TagToken;

  })(this.Token);

  this.ScalarToken = (function(_super) {
    __extends(ScalarToken, _super);

    ScalarToken.prototype.id = '<scalar>';

    function ScalarToken(value, plain, start_mark, end_mark, style) {
      this.value = value;
      this.plain = plain;
      this.start_mark = start_mark;
      this.end_mark = end_mark;
      this.style = style;
    }

    return ScalarToken;

  })(this.Token);

}).call(this);

},{}],48:[function(require,module,exports){
(function() {
  var MarkedYAMLError, inflection, nodes, util, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  inflection = require('inflection');

  util = require('./util');

  /*
  The Traits throws these.
  */


  this.TraitError = (function(_super) {
    __extends(TraitError, _super);

    function TraitError() {
      _ref = TraitError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return TraitError;

  })(MarkedYAMLError);

  /*
  */


  this.ParameterError = (function(_super) {
    __extends(ParameterError, _super);

    function ParameterError() {
      _ref1 = ParameterError.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    return ParameterError;

  })(MarkedYAMLError);

  /*
  The Traits class deals with applying traits to resources according to the spec
  */


  this.Traits = (function() {
    function Traits() {
      this.declaredTraits = {};
    }

    Traits.prototype.load_traits = function(node) {
      var allTraits,
        _this = this;
      if (this.has_property(node, 'traits')) {
        allTraits = this.property_value(node, 'traits');
        if (allTraits && typeof allTraits === "object") {
          return allTraits.forEach(function(trait_item) {
            if (trait_item && typeof trait_item === "object" && typeof trait_item.value === "object") {
              return trait_item.value.forEach(function(trait) {
                return _this.declaredTraits[trait[0].value] = trait;
              });
            }
          });
        }
      }
    };

    Traits.prototype.has_traits = function(node) {
      if (this.declaredTraits.length === 0 && this.has_property(node, 'traits')) {
        this.load_traits(node);
      }
      return Object.keys(this.declaredTraits).length > 0;
    };

    Traits.prototype.get_trait = function(traitName) {
      if (traitName in this.declaredTraits) {
        return this.declaredTraits[traitName][1];
      }
      return null;
    };

    Traits.prototype.apply_traits = function(node, resourceUri, removeQs) {
      var resources,
        _this = this;
      if (resourceUri == null) {
        resourceUri = "";
      }
      if (removeQs == null) {
        removeQs = true;
      }
      if (!util.isMapping(node)) {
        return;
      }
      if (this.has_traits(node)) {
        resources = this.child_resources(node);
        return resources.forEach(function(resource) {
          return _this.apply_traits_to_resource(resourceUri + resource[0].value, resource[1], removeQs);
        });
      }
    };

    Traits.prototype.apply_traits_to_resource = function(resourceUri, resource, removeQs) {
      var methods, uses,
        _this = this;
      if (!util.isMapping(resource)) {
        return;
      }
      methods = this.child_methods(resource);
      if (this.has_property(resource, 'is')) {
        uses = this.property_value(resource, 'is');
        uses.forEach(function(use) {
          return methods.forEach(function(method) {
            return _this.apply_trait(resourceUri, method, use);
          });
        });
      }
      methods.forEach(function(method) {
        if (_this.has_property(method[1], 'is')) {
          uses = _this.property_value(method[1], 'is');
          return uses.forEach(function(use) {
            return _this.apply_trait(resourceUri, method, use);
          });
        }
      });
      if (removeQs) {
        resource.remove_question_mark_properties();
      }
      return this.apply_traits(resource, resourceUri, removeQs);
    };

    Traits.prototype.apply_trait = function(resourceUri, method, useKey) {
      var plainParameters, temp, trait, traitName;
      traitName = this.key_or_value(useKey);
      if (!(traitName != null ? traitName.trim() : void 0)) {
        throw new exports.TraitError('while applying trait', null, 'trait name must be provided', useKey.start_mark);
      }
      if (!(trait = this.get_trait(traitName))) {
        throw new exports.TraitError('while applying trait', null, "there is no trait named " + traitName, useKey.start_mark);
      }
      plainParameters = this.get_parameters_from_is_key(resourceUri, method[0].value, useKey);
      temp = trait.cloneForTrait();
      this.apply_parameters(temp, plainParameters, useKey);
      this.apply_default_media_type_to_method(temp);
      temp.combine(method[1]);
      return method[1] = temp;
    };

    Traits.prototype.apply_parameters = function(resource, parameters, useKey) {
      var parameterName, usedParameters, _results;
      this._apply_parameters(resource, parameters, useKey, usedParameters = {
        resourcePath: true,
        resourcePathName: true,
        methodName: true
      });
      _results = [];
      for (parameterName in parameters) {
        if (!usedParameters[parameterName]) {
          throw new exports.ParameterError('while applying parameters', null, "unused parameter: " + parameterName, useKey.start_mark);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Traits.prototype._apply_parameters = function(resource, parameters, useKey, usedParameters) {
      var parameterUse,
        _this = this;
      if (!resource) {
        return;
      }
      if (util.isString(resource)) {
        if (parameterUse = resource.value.match(/<<\s*([^\|\s>]+)\s*(\|.*)?\s*>>/g)) {
          parameterUse.forEach(function(parameter) {
            var method, parameterName, value, _ref2, _ref3;
            parameterName = parameter != null ? (_ref2 = parameter.trim()) != null ? _ref2.replace(/[<>]+/g, '').trim() : void 0 : void 0;
            _ref3 = parameterName.split(/\s*\|\s*/), parameterName = _ref3[0], method = _ref3[1];
            if (!(parameterName in parameters)) {
              throw new exports.ParameterError('while applying parameters', null, "value was not provided for parameter: " + parameterName, useKey.start_mark);
            }
            value = parameters[parameterName];
            usedParameters[parameterName] = true;
            if (method) {
              if (method.match(/!\s*singularize/)) {
                value = inflection.singularize(value);
              } else if (method.match(/!\s*pluralize/)) {
                value = inflection.pluralize(value);
              } else {
                throw new exports.ParameterError('while validating parameter', null, 'unknown function applied to parameter', resource.start_mark);
              }
            }
            return resource.value = resource.value.replace(parameter, value);
          });
        }
        return;
      }
      if (util.isSequence(resource)) {
        resource.value.forEach(function(node) {
          return _this._apply_parameters(node, parameters, useKey, usedParameters);
        });
        return;
      }
      if (util.isMapping(resource)) {
        resource.value.forEach(function(property) {
          _this._apply_parameters(property[0], parameters, useKey, usedParameters);
          return _this._apply_parameters(property[1], parameters, useKey, usedParameters);
        });
      }
    };

    Traits.prototype.get_parameters_from_is_key = function(resourceUri, methodName, typeKey) {
      var parameter, parameters, reserved, result, _i, _len, _ref2;
      result = {};
      reserved = {
        methodName: methodName,
        resourcePath: resourceUri.replace(/\/\/*/g, '/'),
        resourcePathName: this.extractResourcePathName(resourceUri)
      };
      if (util.isMapping(typeKey)) {
        parameters = this.value_or_undefined(typeKey);
        if (util.isMapping(parameters[0][1])) {
          _ref2 = parameters[0][1].value;
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            parameter = _ref2[_i];
            if (parameter[0].value in reserved) {
              throw new exports.TraitError('while applying parameters', null, "invalid parameter name: " + parameter[0].value + " is reserved", parameter[0].start_mark);
            }
            result[parameter[0].value] = parameter[1].value;
          }
        }
      }
      return util.extend(result, reserved);
    };

    Traits.prototype.extractResourcePathName = function(resourceUri) {
      var pathSegments, segment;
      pathSegments = resourceUri.split(/\//);
      while (segment = pathSegments.pop()) {
        if (!(typeof segment !== "undefined" && segment !== null ? segment.match(/[{}]/) : void 0)) {
          return segment;
        }
      }
      return "";
    };

    return Traits;

  })();

}).call(this);

},{"./errors":33,"./nodes":37,"./util":50,"inflection":52}],49:[function(require,module,exports){
(function() {
  var nodes, uritemplate, util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  uritemplate = require('uritemplate');

  nodes = require('./nodes');

  util = require('./util');

  /*
     Applies transformations to the RAML
  */


  this.Transformations = (function() {
    function Transformations(settings) {
      this.settings = settings;
      this.isContentTypeString = __bind(this.isContentTypeString, this);
      this.add_key_value_to_node = __bind(this.add_key_value_to_node, this);
      this.apply_default_media_type_to_resource = __bind(this.apply_default_media_type_to_resource, this);
      this.get_media_type = __bind(this.get_media_type, this);
      this.load_default_media_type = __bind(this.load_default_media_type, this);
      this.applyAstTransformations = __bind(this.applyAstTransformations, this);
      this.applyTransformations = __bind(this.applyTransformations, this);
      this.declaredSchemas = {};
    }

    Transformations.prototype.applyTransformations = function(rootObject) {
      var resources;
      if (this.settings.transform) {
        this.applyTransformationsToRoot(rootObject);
        resources = rootObject.resources;
        return this.applyTransformationsToResources(rootObject, resources);
      }
    };

    Transformations.prototype.applyAstTransformations = function(document) {
      if (this.settings.transform) {
        return this.transform_document(document);
      }
    };

    Transformations.prototype.load_default_media_type = function(node) {
      if (!util.isMapping(node || (node != null ? node.value : void 0))) {
        return;
      }
      return this.mediaType = this.property_value(node, 'mediaType');
    };

    Transformations.prototype.get_media_type = function() {
      return this.mediaType;
    };

    Transformations.prototype.applyTransformationsToRoot = function(rootObject) {
      var expressions, template;
      if (rootObject.baseUri) {
        template = uritemplate.parse(rootObject.baseUri);
        expressions = template.expressions.filter(function(expr) {
          return 'templateText' in expr;
        }).map(function(expression) {
          return expression.templateText;
        });
        if (expressions.length) {
          if (!rootObject.baseUriParameters) {
            rootObject.baseUriParameters = {};
          }
        }
        return expressions.forEach(function(parameterName) {
          if (!(parameterName in rootObject.baseUriParameters)) {
            rootObject.baseUriParameters[parameterName] = {
              type: "string",
              required: true,
              displayName: parameterName
            };
            if (parameterName === "version") {
              return rootObject.baseUriParameters[parameterName]["enum"] = [rootObject.version];
            }
          }
        });
      }
    };

    Transformations.prototype.applyTransformationsToResources = function(rootObject, resources) {
      var expressions, inheritedSecScheme, method, parameterName, pathParts, resource, template, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _results;
      if (resources != null ? resources.length : void 0) {
        _results = [];
        for (_i = 0, _len = resources.length; _i < _len; _i++) {
          resource = resources[_i];
          inheritedSecScheme = resource.securedBy ? resource.securedBy : rootObject != null ? rootObject.securedBy : void 0;
          if ((_ref = resource.methods) != null ? _ref.length : void 0) {
            _ref1 = resource.methods;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              method = _ref1[_j];
              if (!("securedBy" in method)) {
                if (inheritedSecScheme) {
                  method.securedBy = inheritedSecScheme;
                }
              }
            }
          }
          pathParts = resource.relativeUri.split('\/');
          while (!pathParts[0] && pathParts.length) {
            pathParts.shift();
          }
          resource.relativeUriPathSegments = pathParts;
          template = uritemplate.parse(resource.relativeUri);
          expressions = template.expressions.filter(function(expr) {
            return 'templateText' in expr;
          }).map(function(expression) {
            return expression.templateText;
          });
          if (expressions.length) {
            if (!resource.uriParameters) {
              resource.uriParameters = {};
            }
          }
          for (_k = 0, _len2 = expressions.length; _k < _len2; _k++) {
            parameterName = expressions[_k];
            if (!(parameterName in resource.uriParameters)) {
              resource.uriParameters[parameterName] = {
                type: "string",
                required: true,
                displayName: parameterName
              };
            }
          }
          _results.push(this.applyTransformationsToResources(rootObject, resource.resources));
        }
        return _results;
      }
    };

    /*
    Media Type pivot when using default mediaType property
    */


    Transformations.prototype.apply_default_media_type_to_resource = function(resource) {
      var childResource, method, _i, _j, _len, _len1, _ref, _ref1, _results;
      if (!this.mediaType) {
        return;
      }
      if (!util.isMapping(resource)) {
        return;
      }
      _ref = this.child_resources(resource);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        childResource = _ref[_i];
        this.apply_default_media_type_to_resource(childResource[1]);
      }
      _ref1 = this.child_methods(resource);
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        method = _ref1[_j];
        _results.push(this.apply_default_media_type_to_method(method[1]));
      }
      return _results;
    };

    Transformations.prototype.apply_default_media_type_to_method = function(method) {
      var responses,
        _this = this;
      if (!this.mediaType) {
        return;
      }
      if (!util.isMapping(method)) {
        return;
      }
      if (this.has_property(method, 'body')) {
        this.apply_default_media_type_to_body(this.get_property(method, 'body'));
      }
      if (this.has_property(method, 'responses')) {
        responses = this.get_property(method, 'responses');
        if (!(responses && responses.value)) {
          return;
        }
        return responses.value.forEach(function(response) {
          if (_this.has_property(response[1], 'body')) {
            return _this.apply_default_media_type_to_body(_this.get_property(response[1], 'body'));
          }
        });
      }
    };

    Transformations.prototype.apply_default_media_type_to_body = function(body) {
      var key, responseType, responseTypeKey, _ref, _ref1, _ref2;
      if (!util.isMapping(body)) {
        return;
      }
      if (body != null ? (_ref = body.value) != null ? (_ref1 = _ref[0]) != null ? (_ref2 = _ref1[0]) != null ? _ref2.value : void 0 : void 0 : void 0 : void 0) {
        key = body.value[0][0].value;
        if (!key.match(/\//)) {
          responseType = new nodes.MappingNode('tag:yaml.org,2002:map', [], body.start_mark, body.end_mark);
          responseTypeKey = new nodes.ScalarNode('tag:yaml.org,2002:str', this.mediaType, body.start_mark, body.end_mark);
          responseType.value.push([responseTypeKey, body.clone()]);
          return body.value = responseType.value;
        }
      }
    };

    Transformations.prototype.noop = function() {};

    Transformations.prototype.transform_types = function(typeProperty) {
      var types,
        _this = this;
      types = typeProperty.value;
      return types.forEach(function(type_entry) {
        return type_entry.value.forEach(function(type) {
          return _this.transform_resource(type, true);
        });
      });
    };

    Transformations.prototype.transform_traits = function(traitProperty) {
      var traits,
        _this = this;
      traits = traitProperty.value;
      return traits.forEach(function(trait_entry) {
        return trait_entry.value.forEach(function(trait) {
          return _this.transform_method(trait[1], true);
        });
      });
    };

    Transformations.prototype.transform_named_params = function(property, allowParameterKeys, requiredByDefault) {
      var _this = this;
      if (requiredByDefault == null) {
        requiredByDefault = true;
      }
      if (util.isNull(property[1])) {
        return;
      }
      return property[1].value.forEach(function(param) {
        if (util.isNull(param[1])) {
          param[1] = new nodes.MappingNode('tag:yaml.org,2002:map', [], param[1].start_mark, param[1].end_mark);
        }
        return _this.transform_common_parameter_properties(param[0].value, param[1], allowParameterKeys, requiredByDefault);
      });
    };

    Transformations.prototype.transform_common_parameter_properties = function(parameterName, node, allowParameterKeys, requiredByDefault) {
      var _this = this;
      if (util.isSequence(node)) {
        return node.value.forEach(function(parameter) {
          return _this.transform_named_parameter(parameterName, parameter, allowParameterKeys, requiredByDefault);
        });
      } else {
        return this.transform_named_parameter(parameterName, node, allowParameterKeys, requiredByDefault);
      }
    };

    Transformations.prototype.transform_named_parameter = function(parameterName, node, allowParameterKeys, requiredByDefault) {
      var hasDisplayName, hasRequired, hasType,
        _this = this;
      hasDisplayName = false;
      hasRequired = false;
      hasType = false;
      node.value.forEach(function(childNode) {
        var canonicalPropertyName;
        if (allowParameterKeys && _this.isParameterKey(childNode)) {
          return;
        }
        canonicalPropertyName = _this.canonicalizePropertyName(childNode[0].value, allowParameterKeys);
        switch (canonicalPropertyName) {
          case "pattern":
            return _this.noop();
          case "default":
            return _this.noop();
          case "enum":
            return _this.noop();
          case "description":
            return _this.noop();
          case "example":
            return _this.noop();
          case "minLength":
            return _this.noop();
          case "maxLength":
            return _this.noop();
          case "minimum":
            return _this.noop();
          case "maximum":
            return _this.noop();
          case "repeat":
            return _this.noop();
          case "displayName":
            return hasDisplayName = true;
          case "type":
            return hasType = true;
          case "required":
            return hasRequired = true;
          default:
            return _this.noop();
        }
      });
      if (!hasDisplayName) {
        this.add_key_value_to_node(node, 'displayName', 'tag:yaml.org,2002:str', this.canonicalizePropertyName(parameterName, allowParameterKeys));
      }
      if (!hasRequired) {
        if (requiredByDefault) {
          this.add_key_value_to_node(node, 'required', 'tag:yaml.org,2002:bool', 'true');
        }
      }
      if (!hasType) {
        return this.add_key_value_to_node(node, 'type', 'tag:yaml.org,2002:str', 'string');
      }
    };

    Transformations.prototype.add_key_value_to_node = function(node, keyName, valueTag, value) {
      var propertyName, propertyValue;
      propertyName = new nodes.ScalarNode('tag:yaml.org,2002:str', keyName, node.start_mark, node.end_mark);
      propertyValue = new nodes.ScalarNode(valueTag, value, node.start_mark, node.end_mark);
      return node.value.push([propertyName, propertyValue]);
    };

    Transformations.prototype.transform_document = function(node) {
      var _this = this;
      if (node != null ? node.value : void 0) {
        return node.value.forEach(function(property) {
          var _ref;
          switch (property[0].value) {
            case "title":
              return _this.noop();
            case "securitySchemes":
              return _this.noop();
            case "schemas":
              return _this.noop();
            case "version":
              return _this.noop();
            case "documentation":
              return _this.noop();
            case "mediaType":
              return _this.noop();
            case "securedBy":
              return _this.noop();
            case "baseUri":
              return _this.noop();
            case "traits":
              return _this.transform_traits(property[1]);
            case "baseUriParameters":
              return _this.transform_named_params(property, false);
            case "resourceTypes":
              return _this.transform_types(property[1]);
            case "resources":
              return (_ref = property[1]) != null ? _ref.value.forEach(function(resource) {
                return _this.transform_resource(resource);
              }) : void 0;
            default:
              return _this.noop();
          }
        });
      }
    };

    Transformations.prototype.transform_resource = function(resource, allowParameterKeys) {
      var _this = this;
      if (allowParameterKeys == null) {
        allowParameterKeys = false;
      }
      if (resource.value) {
        return resource.value.forEach(function(property) {
          var canonicalKey, isKnownCommonProperty, _ref, _ref1;
          isKnownCommonProperty = _this.transform_common_properties(property, allowParameterKeys);
          if (!isKnownCommonProperty) {
            if (_this.isHttpMethod(property[0].value, allowParameterKeys)) {
              return _this.transform_method(property[1], allowParameterKeys);
            } else {
              canonicalKey = _this.canonicalizePropertyName(property[0].value, allowParameterKeys);
              switch (canonicalKey) {
                case "type":
                  return _this.noop();
                case "usage":
                  return _this.noop();
                case "securedBy":
                  return _this.noop();
                case "uriParameters":
                  return _this.transform_named_params(property, allowParameterKeys);
                case "baseUriParameters":
                  return _this.transform_named_params(property, allowParameterKeys);
                case "resources":
                  return (_ref = property[1]) != null ? _ref.value.forEach(function(resource) {
                    return _this.transform_resource(resource);
                  }) : void 0;
                case "methods":
                  return (_ref1 = property[1]) != null ? _ref1.value.forEach(function(method) {
                    return _this.transform_method(method, allowParameterKeys);
                  }) : void 0;
                default:
                  return _this.noop();
              }
            }
          }
        });
      }
    };

    Transformations.prototype.transform_method = function(method, allowParameterKeys) {
      var _this = this;
      if (util.isNull(method)) {
        return;
      }
      return method.value.forEach(function(property) {
        var canonicalKey;
        if (_this.transform_common_properties(property, allowParameterKeys)) {
          return;
        }
        canonicalKey = _this.canonicalizePropertyName(property[0].value, allowParameterKeys);
        switch (canonicalKey) {
          case "securedBy":
            return _this.noop();
          case "usage":
            return _this.noop();
          case "headers":
            return _this.transform_named_params(property, allowParameterKeys, false);
          case "queryParameters":
            return _this.transform_named_params(property, allowParameterKeys, false);
          case "baseUriParameters":
            return _this.transform_named_params(property, allowParameterKeys);
          case "body":
            return _this.transform_body(property, allowParameterKeys);
          case "responses":
            return _this.transform_responses(property, allowParameterKeys);
          default:
            return _this.noop();
        }
      });
    };

    Transformations.prototype.transform_responses = function(responses, allowParameterKeys) {
      var _this = this;
      if (util.isNull(responses[1])) {
        return;
      }
      return responses[1].value.forEach(function(response) {
        return _this.transform_response(response, allowParameterKeys);
      });
    };

    Transformations.prototype.transform_response = function(response, allowParameterKeys) {
      var _this = this;
      if (util.isMapping(response[1])) {
        return response[1].value.forEach(function(property) {
          var canonicalKey;
          canonicalKey = _this.canonicalizePropertyName(property[0].value, allowParameterKeys);
          switch (canonicalKey) {
            case "description":
              return _this.noop();
            case "body":
              return _this.transform_body(property, allowParameterKeys);
            case "headers":
              return _this.transform_named_params(property, allowParameterKeys, false);
            default:
              return _this.noop();
          }
        });
      }
    };

    Transformations.prototype.isContentTypeString = function(value) {
      return value != null ? value.match(/^[^\/]+\/[^\/]+$/) : void 0;
    };

    Transformations.prototype.transform_body = function(property, allowParameterKeys) {
      var _ref,
        _this = this;
      if (util.isNull(property[1])) {
        return;
      }
      return (_ref = property[1].value) != null ? _ref.forEach(function(bodyProperty) {
        var canonicalProperty;
        if (_this.isParameterKey(bodyProperty)) {
          return _this.noop();
        } else if (_this.isContentTypeString(bodyProperty[0].value)) {
          return _this.transform_body(bodyProperty, allowParameterKeys);
        } else {
          canonicalProperty = _this.canonicalizePropertyName(bodyProperty[0].value, allowParameterKeys);
          switch (canonicalProperty) {
            case "example":
              return _this.noop();
            case "schema":
              return _this.noop();
            case "formParameters":
              return _this.transform_named_params(bodyProperty, allowParameterKeys, false);
            default:
              return _this.noop();
          }
        }
      }) : void 0;
    };

    Transformations.prototype.transform_common_properties = function(property, allowParameterKeys) {
      var canonicalProperty;
      if (this.isParameterKey(property)) {
        return true;
      } else {
        canonicalProperty = this.canonicalizePropertyName(property[0].value, allowParameterKeys);
        switch (canonicalProperty) {
          case "displayName":
            return true;
          case "description":
            return true;
          case "is":
            return true;
          default:
            this.noop();
        }
      }
      return false;
    };

    return Transformations;

  })();

}).call(this);

},{"./nodes":37,"./util":50,"uritemplate":56}],50:[function(require,module,exports){
(function() {
  var __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  this.extend = function() {
    var destination, k, source, sources, v, _i, _len;
    destination = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      source = sources[_i];
      for (k in source) {
        v = source[k];
        destination[k] = v;
      }
    }
    return destination;
  };

  this.is_empty = function(obj) {
    var key;
    if (Array.isArray(obj) || typeof obj === 'string') {
      return obj.length === 0;
    }
    for (key in obj) {
      if (!__hasProp.call(obj, key)) continue;
      return false;
    }
    return true;
  };

  this.isNoop = function(node) {
    return node;
  };

  this.isMapping = function(node) {
    return (node != null ? node.tag : void 0) === "tag:yaml.org,2002:map";
  };

  this.isNull = function(node) {
    return (node != null ? node.tag : void 0) === "tag:yaml.org,2002:null";
  };

  this.isSequence = function(node) {
    return (node != null ? node.tag : void 0) === "tag:yaml.org,2002:seq";
  };

  this.isString = function(node) {
    return (node != null ? node.tag : void 0) === "tag:yaml.org,2002:str";
  };

  this.isInteger = function(node) {
    return (node != null ? node.tag : void 0) === "tag:yaml.org,2002:int";
  };

  this.isNullableMapping = function(node) {
    return this.isMapping(node) || this.isNull(node);
  };

  this.isNullableString = function(node) {
    return this.isString(node) || this.isNull(node);
  };

  this.isNullableSequence = function(node) {
    return this.isSequence(node) || this.isNull(node);
  };

  this.isNumber = function(node) {
    return (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:int' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:float';
  };

  this.isScalar = function(node) {
    return (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:null' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:bool' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:int' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:float' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:binary' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:timestamp' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:str';
  };

  this.isCollection = function(node) {
    return (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:omap' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:pairs' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:set' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:seq' || (node != null ? node.tag : void 0) === 'tag:yaml.org,2002:map';
  };

}).call(this);

},{}],51:[function(require,module,exports){
(function() {
  var MarkedYAMLError, jsonlint, nodes, traits, uritemplate, url, util, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  url = require('url');

  uritemplate = require('uritemplate');

  MarkedYAMLError = require('./errors').MarkedYAMLError;

  nodes = require('./nodes');

  traits = require('./traits');

  util = require('./util');

  jsonlint = require('json-lint');

  /*
  The Validator throws these.
  */


  this.ValidationError = (function(_super) {
    __extends(ValidationError, _super);

    function ValidationError() {
      _ref = ValidationError.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    return ValidationError;

  })(MarkedYAMLError);

  /*
  A collection of multiple validation errors
  */


  this.ValidationErrors = (function(_super) {
    __extends(ValidationErrors, _super);

    function ValidationErrors(validation_errors) {
      this.validation_errors = validation_errors;
    }

    ValidationErrors.prototype.get_validation_errors = function() {
      return this.validation_errors;
    };

    return ValidationErrors;

  })(MarkedYAMLError);

  /*
  The Validator class deals with validating a YAML file according to the spec
  */


  this.Validator = (function() {
    function Validator() {
      this.get_properties = __bind(this.get_properties, this);
      this.get_list_values = __bind(this.get_list_values, this);
      this.validations = [this.validate_root, this.validate_root_properties, this.validate_base_uri_parameters, this.valid_absolute_uris];
    }

    Validator.prototype.validate_document = function(node) {
      var validation, _i, _len, _ref1;
      _ref1 = this.validations;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        validation = _ref1[_i];
        validation.call(this, node);
      }
      return true;
    };

    Validator.prototype.validate_security_schemes = function(schemesProperty) {
      var scheme, scheme_entry, _i, _len, _ref1, _results;
      if (!util.isSequence(schemesProperty)) {
        throw new exports.ValidationError('while validating securitySchemes', null, 'invalid security schemes property, it must be an array', schemesProperty.start_mark);
      }
      _ref1 = schemesProperty.value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        scheme_entry = _ref1[_i];
        if (!util.isMapping(scheme_entry)) {
          throw new exports.ValidationError('while validating securitySchemes', null, 'invalid security scheme property, it must be a map', scheme_entry.start_mark);
        }
        _results.push((function() {
          var _j, _len1, _ref2, _results1;
          _ref2 = scheme_entry.value;
          _results1 = [];
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            scheme = _ref2[_j];
            if (!util.isMapping(scheme[1])) {
              throw new exports.ValidationError('while validating securitySchemes', null, 'invalid security scheme property, it must be a map', scheme[0].start_mark);
            }
            _results1.push(this.validate_security_scheme(scheme[1]));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Validator.prototype.trackRepeatedProperties = function(properties, key, property, section, errorMessage) {
      if (section == null) {
        section = "RAML";
      }
      if (errorMessage == null) {
        errorMessage = "a property with the same name already exists";
      }
      if (key in properties) {
        throw new exports.ValidationError("while validating " + section, null, "" + errorMessage + ": '" + key + "'", property.start_mark);
      }
      return properties[key] = property;
    };

    Validator.prototype.validate_security_scheme = function(scheme) {
      var property, schemeProperties, settings, type, _i, _len, _ref1;
      type = null;
      settings = null;
      schemeProperties = {};
      _ref1 = scheme.value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        property = _ref1[_i];
        this.trackRepeatedProperties(schemeProperties, property[0].value, property[0], 'while validating security scheme', "property already used in security scheme");
        switch (property[0].value) {
          case "description":
            if (!util.isScalar(property[1])) {
              throw new exports.ValidationError('while validating security scheme', null, 'schemes description must be a string', property[1].start_mark);
            }
            break;
          case "type":
            type = property[1].value;
            if (!(util.isString(property[1]) && type.match(/^(OAuth 1.0|OAuth 2.0|Basic Authentication|Digest Authentication|x-.+)$/))) {
              throw new exports.ValidationError('while validating security scheme', null, 'schemes type must be any of: "OAuth 1.0", "OAuth 2.0", "Basic Authentication", "Digest Authentication", "x-\{.+\}"', property[1].start_mark);
            }
            break;
          case "describedBy":
            this.validate_method(property, true, "security scheme");
            break;
          case "settings":
            settings = property;
            if (!util.isNullableMapping(property[1])) {
              throw new exports.ValidationError('while validating security scheme', null, 'schemes settings must be a map', property[1].start_mark);
            }
            break;
          default:
            throw new exports.ValidationError('while validating security scheme', null, "property: '" + property[0].value + "' is invalid in a security scheme", property[0].start_mark);
        }
      }
      if (!type) {
        throw new exports.ValidationError('while validating security scheme', null, 'schemes type must be any of: "OAuth 1.0", "OAuth 2.0", "Basic Authentication", "Digest Authentication", "x-\{.+\}"', scheme.start_mark);
      } else if (type === "OAuth 2.0") {
        if (!settings) {
          throw new exports.ValidationError('while validating security scheme', null, 'for OAuth 2.0 settings must be a map', scheme.start_mark);
        }
        return this.validate_oauth2_settings(settings);
      } else if (type === "OAuth 1.0") {
        if (!settings) {
          throw new exports.ValidationError('while validating security scheme', null, 'for OAuth 1.0 settings must be a map', scheme.start_mark);
        }
        return this.validate_oauth1_settings(settings);
      }
    };

    Validator.prototype.validate_oauth2_settings = function(settings) {
      var property, propertyName, settingProperties, _i, _j, _len, _len1, _ref1, _ref2, _results;
      settingProperties = {};
      _ref1 = settings[1].value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        property = _ref1[_i];
        this.trackRepeatedProperties(settingProperties, property[0].value, property[0], 'while validating security scheme', "setting with the same name already exists");
        switch (property[0].value) {
          case "authorizationUri":
            if (!util.isString(property[1])) {
              throw new exports.ValidationError('while validating security scheme', null, 'authorizationUri must be a URL', property[0].start_mark);
            }
            break;
          case "accessTokenUri":
            if (!util.isString(property[1])) {
              throw new exports.ValidationError('while validating security scheme', null, 'accessTokenUri must be a URL', property[0].start_mark);
            }
        }
      }
      _ref2 = ['accessTokenUri', 'authorizationUri'];
      _results = [];
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        propertyName = _ref2[_j];
        if (!(propertyName in settingProperties)) {
          throw new exports.ValidationError('while validating security scheme', null, "OAuth 2.0 settings must have " + propertyName + " property", settings[0].start_mark);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Validator.prototype.validate_oauth1_settings = function(settings) {
      var property, propertyName, settingProperties, _i, _j, _len, _len1, _ref1, _ref2, _results;
      settingProperties = {};
      _ref1 = settings[1].value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        property = _ref1[_i];
        this.trackRepeatedProperties(settingProperties, property[0].value, property[0], 'while validating security scheme', "setting with the same name already exists");
        switch (property[0].value) {
          case "requestTokenUri":
            if (!util.isString(property[1])) {
              throw new exports.ValidationError('while validating security scheme', null, 'requestTokenUri must be a URL', property[0].start_mark);
            }
            break;
          case "authorizationUri":
            if (!util.isString(property[1])) {
              throw new exports.ValidationError('while validating security scheme', null, 'authorizationUri must be a URL', property[0].start_mark);
            }
            break;
          case "tokenCredentialsUri":
            if (!util.isString(property[1])) {
              throw new exports.ValidationError('while validating security scheme', null, 'tokenCredentialsUri must be a URL', property[0].start_mark);
            }
        }
      }
      _ref2 = ['requestTokenUri', 'authorizationUri', 'tokenCredentialsUri'];
      _results = [];
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        propertyName = _ref2[_j];
        if (!(propertyName in settingProperties)) {
          throw new exports.ValidationError('while validating security scheme', null, "OAuth 1.0 settings must have " + propertyName + " property", settings[0].start_mark);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Validator.prototype.validate_root_schemas = function(schemas) {
      var schema, schemaList, schemaName, _results;
      if (!util.isSequence(schemas)) {
        throw new exports.ValidationError('while validating schemas', null, 'schemas property must be an array', schemas.start_mark);
      }
      schemaList = this.get_all_schemas();
      _results = [];
      for (schemaName in schemaList) {
        schema = schemaList[schemaName];
        if (!(schema[1].tag && util.isString(schema[1]))) {
          throw new exports.ValidationError('while validating schemas', null, 'schema ' + schemaName + ' must be a string', schema[0].start_mark);
        }
        _results.push(this.validateSchema(schema[1]));
      }
      return _results;
    };

    Validator.prototype.validate_root = function(node) {
      if (!(node || util.isNull(node))) {
        throw new exports.ValidationError('while validating root', null, 'empty document', node != null ? node.start_mark : void 0);
      }
      if (!util.isMapping(node)) {
        throw new exports.ValidationError('while validating root', null, 'document must be a map', node.start_mark);
      }
    };

    Validator.prototype.validate_base_uri_parameters = function() {
      if (!this.baseUriParameters) {
        return;
      }
      if (!this.baseUri) {
        throw new exports.ValidationError('while validating uri parameters', null, 'uri parameters defined when there is no baseUri', this.baseUriParameters.start_mark);
      }
      if (!util.isNullableMapping(this.baseUriParameters)) {
        throw new exports.ValidationError('while validating uri parameters', null, 'base uri parameters must be a map', this.baseUriParameters.start_mark);
      }
      return this.validate_uri_parameters(this.baseUri, this.baseUriParameters, false, false, ["version"]);
    };

    Validator.prototype.validate_uri_parameters = function(uri, uriProperty, allowParameterKeys, skipParameterUseCheck, reservedNames) {
      var err, expressions, parameterName, template, uriParameter, uriParameters, _i, _len, _ref1, _ref2, _results;
      if (reservedNames == null) {
        reservedNames = [];
      }
      try {
        template = uritemplate.parse(uri);
      } catch (_error) {
        err = _error;
        throw new exports.ValidationError('while validating uri parameters', null, err != null ? (_ref1 = err.options) != null ? _ref1.message : void 0 : void 0, uriProperty.start_mark);
      }
      expressions = template.expressions.filter(function(expr) {
        return "templateText" in expr;
      }).map(function(expression) {
        return expression.templateText;
      });
      uriParameters = {};
      if (typeof uriProperty.value === "object") {
        _ref2 = uriProperty.value;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          uriParameter = _ref2[_i];
          parameterName = this.canonicalizePropertyName(uriParameter[0].value, allowParameterKeys);
          this.trackRepeatedProperties(uriParameters, parameterName, uriProperty, 'while validating URI parameters', "URI parameter with the same name already exists");
          if (__indexOf.call(reservedNames, parameterName) >= 0) {
            throw new exports.ValidationError('while validating baseUri', null, uriParameter[0].value + ' parameter not allowed here', uriParameter[0].start_mark);
          }
          if (!(util.isNullableMapping(uriParameter[1], allowParameterKeys) || util.isNullableSequence(uriParameter[1], allowParameterKeys))) {
            throw new exports.ValidationError('while validating baseUri', null, 'URI parameter must be a map', uriParameter[0].start_mark);
          }
          if (!util.isNull(uriParameter[1])) {
            this.valid_common_parameter_properties(uriParameter[1], allowParameterKeys);
          }
          if (!(skipParameterUseCheck || this.isParameterKey(uriParameter) || __indexOf.call(expressions, parameterName) >= 0)) {
            throw new exports.ValidationError('while validating baseUri', null, uriParameter[0].value + ' uri parameter unused', uriParameter[0].start_mark);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    Validator.prototype.validate_types = function(typeProperty) {
      var type, type_entry, types, _i, _len, _results;
      types = typeProperty.value;
      if (!util.isSequence(typeProperty)) {
        throw new exports.ValidationError('while validating resource types', null, 'invalid resourceTypes definition, it must be an array', typeProperty.start_mark);
      }
      _results = [];
      for (_i = 0, _len = types.length; _i < _len; _i++) {
        type_entry = types[_i];
        if (!util.isMapping(type_entry)) {
          throw new exports.ValidationError('while validating resource types', null, 'invalid resourceType definition, it must be a map', type_entry.start_mark);
        }
        _results.push((function() {
          var _j, _len1, _ref1, _results1;
          _ref1 = type_entry.value;
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            type = _ref1[_j];
            if (this.isParameterKey(type)) {
              throw new exports.ValidationError('while validating resource types', null, 'parameter key cannot be used as a resource type name', type[0].start_mark);
            }
            if (!util.isMapping(type[1])) {
              throw new exports.ValidationError('while validating resource types', null, 'invalid resourceType definition, it must be a map', type[1].start_mark);
            }
            _results1.push(this.validate_resource(type, true, 'resource type'));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Validator.prototype.validate_traits = function(traitProperty) {
      var trait, trait_entry, _i, _len, _results;
      traits = traitProperty.value;
      if (!Array.isArray(traits)) {
        throw new exports.ValidationError('while validating traits', null, 'invalid traits definition, it must be an array', traitProperty.start_mark);
      }
      _results = [];
      for (_i = 0, _len = traits.length; _i < _len; _i++) {
        trait_entry = traits[_i];
        if (!Array.isArray(trait_entry.value)) {
          throw new exports.ValidationError('while validating traits', null, 'invalid traits definition, it must be an array', traitProperty.start_mark);
        }
        _results.push((function() {
          var _j, _len1, _ref1, _results1;
          _ref1 = trait_entry.value;
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            trait = _ref1[_j];
            if (this.isParameterKey(trait)) {
              throw new exports.ValidationError('while validating traits', null, 'parameter key cannot be used as a trait name', trait[0].start_mark);
            }
            if (!util.isMapping(trait[1])) {
              throw new exports.ValidationError('while validating traits', null, 'invalid trait definition, it must be a map', trait[1].start_mark);
            }
            _results1.push(this.valid_traits_properties(trait));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Validator.prototype.valid_traits_properties = function(node) {
      var invalid;
      if (!node[1].value) {
        return;
      }
      if (!util.isMapping(node[1])) {
        return;
      }
      invalid = node[1].value.filter(function(childNode) {
        return childNode[0].value === "is" || childNode[0].value === "type";
      });
      if (invalid.length > 0) {
        throw new exports.ValidationError('while validating trait properties', null, "property: '" + invalid[0][0].value + "' is invalid in a trait", invalid[0][0].start_mark);
      }
      return this.validate_method(node, true, 'trait');
    };

    Validator.prototype.canonicalizePropertyName = function(propertyName, mustRemoveQuestionMark) {
      if (mustRemoveQuestionMark && propertyName.slice(-1) === '?') {
        return propertyName.slice(0, -1);
      }
      return propertyName;
    };

    Validator.prototype.valid_common_parameter_properties = function(node, allowParameterKeys) {
      var parameter, _i, _len, _ref1, _results;
      if (!node.value) {
        return;
      }
      if (util.isSequence(node)) {
        if (node.value.length === 0) {
          throw new exports.ValidationError('while validating parameter properties', null, 'named parameter needs at least one type', node.start_mark);
        }
        if (!(node.value.length > 1)) {
          throw new exports.ValidationError('while validating parameter properties', null, 'single type for variably typed parameter', node.start_mark);
        }
        _ref1 = node.value;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          parameter = _ref1[_i];
          _results.push(this.validate_named_parameter(parameter, allowParameterKeys));
        }
        return _results;
      } else {
        return this.validate_named_parameter(node, allowParameterKeys);
      }
    };

    Validator.prototype.validate_named_parameter = function(node, allowParameterKeys) {
      var booleanValues, canonicalPropertyName, childNode, enumValues, parameterProperties, parameterType, propertyName, propertyValue, unusableProperty, valid, validTypes, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3, _results;
      parameterProperties = {};
      parameterType = "string";
      _ref1 = node.value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        childNode = _ref1[_i];
        propertyName = childNode[0].value;
        propertyValue = childNode[1].value;
        this.trackRepeatedProperties(parameterProperties, this.canonicalizePropertyName(childNode[0].value, true), childNode[0], 'while validating parameter properties', "parameter property already used");
        booleanValues = ["true", "false"];
        if (allowParameterKeys) {
          if (this.isParameterKey(childNode) || this.isParameterValue(childNode)) {
            continue;
          }
        }
        canonicalPropertyName = this.canonicalizePropertyName(propertyName, allowParameterKeys);
        valid = true;
        switch (propertyName) {
          case "displayName":
            if (!util.isScalar(childNode[1])) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of displayName must be a scalar', childNode[1].start_mark);
            }
            break;
          case "pattern":
            if (!util.isScalar(childNode[1])) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of pattern must be a scalar', childNode[1].start_mark);
            }
            break;
          case "default":
            if (!util.isScalar(childNode[1])) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of default must be a scalar', childNode[1].start_mark);
            }
            break;
          case "description":
            if (!util.isScalar(childNode[1])) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of description must be a scalar', childNode[1].start_mark);
            }
            break;
          case "example":
            if (!util.isScalar(childNode[1])) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of example must be a scalar', childNode[1].start_mark);
            }
            break;
          case "minLength":
            if (isNaN(propertyValue)) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of minLength must be a number', childNode[1].start_mark);
            }
            break;
          case "maxLength":
            if (isNaN(propertyValue)) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of maxLength must be a number', childNode[1].start_mark);
            }
            break;
          case "minimum":
            if (isNaN(propertyValue)) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of minimum must be a number', childNode[1].start_mark);
            }
            break;
          case "maximum":
            if (isNaN(propertyValue)) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of maximum must be a number', childNode[1].start_mark);
            }
            break;
          case "type":
            parameterType = propertyValue;
            validTypes = ['string', 'number', 'integer', 'date', 'boolean', 'file'];
            if (__indexOf.call(validTypes, propertyValue) < 0) {
              throw new exports.ValidationError('while validating parameter properties', null, 'type can be either of: string, number, integer, file, date or boolean ', childNode[1].start_mark);
            }
            break;
          case "required":
            if (__indexOf.call(booleanValues, propertyValue) < 0) {
              throw new exports.ValidationError('while validating parameter properties', null, 'required can be any either true or false', childNode[1].start_mark);
            }
            break;
          case "repeat":
            if (__indexOf.call(booleanValues, propertyValue) < 0) {
              throw new exports.ValidationError('while validating parameter properties', null, 'repeat can be any either true or false', childNode[1].start_mark);
            }
            break;
          default:
            valid = false;
        }
        switch (canonicalPropertyName) {
          case "enum":
            if (!util.isNullableSequence(childNode[1])) {
              throw new exports.ValidationError('while validating parameter properties', null, 'the value of enum must be an array', childNode[1].start_mark);
            }
            if (!childNode[1].value.length) {
              throw new exports.ValidationError('while validating parameter properties', null, 'enum is empty', childNode[1].start_mark);
            }
            enumValues = this.get_list_values(childNode[1].value);
            if (this.hasDuplicates(enumValues)) {
              throw new exports.ValidationError('while validating parameter properties', null, 'enum contains duplicated values', childNode[1].start_mark);
            }
            break;
          default:
            if (!valid) {
              throw new exports.ValidationError('while validating parameter properties', null, "unknown property " + propertyName, childNode[0].start_mark);
            }
        }
      }
      if (parameterType !== "string") {
        _ref2 = ['enum', 'pattern', 'minLength', 'maxLength'];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          unusableProperty = _ref2[_j];
          if (unusableProperty in parameterProperties) {
            throw new exports.ValidationError('while validating parameter properties', null, "property " + unusableProperty + " can only be used if type is 'string'", parameterProperties[unusableProperty].start_mark);
          }
        }
      }
      if (!(parameterType === "number" || parameterType === "integer")) {
        _ref3 = ['minimum', 'maximum'];
        _results = [];
        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
          unusableProperty = _ref3[_k];
          if (unusableProperty in parameterProperties) {
            throw new exports.ValidationError('while validating parameter properties', null, "property " + unusableProperty + " can only be used if type is 'number' or 'integer'", parameterProperties[unusableProperty].start_mark);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    Validator.prototype.get_list_values = function(node) {
      var _this = this;
      return node.map(function(item) {
        return item.value;
      });
    };

    Validator.prototype.validate_root_properties = function(node) {
      var checkVersion, property, rootProperties, _i, _len, _ref1;
      checkVersion = false;
      rootProperties = {};
      if (node != null ? node.value : void 0) {
        _ref1 = node.value;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          property = _ref1[_i];
          if (property[0].value.match(/^\//)) {
            this.trackRepeatedProperties(rootProperties, this.canonicalizePropertyName(property[0].value, true), property[0], 'while validating root properties', "resource already declared");
          } else {
            this.trackRepeatedProperties(rootProperties, property[0].value, property[0], 'while validating root properties', 'root property already used');
          }
          switch (property[0].value) {
            case 'title':
              if (!util.isScalar(property[1])) {
                throw new exports.ValidationError('while validating root properties', null, 'title must be a string', property[0].start_mark);
              }
              break;
            case 'baseUri':
              if (!util.isScalar(property[1])) {
                throw new exports.ValidationError('while validating root properties', null, 'baseUri must be a string', property[0].start_mark);
              }
              this.baseUri = property[1].value;
              checkVersion = this.validate_base_uri(property[1]);
              break;
            case 'securitySchemes':
              this.validate_security_schemes(property[1]);
              break;
            case 'schemas':
              this.validate_root_schemas(property[1]);
              break;
            case 'version':
              if (!util.isScalar(property[1])) {
                throw new exports.ValidationError('while validating root properties', null, 'version must be a string', property[0].start_mark);
              }
              if (!util.isNull(property[1])) {
                property[1].tag = 'tag:yaml.org,2002:str';
              }
              break;
            case 'traits':
              this.validate_traits(property[1]);
              break;
            case 'documentation':
              if (!util.isSequence(property[1])) {
                throw new exports.ValidationError('while validating root properties', null, 'documentation must be an array', property[0].start_mark);
              }
              this.validate_documentation(property[1]);
              break;
            case 'mediaType':
              if (!util.isString(property[1])) {
                throw new exports.ValidationError('while validating root properties', null, 'mediaType must be a scalar', property[0].start_mark);
              }
              break;
            case 'baseUriParameters':
              this.baseUriParameters = property[1];
              util.isNoop(property[1]);
              break;
            case 'resourceTypes':
              this.validate_types(property[1]);
              break;
            case 'securedBy':
              this.validate_secured_by(property);
              break;
            case 'protocols':
              this.validate_protocols_property(property);
              break;
            default:
              if (property[0].value.match(/^\//)) {
                this.validate_resource(property);
              } else {
                throw new exports.ValidationError('while validating root properties', null, "unknown property " + property[0].value, property[0].start_mark);
              }
          }
        }
      }
      if (!('title' in rootProperties)) {
        throw new exports.ValidationError('while validating root properties', null, 'missing title', node.start_mark);
      }
      if (checkVersion && !('version' in rootProperties)) {
        throw new exports.ValidationError('while validating version', null, 'missing version', node.start_mark);
      }
    };

    Validator.prototype.validate_documentation = function(documentation_property) {
      var docSection, _i, _len, _ref1, _results;
      if (!documentation_property.value.length) {
        throw new exports.ValidationError('while validating documentation section', null, 'there must be at least one document in the documentation section', documentation_property.start_mark);
      }
      _ref1 = documentation_property.value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        docSection = _ref1[_i];
        _results.push(this.validate_doc_section(docSection));
      }
      return _results;
    };

    Validator.prototype.validate_doc_section = function(docSection) {
      var docProperties, property, _i, _len, _ref1;
      if (!util.isMapping(docSection)) {
        throw new exports.ValidationError('while validating documentation section', null, 'each documentation section must be a map', docSection.start_mark);
      }
      docProperties = {};
      _ref1 = docSection.value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        property = _ref1[_i];
        this.trackRepeatedProperties(docProperties, property[0].value, property[0], 'while validating documentation section', "property already used");
        switch (property[0].value) {
          case "title":
            if (!(util.isScalar(property[1]) && !util.isNull(property[1]))) {
              throw new exports.ValidationError('while validating documentation section', null, 'title must be a string', property[0].start_mark);
            }
            break;
          case "content":
            if (!(util.isScalar(property[1]) && !util.isNull(property[1]))) {
              throw new exports.ValidationError('while validating documentation section', null, 'content must be a string', property[0].start_mark);
            }
            break;
          default:
            throw new exports.ValidationError('while validating root properties', null, 'unknown property ' + property[0].value, property[0].start_mark);
        }
      }
      if (!("content" in docProperties)) {
        throw new exports.ValidationError('while validating documentation section', null, 'a documentation entry must have content property', docSection.start_mark);
      }
      if (!("title" in docProperties)) {
        throw new exports.ValidationError('while validating documentation section', null, 'a documentation entry must have title property', docSection.start_mark);
      }
    };

    Validator.prototype.child_resources = function(node) {
      if (node && util.isMapping(node)) {
        return node.value.filter(function(childNode) {
          return childNode[0].value.match(/^\//);
        });
      }
      return [];
    };

    Validator.prototype.validate_resource = function(resource, allowParameterKeys, context) {
      var canonicalKey, err, key, property, resourceProperties, template, valid, _i, _len, _ref1, _ref2, _results;
      if (allowParameterKeys == null) {
        allowParameterKeys = false;
      }
      if (context == null) {
        context = "resource";
      }
      if (!(resource[1] && util.isNullableMapping(resource[1]))) {
        throw new exports.ValidationError('while validating resources', null, 'resource is not a map', resource[1].start_mark);
      }
      if (resource[0].value) {
        try {
          template = uritemplate.parse(resource[0].value);
        } catch (_error) {
          err = _error;
          throw new exports.ValidationError('while validating resource', null, "Resource name is invalid: " + (err != null ? (_ref1 = err.options) != null ? _ref1.message : void 0 : void 0), resource[0].start_mark);
        }
      }
      if (util.isNull(resource[1])) {
        return;
      }
      if (resource[1].value) {
        resourceProperties = {};
        _ref2 = resource[1].value;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          property = _ref2[_i];
          if (property[0].value.match(/^\//)) {
            this.trackRepeatedProperties(resourceProperties, this.canonicalizePropertyName(property[0].value, true), property[0], 'while validating resource', "resource already declared");
          } else if (this.isHttpMethod(property[0].value, allowParameterKeys)) {
            this.trackRepeatedProperties(resourceProperties, this.canonicalizePropertyName(property[0].value, true), property[0], 'while validating resource', "method already declared");
          } else {
            this.trackRepeatedProperties(resourceProperties, this.canonicalizePropertyName(property[0].value, true), property[0], 'while validating resource', "property already used");
          }
          if (!this.validate_common_properties(property, allowParameterKeys)) {
            if (property[0].value.match(/^\//)) {
              if (allowParameterKeys) {
                throw new exports.ValidationError('while validating trait properties', null, 'resource type cannot define child resources', property[0].start_mark);
              }
              _results.push(this.validate_resource(property, allowParameterKeys));
            } else if (this.isHttpMethod(property[0].value, allowParameterKeys)) {
              _results.push(this.validate_method(property, allowParameterKeys, 'method'));
            } else {
              key = property[0].value;
              canonicalKey = this.canonicalizePropertyName(key, allowParameterKeys);
              valid = true;
              switch (canonicalKey) {
                case "uriParameters":
                  if (!util.isNullableMapping(property[1])) {
                    throw new exports.ValidationError('while validating uri parameters', null, 'uri parameters must be a map', property[0].start_mark);
                  }
                  this.validate_uri_parameters(resource[0].value, property[1], allowParameterKeys, allowParameterKeys);
                  break;
                case "baseUriParameters":
                  if (!this.baseUri) {
                    throw new exports.ValidationError('while validating uri parameters', null, 'base uri parameters defined when there is no baseUri', property[0].start_mark);
                  }
                  if (!util.isNullableMapping(property[1])) {
                    throw new exports.ValidationError('while validating uri parameters', null, 'base uri parameters must be a map', property[0].start_mark);
                  }
                  this.validate_uri_parameters(this.baseUri, property[1], allowParameterKeys);
                  break;
                default:
                  valid = false;
              }
              switch (key) {
                case "type":
                  _results.push(this.validate_type_property(property, allowParameterKeys));
                  break;
                case "usage":
                  if (!allowParameterKeys) {
                    throw new exports.ValidationError('while validating resources', null, "property: '" + property[0].value + "' is invalid in a resource", property[0].start_mark);
                  } else {
                    _results.push(void 0);
                  }
                  break;
                case "securedBy":
                  _results.push(this.validate_secured_by(property));
                  break;
                default:
                  if (!valid) {
                    throw new exports.ValidationError('while validating resources', null, "property: '" + property[0].value + ("' is invalid in a " + context), property[0].start_mark);
                  } else {
                    _results.push(void 0);
                  }
              }
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    Validator.prototype.validate_secured_by = function(property) {
      var secScheme, secSchemes, securitySchemeName, _i, _len, _ref1, _results;
      if (!util.isSequence(property[1])) {
        throw new exports.ValidationError('while validating securityScheme', null, "property 'securedBy' must be an array", property[0].start_mark);
      }
      secSchemes = this.get_list_values(property[1].value);
      if (this.hasDuplicates(secSchemes)) {
        throw new exports.ValidationError('while validating securityScheme consumption', null, 'securitySchemes can only be referenced once in a securedBy property', property[0].start_mark);
      }
      _ref1 = property[1].value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        secScheme = _ref1[_i];
        if (util.isSequence(secScheme)) {
          throw new exports.ValidationError('while validating securityScheme consumption', null, 'securityScheme reference cannot be an array', secScheme.start_mark);
        }
        if (!util.isNull(secScheme)) {
          securitySchemeName = this.key_or_value(secScheme);
          if (!this.get_security_scheme(securitySchemeName)) {
            throw new exports.ValidationError('while validating securityScheme consumption', null, 'there is no securityScheme named ' + securitySchemeName, secScheme.start_mark);
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Validator.prototype.validate_protocols_property = function(property) {
      var protocol, _i, _len, _ref1, _ref2, _results;
      if (!util.isSequence(property[1])) {
        throw new exports.ValidationError('while validating protocols', null, 'property must be an array', property[0].start_mark);
      }
      _ref1 = property[1].value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        protocol = _ref1[_i];
        if (!util.isString(protocol)) {
          throw new exports.ValidationError('while validating protocols', null, 'value must be a string', protocol.start_mark);
        }
        if ((_ref2 = protocol.value) !== 'HTTP' && _ref2 !== 'HTTPS') {
          throw new exports.ValidationError('while validating protocols', null, 'only HTTP and HTTPS values are allowed', protocol.start_mark);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Validator.prototype.validate_type_property = function(property) {
      var parameter, typeName, _i, _len, _ref1, _results;
      if (!(util.isMapping(property[1]) || util.isString(property[1]))) {
        throw new exports.ValidationError('while validating resource types', null, "property 'type' must be a string or a map", property[0].start_mark);
      }
      if (util.isMapping(property[1])) {
        if (property[1].value.length > 1) {
          throw new exports.ValidationError('while validating resource types', null, 'a resource or resourceType can inherit from a single resourceType', property[0].start_mark);
        }
      }
      typeName = this.key_or_value(property[1]);
      if (!(typeName != null ? typeName.trim() : void 0)) {
        throw new exports.ValidationError('while validating resource type consumption', null, 'resource type name must be provided', property[1].start_mark);
      }
      if (!(this.isParameterKeyValue(typeName) || this.get_type(typeName))) {
        throw new exports.ValidationError('while validating resource type consumption', null, "there is no resource type named " + typeName, property[1].start_mark);
      }
      if (util.isMapping(property[1])) {
        _ref1 = property[1].value;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          parameter = _ref1[_i];
          if (!(util.isNull(parameter[1]) || util.isMapping(parameter[1]))) {
            throw new exports.ValidationError('while validating resource consumption', null, 'resource type parameters must be in a map', parameter[1].start_mark);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    Validator.prototype.validate_method = function(method, allowParameterKeys, context) {
      var canonicalKey, key, methodProperties, property, valid, _i, _len, _ref1, _results;
      if (context == null) {
        context = 'method';
      }
      if (util.isNull(method[1])) {
        return;
      }
      if (!util.isMapping(method[1])) {
        throw new exports.ValidationError('while validating methods', null, "method must be a map", method[0].start_mark);
      }
      methodProperties = {};
      _ref1 = method[1].value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        property = _ref1[_i];
        this.trackRepeatedProperties(methodProperties, this.canonicalizePropertyName(property[0].value, true), property[0], 'while validating method', "property already used");
        if (this.validate_common_properties(property, allowParameterKeys, context)) {
          continue;
        }
        key = property[0].value;
        canonicalKey = this.canonicalizePropertyName(key, allowParameterKeys);
        valid = true;
        switch (canonicalKey) {
          case 'headers':
            this.validate_headers(property, allowParameterKeys);
            break;
          case 'queryParameters':
            this.validate_query_params(property, allowParameterKeys);
            break;
          case 'body':
            this.validate_body(property, allowParameterKeys, null, false);
            break;
          case 'responses':
            this.validate_responses(property, allowParameterKeys);
            break;
          case 'baseUriParameters':
            if (!this.baseUri) {
              throw new exports.ValidationError('while validating uri parameters', null, 'base uri parameters defined when there is no baseUri', property[0].start_mark);
            }
            if (!util.isNullableMapping(property[1])) {
              throw new exports.ValidationError('while validating uri parameters', null, 'base uri parameters must be a map', property[0].start_mark);
            }
            this.validate_uri_parameters(this.baseUri, property[1], allowParameterKeys);
            break;
          case 'protocols':
            this.validate_protocols_property(property);
            break;
          default:
            valid = false;
        }
        switch (key) {
          case 'securedBy':
            _results.push(this.validate_secured_by(property));
            break;
          case 'usage':
            if (!(allowParameterKeys && context === 'trait')) {
              throw new exports.ValidationError('while validating resources', null, "property: 'usage' is invalid in a " + context, property[0].start_mark);
            } else {
              _results.push(void 0);
            }
            break;
          default:
            if (!valid) {
              throw new exports.ValidationError('while validating resources', null, "property: '" + property[0].value + "' is invalid in a " + context, property[0].start_mark);
            } else {
              _results.push(void 0);
            }
        }
      }
      return _results;
    };

    Validator.prototype.validate_responses = function(responses, allowParameterKeys) {
      var response, responseValues, _i, _len, _ref1, _results;
      if (util.isNull(responses[1])) {
        return;
      }
      if (!util.isMapping(responses[1])) {
        throw new exports.ValidationError('while validating responses', null, "property: 'responses' must be a map", responses[0].start_mark);
      }
      responseValues = {};
      _ref1 = responses[1].value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        response = _ref1[_i];
        if (!util.isNullableMapping(response[1])) {
          throw new exports.ValidationError('while validating responses', null, 'each response must be a map', response[1].start_mark);
        }
        this.trackRepeatedProperties(responseValues, this.canonicalizePropertyName(response[0].value, true), response[0], 'while validating responses', "response code already used");
        _results.push(this.validate_response(response, allowParameterKeys));
      }
      return _results;
    };

    Validator.prototype.validate_query_params = function(property, allowParameterKeys) {
      var param, queryParameters, _i, _len, _ref1, _results;
      if (util.isNull(property[1])) {
        return;
      }
      if (!util.isMapping(property[1])) {
        throw new exports.ValidationError('while validating query parameters', null, "property: 'queryParameters' must be a map", property[0].start_mark);
      }
      queryParameters = {};
      _ref1 = property[1].value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        param = _ref1[_i];
        if (!(util.isNullableMapping(param[1]) || util.isNullableSequence(param[1]))) {
          throw new exports.ValidationError('while validating query parameters', null, "each query parameter must be a map", param[1].start_mark);
        }
        this.trackRepeatedProperties(queryParameters, this.canonicalizePropertyName(param[0].value, true), param[0], 'while validating query parameter', "parameter name already used");
        _results.push(this.valid_common_parameter_properties(param[1], allowParameterKeys));
      }
      return _results;
    };

    Validator.prototype.validate_form_params = function(property, allowParameterKeys) {
      var formParameters, param, _i, _len, _ref1, _results;
      if (util.isNull(property[1])) {
        return;
      }
      if (!util.isMapping(property[1])) {
        throw new exports.ValidationError('while validating query parameters', null, "property: 'formParameters' must be a map", property[0].start_mark);
      }
      formParameters = {};
      _ref1 = property[1].value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        param = _ref1[_i];
        if (!(util.isNullableMapping(param[1]) || util.isNullableSequence(param[1]))) {
          throw new exports.ValidationError('while validating query parameters', null, 'each form parameter must be a map', param[1].start_mark);
        }
        this.trackRepeatedProperties(formParameters, this.canonicalizePropertyName(param[0].value, true), param[0], 'while validating form parameter', "parameter name already used");
        _results.push(this.valid_common_parameter_properties(param[1], allowParameterKeys));
      }
      return _results;
    };

    Validator.prototype.validate_headers = function(property, allowParameterKeys) {
      var headerNames, param, _i, _len, _ref1, _results;
      if (util.isNull(property[1])) {
        return;
      }
      if (!util.isMapping(property[1])) {
        throw new exports.ValidationError('while validating headers', null, "property: 'headers' must be a map", property[0].start_mark);
      }
      headerNames = {};
      _ref1 = property[1].value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        param = _ref1[_i];
        if (!(util.isNullableMapping(param[1]) || util.isNullableSequence(param[1]))) {
          throw new exports.ValidationError('while validating query parameters', null, "each header must be a map", param[1].start_mark);
        }
        this.trackRepeatedProperties(headerNames, this.canonicalizePropertyName(param[0].value, true), param[0], 'while validating headers', "header name already used");
        _results.push(this.valid_common_parameter_properties(param[1], allowParameterKeys));
      }
      return _results;
    };

    Validator.prototype.validate_response = function(response, allowParameterKeys) {
      var canonicalKey, property, responseCode, responseProperties, valid, _i, _j, _len, _len1, _ref1, _ref2, _results;
      if (util.isSequence(response[0])) {
        if (!response[0].value.length) {
          throw new exports.ValidationError('while validating responses', null, 'there must be at least one response code', response[0].start_mark);
        }
        _ref1 = response[0].value;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          responseCode = _ref1[_i];
          if (!(this.isParameterKey(responseCode) || util.isInteger(responseCode) || !isNaN(this.canonicalizePropertyName(responseCode, allowParameterKeys)))) {
            throw new exports.ValidationError('while validating responses', null, "each response key must be an integer", responseCode.start_mark);
          }
        }
      } else if (!(this.isParameterKey(response) || util.isInteger(response[0]) || !isNaN(this.canonicalizePropertyName(response[0].value, allowParameterKeys)))) {
        throw new exports.ValidationError('while validating responses', null, "each response key must be an integer", response[0].start_mark);
      }
      if (!util.isNullableMapping(response[1])) {
        throw new exports.ValidationError('while validating responses', null, "each response property must be a map", response[0].start_mark);
      }
      if (util.isMapping(response[1])) {
        responseProperties = {};
        _ref2 = response[1].value;
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          property = _ref2[_j];
          canonicalKey = this.canonicalizePropertyName(property[0].value, allowParameterKeys);
          this.trackRepeatedProperties(responseProperties, canonicalKey, property[0], 'while validating responses', "property already used");
          valid = true;
          if (!this.isParameterKey(property)) {
            switch (property[0].value) {
              case "description":
                if (!util.isScalar(property[1])) {
                  throw new exports.ValidationError('while validating responses', null, 'property description must be a string', response[0].start_mark);
                }
                break;
              default:
                valid = false;
            }
            switch (canonicalKey) {
              case "body":
                _results.push(this.validate_body(property, allowParameterKeys, null, true));
                break;
              case "headers":
                if (!util.isNullableMapping(property[1])) {
                  throw new exports.ValidationError('while validating resources', null, "property 'headers' must be a map", property[0].start_mark);
                }
                _results.push(this.validate_headers(property));
                break;
              default:
                if (!valid) {
                  throw new exports.ValidationError('while validating response', null, "property: '" + property[0].value + "' is invalid in a response", property[0].start_mark);
                } else {
                  _results.push(void 0);
                }
            }
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    Validator.prototype.isHttpMethod = function(value, allowParameterKeys) {
      var _ref1;
      if (allowParameterKeys == null) {
        allowParameterKeys = false;
      }
      if (value) {
        value = this.canonicalizePropertyName(value, allowParameterKeys);
        return (_ref1 = value.toLowerCase()) === 'options' || _ref1 === 'get' || _ref1 === 'head' || _ref1 === 'post' || _ref1 === 'put' || _ref1 === 'delete' || _ref1 === 'trace' || _ref1 === 'connect' || _ref1 === 'patch';
      }
      return false;
    };

    Validator.prototype.isParameterValue = function(property) {
      return this.isParameterKey(property, false);
    };

    Validator.prototype.isParameterKey = function(property, checkKey) {
      var offset;
      if (checkKey == null) {
        checkKey = true;
      }
      offset = checkKey ? 0 : 1;
      if (!(checkKey || util.isScalar(property[1]))) {
        return false;
      }
      if (this.isParameterKeyValue(property[offset].value)) {
        return true;
      } else if (property[offset].value.match(/<<\s*([^\|\s>]+)\s*\|.*\s*>>/g)) {
        throw new exports.ValidationError('while validating parameter', null, "unknown function applied to property name", property[0].start_mark);
      }
      return false;
    };

    Validator.prototype.isParameterKeyValue = function(value) {
      if (value.match(/<<\s*([^\|\s>]+)\s*>>/g) || value.match(/<<\s*([^\|\s>]+)\s*(\|\s*\!\s*(singularize|pluralize))?\s*>>/g)) {
        return true;
      }
      return false;
    };

    Validator.prototype.validate_body = function(property, allowParameterKeys, bodyMode, isResponseBody) {
      var bodyProperties, bodyProperty, canonicalProperty, implicitMode, key, start_mark, valid, _i, _len, _ref1;
      if (bodyMode == null) {
        bodyMode = null;
      }
      if (util.isNull(property[1])) {
        return;
      }
      if (!util.isMapping(property[1])) {
        throw new exports.ValidationError('while validating body', null, "property: body specification must be a map", property[0].start_mark);
      }
      implicitMode = ["implicit", "forcedImplicit"];
      bodyProperties = {};
      _ref1 = property[1].value;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        bodyProperty = _ref1[_i];
        this.trackRepeatedProperties(bodyProperties, this.canonicalizePropertyName(bodyProperty[0].value, true), bodyProperty[0], 'while validating body', "property already used");
        if (this.isParameterKey(bodyProperty)) {
          if (!allowParameterKeys) {
            throw new exports.ValidationError('while validating body', null, "property '" + bodyProperty[0].value + "' is invalid in a resource", bodyProperty[0].start_mark);
          }
        } else if (bodyProperty[0].value.match(/^[^\/]+\/[^\/]+$/)) {
          if (bodyMode && bodyMode !== "explicit") {
            throw new exports.ValidationError('while validating body', null, "not compatible with implicit default Media Type", bodyProperty[0].start_mark);
          }
          bodyMode = "explicit";
          this.validate_body(bodyProperty, allowParameterKeys, "forcedImplicit", isResponseBody);
        } else {
          key = bodyProperty[0].value;
          canonicalProperty = this.canonicalizePropertyName(key, allowParameterKeys);
          valid = true;
          switch (canonicalProperty) {
            case "formParameters":
              if (bodyMode && __indexOf.call(implicitMode, bodyMode) < 0) {
                throw new exports.ValidationError('while validating body', null, "not compatible with explicit Media Type", bodyProperty[0].start_mark);
              }
              if (bodyMode == null) {
                bodyMode = "implicit";
              }
              this.validate_form_params(bodyProperty, allowParameterKeys);
              break;
            default:
              valid = false;
          }
          switch (key) {
            case "example":
              if (bodyMode && __indexOf.call(implicitMode, bodyMode) < 0) {
                throw new exports.ValidationError('while validating body', null, "not compatible with explicit Media Type", bodyProperty[0].start_mark);
              }
              if (bodyMode == null) {
                bodyMode = "implicit";
              }
              if (!util.isScalar(bodyProperty[1])) {
                throw new exports.ValidationError('while validating body', null, "example must be a string", bodyProperty[0].start_mark);
              }
              break;
            case "schema":
              if (bodyMode && __indexOf.call(implicitMode, bodyMode) < 0) {
                throw new exports.ValidationError('while validating body', null, "not compatible with explicit Media Type", bodyProperty[0].start_mark);
              }
              if (bodyMode == null) {
                bodyMode = "implicit";
              }
              if (!util.isScalar(bodyProperty[1])) {
                throw new exports.ValidationError('while validating body', null, "schema must be a string", bodyProperty[0].start_mark);
              }
              this.validateSchema(bodyProperty[1]);
              break;
            default:
              if (!valid) {
                throw new exports.ValidationError('while validating body', null, "property: '" + bodyProperty[0].value + "' is invalid in a body", bodyProperty[0].start_mark);
              }
          }
        }
      }
      if ("formParameters" in bodyProperties) {
        start_mark = bodyProperties.formParameters.start_mark;
        if (isResponseBody) {
          throw new exports.ValidationError('while validating body', null, "formParameters cannot be used to describe response bodies", start_mark);
        }
        if ("schema" in bodyProperties || "example" in bodyProperties) {
          throw new exports.ValidationError('while validating body', null, "formParameters cannot be used together with the example or schema properties", start_mark);
        }
      }
      if (bodyMode === "implicit") {
        if (!this.get_media_type()) {
          throw new exports.ValidationError('while validating body', null, "body tries to use default Media Type, but mediaType is null", property[0].start_mark);
        }
      }
    };

    Validator.prototype.validateSchema = function(property) {
      var error, lint, mark, schema;
      if (this.isXmlSchema(property.value)) {
        return void 0;
      } else if (this.isJsonSchema(property.value)) {
        lint = jsonlint(property.value);
        if (lint.error) {
          mark = this.create_mark(property.start_mark.line + lint.line, 0);
          if (property.end_mark.line === mark.line && property.end_mark.column === 0) {
            mark.line--;
          }
          throw new exports.ValidationError('while validating body', null, "schema is not valid JSON error: '" + lint.error + "'", mark);
        }
        try {
          return schema = JSON.parse(property.value);
        } catch (_error) {
          error = _error;
          throw new exports.ValidationError('while validating body', null, "schema is not valid JSON error: '" + error + "'", property.start_mark);
        }
      }
    };

    Validator.prototype.isJsonSchema = function(string) {
      return string != null ? string.match(/^\s*\{/) : void 0;
    };

    Validator.prototype.isXmlSchema = function(string) {
      return string != null ? string.match(/^\s*(<\?xml[^>]+>)?[\s\n]*<xs:schema/) : void 0;
    };

    Validator.prototype.validate_common_properties = function(property, allowParameterKeys, context) {
      var use, _i, _len, _ref1;
      if (this.isParameterKey(property)) {
        if (!allowParameterKeys) {
          throw new exports.ValidationError('while validating resources', null, "property '" + property[0].value + "' is invalid in a resource", property[0].start_mark);
        }
        return true;
      } else {
        switch (property[0].value) {
          case "displayName":
            if (context === 'method') {
              return false;
            }
            if (!util.isScalar(property[1])) {
              throw new exports.ValidationError('while validating resources', null, "property 'displayName' must be a string", property[0].start_mark);
            }
            return true;
          case "description":
            if (!util.isScalar(property[1])) {
              throw new exports.ValidationError('while validating resources', null, "property 'description' must be a string", property[0].start_mark);
            }
            return true;
          case "is":
            if (!util.isSequence(property[1])) {
              throw new exports.ValidationError('while validating resources', null, "property 'is' must be an array", property[0].start_mark);
            }
            _ref1 = property[1].value;
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              use = _ref1[_i];
              this.validate_trait_use(use);
            }
            return true;
        }
      }
      return false;
    };

    Validator.prototype.validate_trait_use = function(node) {
      var parameter, traitName, traitValue, _i, _len, _ref1, _results;
      if (!(util.isScalar(node) || util.isMapping(node))) {
        throw new exports.ValidationError('while validating trait consumption', null, 'trait must be a string or a map', node.start_mark);
      }
      traitName = this.key_or_value(node);
      if (!(traitName != null ? traitName.trim() : void 0)) {
        throw new exports.ValidationError('while validating trait consumption', null, 'trait name must be provided', node.start_mark);
      }
      if (!(this.isParameterKeyValue(traitName) || this.get_trait(traitName))) {
        throw new exports.ValidationError('while validating trait consumption', null, "there is no trait named " + traitName, node.start_mark);
      }
      if (util.isScalar(node)) {
        return;
      }
      traitValue = node.value[0][1];
      if (!(util.isNull(traitValue) || util.isMapping(traitValue))) {
        throw new exports.ValidationError('while validating trait consumption', null, 'trait must be a map', traitValue.start_mark);
      }
      if (util.isNull(traitValue)) {
        return;
      }
      _ref1 = traitValue.value;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        parameter = _ref1[_i];
        if (!util.isScalar(parameter[1])) {
          throw new exports.ValidationError('while validating trait consumption', null, 'parameter value must be a scalar', parameter[1].start_mark);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Validator.prototype.child_methods = function(node) {
      var _this = this;
      if (!(node && util.isMapping(node))) {
        return [];
      }
      return node.value.filter(function(childNode) {
        return _this.isHttpMethod(childNode[0].value);
      });
    };

    Validator.prototype.has_property = function(node, property) {
      if (node && util.isMapping(node)) {
        return node.value.some(function(childNode) {
          return childNode[0].value && typeof childNode[0].value !== "object" && childNode[0].value === property;
        });
      }
      return false;
    };

    Validator.prototype.property_value = function(node, property) {
      var filteredNodes;
      filteredNodes = node.value.filter(function(childNode) {
        return typeof childNode[0].value !== "object" && childNode[0].value === property;
      });
      if (filteredNodes.length) {
        return filteredNodes[0][1].value;
      }
    };

    Validator.prototype.get_property = function(node, property) {
      var filteredNodes,
        _this = this;
      if (node && util.isMapping(node)) {
        filteredNodes = node.value.filter(function(childNode) {
          return util.isString(childNode[0]) && childNode[0].value === property;
        });
        if (filteredNodes.length > 0) {
          if (filteredNodes[0].length > 0) {
            return filteredNodes[0][1];
          }
        }
      }
      return [];
    };

    Validator.prototype.get_properties = function(node, property) {
      var prop, properties, _i, _len, _ref1;
      properties = [];
      if (node && util.isMapping(node)) {
        _ref1 = node.value;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          prop = _ref1[_i];
          if (util.isString(prop[0]) && prop[0].value === property) {
            properties.push(prop);
          } else {
            properties = properties.concat(this.get_properties(prop[1], property));
          }
        }
      }
      return properties;
    };

    Validator.prototype.valid_absolute_uris = function(node) {
      var repeatedUri, uris;
      uris = this.get_absolute_uris(node);
      if (repeatedUri = this.hasDuplicatesUris(uris)) {
        throw new exports.ValidationError('while validating trait consumption', null, "two resources share same URI " + repeatedUri.uri, repeatedUri.mark);
      }
    };

    Validator.prototype.get_absolute_uris = function(node, parentPath) {
      var childResource, child_resources, response, uri, _i, _len;
      response = [];
      if (!util.isNullableMapping(node)) {
        throw new exports.ValidationError('while validating resources', null, 'resource is not a map', node.start_mark);
      }
      child_resources = this.child_resources(node);
      for (_i = 0, _len = child_resources.length; _i < _len; _i++) {
        childResource = child_resources[_i];
        if (parentPath != null) {
          uri = parentPath + childResource[0].value;
        } else {
          uri = childResource[0].value;
        }
        response.push({
          uri: uri,
          mark: childResource[0].start_mark
        });
        response = response.concat(this.get_absolute_uris(childResource[1], uri));
      }
      return response;
    };

    Validator.prototype.key_or_value = function(node) {
      var possibleKeyName, _ref1, _ref2, _ref3;
      if (node instanceof nodes.ScalarNode) {
        return node.value;
      }
      if (node instanceof nodes.MappingNode) {
        possibleKeyName = node != null ? (_ref1 = node.value) != null ? (_ref2 = _ref1[0]) != null ? (_ref3 = _ref2[0]) != null ? _ref3.value : void 0 : void 0 : void 0 : void 0;
        if (possibleKeyName) {
          return possibleKeyName;
        }
      }
      return null;
    };

    Validator.prototype.value_or_undefined = function(node) {
      if (node instanceof nodes.MappingNode) {
        return node.value;
      }
      return void 0;
    };

    Validator.prototype.validate_base_uri = function(baseUriNode) {
      var baseUri, err, expressions, protocol, template, _ref1, _ref2;
      baseUri = (_ref1 = baseUriNode.value) != null ? _ref1.trim() : void 0;
      if (!baseUri) {
        throw new exports.ValidationError('while validating baseUri', null, 'baseUri must have a value', baseUriNode.start_mark);
      }
      protocol = ((url.parse(baseUri)).protocol || 'http:').slice(0, -1).toUpperCase();
      if (protocol !== 'HTTP' && protocol !== 'HTTPS') {
        throw new exports.ValidationError('while validating baseUri', null, 'baseUri protocol must be either HTTP or HTTPS', baseUriNode.start_mark);
      }
      try {
        template = uritemplate.parse(baseUri);
      } catch (_error) {
        err = _error;
        throw new exports.ValidationError('while validating baseUri', null, err != null ? (_ref2 = err.options) != null ? _ref2.message : void 0 : void 0, baseUriNode.start_mark);
      }
      expressions = template.expressions.filter(function(expr) {
        return 'templateText' in expr;
      }).map(function(expression) {
        return expression.templateText;
      });
      if (__indexOf.call(expressions, 'version') >= 0) {
        return true;
      }
    };

    Validator.prototype.get_validation_errors = function() {
      return this.validation_errors;
    };

    Validator.prototype.is_valid = function() {
      return this.validation_errors.length === 0;
    };

    Validator.prototype.hasDuplicatesUris = function(array) {
      var item, output, _i, _len;
      output = {};
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        item = array[_i];
        if (item.uri in output) {
          return item;
        }
        output[item.uri] = item;
      }
      return false;
    };

    Validator.prototype.hasDuplicates = function(array) {
      var item, output, _i, _len;
      output = {};
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        item = array[_i];
        if (item in output) {
          return true;
        }
        output[item] = true;
      }
      return false;
    };

    return Validator;

  })();

}).call(this);

},{"./errors":33,"./nodes":37,"./traits":48,"./util":50,"json-lint":53,"uritemplate":56,"url":25}],52:[function(require,module,exports){
/*!
 * inflection
 * Copyright(c) 2011 Ben Lin <ben@dreamerslab.com>
 * MIT Licensed
 *
 * @fileoverview
 * A port of inflection-js to node.js module.
 */

( function ( root ){

  /**
   * @description This is a list of nouns that use the same form for both singular and plural.
   *              This list should remain entirely in lower case to correctly match Strings.
   * @private
   */
  var uncountable_words = [
    'equipment', 'information', 'rice', 'money', 'species',
    'series', 'fish', 'sheep', 'moose', 'deer', 'news'
  ];

  /**
   * @description These rules translate from the singular form of a noun to its plural form.
   * @private
   */
  var plural_rules = [

    // do not replace if its already a plural word
    [ new RegExp( '(m)en$',      'gi' )],
    [ new RegExp( '(pe)ople$',   'gi' )],
    [ new RegExp( '(child)ren$', 'gi' )],
    [ new RegExp( '([ti])a$',    'gi' )],
    [ new RegExp( '((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$','gi' )],
    [ new RegExp( '(hive)s$',           'gi' )],
    [ new RegExp( '(tive)s$',           'gi' )],
    [ new RegExp( '(curve)s$',          'gi' )],
    [ new RegExp( '([lr])ves$',         'gi' )],
    [ new RegExp( '([^fo])ves$',        'gi' )],
    [ new RegExp( '([^aeiouy]|qu)ies$', 'gi' )],
    [ new RegExp( '(s)eries$',          'gi' )],
    [ new RegExp( '(m)ovies$',          'gi' )],
    [ new RegExp( '(x|ch|ss|sh)es$',    'gi' )],
    [ new RegExp( '([m|l])ice$',        'gi' )],
    [ new RegExp( '(bus)es$',           'gi' )],
    [ new RegExp( '(o)es$',             'gi' )],
    [ new RegExp( '(shoe)s$',           'gi' )],
    [ new RegExp( '(cris|ax|test)es$',  'gi' )],
    [ new RegExp( '(octop|vir)i$',      'gi' )],
    [ new RegExp( '(alias|status)es$',  'gi' )],
    [ new RegExp( '^(ox)en',            'gi' )],
    [ new RegExp( '(vert|ind)ices$',    'gi' )],
    [ new RegExp( '(matr)ices$',        'gi' )],
    [ new RegExp( '(quiz)zes$',         'gi' )],

    // original rule
    [ new RegExp( '(m)an$', 'gi' ),                 '$1en' ],
    [ new RegExp( '(pe)rson$', 'gi' ),              '$1ople' ],
    [ new RegExp( '(child)$', 'gi' ),               '$1ren' ],
    [ new RegExp( '^(ox)$', 'gi' ),                 '$1en' ],
    [ new RegExp( '(ax|test)is$', 'gi' ),           '$1es' ],
    [ new RegExp( '(octop|vir)us$', 'gi' ),         '$1i' ],
    [ new RegExp( '(alias|status)$', 'gi' ),        '$1es' ],
    [ new RegExp( '(bu)s$', 'gi' ),                 '$1ses' ],
    [ new RegExp( '(buffal|tomat|potat)o$', 'gi' ), '$1oes' ],
    [ new RegExp( '([ti])um$', 'gi' ),              '$1a' ],
    [ new RegExp( 'sis$', 'gi' ),                   'ses' ],
    [ new RegExp( '(?:([^f])fe|([lr])f)$', 'gi' ),  '$1$2ves' ],
    [ new RegExp( '(hive)$', 'gi' ),                '$1s' ],
    [ new RegExp( '([^aeiouy]|qu)y$', 'gi' ),       '$1ies' ],
    [ new RegExp( '(x|ch|ss|sh)$', 'gi' ),          '$1es' ],
    [ new RegExp( '(matr|vert|ind)ix|ex$', 'gi' ),  '$1ices' ],
    [ new RegExp( '([m|l])ouse$', 'gi' ),           '$1ice' ],
    [ new RegExp( '(quiz)$', 'gi' ),                '$1zes' ],

    [ new RegExp( 's$', 'gi' ), 's' ],
    [ new RegExp( '$', 'gi' ),  's' ]
  ];

  /**
   * @description These rules translate from the plural form of a noun to its singular form.
   * @private
   */
  var singular_rules = [

    // do not replace if its already a singular word
    [ new RegExp( '(m)an$',                 'gi' )],
    [ new RegExp( '(pe)rson$',              'gi' )],
    [ new RegExp( '(child)$',               'gi' )],
    [ new RegExp( '^(ox)$',                 'gi' )],
    [ new RegExp( '(ax|test)is$',           'gi' )],
    [ new RegExp( '(octop|vir)us$',         'gi' )],
    [ new RegExp( '(alias|status)$',        'gi' )],
    [ new RegExp( '(bu)s$',                 'gi' )],
    [ new RegExp( '(buffal|tomat|potat)o$', 'gi' )],
    [ new RegExp( '([ti])um$',              'gi' )],
    [ new RegExp( 'sis$',                   'gi' )],
    [ new RegExp( '(?:([^f])fe|([lr])f)$',  'gi' )],
    [ new RegExp( '(hive)$',                'gi' )],
    [ new RegExp( '([^aeiouy]|qu)y$',       'gi' )],
    [ new RegExp( '(x|ch|ss|sh)$',          'gi' )],
    [ new RegExp( '(matr|vert|ind)ix|ex$',  'gi' )],
    [ new RegExp( '([m|l])ouse$',           'gi' )],
    [ new RegExp( '(quiz)$',                'gi' )],

    // original rule
    [ new RegExp( '(m)en$', 'gi' ),                                                       '$1an' ],
    [ new RegExp( '(pe)ople$', 'gi' ),                                                    '$1rson' ],
    [ new RegExp( '(child)ren$', 'gi' ),                                                  '$1' ],
    [ new RegExp( '([ti])a$', 'gi' ),                                                     '$1um' ],
    [ new RegExp( '((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$','gi' ), '$1$2sis' ],
    [ new RegExp( '(hive)s$', 'gi' ),                                                     '$1' ],
    [ new RegExp( '(tive)s$', 'gi' ),                                                     '$1' ],
    [ new RegExp( '(curve)s$', 'gi' ),                                                    '$1' ],
    [ new RegExp( '([lr])ves$', 'gi' ),                                                   '$1f' ],
    [ new RegExp( '([^fo])ves$', 'gi' ),                                                  '$1fe' ],
    [ new RegExp( '([^aeiouy]|qu)ies$', 'gi' ),                                           '$1y' ],
    [ new RegExp( '(s)eries$', 'gi' ),                                                    '$1eries' ],
    [ new RegExp( '(m)ovies$', 'gi' ),                                                    '$1ovie' ],
    [ new RegExp( '(x|ch|ss|sh)es$', 'gi' ),                                              '$1' ],
    [ new RegExp( '([m|l])ice$', 'gi' ),                                                  '$1ouse' ],
    [ new RegExp( '(bus)es$', 'gi' ),                                                     '$1' ],
    [ new RegExp( '(o)es$', 'gi' ),                                                       '$1' ],
    [ new RegExp( '(shoe)s$', 'gi' ),                                                     '$1' ],
    [ new RegExp( '(cris|ax|test)es$', 'gi' ),                                            '$1is' ],
    [ new RegExp( '(octop|vir)i$', 'gi' ),                                                '$1us' ],
    [ new RegExp( '(alias|status)es$', 'gi' ),                                            '$1' ],
    [ new RegExp( '^(ox)en', 'gi' ),                                                      '$1' ],
    [ new RegExp( '(vert|ind)ices$', 'gi' ),                                              '$1ex' ],
    [ new RegExp( '(matr)ices$', 'gi' ),                                                  '$1ix' ],
    [ new RegExp( '(quiz)zes$', 'gi' ),                                                   '$1' ],
    [ new RegExp( 'ss$', 'gi' ),                                                          'ss' ],
    [ new RegExp( 's$', 'gi' ),                                                           '' ]
  ];

  /**
   * @description This is a list of words that should not be capitalized for title case.
   * @private
   */
  var non_titlecased_words = [
    'and', 'or', 'nor', 'a', 'an', 'the', 'so', 'but', 'to', 'of', 'at','by',
    'from', 'into', 'on', 'onto', 'off', 'out', 'in', 'over', 'with', 'for'
  ];

  /**
   * @description These are regular expressions used for converting between String formats.
   * @private
   */
  var id_suffix         = new RegExp( '(_ids|_id)$', 'g' );
  var underbar          = new RegExp( '_', 'g' );
  var space_or_underbar = new RegExp( '[\ _]', 'g' );
  var uppercase         = new RegExp( '([A-Z])', 'g' );
  var underbar_prefix   = new RegExp( '^_' );

  var inflector = {

  /**
   * A helper method that applies rules based replacement to a String.
   * @private
   * @function
   * @param {String} str String to modify and return based on the passed rules.
   * @param {Array: [RegExp, String]} rules Regexp to match paired with String to use for replacement
   * @param {Array: [String]} skip Strings to skip if they match
   * @param {String} override String to return as though this method succeeded (used to conform to APIs)
   * @returns {String} Return passed String modified by passed rules.
   * @example
   *
   *     this._apply_rules( 'cows', singular_rules ); // === 'cow'
   */
    _apply_rules : function( str, rules, skip, override ){
      if( override ){
        str = override;
      }else{
        var ignore = ( inflector.indexOf( skip, str.toLowerCase()) > -1 );

        if( !ignore ){
          var i = 0;
          var j = rules.length;

          for( ; i < j; i++ ){
            if( str.match( rules[ i ][ 0 ])){
              if( rules[ i ][ 1 ] !== undefined ){
                str = str.replace( rules[ i ][ 0 ], rules[ i ][ 1 ]);
              }
              break;
            }
          }
        }
      }

      return str;
    },



  /**
   * This lets us detect if an Array contains a given element.
   * @public
   * @function
   * @param {Array} arr The subject array.
   * @param {Object} item Object to locate in the Array.
   * @param {Number} fromIndex Starts checking from this position in the Array.(optional)
   * @param {Function} compareFunc Function used to compare Array item vs passed item.(optional)
   * @returns {Number} Return index position in the Array of the passed item.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.indexOf([ 'hi','there' ], 'guys' ); // === -1
   *     inflection.indexOf([ 'hi','there' ], 'hi' ); // === 0
   */
    indexOf : function( arr, item, fromIndex, compareFunc ){
      if( !fromIndex ){
        fromIndex = -1;
      }

      var index = -1;
      var i     = fromIndex;
      var j     = arr.length;

      for( ; i < j; i++ ){
        if( arr[ i ]  === item || compareFunc && compareFunc( arr[ i ], item )){
          index = i;
          break;
        }
      }

      return index;
    },



  /**
   * This function adds pluralization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {String} plural Overrides normal output with said String.(optional)
   * @returns {String} Singular English language nouns are returned in plural form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.pluralize( 'person' ); // === 'people'
   *     inflection.pluralize( 'octopus' ); // === 'octopi'
   *     inflection.pluralize( 'Hat' ); // === 'Hats'
   *     inflection.pluralize( 'person', 'guys' ); // === 'guys'
   */
    pluralize : function ( str, plural ){
      return inflector._apply_rules( str, plural_rules, uncountable_words, plural );
    },



  /**
   * This function adds singularization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {String} singular Overrides normal output with said String.(optional)
   * @returns {String} Plural English language nouns are returned in singular form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.singularize( 'people' ); // === 'person'
   *     inflection.singularize( 'octopi' ); // === 'octopus'
   *     inflection.singularize( 'Hats' ); // === 'Hat'
   *     inflection.singularize( 'guys', 'person' ); // === 'person'
   */
    singularize : function ( str, singular ){
      return inflector._apply_rules( str, singular_rules, uncountable_words, singular );
    },



  /**
   * This function adds camelization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} lowFirstLetter Default is to capitalize the first letter of the results.(optional)
   *                                 Passing true will lowercase it.
   * @returns {String} Lower case underscored words will be returned in camel case.
   *                  additionally '/' is translated to '::'
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.camelize( 'message_properties' ); // === 'MessageProperties'
   *     inflection.camelize( 'message_properties', true ); // === 'messageProperties'
   */
    camelize : function ( str, lowFirstLetter ){
      var str_path = str.split( '/' );
      var i        = 0;
      var j        = str_path.length;
      var str_arr, init_x, k, l, first;

      for( ; i < j; i++ ){
        str_arr = str_path[ i ].split( '_' );
        k       = 0;
        l       = str_arr.length;

        for( ; k < l; k++ ){
          if( k !== 0 ){
            str_arr[ k ] = str_arr[ k ].toLowerCase();
          }

          first = str_arr[ k ].charAt( 0 );
          first = lowFirstLetter && i === 0 && k === 0
            ? first.toLowerCase() : first.toUpperCase();
          str_arr[ k ] = first + str_arr[ k ].substring( 1 );
        }

        str_path[ i ] = str_arr.join( '' );
      }

      return str_path.join( '::' );
    },



  /**
   * This function adds underscore support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} allUpperCase Default is to lowercase and add underscore prefix.(optional)
   *                  Passing true will return as entered.
   * @returns {String} Camel cased words are returned as lower cased and underscored.
   *                  additionally '::' is translated to '/'.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.underscore( 'MessageProperties' ); // === 'message_properties'
   *     inflection.underscore( 'messageProperties' ); // === 'message_properties'
   *     inflection.underscore( 'MP', true ); // === 'MP'
   */
    underscore : function ( str, allUpperCase ){
      if( allUpperCase && str === str.toUpperCase()) return str;

      var str_path = str.split( '::' );
      var i        = 0;
      var j        = str_path.length;

      for( ; i < j; i++ ){
        str_path[ i ] = str_path[ i ].replace( uppercase, '_$1' );
        str_path[ i ] = str_path[ i ].replace( underbar_prefix, '' );
      }

      return str_path.join( '/' ).toLowerCase();
    },



  /**
   * This function adds humanize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} lowFirstLetter Default is to capitalize the first letter of the results.(optional)
   *                                 Passing true will lowercase it.
   * @returns {String} Lower case underscored words will be returned in humanized form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.humanize( 'message_properties' ); // === 'Message properties'
   *     inflection.humanize( 'message_properties', true ); // === 'message properties'
   */
    humanize : function( str, lowFirstLetter ){
      str = str.toLowerCase();
      str = str.replace( id_suffix, '' );
      str = str.replace( underbar, ' ' );

      if( !lowFirstLetter ){
        str = inflector.capitalize( str );
      }

      return str;
    },



  /**
   * This function adds capitalization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} All characters will be lower case and the first will be upper.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.capitalize( 'message_properties' ); // === 'Message_properties'
   *     inflection.capitalize( 'message properties', true ); // === 'Message properties'
   */
    capitalize : function ( str ){
      str = str.toLowerCase();

      return str.substring( 0, 1 ).toUpperCase() + str.substring( 1 );
    },



  /**
   * This function adds dasherization support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Replaces all spaces or underbars with dashes.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.dasherize( 'message_properties' ); // === 'message-properties'
   *     inflection.dasherize( 'Message Properties' ); // === 'Message-Properties'
   */
    dasherize : function ( str ){
      return str.replace( space_or_underbar, '-' );
    },



  /**
   * This function adds titleize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Capitalizes words as you would for a book title.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.titleize( 'message_properties' ); // === 'Message Properties'
   *     inflection.titleize( 'message properties to keep' ); // === 'Message Properties to Keep'
   */
    titleize : function ( str ){
      str         = str.toLowerCase().replace( underbar, ' ');
      var str_arr = str.split(' ');
      var i       = 0;
      var j       = str_arr.length;
      var d, k, l;

      for( ; i < j; i++ ){
        d = str_arr[ i ].split( '-' );
        k = 0;
        l = d.length;

        for( ; k < l; k++){
          if( inflector.indexOf( non_titlecased_words, d[ k ].toLowerCase()) < 0 ){
            d[ k ] = inflector.capitalize( d[ k ]);
          }
        }

        str_arr[ i ] = d.join( '-' );
      }

      str = str_arr.join( ' ' );
      str = str.substring( 0, 1 ).toUpperCase() + str.substring( 1 );

      return str;
    },



  /**
   * This function adds demodulize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Removes module names leaving only class names.(Ruby style)
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.demodulize( 'Message::Bus::Properties' ); // === 'Properties'
   */
    demodulize : function ( str ){
      var str_arr = str.split( '::' );

      return str_arr[ str_arr.length - 1 ];
    },



  /**
   * This function adds tableize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Return camel cased words into their underscored plural form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.tableize( 'MessageBusProperty' ); // === 'message_bus_properties'
   */
    tableize : function ( str ){
      str = inflector.underscore( str );
      str = inflector.pluralize( str );

      return str;
    },



  /**
   * This function adds classification support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Underscored plural nouns become the camel cased singular form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.classify( 'message_bus_properties' ); // === 'MessageBusProperty'
   */
    classify : function ( str ){
      str = inflector.camelize( str );
      str = inflector.singularize( str );

      return str;
    },



  /**
   * This function adds foreign key support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Boolean} dropIdUbar Default is to seperate id with an underbar at the end of the class name,
                                 you can pass true to skip it.(optional)
   * @returns {String} Underscored plural nouns become the camel cased singular form.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.foreign_key( 'MessageBusProperty' ); // === 'message_bus_property_id'
   *     inflection.foreign_key( 'MessageBusProperty', true ); // === 'message_bus_propertyid'
   */
    foreign_key : function( str, dropIdUbar ){
      str = inflector.demodulize( str );
      str = inflector.underscore( str ) + (( dropIdUbar ) ? ( '' ) : ( '_' )) + 'id';

      return str;
    },



  /**
   * This function adds ordinalize support to every String object.
   * @public
   * @function
   * @param {String} str The subject string.
   * @returns {String} Return all found numbers their sequence like '22nd'.
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.ordinalize( 'the 1 pitch' ); // === 'the 1st pitch'
   */
    ordinalize : function ( str ){
      var str_arr = str.split(' ');
      var i       = 0;
      var j       = str_arr.length;

      for( ; i < j; i++ ){
        var k = parseInt( str_arr[ i ], 10 );

        if( !isNaN( k )){
          var ltd = str_arr[ i ].substring( str_arr[ i ].length - 2 );
          var ld  = str_arr[ i ].substring( str_arr[ i ].length - 1 );
          var suf = 'th';

          if( ltd != '11' && ltd != '12' && ltd != '13' ){
            if( ld === '1' ){
              suf = 'st';
            }else if( ld === '2' ){
              suf = 'nd';
            }else if( ld === '3' ){
              suf = 'rd';
            }
          }

          str_arr[ i ] += suf;
        }
      }

      return str_arr.join( ' ' );
    },

  /**
   * This function performs multiple inflection methods on a string
   * @public
   * @function
   * @param {String} str The subject string.
   * @param {Array} arr An array of inflection methods.
   * @returns {String}
   * @example
   *
   *     var inflection = require( 'inflection' );
   *
   *     inflection.transform( 'all job', [ 'pluralize', 'capitalize', 'dasherize' ]); // === 'All-jobs'
   */
    transform : function ( str, arr ){
      var i = 0;
      var j = arr.length;

      for( ;i < j; i++ ){
        var method = arr[ i ];

        if( this.hasOwnProperty( method )){
          str = this[ method ]( str );
        }
      }

      return str;
    }
  };

/**
 * @public
 */
  inflector.version = '1.3.5';

  // browser support
  // requirejs
  if( typeof define !== 'undefined' ){
    return define( function ( require, exports, module ){
      module.exports = inflector;
    });
  }

  // browser support
  // normal usage
  if( typeof exports === 'undefined' ){
    root.inflection = inflector;
    return;
  }

/**
 * Exports module.
 */
  module.exports = inflector;
})( this );

},{}],53:[function(require,module,exports){
(function( glob, undefined ) {

var rnumber = /[0-9]/,
	rnewline = /(\r\n|\r|\n)/,
	revidence = /\r\n|\r|\n/,
	rwhitespace = /(\s|\t)/,
	rvalidsolidus = /\\("|\\|\/|b|f|n|r|t|u[0-9]{4})/,
	rE = /^(\-|\+)?[0-9]/;


// Leeeeeeerrrrroooyy Jennkkkiiinnnss
function JSONLint( json, options ) {
	var self = this;

	if ( ! ( self instanceof JSONLint ) ) {
		return new JSONLint( json, options );
	}

	// Argument handling
	self.json = json || '';
	self.options = options || {};
	self.lower = self.json.toLowerCase();

	// Allow comments by default
	if ( ! self.options.hasOwnProperty( 'comments' ) ) {
		self.options.comments = true;
	}

	// Internals
	self.c = '';
	self.i = -1;
	self.length = self.json.length;
	self.line = 1;
	self.character = 0;
	self._evidence = self.json.split( revidence );
	self.endblock = '';
	self.commabreak = false;

	try {
		self.render();
	} catch ( e ) {
		if ( typeof e != 'string' ) {
			throw e;
		}
		self.error = e;
		self.setEvidence();
	}
}


// Meta (Please change contact info for republishing with changes)
JSONLint.contact = "Corey Hart (corey@codenothing.com)";
JSONLint.version = '[VERSION]';
JSONLint.date = '[DATE]';


// Methods
JSONLint.prototype = {

	// Rendering Start
	render: function(){
		var self = this, peek = '', content = false;

		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( self.options.comments && self.c == '/' ) {
				peek = self.json[ self.i + 1 ];
				if ( peek == '*' ) {
					self.multicomment();
				}
				else if ( peek == '/' ) {
					self.comment();
				}
				else {
					throw "Unknown character '/', maybe a comment?";
				}
			}
			else if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
			}
			else if ( rwhitespace.exec( self.c ) ) {
				continue;
			}
			else if ( content ) {
				throw "Unknown character '" + self.c + "', expecting end of file.";
			}
			else if ( self.c == '[' ) {
				content = true;
				self.array();
			}
			else if ( self.c == '{' ) {
				content = true;
				self.object();
			}
			else {
				throw "Unknown character '" + self.c + "', expecting opening block '{' or '[', or maybe a comment";
			}
		}

		// Check for pure whitespace
		if ( ! content ) {
			throw "Invalid JSON, no content.";
		}
	},

	// Multi line comment
	multicomment: function(){
		var self = this;

		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( self.c == "*" && self.json[ self.i + 1 ] == "/" ) {
				self.i++;
				self.character++;
				break;
			}
			else if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
			}
		}
	},

	// Single line comment
	comment: function(){
		var self = this;

		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
				break;
			}
		}
	},

	// Array Block
	array: function(){
		// Keep reference of current endblock
		var self = this,
			_endblock = self.endblock,
			_commabreak = self.commabreak,
			ended = false;

		self.endblock = ']';
		self.commabreak = false;
		while ( ( ended = self.value() ) !== true && self.i < self.length ) {
			// Do nothing, just wait for array values to finish
		}

		if ( ! ended ) {
			throw "EOF Error. Expecting closing ']'";
		}

		// Reset previous endblock
		self.endblock = _endblock;
		self.commabreak = _commabreak;
	},

	// Object Block
	object: function(){
		// Keep reference of current endblock
		var self = this,
			_endblock = self.endblock,
			_commabreak = self.commabreak,
			found = false, peek = '', empty = true;

		self.endblock = '}';
		self.commabreak = false;
		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( self.options.comments && self.c == '/' ) {
				peek = self.json[ self.i + 1 ];
				if ( peek == '*' ) {
					self.multicomment();
				}
				else if ( peek == '/' ) {
					self.comment();
				}
				else {
					throw "Unknown character '/', maybe a comment?";
				}
			}
			else if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
			}
			else if ( rwhitespace.exec( self.c ) ) {
				continue;
			}
			else if ( self.c == '"' ) {
				empty = false;
				if ( self.key() === true ) {
					// Reset old endblock
					self.endblock = _endblock;
					self.commabreak = _commabreak;
					found = true;
					break;
				}
			}
			else if ( empty && self.c == '}' ) {
				self.endblock = _endblock;
				self.commabreak = _commabreak;
				found = true;
				break;
			}
			else {
				throw "Unknown Character '" + self.c + "', expecting a string for key statement.";
			}
		}

		if ( ! found ) {
			throw "EOF Error, expecting closing '}'.";
		}
	},

	// Key Statement
	key: function(){
		var self = this;
		self.string();

		for ( var peek = ''; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( self.options.comments && self.c == '/' ) {
				peek = self.json[ self.i + 1 ];
				if ( peek == '*' ) {
					self.multicomment();
				}
				else if ( peek == '/' ) {
					self.comment();
				}
				else {
					throw "Unknown character '/', maybe a comment?";
				}
			}
			else if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
			}
			else if ( rwhitespace.exec( self.c ) ) {
				continue;
			}
			else if ( self.c == ":" ) {
				return self.value();
			}
			else {
				throw "Unknown Character '" + self.c + "', expecting a semicolon.";
			}
		}
	},

	// Value statement
	value: function(){
		var self = this, peek = '';

		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( self.options.comments && self.c == '/' ) {
				peek = self.json[ self.i + 1 ];
				if ( peek == '*' ) {
					self.multicomment();
				}
				else if ( peek == '/' ) {
					self.comment();
				}
				else {
					throw "Unknown character '/', maybe a comment?";
				}
			}
			else if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
			}
			else if ( rwhitespace.exec( self.c ) ) {
				continue;
			}
			else if ( self.c == '{' ) {
				self.object();
				return self.endval();
			}
			else if ( self.c == '[' ) {
				self.array();
				return self.endval();
			}
			else if ( self.c == '"' ) {
				self.string();
				return self.endval();
			}
			else if ( self.json.indexOf( 'true', self.i ) === self.i ) {
				self.i += 3;
				self.character += 3;
				return self.endval();
			}
			else if ( self.json.indexOf( 'false', self.i ) === self.i ) {
				self.i += 4;
				self.character += 4;
				return self.endval();
			}
			else if ( self.json.indexOf( 'null', self.i ) === self.i ) {
				self.i += 3;
				self.character += 3;
				return self.endval();
			}
			else if ( self.c == '-' || rnumber.exec( self.c ) ) {
				return self.numeric();
			}
			else if ( self.c == ']' && self.endblock == ']' ) {
				if ( self.commabreak ) {
					throw "Unexpected End Of Array Error. Expecting a value statement.";
				}
				return true;
			}
			else {
				throw "Unknown Character '" + self.c + "', expecting a value.";
			}
		}
	},

	// String statement
	string: function(){
		var self = this, found = false, m;

		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( self.c == "\\" ) {
				if ( ( m = rvalidsolidus.exec( self.json.substr( self.i ) ) ) && m.index === 0 ) {
					self.i += m[ 1 ].length;
					self.character += m[ 1 ].length;
				}
				else {
					throw "Invalid Reverse Solidus '\\' declaration.";
				}
			}
			else if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
			}
			else if ( self.c == '"' ) {
				found = true;
				break;
			}
		}

		// Make sure close string is found
		if ( ! found ) {
			throw "EOF: No close string '\"' found.";
		}
	},

	// Numeric Value
	numeric: function(){
		var self = this,
			negative = true,
			decimal = null,
			e = null,
			peek = '';

		// We need to jump back a character to catch the whole number
		self.i--;
		self.character--;
		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			// Handle initial negative sign
			if ( negative ) {
				negative = false;
				if ( self.c == '-' ) {
					if ( ! rnumber.exec( self.json[ self.i + 1 ] ) ) {
						throw "Unknown Character '" + self.c + "' following a negative, expecting a numeric value.";
					}
					continue;
				}
			}

			// Only a single decimal is allowed in a numeric value
			if ( decimal && self.c == '.' ) {
				decimal = false;
				e = true;
				continue;
			}
			// Only a single e notation is allowed in a numeric value
			else if ( e && self.c.toLowerCase() == 'e' ) {
				e = false;
				negative = true;
				if ( rE.exec( self.json.substr( self.i + 1, 2 ) ) ) {
					self.character++;
					self.i++;
				}
				else {
					self.character++;
					throw "Unknown Character '" + self.json[ self.i + 1 ] + "' following e notation, expecting a numeric value.";
				}
			}
			// Normal Digit
			else if ( rnumber.exec( self.c ) ) {
				if ( decimal === null ) {
					decimal = true;
				}
			}
			// Assume end of number, and allow endval to handle it
			else {
				// Jump back a character to include the current one
				self.i--;
				self.character--;
				return self.endval();
			}
		}
	},

	// Ending a value statement
	endval: function(){
		var self = this, peek = '';
		self.commabreak = false;

		for ( ; ++self.i < self.length; ) {
			self.c = self.json[ self.i ];
			self.character++;

			if ( self.options.comments && self.c == '/' ) {
				peek = self.json[ self.i + 1 ];
				if ( peek == '*' ) {
					self.multicomment();
				}
				else if ( peek == '/' ) {
					self.comment();
				}
				else {
					throw "Unknown character '/', maybe a comment?";
				}
			}
			else if ( rnewline.exec( self.c ) ) {
				self.line++;
				self.character = 0;
			}
			else if ( rwhitespace.exec( self.c ) ) {
				continue;
			}
			else if ( self.c == ',' ) {
				self.commabreak = true;
				break;
			}
			else if ( self.c == self.endblock ) {
				return true;
			}
			else {
				throw "Unknown Character '" + self.c + "', expecting a comma or a closing '" + self.endblock + "'";
			}
		}
	},

	// Expose line of the error
	setEvidence: function(){
		var self = this, start = self.line - 5, end = start + 8, evidence = '';

		// Min start
		if ( start < 0 ) {
			start = 0;
			end = 8;
		}

		// Max end
		if ( end >= self._evidence.length ) {
			end = self._evidence.length;
		}

		// Evidence display
		for ( ; start < end; start++ ) {
			evidence += ( start === ( self.line - 1 ) ? "-> " : "   " ) +
				( start + 1 ) + '| ' +
				self._evidence[ start ] + "\n";
		}

		// Set the evidence display
		self.evidence = evidence;
	}
};


// Check for nodejs module system
if ( typeof exports == 'object' && typeof module == 'object' ) {
	module.exports = JSONLint;
}
// In a browser
else {
	glob.JSONLint = JSONLint;
}

})( this );

},{}],54:[function(require,module,exports){
(function (process){
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    // Turn off strict mode for this function so we can assign to global.Q
    /* jshint strict: false */

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else {
        Q = definition();
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;

    function flush() {
        /* jshint loopfunc: true */

        while (head.next) {
            head = head.next;
            var task = head.task;
            head.task = void 0;
            var domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }

            try {
                task();

            } catch (e) {
                if (isNodeJS) {
                    // In node, uncaught exceptions are considered fatal errors.
                    // Re-throw them synchronously to interrupt flushing!

                    // Ensure continuation if the uncaught exception is suppressed
                    // listening "uncaughtException" events (as domains does).
                    // Continue in next event to avoid tick recursion.
                    if (domain) {
                        domain.exit();
                    }
                    setTimeout(flush, 0);
                    if (domain) {
                        domain.enter();
                    }

                    throw e;

                } else {
                    // In browsers, uncaught exceptions are not fatal.
                    // Re-throw them asynchronously to avoid slow-downs.
                    setTimeout(function() {
                       throw e;
                    }, 0);
                }
            }

            if (domain) {
                domain.exit();
            }
        }

        flushing = false;
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process !== "undefined" && process.nextTick) {
        // Node.js before 0.9. Note that some fake-Node environments, like the
        // Mocha test runner, introduce a `process` global without a `nextTick`.
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }

    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you don’t need a security guarantee,
// this is just plain paranoid.
// However, this does have the nice side-effect of reducing the size
// of the code by reducing x.call() to merely x(), eliminating many
// hard-to-minify characters.
// See Mark Miller’s explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
// engine that has a deployed base of browsers that support generators.
// However, SM's generators use the Python-inspired semantics of
// outdated ES6 drafts.  We would like to support ES6, but we'd also
// like to make it possible to use generators in deployed browsers, so
// we also support Python-style generators.  At some point we can remove
// this block.
var hasES6Generators;
try {
    /* jshint evil: true, nonew: false */
    new Function("(function* (){ yield 1; })");
    hasES6Generators = true;
} catch (e) {
    hasES6Generators = false;
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (isPromise(value)) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = deprecate(function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    }, "valueOf", "inspect");

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become fulfilled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be fulfilled
 */
Q.race = race;
function race(answerPs) {
    return promise(function(resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function(answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = deprecate(function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        });
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it’s a fulfilled promise, the fulfillment value is nearer.
 * If it’s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return isObject(object) &&
        typeof object.promiseDispatch === "function" &&
        typeof object.inspect === "function";
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var unhandledReasonsDisplayed = false;
var trackUnhandledRejections = true;
function displayUnhandledReasons() {
    if (
        !unhandledReasonsDisplayed &&
        typeof window !== "undefined" &&
        !window.Touch &&
        window.console
    ) {
        console.warn("[Q] Unhandled rejection reasons (should be empty):",
                     unhandledReasons);
    }

    unhandledReasonsDisplayed = true;
}

function logUnhandledReasons() {
    for (var i = 0; i < unhandledReasons.length; i++) {
        var reason = unhandledReasons[i];
        console.warn("Unhandled rejection reason:", reason);
    }
}

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;
    unhandledReasonsDisplayed = false;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;

        // Show unhandled rejection reasons if Node exits without handling an
        // outstanding rejection.  (Note that Browserify presently produces a
        // `process` global without the `EventEmitter` `on` method.)
        if (typeof process !== "undefined" && process.on) {
            process.on("exit", logUnhandledReasons);
        }
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
    displayUnhandledReasons();
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    if (typeof process !== "undefined" && process.on) {
        process.removeListener("exit", logUnhandledReasons);
    }
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;
            if (hasES6Generators) {
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return result.value;
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return exception.value;
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var countDown = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++countDown;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--countDown === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (countDown === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {String} custom error message (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, message) {
    return Q(object).timeout(ms, message);
};

Promise.prototype.timeout = function (ms, message) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        deferred.reject(new Error(message || "Timed out after " + ms + " ms"));
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

}).call(this,require("/Users/blakeembrey/Projects/api-notebook/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"/Users/blakeembrey/Projects/api-notebook/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":9}],55:[function(require,module,exports){
(function (process,Buffer){
/**
 * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.
 *
 * This can be used with JS designed for browsers to improve reuse of code and
 * allow the use of existing libraries.
 *
 * Usage: include("XMLHttpRequest.js") and use XMLHttpRequest per W3C specs.
 *
 * @author Dan DeFelippi <dan@driverdan.com>
 * @contributor David Ellis <d.f.ellis@ieee.org>
 * @license MIT
 */

var Url = require("url")
  , spawn = require("child_process").spawn
  , fs = require('fs');

exports.XMLHttpRequest = function() {
  /**
   * Private variables
   */
  var self = this;
  var http = require('http');
  var https = require('https');

  // Holds http.js objects
  var request;
  var response;

  // Request settings
  var settings = {};

  // Disable header blacklist.
  // Not part of XHR specs.
  var disableHeaderCheck = false;

  // Set some default headers
  var defaultHeaders = {
    "User-Agent": "node-XMLHttpRequest",
    "Accept": "*/*",
  };

  var headers = defaultHeaders;

  // These headers are not user setable.
  // The following are allowed but banned in the spec:
  // * user-agent
  var forbiddenRequestHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "content-transfer-encoding",
    "cookie",
    "cookie2",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "via"
  ];

  // These request methods are not allowed
  var forbiddenRequestMethods = [
    "TRACE",
    "TRACK",
    "CONNECT"
  ];

  // Send flag
  var sendFlag = false;
  // Error flag, used when errors occur or abort is called
  var errorFlag = false;

  // Event listeners
  var listeners = {};

  /**
   * Constants
   */

  this.UNSENT = 0;
  this.OPENED = 1;
  this.HEADERS_RECEIVED = 2;
  this.LOADING = 3;
  this.DONE = 4;

  /**
   * Public vars
   */

  // Current state
  this.readyState = this.UNSENT;

  // default ready state change handler in case one is not set or is set late
  this.onreadystatechange = null;

  // Result & response
  this.responseText = "";
  this.responseXML = "";
  this.status = null;
  this.statusText = null;

  /**
   * Private methods
   */

  /**
   * Check if the specified header is allowed.
   *
   * @param string header Header to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpHeader = function(header) {
    return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);
  };

  /**
   * Check if the specified method is allowed.
   *
   * @param string method Request method to validate
   * @return boolean False if not allowed, otherwise true
   */
  var isAllowedHttpMethod = function(method) {
    return (method && forbiddenRequestMethods.indexOf(method) === -1);
  };

  /**
   * Public methods
   */

  /**
   * Open the connection. Currently supports local server requests.
   *
   * @param string method Connection method (eg GET, POST)
   * @param string url URL for the connection.
   * @param boolean async Asynchronous connection. Default is true.
   * @param string user Username for basic authentication (optional)
   * @param string password Password for basic authentication (optional)
   */
  this.open = function(method, url, async, user, password) {
    this.abort();
    errorFlag = false;

    // Check for valid request method
    if (!isAllowedHttpMethod(method)) {
      throw "SecurityError: Request method not allowed";
    }

    settings = {
      "method": method,
      "url": url.toString(),
      "async": (typeof async !== "boolean" ? true : async),
      "user": user || null,
      "password": password || null
    };

    setState(this.OPENED);
  };

  /**
   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.
   * This does not conform to the W3C spec.
   *
   * @param boolean state Enable or disable header checking.
   */
  this.setDisableHeaderCheck = function(state) {
    disableHeaderCheck = state;
  };

  /**
   * Sets a header for the request.
   *
   * @param string header Header name
   * @param string value Header value
   */
  this.setRequestHeader = function(header, value) {
    if (this.readyState != this.OPENED) {
      throw "INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN";
    }
    if (!isAllowedHttpHeader(header)) {
      console.warn('Refused to set unsafe header "' + header + '"');
      return;
    }
    if (sendFlag) {
      throw "INVALID_STATE_ERR: send flag is true";
    }
    headers[header] = value;
  };

  /**
   * Gets a header from the server response.
   *
   * @param string header Name of header to get.
   * @return string Text of the header or null if it doesn't exist.
   */
  this.getResponseHeader = function(header) {
    if (typeof header === "string"
      && this.readyState > this.OPENED
      && response.headers[header.toLowerCase()]
      && !errorFlag
    ) {
      return response.headers[header.toLowerCase()];
    }

    return null;
  };

  /**
   * Gets all the response headers.
   *
   * @return string A string with all response headers separated by CR+LF
   */
  this.getAllResponseHeaders = function() {
    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {
      return "";
    }
    var result = "";

    for (var i in response.headers) {
      // Cookie headers are excluded
      if (i !== "set-cookie" && i !== "set-cookie2") {
        result += i + ": " + response.headers[i] + "\r\n";
      }
    }
    return result.substr(0, result.length - 2);
  };

  /**
   * Gets a request header
   *
   * @param string name Name of header to get
   * @return string Returns the request header or empty string if not set
   */
  this.getRequestHeader = function(name) {
    // @TODO Make this case insensitive
    if (typeof name === "string" && headers[name]) {
      return headers[name];
    }

    return "";
  };

  /**
   * Sends the request to the server.
   *
   * @param string data Optional data to send as request body.
   */
  this.send = function(data) {
    if (this.readyState != this.OPENED) {
      throw "INVALID_STATE_ERR: connection must be opened before send() is called";
    }

    if (sendFlag) {
      throw "INVALID_STATE_ERR: send has already been called";
    }

    var ssl = false, local = false;
    var url = Url.parse(settings.url);
    var host;
    // Determine the server
    switch (url.protocol) {
      case 'https:':
        ssl = true;
        // SSL & non-SSL both need host, no break here.
      case 'http:':
        host = url.hostname;
        break;

      case 'file:':
        local = true;
        break;

      case undefined:
      case '':
        host = "localhost";
        break;

      default:
        throw "Protocol not supported.";
    }

    // Load files off the local filesystem (file://)
    if (local) {
      if (settings.method !== "GET") {
        throw "XMLHttpRequest: Only GET method is supported";
      }

      if (settings.async) {
        fs.readFile(url.pathname, 'utf8', function(error, data) {
          if (error) {
            self.handleError(error);
          } else {
            self.status = 200;
            self.responseText = data;
            setState(self.DONE);
          }
        });
      } else {
        try {
          this.responseText = fs.readFileSync(url.pathname, 'utf8');
          this.status = 200;
          setState(self.DONE);
        } catch(e) {
          this.handleError(e);
        }
      }

      return;
    }

    // Default to port 80. If accessing localhost on another port be sure
    // to use http://localhost:port/path
    var port = url.port || (ssl ? 443 : 80);
    // Add query string if one is used
    var uri = url.pathname + (url.search ? url.search : '');

    // Set the Host header or the server may reject the request
    headers["Host"] = host;
    if (!((ssl && port === 443) || port === 80)) {
      headers["Host"] += ':' + url.port;
    }

    // Set Basic Auth if necessary
    if (settings.user) {
      if (typeof settings.password == "undefined") {
        settings.password = "";
      }
      var authBuf = new Buffer(settings.user + ":" + settings.password);
      headers["Authorization"] = "Basic " + authBuf.toString("base64");
    }

    // Set content length header
    if (settings.method === "GET" || settings.method === "HEAD") {
      data = null;
    } else if (data) {
      headers["Content-Length"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);

      if (!headers["Content-Type"]) {
        headers["Content-Type"] = "text/plain;charset=UTF-8";
      }
    } else if (settings.method === "POST") {
      // For a post with no data set Content-Length: 0.
      // This is required by buggy servers that don't meet the specs.
      headers["Content-Length"] = 0;
    }

    var options = {
      host: host,
      port: port,
      path: uri,
      method: settings.method,
      headers: headers,
      agent: false
    };

    // Reset error flag
    errorFlag = false;

    // Handle async requests
    if (settings.async) {
      // Use the proper protocol
      var doRequest = ssl ? https.request : http.request;

      // Request is being sent, set send flag
      sendFlag = true;

      // As per spec, this is called here for historical reasons.
      self.dispatchEvent("readystatechange");

      // Handler for the response
      function responseHandler(resp) {
        // Set response var to the response we got back
        // This is so it remains accessable outside this scope
        response = resp;
        // Check for redirect
        // @TODO Prevent looped redirects
        if (response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {
          // Change URL to the redirect location
          settings.url = response.headers.location;
          var url = Url.parse(settings.url);
          // Set host var in case it's used later
          host = url.hostname;
          // Options for the new request
          var newOptions = {
            hostname: url.hostname,
            port: url.port,
            path: url.path,
            method: response.statusCode === 303 ? 'GET' : settings.method,
            headers: headers
          };

          // Issue the new request
          request = doRequest(newOptions, responseHandler).on('error', errorHandler);
          request.end();
          // @TODO Check if an XHR event needs to be fired here
          return;
        }

        response.setEncoding("utf8");

        setState(self.HEADERS_RECEIVED);
        self.status = response.statusCode;

        response.on('data', function(chunk) {
          // Make sure there's some data
          if (chunk) {
            self.responseText += chunk;
          }
          // Don't emit state changes if the connection has been aborted.
          if (sendFlag) {
            setState(self.LOADING);
          }
        });

        response.on('end', function() {
          if (sendFlag) {
            // Discard the 'end' event if the connection has been aborted
            setState(self.DONE);
            sendFlag = false;
          }
        });

        response.on('error', function(error) {
          self.handleError(error);
        });
      }

      // Error handler for the request
      function errorHandler(error) {
        self.handleError(error);
      }

      // Create the request
      request = doRequest(options, responseHandler).on('error', errorHandler);

      // Node 0.4 and later won't accept empty data. Make sure it's needed.
      if (data) {
        request.write(data);
      }

      request.end();

      self.dispatchEvent("loadstart");
    } else { // Synchronous
      // Create a temporary file for communication with the other Node process
      var contentFile = ".node-xmlhttprequest-content-" + process.pid;
      var syncFile = ".node-xmlhttprequest-sync-" + process.pid;
      fs.writeFileSync(syncFile, "", "utf8");
      // The async request the other Node process executes
      var execString = "var http = require('http'), https = require('https'), fs = require('fs');"
        + "var doRequest = http" + (ssl ? "s" : "") + ".request;"
        + "var options = " + JSON.stringify(options) + ";"
        + "var responseText = '';"
        + "var req = doRequest(options, function(response) {"
        + "response.setEncoding('utf8');"
        + "response.on('data', function(chunk) {"
        + "  responseText += chunk;"
        + "});"
        + "response.on('end', function() {"
        + "fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-STATUS:' + response.statusCode + ',' + responseText, 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + "response.on('error', function(error) {"
        + "fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + "}).on('error', function(error) {"
        + "fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');"
        + "fs.unlinkSync('" + syncFile + "');"
        + "});"
        + (data ? "req.write('" + data.replace(/'/g, "\\'") + "');":"")
        + "req.end();";
      // Start the other Node Process, executing this string
      var syncProc = spawn(process.argv[0], ["-e", execString]);
      var statusText;
      while(fs.existsSync(syncFile)) {
        // Wait while the sync file is empty
      }
      self.responseText = fs.readFileSync(contentFile, 'utf8');
      // Kill the child process once the file has data
      syncProc.stdin.end();
      // Remove the temporary file
      fs.unlinkSync(contentFile);
      if (self.responseText.match(/^NODE-XMLHTTPREQUEST-ERROR:/)) {
        // If the file returned an error, handle it
        var errorObj = self.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR:/, "");
        self.handleError(errorObj);
      } else {
        // If the file returned okay, parse its data and move to the DONE state
        self.status = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:([0-9]*),.*/, "$1");
        self.responseText = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:[0-9]*,(.*)/, "$1");
        setState(self.DONE);
      }
    }
  };

  /**
   * Called when an error is encountered to deal with it.
   */
  this.handleError = function(error) {
    this.status = 503;
    this.statusText = error;
    this.responseText = error.stack;
    errorFlag = true;
    setState(this.DONE);
  };

  /**
   * Aborts a request.
   */
  this.abort = function() {
    if (request) {
      request.abort();
      request = null;
    }

    headers = defaultHeaders;
    this.responseText = "";
    this.responseXML = "";

    errorFlag = true;

    if (this.readyState !== this.UNSENT
        && (this.readyState !== this.OPENED || sendFlag)
        && this.readyState !== this.DONE) {
      sendFlag = false;
      setState(this.DONE);
    }
    this.readyState = this.UNSENT;
  };

  /**
   * Adds an event listener. Preferred method of binding to events.
   */
  this.addEventListener = function(event, callback) {
    if (!(event in listeners)) {
      listeners[event] = [];
    }
    // Currently allows duplicate callbacks. Should it?
    listeners[event].push(callback);
  };

  /**
   * Remove an event callback that has already been bound.
   * Only works on the matching funciton, cannot be a copy.
   */
  this.removeEventListener = function(event, callback) {
    if (event in listeners) {
      // Filter will return a new array with the callback removed
      listeners[event] = listeners[event].filter(function(ev) {
        return ev !== callback;
      });
    }
  };

  /**
   * Dispatch any events, including both "on" methods and events attached using addEventListener.
   */
  this.dispatchEvent = function(event) {
    if (typeof self["on" + event] === "function") {
      self["on" + event]();
    }
    if (event in listeners) {
      for (var i = 0, len = listeners[event].length; i < len; i++) {
        listeners[event][i].call(self);
      }
    }
  };

  /**
   * Changes readyState and calls onreadystatechange.
   *
   * @param int state New state
   */
  var setState = function(state) {
    if (self.readyState !== state) {
      self.readyState = state;

      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {
        self.dispatchEvent("readystatechange");
      }

      if (self.readyState === self.DONE && !errorFlag) {
        self.dispatchEvent("load");
        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)
        self.dispatchEvent("loadend");
      }
    }
  };
};

}).call(this,require("/Users/blakeembrey/Projects/api-notebook/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),require("buffer").Buffer)
},{"child_process":1,"fs":1,"http":3,"https":7,"url":25}],56:[function(require,module,exports){
(function (global){
/*global unescape, module, define, window, global*/

/*
 UriTemplate Copyright (c) 2012-2013 Franz Antesberger. All Rights Reserved.
 Available via the MIT license.
*/

(function (exportCallback) {
    "use strict";

var UriTemplateError = (function () {

    function UriTemplateError (options) {
        this.options = options;
    }

    UriTemplateError.prototype.toString = function () {
        if (JSON && JSON.stringify) {
            return JSON.stringify(this.options);
        }
        else {
            return this.options;
        }
    };

    return UriTemplateError;
}());

var objectHelper = (function () {
    function isArray (value) {
        return Object.prototype.toString.apply(value) === '[object Array]';
    }

    function isString (value) {
        return Object.prototype.toString.apply(value) === '[object String]';
    }
    
    function isNumber (value) {
        return Object.prototype.toString.apply(value) === '[object Number]';
    }
    
    function isBoolean (value) {
        return Object.prototype.toString.apply(value) === '[object Boolean]';
    }
    
    function join (arr, separator) {
        var
            result = '',
            first = true,
            index;
        for (index = 0; index < arr.length; index += 1) {
            if (first) {
                first = false;
            }
            else {
                result += separator;
            }
            result += arr[index];
        }
        return result;
    }

    function map (arr, mapper) {
        var
            result = [],
            index = 0;
        for (; index < arr.length; index += 1) {
            result.push(mapper(arr[index]));
        }
        return result;
    }

    function filter (arr, predicate) {
        var
            result = [],
            index = 0;
        for (; index < arr.length; index += 1) {
            if (predicate(arr[index])) {
                result.push(arr[index]);
            }
        }
        return result;
    }

    function deepFreezeUsingObjectFreeze (object) {
        if (typeof object !== "object" || object === null) {
            return object;
        }
        Object.freeze(object);
        var property, propertyName;
        for (propertyName in object) {
            if (object.hasOwnProperty(propertyName)) {
                property = object[propertyName];
                // be aware, arrays are 'object', too
                if (typeof property === "object") {
                    deepFreeze(property);
                }
            }
        }
        return object;
    }

    function deepFreeze (object) {
        if (typeof Object.freeze === 'function') {
            return deepFreezeUsingObjectFreeze(object);
        }
        return object;
    }


    return {
        isArray: isArray,
        isString: isString,
        isNumber: isNumber,
        isBoolean: isBoolean,
        join: join,
        map: map,
        filter: filter,
        deepFreeze: deepFreeze
    };
}());

var charHelper = (function () {

    function isAlpha (chr) {
        return (chr >= 'a' && chr <= 'z') || ((chr >= 'A' && chr <= 'Z'));
    }

    function isDigit (chr) {
        return chr >= '0' && chr <= '9';
    }

    function isHexDigit (chr) {
        return isDigit(chr) || (chr >= 'a' && chr <= 'f') || (chr >= 'A' && chr <= 'F');
    }

    return {
        isAlpha: isAlpha,
        isDigit: isDigit,
        isHexDigit: isHexDigit
    };
}());

var pctEncoder = (function () {
    var utf8 = {
        encode: function (chr) {
            // see http://ecmanaut.blogspot.de/2006/07/encoding-decoding-utf8-in-javascript.html
            return unescape(encodeURIComponent(chr));
        },
        numBytes: function (firstCharCode) {
            if (firstCharCode <= 0x7F) {
                return 1;
            }
            else if (0xC2 <= firstCharCode && firstCharCode <= 0xDF) {
                return 2;
            }
            else if (0xE0 <= firstCharCode && firstCharCode <= 0xEF) {
                return 3;
            }
            else if (0xF0 <= firstCharCode && firstCharCode <= 0xF4) {
                return 4;
            }
            // no valid first octet
            return 0;
        },
        isValidFollowingCharCode: function (charCode) {
            return 0x80 <= charCode && charCode <= 0xBF;
        }
    };

    /**
     * encodes a character, if needed or not.
     * @param chr
     * @return pct-encoded character
     */
    function encodeCharacter (chr) {
        var
            result = '',
            octets = utf8.encode(chr),
            octet,
            index;
        for (index = 0; index < octets.length; index += 1) {
            octet = octets.charCodeAt(index);
            result += '%' + (octet < 0x10 ? '0' : '') + octet.toString(16).toUpperCase();
        }
        return result;
    }

    /**
     * Returns, whether the given text at start is in the form 'percent hex-digit hex-digit', like '%3F'
     * @param text
     * @param start
     * @return {boolean|*|*}
     */
    function isPercentDigitDigit (text, start) {
        return text.charAt(start) === '%' && charHelper.isHexDigit(text.charAt(start + 1)) && charHelper.isHexDigit(text.charAt(start + 2));
    }

    /**
     * Parses a hex number from start with length 2.
     * @param text a string
     * @param start the start index of the 2-digit hex number
     * @return {Number}
     */
    function parseHex2 (text, start) {
        return parseInt(text.substr(start, 2), 16);
    }

    /**
     * Returns whether or not the given char sequence is a correctly pct-encoded sequence.
     * @param chr
     * @return {boolean}
     */
    function isPctEncoded (chr) {
        if (!isPercentDigitDigit(chr, 0)) {
            return false;
        }
        var firstCharCode = parseHex2(chr, 1);
        var numBytes = utf8.numBytes(firstCharCode);
        if (numBytes === 0) {
            return false;
        }
        for (var byteNumber = 1; byteNumber < numBytes; byteNumber += 1) {
            if (!isPercentDigitDigit(chr, 3*byteNumber) || !utf8.isValidFollowingCharCode(parseHex2(chr, 3*byteNumber + 1))) {
                return false;
            }
        }
        return true;
    }

    /**
     * Reads as much as needed from the text, e.g. '%20' or '%C3%B6'. It does not decode!
     * @param text
     * @param startIndex
     * @return the character or pct-string of the text at startIndex
     */
    function pctCharAt(text, startIndex) {
        var chr = text.charAt(startIndex);
        if (!isPercentDigitDigit(text, startIndex)) {
            return chr;
        }
        var utf8CharCode = parseHex2(text, startIndex + 1);
        var numBytes = utf8.numBytes(utf8CharCode);
        if (numBytes === 0) {
            return chr;
        }
        for (var byteNumber = 1; byteNumber < numBytes; byteNumber += 1) {
            if (!isPercentDigitDigit(text, startIndex + 3 * byteNumber) || !utf8.isValidFollowingCharCode(parseHex2(text, startIndex + 3 * byteNumber + 1))) {
                return chr;
            }
        }
        return text.substr(startIndex, 3 * numBytes);
    }

    return {
        encodeCharacter: encodeCharacter,
        isPctEncoded: isPctEncoded,
        pctCharAt: pctCharAt
    };
}());

var rfcCharHelper = (function () {

    /**
     * Returns if an character is an varchar character according 2.3 of rfc 6570
     * @param chr
     * @return (Boolean)
     */
    function isVarchar (chr) {
        return charHelper.isAlpha(chr) || charHelper.isDigit(chr) || chr === '_' || pctEncoder.isPctEncoded(chr);
    }

    /**
     * Returns if chr is an unreserved character according 1.5 of rfc 6570
     * @param chr
     * @return {Boolean}
     */
    function isUnreserved (chr) {
        return charHelper.isAlpha(chr) || charHelper.isDigit(chr) || chr === '-' || chr === '.' || chr === '_' || chr === '~';
    }

    /**
     * Returns if chr is an reserved character according 1.5 of rfc 6570
     * or the percent character mentioned in 3.2.1.
     * @param chr
     * @return {Boolean}
     */
    function isReserved (chr) {
        return chr === ':' || chr === '/' || chr === '?' || chr === '#' || chr === '[' || chr === ']' || chr === '@' || chr === '!' || chr === '$' || chr === '&' || chr === '(' ||
            chr === ')' || chr === '*' || chr === '+' || chr === ',' || chr === ';' || chr === '=' || chr === "'";
    }

    return {
        isVarchar: isVarchar,
        isUnreserved: isUnreserved,
        isReserved: isReserved
    };

}());

/**
 * encoding of rfc 6570
 */
var encodingHelper = (function () {

    function encode (text, passReserved) {
        var
            result = '',
            index,
            chr = '';
        if (typeof text === "number" || typeof text === "boolean") {
            text = text.toString();
        }
        for (index = 0; index < text.length; index += chr.length) {
            chr = text.charAt(index);
            result += rfcCharHelper.isUnreserved(chr) || (passReserved && rfcCharHelper.isReserved(chr)) ? chr : pctEncoder.encodeCharacter(chr);
        }
        return result;
    }

    function encodePassReserved (text) {
        return encode(text, true);
    }

    function encodeLiteralCharacter (literal, index) {
        var chr = pctEncoder.pctCharAt(literal, index);
        if (chr.length > 1) {
            return chr;
        }
        else {
            return rfcCharHelper.isReserved(chr) || rfcCharHelper.isUnreserved(chr) ? chr : pctEncoder.encodeCharacter(chr);
        }
    }

    function encodeLiteral (literal) {
        var
            result = '',
            index,
            chr = '';
        for (index = 0; index < literal.length; index += chr.length) {
            chr = pctEncoder.pctCharAt(literal, index);
            if (chr.length > 1) {
                result += chr;
            }
            else {
                result += rfcCharHelper.isReserved(chr) || rfcCharHelper.isUnreserved(chr) ? chr : pctEncoder.encodeCharacter(chr);
            }
        }
        return result;
    }

    return {
        encode: encode,
        encodePassReserved: encodePassReserved,
        encodeLiteral: encodeLiteral,
        encodeLiteralCharacter: encodeLiteralCharacter
    };

}());


// the operators defined by rfc 6570
var operators = (function () {

    var
        bySymbol = {};

    function create (symbol) {
        bySymbol[symbol] = {
            symbol: symbol,
            separator: (symbol === '?') ? '&' : (symbol === '' || symbol === '+' || symbol === '#') ? ',' : symbol,
            named: symbol === ';' || symbol === '&' || symbol === '?',
            ifEmpty: (symbol === '&' || symbol === '?') ? '=' : '',
            first: (symbol === '+' ) ? '' : symbol,
            encode: (symbol === '+' || symbol === '#') ? encodingHelper.encodePassReserved : encodingHelper.encode,
            toString: function () {
                return this.symbol;
            }
        };
    }

    create('');
    create('+');
    create('#');
    create('.');
    create('/');
    create(';');
    create('?');
    create('&');
    return {
        valueOf: function (chr) {
            if (bySymbol[chr]) {
                return bySymbol[chr];
            }
            if ("=,!@|".indexOf(chr) >= 0) {
                return null;
            }
            return bySymbol[''];
        }
    };
}());


/**
 * Detects, whether a given element is defined in the sense of rfc 6570
 * Section 2.3 of the RFC makes clear defintions:
 * * undefined and null are not defined.
 * * the empty string is defined
 * * an array ("list") is defined, if it is not empty (even if all elements are not defined)
 * * an object ("map") is defined, if it contains at least one property with defined value
 * @param object
 * @return {Boolean}
 */
function isDefined (object) {
    var
        propertyName;
    if (object === null || object === undefined) {
        return false;
    }
    if (objectHelper.isArray(object)) {
        // Section 2.3: A variable defined as a list value is considered undefined if the list contains zero members
        return object.length > 0;
    }
    if (typeof object === "string" || typeof object === "number" || typeof object === "boolean") {
        // falsy values like empty strings, false or 0 are "defined"
        return true;
    }
    // else Object
    for (propertyName in object) {
        if (object.hasOwnProperty(propertyName) && isDefined(object[propertyName])) {
            return true;
        }
    }
    return false;
}

var LiteralExpression = (function () {
    function LiteralExpression (literal) {
        this.literal = encodingHelper.encodeLiteral(literal);
    }

    LiteralExpression.prototype.expand = function () {
        return this.literal;
    };

    LiteralExpression.prototype.toString = LiteralExpression.prototype.expand;

    return LiteralExpression;
}());

var parse = (function () {

    function parseExpression (expressionText) {
        var
            operator,
            varspecs = [],
            varspec = null,
            varnameStart = null,
            maxLengthStart = null,
            index,
            chr = '';

        function closeVarname () {
            var varname = expressionText.substring(varnameStart, index);
            if (varname.length === 0) {
                throw new UriTemplateError({expressionText: expressionText, message: "a varname must be specified", position: index});
            }
            varspec = {varname: varname, exploded: false, maxLength: null};
            varnameStart = null;
        }

        function closeMaxLength () {
            if (maxLengthStart === index) {
                throw new UriTemplateError({expressionText: expressionText, message: "after a ':' you have to specify the length", position: index});
            }
            varspec.maxLength = parseInt(expressionText.substring(maxLengthStart, index), 10);
            maxLengthStart = null;
        }

        operator = (function (operatorText) {
            var op = operators.valueOf(operatorText);
            if (op === null) {
                throw new UriTemplateError({expressionText: expressionText, message: "illegal use of reserved operator", position: index, operator: operatorText});
            }
            return op;
        }(expressionText.charAt(0)));
        index = operator.symbol.length;

        varnameStart = index;

        for (; index < expressionText.length; index += chr.length) {
            chr = pctEncoder.pctCharAt(expressionText, index);

            if (varnameStart !== null) {
                // the spec says: varname =  varchar *( ["."] varchar )
                // so a dot is allowed except for the first char
                if (chr === '.') {
                    if (varnameStart === index) {
                        throw new UriTemplateError({expressionText: expressionText, message: "a varname MUST NOT start with a dot", position: index});
                    }
                    continue;
                }
                if (rfcCharHelper.isVarchar(chr)) {
                    continue;
                }
                closeVarname();
            }
            if (maxLengthStart !== null) {
                if (index === maxLengthStart && chr === '0') {
                    throw new UriTemplateError({expressionText: expressionText, message: "A :prefix must not start with digit 0", position: index});
                }
                if (charHelper.isDigit(chr)) {
                    if (index - maxLengthStart >= 4) {
                        throw new UriTemplateError({expressionText: expressionText, message: "A :prefix must have max 4 digits", position: index});
                    }
                    continue;
                }
                closeMaxLength();
            }
            if (chr === ':') {
                if (varspec.maxLength !== null) {
                    throw new UriTemplateError({expressionText: expressionText, message: "only one :maxLength is allowed per varspec", position: index});
                }
                if (varspec.exploded) {
                    throw new UriTemplateError({expressionText: expressionText, message: "an exploeded varspec MUST NOT be varspeced", position: index});
                }
                maxLengthStart = index + 1;
                continue;
            }
            if (chr === '*') {
                if (varspec === null) {
                    throw new UriTemplateError({expressionText: expressionText, message: "exploded without varspec", position: index});
                }
                if (varspec.exploded) {
                    throw new UriTemplateError({expressionText: expressionText, message: "exploded twice", position: index});
                }
                if (varspec.maxLength) {
                    throw new UriTemplateError({expressionText: expressionText, message: "an explode (*) MUST NOT follow to a prefix", position: index});
                }
                varspec.exploded = true;
                continue;
            }
            // the only legal character now is the comma
            if (chr === ',') {
                varspecs.push(varspec);
                varspec = null;
                varnameStart = index + 1;
                continue;
            }
            throw new UriTemplateError({expressionText: expressionText, message: "illegal character", character: chr, position: index});
        } // for chr
        if (varnameStart !== null) {
            closeVarname();
        }
        if (maxLengthStart !== null) {
            closeMaxLength();
        }
        varspecs.push(varspec);
        return new VariableExpression(expressionText, operator, varspecs);
    }

    function parse (uriTemplateText) {
        // assert filled string
        var
            index,
            chr,
            expressions = [],
            braceOpenIndex = null,
            literalStart = 0;
        for (index = 0; index < uriTemplateText.length; index += 1) {
            chr = uriTemplateText.charAt(index);
            if (literalStart !== null) {
                if (chr === '}') {
                    throw new UriTemplateError({templateText: uriTemplateText, message: "unopened brace closed", position: index});
                }
                if (chr === '{') {
                    if (literalStart < index) {
                        expressions.push(new LiteralExpression(uriTemplateText.substring(literalStart, index)));
                    }
                    literalStart = null;
                    braceOpenIndex = index;
                }
                continue;
            }

            if (braceOpenIndex !== null) {
                // here just { is forbidden
                if (chr === '{') {
                    throw new UriTemplateError({templateText: uriTemplateText, message: "brace already opened", position: index});
                }
                if (chr === '}') {
                    if (braceOpenIndex + 1 === index) {
                        throw new UriTemplateError({templateText: uriTemplateText, message: "empty braces", position: braceOpenIndex});
                    }
                    try {
                        expressions.push(parseExpression(uriTemplateText.substring(braceOpenIndex + 1, index)));
                    }
                    catch (error) {
                        if (error.prototype === UriTemplateError.prototype) {
                            throw new UriTemplateError({templateText: uriTemplateText, message: error.options.message, position: braceOpenIndex + error.options.position, details: error.options});
                        }
                        throw error;
                    }
                    braceOpenIndex = null;
                    literalStart = index + 1;
                }
                continue;
            }
            throw new Error('reached unreachable code');
        }
        if (braceOpenIndex !== null) {
            throw new UriTemplateError({templateText: uriTemplateText, message: "unclosed brace", position: braceOpenIndex});
        }
        if (literalStart < uriTemplateText.length) {
            expressions.push(new LiteralExpression(uriTemplateText.substr(literalStart)));
        }
        return new UriTemplate(uriTemplateText, expressions);
    }

    return parse;
}());

var VariableExpression = (function () {
    // helper function if JSON is not available
    function prettyPrint (value) {
        return (JSON && JSON.stringify) ? JSON.stringify(value) : value;
    }

    function isEmpty (value) {
        if (!isDefined(value)) {
            return true;
        }
        if (objectHelper.isString(value)) {
            return value === '';
        }
        if (objectHelper.isNumber(value) || objectHelper.isBoolean(value)) {
            return false;
        }
        if (objectHelper.isArray(value)) {
            return value.length === 0;
        }
        for (var propertyName in value) {
            if (value.hasOwnProperty(propertyName)) {
                return false;
            }
        }
        return true;
    }

    function propertyArray (object) {
        var
            result = [],
            propertyName;
        for (propertyName in object) {
            if (object.hasOwnProperty(propertyName)) {
                result.push({name: propertyName, value: object[propertyName]});
            }
        }
        return result;
    }

    function VariableExpression (templateText, operator, varspecs) {
        this.templateText = templateText;
        this.operator = operator;
        this.varspecs = varspecs;
    }

    VariableExpression.prototype.toString = function () {
        return this.templateText;
    };

    function expandSimpleValue(varspec, operator, value) {
        var result = '';
        value = value.toString();
        if (operator.named) {
            result += encodingHelper.encodeLiteral(varspec.varname);
            if (value === '') {
                result += operator.ifEmpty;
                return result;
            }
            result += '=';
        }
        if (varspec.maxLength !== null) {
            value = value.substr(0, varspec.maxLength);
        }
        result += operator.encode(value);
        return result;
    }

    function valueDefined (nameValue) {
        return isDefined(nameValue.value);
    }

    function expandNotExploded(varspec, operator, value) {
        var
            arr = [],
            result = '';
        if (operator.named) {
            result += encodingHelper.encodeLiteral(varspec.varname);
            if (isEmpty(value)) {
                result += operator.ifEmpty;
                return result;
            }
            result += '=';
        }
        if (objectHelper.isArray(value)) {
            arr = value;
            arr = objectHelper.filter(arr, isDefined);
            arr = objectHelper.map(arr, operator.encode);
            result += objectHelper.join(arr, ',');
        }
        else {
            arr = propertyArray(value);
            arr = objectHelper.filter(arr, valueDefined);
            arr = objectHelper.map(arr, function (nameValue) {
                return operator.encode(nameValue.name) + ',' + operator.encode(nameValue.value);
            });
            result += objectHelper.join(arr, ',');
        }
        return result;
    }

    function expandExplodedNamed (varspec, operator, value) {
        var
            isArray = objectHelper.isArray(value),
            arr = [];
        if (isArray) {
            arr = value;
            arr = objectHelper.filter(arr, isDefined);
            arr = objectHelper.map(arr, function (listElement) {
                var tmp = encodingHelper.encodeLiteral(varspec.varname);
                if (isEmpty(listElement)) {
                    tmp += operator.ifEmpty;
                }
                else {
                    tmp += '=' + operator.encode(listElement);
                }
                return tmp;
            });
        }
        else {
            arr = propertyArray(value);
            arr = objectHelper.filter(arr, valueDefined);
            arr = objectHelper.map(arr, function (nameValue) {
                var tmp = encodingHelper.encodeLiteral(nameValue.name);
                if (isEmpty(nameValue.value)) {
                    tmp += operator.ifEmpty;
                }
                else {
                    tmp += '=' + operator.encode(nameValue.value);
                }
                return tmp;
            });
        }
        return objectHelper.join(arr, operator.separator);
    }

    function expandExplodedUnnamed (operator, value) {
        var
            arr = [],
            result = '';
        if (objectHelper.isArray(value)) {
            arr = value;
            arr = objectHelper.filter(arr, isDefined);
            arr = objectHelper.map(arr, operator.encode);
            result += objectHelper.join(arr, operator.separator);
        }
        else {
            arr = propertyArray(value);
            arr = objectHelper.filter(arr, function (nameValue) {
                return isDefined(nameValue.value);
            });
            arr = objectHelper.map(arr, function (nameValue) {
                return operator.encode(nameValue.name) + '=' + operator.encode(nameValue.value);
            });
            result += objectHelper.join(arr, operator.separator);
        }
        return result;
    }


    VariableExpression.prototype.expand = function (variables) {
        var
            expanded = [],
            index,
            varspec,
            value,
            valueIsArr,
            oneExploded = false,
            operator = this.operator;

        // expand each varspec and join with operator's separator
        for (index = 0; index < this.varspecs.length; index += 1) {
            varspec = this.varspecs[index];
            value = variables[varspec.varname];
            // if (!isDefined(value)) {
            // if (variables.hasOwnProperty(varspec.name)) {
            if (value === null || value === undefined) {
                continue;
            }
            if (varspec.exploded) {
                oneExploded = true;
            }
            valueIsArr = objectHelper.isArray(value);
            if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
                expanded.push(expandSimpleValue(varspec, operator, value));
            }
            else if (varspec.maxLength && isDefined(value)) {
                // 2.4.1 of the spec says: "Prefix modifiers are not applicable to variables that have composite values."
                throw new Error('Prefix modifiers are not applicable to variables that have composite values. You tried to expand ' + this + " with " + prettyPrint(value));
            }
            else if (!varspec.exploded) {
                if (operator.named || !isEmpty(value)) {
                    expanded.push(expandNotExploded(varspec, operator, value));
                }
            }
            else if (isDefined(value)) {
                if (operator.named) {
                    expanded.push(expandExplodedNamed(varspec, operator, value));
                }
                else {
                    expanded.push(expandExplodedUnnamed(operator, value));
                }
            }
        }

        if (expanded.length === 0) {
            return "";
        }
        else {
            return operator.first + objectHelper.join(expanded, operator.separator);
        }
    };

    return VariableExpression;
}());

var UriTemplate = (function () {
    function UriTemplate (templateText, expressions) {
        this.templateText = templateText;
        this.expressions = expressions;
        objectHelper.deepFreeze(this);
    }

    UriTemplate.prototype.toString = function () {
        return this.templateText;
    };

    UriTemplate.prototype.expand = function (variables) {
        // this.expressions.map(function (expression) {return expression.expand(variables);}).join('');
        var
            index,
            result = '';
        for (index = 0; index < this.expressions.length; index += 1) {
            result += this.expressions[index].expand(variables);
        }
        return result;
    };

    UriTemplate.parse = parse;
    UriTemplate.UriTemplateError = UriTemplateError;
    return UriTemplate;
}());

    exportCallback(UriTemplate);

}(function (UriTemplate) {
        "use strict";
        // export UriTemplate, when module is present, or pass it to window or global
        if (typeof module !== "undefined") {
            module.exports = UriTemplate;
        }
        else if (typeof define === "function") {
            define([],function() {
                return UriTemplate;
            });
        }
        else if (typeof window !== "undefined") {
            window.UriTemplate = UriTemplate;
        }
        else {
            global.UriTemplate = UriTemplate;
        }
    }
));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],57:[function(require,module,exports){
/**
 * Accepts an array of strings that represent a reference to a value on an
 * object. Supports passing an optional setter, to set the value.
 *
 * @param  {Object} object
 * @param  {Array}  path
 * @param  {*}      [setter]
 * @return {*}
 */
module.exports = function (object, path, setter) {
  var isSetter = arguments.length > 2;

  for (var i = 0; i < path.length; i++) {
    var prop = path[i];

    if (isSetter) {
      if (i === path.length - 1) {
        object[prop] = setter;
      } else if (!(prop in object)) {
        object[prop] = {};
      }
    }

    object = object[prop];
  }

  // Return the updated object reference.
  return object;
};

},{}],58:[function(require,module,exports){
/* global App */
var _     = App.Library._;
var async = App.Library.async;

/**
 * Map authentication types to automatic preference.
 *
 * @type {Array}
 */
var ORDER_PREFERENCE = ['OAuth 2.0', 'OAuth 1.0', 'Basic Authentication'];

/**
 * Returns an object of available keys and whether they are required.
 *
 * @param  {Object} scheme
 * @return {Object}
 */
var requiredTokens = function (scheme) {
  var keys = _.extend({}, requiredTokens.defaults[scheme.type]);

  // Special case is required for OAuth2 implicit auth flow.
  if (scheme.type === 'OAuth 2.0') {
    keys.clientSecret = !_.contains(
      scheme.settings.authorizationGrants, 'token'
    );
  }

  return keys;
};

/**
 * Sanitize scopes to be an array.
 *
 * @param  {*}     scopes
 * @return {Array}
 */
var sanitizeScope = function (scopes) {
  if (_.isString(scopes)) {
    return scopes.split(' ');
  }

  if (!Array.isArray(scopes)) {
    return [];
  }

  return scopes;
};

/**
 * Required authentication keys used to check the options object.
 *
 * @type {Object}
 */
requiredTokens.defaults = {
  'OAuth 1.0': {
    consumerKey:    true,
    consumerSecret: true
  },
  'OAuth 2.0': {
    clientId:     true,
    clientSecret: true
  },
  'Basic Authentication': {
    username: true,
    password: true
  }
};

/**
 * Check the tokens object against the required tokens.
 *
 * @param  {Object}  scheme
 * @param  {Object}  tokens
 * @return {Boolean}
 */
var hasRequiredTokens = function (scheme, tokens) {
  // Iterate over the required tokens and check that the token is defined.
  return _.every(requiredTokens(scheme), function (value, key) {
    return value ? tokens[key] : true;
  });
};

/**
 * Prompt the user for authentication tokens based on a scheme. We can pass in
 * the current options object to help decide what data to display to the user.
 *
 * @param {Object}   scheme
 * @param {Object}   options
 * @param {Function} done
 */
var promptTokens = function (scheme, options, done) {
  var cancelled   = true;
  var needsTokens = requiredTokens(scheme);

  // Generate an array of the tokens to use with our prompt and filter
  // explicitly not required tokens.
  var possibleTokens = _.filter(
    promptTokens.possibleTokens[scheme.type],
    function (token) {
      return needsTokens[token] !== false;
    }
  );

  // Multiple ways of setting the scope option.
  options.scopes = sanitizeScope(options.scope || options.scopes);
  delete options.scope;

  // Generate the form to prompt the user with.
  var promptForm = _.map(possibleTokens, function (key) {
    if (key === 'scopes') {
      var scopes = sanitizeScope(scheme.settings.scopes);

      // Ignore the scopes selection when nothing is available for selection.
      if (!scopes.length) {
        return '';
      }

      // Map scopes to checkbox selections.
      var scopeOptions = _.map(scopes, function (scope) {
        // Check if the scope is already in the selected scopes. If there is
        // only one possible scope, just select it by default anyway.
        var hasScope = _.contains(options.scopes, scope) || scopes.length === 1;

        return [
          '<div class="checkbox">',
          '<label>',
          '<input type="checkbox" id="scopes" value="' + scope + '" ' +
            (hasScope ? 'checked' : '') + '>',
          scope,
          '</label>',
          '</div>'
        ].join('');
      }).join('\n');

      return [
        '<div class="form-group">',
        '<label class="form-label">' + promptTokens.titles[key] + '</label>',
        '<div class="form-content">' + scopeOptions + '</div>',
        '</div>'
      ].join('\n');
    }

    // By default we show the user an input field to input their keys.
    return [
      '<div class="form-group">',
      '<label for="' + key + '" class="form-label">',
      promptTokens.titles[key],
      '</label>',
      '<div class="form-content">',
      '<input id="' + key + '" value="' + (options[key] || '') + '">',
      '</div>',
      '</div>'
    ].join('');
  }).join('\n');

  return App.middleware.trigger('ui:modal', {
    title: promptTokens.prompts[scheme.type],
    content: [
      '<p>',
      'This API requires authentication. Please enter your application keys.',
      '</p>',
      '<p><em>We will not store your keys.</em></p>',
      '<form>',
      promptForm,
      '<div class="form-footer">',
      '<button type="submit" class="btn btn-primary">Submit</button>',
      '</div>',
      '</form>'
    ].join('\n'),
    show: function (modal) {
      modal.el.querySelector('form')
        .addEventListener('submit', function (e) {
          e.preventDefault();

          _.each(this.querySelectorAll('input'), function (el) {
            var name = el.getAttribute('id');

            if (name === 'scopes') {
              var indexOf = _.indexOf(options.scopes, el.value);

              if (el.checked) {
                if (indexOf < 0) {
                  options.scopes.push(el.value);
                }
              } else {
                if (indexOf > -1) {
                  options.scopes.splice(indexOf, 1);
                }
              }
            } else {
              options[name] = el.value.trim();
            }
          });

          cancelled = false;
          modal.close();
        });
    }
  }, function (err) {
    return done(err || (cancelled ? new Error('Modal closed') : null), options);
  });
};

/**
 * Default authentication prompt titles.
 *
 * @type {Object}
 */
promptTokens.prompts = {
  'OAuth 1.0':            'Please Enter Your OAuth 1.0 Keys',
  'OAuth 2.0':            'Please Enter Your OAuth 2.0 Keys',
  'Basic Authentication': 'Please Enter Your Username and Password'
};

/**
 * Map of object keys to their readable names.
 *
 * @type {Object}
 */
promptTokens.titles = {
  consumerKey:    'Consumer Key',
  consumerSecret: 'Consumer Secret',
  clientId:       'Client ID',
  clientSecret:   'Client Secret',
  scopes:         'Permissions',
  username:       'Username',
  password:       'Password'
};

/**
 * Possible tokens to be filled out by the user.
 *
 * @type {Object}
 */
promptTokens.possibleTokens = {
  'OAuth 1.0':            ['consumerKey', 'consumerSecret'],
  'OAuth 2.0':            ['clientId', 'clientSecret', 'scopes'],
  'Basic Authentication': ['username', 'password']
};

/**
 * Authenticate using an authentication scheme and passed in options.
 *
 * @param  {Object}   scheme
 * @param  {Object}   options
 * @param  {Function} done
 */
var authenticate = function (scheme, options, done) {
  App.middleware.trigger('authenticate', _.extend({
    type: scheme.type
  }, scheme.settings, options), function (err, tokens) {
    if (!tokens) {
      return done(new Error('Authentication failed'));
    }

    return done(err, scheme, options, tokens);
  }, true);
};

/**
 * Request authentication credentials from a third-party source.
 *
 * @param {Object}   scheme
 * @param {Function} done
 */
var requestTokens = function (scheme, done) {
  return App.middleware.trigger('ramlClient:token', scheme, done, true);
};

/**
 * Return the preferred scheme option from an object of every scheme.
 *
 * @param  {Object} schemes
 * @return {Object}
 */
var preferredScheme = function (schemes) {
  var method = _.intersection(ORDER_PREFERENCE, _.pluck(schemes, 'type'))[0];

  // Return an essentially random but consistent scheme.
  if (!method) {
    return schemes[_.keys(schemes)[0]];
  }

  // Find the scheme that matched our preferred method.
  return _.find(schemes, function (scheme) {
    return scheme.type === method;
  });
};

/**
 * Retrieve authentication tokens and method any way possible. It will attempt
 * to resolve automatically. If that is not possible, it will defer to
 * prompting the user.
 *
 * @param {Object}   schemes
 * @param {Function} done
 */
var retrieveTokens = function (schemes, done) {
  var tokens;

  // Attempt to get the first resolving set of access tokens.
  async.detectSeries(_.map(schemes, function (secured, method) {
    return schemes[method];
  }), function (scheme, cb) {
    return requestTokens(scheme, function (err, data) {
      if (err || !data || !hasRequiredTokens(scheme, data)) {
        return cb(false);
      }

      return cb(tokens = data);
    });
  }, function (scheme) {
    if (!scheme) {
      scheme = preferredScheme(schemes);

      return promptTokens(scheme, {}, function (err, tokens) {
        return done(err, scheme, tokens);
      });
    }

    return done(null, scheme, tokens);
  });
};

/**
 * Attempt to magically resolve to the first working authentication method. If
 * we fail, we need to fall back to manual authentication options with the
 * optimal authentication scheme available.
 *
 * @param {Object}   schemes
 * @param {Function} done
 */
var resolveScheme = function (schemes, done) {
  return retrieveTokens(schemes, function (err, scheme, tokens) {
    if (err) { return done(err); }

    return authenticate(scheme, tokens, done);
  });
};

/**
 * Export a function that will contain all the logic for automagically
 * selecting an appropriate authentication method and prompting the user
 * for the following steps.
 *
 * @param {Object}   schemes
 * @param {String}   method
 * @param {Object}   options
 * @param {Function} done
 */
module.exports = function (schemes, method, options, done) {
  // If no authentication method has been passed in, attempt to pick our own.
  if (!method) {
    return resolveScheme(schemes, done);
  }

  // Ensure we are attempting to authenticate with a valid method.
  if (!Object.prototype.hasOwnProperty.call(schemes, method)) {
    return done(new Error(
      'The only available authentication methods are: ' +
      _.keys(schemes).map(JSON.stringify).join(', ')
    ));
  }

  var scheme = schemes[method];
  var auth   = _.extend({}, options);

  // If we don't have all the required tokens available, prompt the user to
  // input tokens and continue authenticating.
  if (!hasRequiredTokens(scheme, auth)) {
    return requestTokens(scheme, function (err, data) {
      if (err) { return done(err); }

      // Don't prompt for the tokens if we managed to retrieve them anyway.
      if (hasRequiredTokens(scheme, _.extend(auth, data))) {
        return authenticate(scheme, auth, done);
      }

      return promptTokens(scheme, auth, function (err, tokens) {
        if (err) { return done(err); }

        return authenticate(scheme, tokens, done);
      });
    });
  }

  // Finally we have everything we need and can initiate authentication.
  return authenticate(scheme, auth, done);
};

},{}],59:[function(require,module,exports){
/* global App */
var _           = App.Library._;
var qs          = App.Library.qs;
var mime        = require('mime-component');
var escape      = require('escape-regexp');
var parser      = require('uritemplate');
var sanitizeAST = require('./sanitize-ast');

var CONFIG_PROPERTY = '!config';
var CLIENT_PROPERTY = '!client';

var JSON_REGEXP = /^application\/([\w!#\$%&\*`\-\.\^~]*\+)?json$/i;

var HTTP_METHODS         = ['get', 'head', 'put', 'post', 'patch', 'delete'];
var RETURN_PROPERTY      = '!return';
var DESCRIPTION_PROPERTY = '!description';
var CONFIG_OPTIONS       = [
  'body', 'proxy', 'uriParameters', 'baseUriParameters', 'headers', 'query'
];
var OVERRIDABLE_CONFIG_OPTIONS = _.object(['body', 'proxy'], true);

/**
 * Static description of the media type extension function.
 *
 * @type {Object}
 */
var EXTENSION_DESCRIPTION = {
  '!type': 'fn(extension)',
  '!args': [{
    '!type': 'string',
    '!doc': 'Set the file extension with relevant `Accept` header.'
  }],
  '!doc': [
    'Set the path extension and corresponding accept header.'
  ].join(' ')
};

/**
 * Static description of the client object.
 *
 * @type {Object}
 */
var CLIENT_DESCRIPTION = {
  '!type': 'fn(url, data?)',
  '!args': [{
    '!type': 'string',
    '!doc': 'Provide a url relative to the base uri.'
  }, {
    '!type': 'object',
    '!doc': 'Provide a data object to replace template tags in the `url`.'
  }],
  '!doc': [
    'Make an API request to a custom URL.'
  ].join(' ')
};

/**
 * Map the supported auth types to the known triggers.
 *
 * @type {Object}
 */
var authMap = {
  'OAuth 1.0':            'oauth1',
  'OAuth 2.0':            'oauth2',
  'Basic Authentication': 'basicAuth'
};

/**
 * Accepts a params object and transforms it into a regex for matching the
 * tokens in the route.
 *
 * @param  {Object} params
 * @return {RegExp}
 */
var uriParamRegex = function (params) {
  // Transform the params into a regular expression for matching.
  return new RegExp('{(' + _.map(_.keys(params), escape).join('|') + ')}', 'g');
};

/**
 * Simple "template" function for working with the uri param variables.
 *
 * @param  {String}       template
 * @param  {Object}       params
 * @param  {Object|Array} context
 * @return {String}
 */
var template = function (string, params, context) {
  // If the context is an array, we need to transform the replacements into
  // index based positions for the uri template parser.
  if (_.isArray(context)) {
    var index = 0;

    string = string.replace(uriParamRegex(params), function () {
      return '{' + (index++) + '}';
    });
  }

  return parser.parse(string).expand(context);
};

/**
 * Check if a method is a query method (not a body as the argument).
 *
 * @param  {String}  method
 * @return {Boolean}
 */
var isQueryMethod = function (method) {
  return method === 'get' || method === 'head';
};

/**
 * Map of methods to their tooltip description objects.
 *
 * @type {Object}
 */
var METHOD_DESCRIPTION = _.object(_.map(HTTP_METHODS, function (method) {
  var argument = isQueryMethod(method) ? 'query?' : 'body?';

  return [method, {
    '!type': 'fn(' + argument + ', options?, async?)'
  }];
}));

/**
 * Convert the RAML documentation to a string.
 *
 * @param  {Object} object
 * @return {String}
 */
var toMarkdownDescription = function (object, name) {
  var title = '**' + name + (object.required ? '' : '?') + ':** ';

  // If a type is available, italicise after the name.
  if (object.type) {
    title += '*' + object.type + '* ';
  }

  return title + (object.description || '');
};

/**
 * Transform a RAML method object into a tooltip documentation object.
 *
 * @param  {Array}  nodes
 * @param  {Object} method
 * @return {Object}
 */
var toMethodDescription = function (nodes, method) {
  var args    = [];
  var config  = [];
  var body    = '';
  var isQuery = isQueryMethod(method.method);
  var documentation;

  if (method.queryParameters) {
    documentation = _.map(method.queryParameters, function (query, name) {
      return '* ' + toMarkdownDescription(query, name);
    }).join('\n');

    if (isQuery) {
      body = documentation;
    } else {
      config.push('**query**', documentation);
    }
  }

  if (method.headers) {
    config.push(
      '**headers:**',
      _.map(method.headers, function (header, name) {
        return '* ' + toMarkdownDescription(header, name);
      }).join('\n')
    );
  }

  if (method.body) {
    documentation = _.map(method.body, function (body, contentType) {
      var title  = '**' + contentType + ':** ';
      var description;

      // Map form parameters to their descriptions.
      if (body) {
        description = _.map(
          body.formParameters, function (param, name) {
            return '* * ' + toMarkdownDescription(param, name);
          }
        ).join('\n');
      }

      return '* ' + title + (description ? '\n' + description : '?');
    }).join('\n');

    if (isQuery) {
      config.push('**body**', documentation);
    } else {
      body = documentation;
    }
  }

  if (nodes.client.baseUriParameters) {
    config.push(
      '**baseUriParameters**',
      _.map(nodes.client.baseUriParameters, function (param, name) {
        return '* ' + toMarkdownDescription(param, name);
      }).join('\n')
    );
  }

  config.push(
    '**proxy**', '*boolean* Disable the proxy for the current request.'
  );

  args.push({
    '!doc': body,
    '!type': 'object'
  }, {
    '!doc': config.join('\n\n'),
    '!type': 'object'
  }, {
    '!doc': 'Pass a function to make the request execute asynchonously.',
    '!type': 'fn(error, response)'
  });

  return _.extend({
    '!doc': method.description,
    '!args': args
  }, METHOD_DESCRIPTION[method.method]);
};

/**
 * List of all plain HTTP methods in the format from the AST.
 *
 * @type {Object}
 */
var allHttpMethods = _.chain(HTTP_METHODS).map(function (method) {
    return [method, {
      method: method
    }];
  }).object().value();

/**
 * Parse an XHR request for response headers and return as an object. Pass an
 * additional flag to filter any potential duplicate headers (E.g. different
 * cases).
 *
 * @param  {Object} xhr
 * @return {Object}
 */
var getAllReponseHeaders = function (xhr) {
  var responseHeaders = {};

  _.each(xhr.getAllResponseHeaders().split('\n'), function (header) {
    header = header.split(':');

    // Make sure we have both parts of the header.
    if (header.length > 1) {
      var name  = header.shift();
      var value = header.join(':').trim();

      responseHeaders[name.toLowerCase()] = value;
    }
  });

  return responseHeaders;
};

/**
 * Return the xhr response mime type.
 *
 * @param  {String} contentType
 * @return {String}
 */
var getMime = function (contentType) {
  return (contentType || '').split(';')[0];
};

/**
 * Check if an object is a host object and avoid serializing.
 *
 * @param  {Object}  obj
 * @return {Boolean}
 */
var isHost = function (obj) {
  var str = Object.prototype.toString.call(obj);

  switch (str) {
    case '[object File]':
    case '[object Blob]':
    case '[object String]':
    case '[object Number]':
    case '[object Boolean]':
    case '[object FormData]':
      return true;
    default:
      return false;
  }
};

/**
 * Transform a data object into a form data instance.
 *
 * @param  {Object}   data
 * @return {FormData}
 */
var toFormData = function (data) {
  var form = new FormData();

  // Iterate over every piece of data and append to the form data object.
  _.each(data, function (value, key) {
    form.append(key, value);
  });

  return form;
};

/**
 * Map mime types to their parsers.
 *
 * @type {Object}
 */
var parse = [
  [JSON_REGEXP, JSON.parse],
  ['application/x-www-form-urlencoded', qs.parse]
];

/**
 * Map mime types to their serializers.
 *
 * @type {Object}
 */
var serialize = [
  [JSON_REGEXP, JSON.stringify],
  ['application/x-www-form-urlencoded', qs.stringify],
  ['multipart/form-data', toFormData]
];

/**
 * Iterate over an array of match and result values, and return the
 * first matching value.
 *
 * @param  {Array}    array
 * @param  {String}   test
 * @return {Function}
 */
var getMatch = function (array, test) {
  var match = _.find(array, function (value) {
    var check = value[0];

    if (_.isRegExp(check)) {
      return check.test(test);
    }

    return check === test;
  });

  return match && match[1];
};

/**
 * Sanitize a specific configuration option.
 *
 * @type {Object}
 */
var sanitizeOption = {
  query: function (query) {
    if (_.isString(query)) {
      return qs.parse(query);
    }

    return query;
  }
};

/**
 * Gets a header from the header object.
 *
 * @param  {Object}  headers
 * @param  {String}  header
 * @return {Boolean}
 */
var findHeader = function (headers, header) {
  header = header.toLowerCase();

  return _.find(headers, function (value, name) {
    return name.toLowerCase() === header;
  });
};

/**
 * Sanitize the XHR request into the desired format.
 *
 * @param  {XMLHttpRequest} xhr
 * @return {Object}
 */
var sanitizeXHR = function (xhr) {
  if (!xhr) { return xhr; }

  var mime    = getMime(xhr.getResponseHeader('Content-Type'));
  var body    = xhr.responseText;
  var headers = getAllReponseHeaders(xhr);

  // Automatically parse certain response types.
  body = (getMatch(parse, mime) || _.identity)(body);

  return {
    body:    body,
    status:  xhr.status,
    headers: headers
  };
};

/**
 * Returns a function that can be used to make ajax requests.
 *
 * @param  {String}   url
 * @return {Function}
 */
var httpRequest = function (nodes, method) {
  return function (body, config, done) {
    // Allow config to be omitted from arguments.
    if (_.isFunction(arguments[1])) {
      done   = arguments[1];
      config = null;
    }

    // Map configuration options and merge with the passed in object.
    config = _.object(CONFIG_OPTIONS, _.map(CONFIG_OPTIONS, function (option) {
      if (_.has(OVERRIDABLE_CONFIG_OPTIONS, option)) {
        return config && option in config ?
          config[option] : nodes.config[option];
      }

      var nodeOption   = nodes.config[option];
      var configOption = config && config[option];
      var sanitize     = sanitizeOption[option] || _.identity;

      return _.extend({}, sanitize(nodeOption), sanitize(configOption));
    }));

    var async   = !!done;
    var request = 'ajax';
    var mime    = getMime(findHeader(config.headers, 'Content-Type'));
    var baseUri = template(nodes.client.baseUri, {}, config.baseUriParameters);
    var fullUri = baseUri + '/' + nodes.join('/');

    // GET and HEAD requests accept the query string as the first argument.
    if (isQueryMethod(method.method)) {
      _.extend(config.query, sanitizeOption.query(body));
      body = null;
    }

    // Set the config object body to the passed in body.
    if (body != null) {
      config.body = body;
    }

    // Append the query string if one is available.
    if (_.keys(config.query).length) {
      fullUri += '?' + qs.stringify(config.query);
    }

    // Set the correct `Content-Type` header, if none exists. Kind of random if
    // more than one exists - in that case I would suggest setting it yourself.
    if (!mime && typeof method.body === 'object') {
      config.headers['content-type'] = mime = _.keys(method.body).pop();
    }

    // If we have no accept header set already, default to accepting
    // everything. This is required because Firefox sets the base accept
    // header to essentially be `html/xml`.
    if (!findHeader(config.headers, 'accept')) {
      config.headers.accept = '*/*';
    }

    // If we were passed in data, attempt to sanitize it to the correct type.
    if (!isHost(config.body)) {
      var serializer = getMatch(serialize, mime || 'application/json');

      if (!serializer) {
        return done(
          new TypeError('Can not serialize content type of "' + mime + '"')
        );
      }

      try {
        config.body = serializer(config.body);
      } catch (e) {
        return done(new TypeError('Could not serialize body: ' + e.message));
      }
    }

    var options = {
      url:     fullUri,
      data:    config.body,
      async:   async,
      proxy:   config.proxy,
      method:  method.method,
      headers: config.headers
    };

    // Iterate through `securedBy` methods and accept the first one we are
    // already authenticated for.
    _.some(method.securedBy || nodes.client.securedBy, function (secured, key) {
      var scheme = nodes.client.securitySchemes[key];

      // Scheme is not documented in the RAML security schemes.
      if (!scheme) {
        return;
      }

      var authenticated = nodes.client.authentication[scheme.type];
      var authType      = authMap[scheme.type];

      if (authenticated) {
        options[authType] = authenticated;
        return request = 'ajax:' + authType;
      }
    });

    // If the request is async, set the relevant function callbacks.
    if (async) {
      App._executeContext.timeout(Infinity);

      if (!_.isFunction(done)) {
        done = App._executeContext.async();
      }
    }

    // Awkward sync and async code mixing.
    var response, error;

    // Trigger the ajax middleware so plugins can hook onto the requests. If
    // the function is async we need to register a callback for the middleware.
    App.middleware.trigger(request, options, function (err, xhr) {
      error = err;

      if (!error) {
        try {
          response = sanitizeXHR(xhr);
        } catch (e) {
          error = new TypeError('Could not parse response: ' + e.message);
        }
      }

      return async && done(error, response);
    });

    // If the request was synchronous, return the sanitized XHR response data.
    // This is super jank for handling errors, etc.
    if (!async) {
      if (error) {
        throw error;
      }

      return response;
    }
  };
};

/**
 * Attaches XHR request methods to the context object for each available method.
 *
 * @param  {Array}  nodes
 * @param  {Object} context
 * @param  {Object} methods
 * @return {Object}
 */
var attachMethods = function (nodes, context, methods) {
  // Attach the available methods to the current context.
  _.each(methods, function (method, verb) {
    context[verb] = httpRequest(nodes, method);
    context[verb][DESCRIPTION_PROPERTY] = toMethodDescription(nodes, method);
  });

  return context;
};

/**
 * Attach a special media extension handler.
 *
 * @param  {Array}  nodes
 * @param  {Object} context
 * @param  {Object} resource
 * @return {Object}
 */
var attachMediaTypeExtension = function (nodes, context, resource) {
  /**
   * Push the extension onto the current route and set relevant headers.
   *
   * @param  {String} extension
   * @return {Object}
   */
  context.extension = function (extension) {
    // Prepend a period to the extension before adding to the route.
    if (extension.charAt(0) !== '.') {
      extension = '.' + extension;
    }

    var newContext  = {};
    var routeNodes  = _.extend([], nodes);
    var contentType = mime.lookup(extension);

    // Append the extension to the current route.
    routeNodes[routeNodes.length - 1] += extension;

    // Automagically set the correct accepts header. Needs to clone the config
    // object and the headers to avoid breaking references.
    if (contentType) {
      routeNodes.config = _.extend({}, routeNodes.config);
      routeNodes.config.headers = _.extend({}, routeNodes.config.headers);
      routeNodes.config.headers.accept = contentType;
    }

    attachMethods(routeNodes, newContext, resource.methods);
    attachResources(routeNodes, newContext, resource.resources);

    return newContext;
  };

  // Attach a description and return property.
  context.extension[RETURN_PROPERTY]      = context.extension('');
  context.extension[DESCRIPTION_PROPERTY] = EXTENSION_DESCRIPTION;

  // Iterate over the enum options and automatically attach to the context.
  _.each(resource.uriParameters.mediaTypeExtension.enum, function (extension) {
    if (extension.charAt(0) === '.') {
      extension = extension.substr(1);
    }

    context[extension] = context.extension(extension);
  });

  return context;
};

/**
 * Generate a context or attach methods and resources to an existing context.
 *
 * @param  {Array}   nodes
 * @param  {Object}  resource
 * @param  {Boolean} hasMediaExtension
 * @param  {Object}  context
 * @return {Object}
 */
var newContext = function (nodes, resource, hasMediaExtension, context) {
  context = context || {};

  if (hasMediaExtension) {
    attachMediaTypeExtension(nodes, context, resource);
  } else {
    attachMethods(nodes, context, resource.methods);
    attachResources(nodes, context, resource.resources);
  }

  return context;
};

/**
 * Recurses through a resource object in the RAML AST, generating a dynamic
 * DSL that only allows methods that were defined in the RAML spec.
 *
 * @param  {Array}  nodes
 * @param  {Object} context
 * @param  {Object} resources
 * @return {Object}
 */

/* jshint -W003 */
var attachResources = function (nodes, context, resources) {
  _.each(resources, function (resource, route) {
    var routeNodes        = _.extend([], nodes);
    var routeName         = route;
    var hasMediaExtension = route.substr(-20) === '{mediaTypeExtension}';

    // Ignore media type extensions in route generation.
    if (hasMediaExtension) {
      route = routeName = route.slice(0, -20);
    }

    // Check the route against our valid uri parameters.
    var templateTags = route.match(uriParamRegex(resource.uriParameters));

    // Push the current route into the route array.
    routeNodes.push(route);

    // If we have template tags available, attach a dynamic route.
    if (templateTags) {
      var routeSuffix = templateTags.join('');

      // The route must end with the chained template tags and have no
      // text between tags.
      if (route.substr(-routeSuffix.length) !== routeSuffix) {
        return false;
      }

      // If the route is only a template tag with no static text, use the
      // template tag text as the method name.
      if (templateTags.length === 1 && route === templateTags[0]) {
        routeName = templateTags[0].slice(1, -1);
      } else {
        routeName = route.substr(0, route.indexOf('{'));
      }

      // Avoid adding empty route name cases. This can occur when we have
      // multiple tag names and no front text. For example, `{this}{that}`.
      // This could also occur if for some reason we are passing in a route that
      // isn't dynamic.
      if (!routeName) {
        return false;
      }

      // Get the ordered tag names for completion.
      var tags = _.map(templateTags, function (param) {
        return resource.uriParameters[param.slice(1, -1)];
      });

      // The route is dynamic, so we set the route name to be a function
      // which accepts the template arguments and updates the path fragment.
      // We'll extend any route already at the same namespace so we can do
      // things like use both `/{route}` and `/route`, if needed.
      context[routeName] = _.extend(function () {
        var args = arguments;

        // Map the tags to the arguments or default arguments.
        var parts = _.map(tags, function (tag, index) {
          // Inject enum parameters if there is only one available enum.
          // TODO: When/if we add validation back, have these routes
          // be generated instead of typed out.
          if (args[index] == null && tag.enum && tag.enum.length === 1) {
            return tag.enum[0];
          }

          // Use any passed in argument - even it's falsy.
          if (index in args) {
            return args[index];
          }

          var param = templateTags[index].slice(1, -1);

          // Fallback to injecting the fallback configuration uri parameter.
          return routeNodes.config && routeNodes.config.uriParameters[param];
        });

        // Change the last path fragment to the proper template text.
        routeNodes[routeNodes.length - 1] = template(
          route, resource.uriParameters, parts
        );

        return newContext(routeNodes, resource, hasMediaExtension);
      }, context[routeName]);

      // Generate the description object for helping tooltip display.
      context[routeName][DESCRIPTION_PROPERTY] = {
        '!type': 'fn(' + _.map(tags, function (param) {
          return param.displayName + (param.required ? '' : '?');
        }).join(', ') + ')',
        '!args': _.map(tags, function (param) {
          return {
            '!type': param.type,
            '!doc': param.description
          };
        }),
        '!doc': 'Dynamically inject variables into the request path.'
      };

      // Generate the return property for helping autocompletion.
      context[routeName][RETURN_PROPERTY] = newContext(
        routeNodes, resource, hasMediaExtension
      );

      return context[routeName];
    }

    context[routeName] = newContext(
      routeNodes, resource, hasMediaExtension, context[routeName]
    );
  });

  return context;
};
/* jshint +W003 */

/**
 * Generate the client object from a sanitized AST object.
 *
 * @param  {Object} ast Passed through `sanitizeAST`
 * @return {Object}
 */
var generateClient = function (ast, config) {
  // Generate the root node array. Set properties directly on this array to be
  // copied to the next execution part. We have a global configuration object
  // which can be altered externally at any point, as well as when we finally
  // make a request. For this reason, it's important that we use objects which
  // are passed by reference.
  var nodes = _.extend([], {
    config: config || (config = {}),
    client: {
      baseUri:           ast.baseUri.replace(/\/+$/, ''),
      baseUriParameters: ast.baseUriParameters,
      securedBy:         ast.securedBy,
      authentication:    {},
      securitySchemes:   ast.securitySchemes
    }
  });

  // Set up the initial baseUriParameters configuration.
  config.baseUriParameters = _.extend(
    {}, config.baseUriParameters, _.pick(ast, 'version')
  );

  /**
   * The root client implementation is simply a function. This allows us to
   * enter a custom path that may not be supported by the DSL and run any
   * method regardless of whether it was defined in the spec.
   *
   * @param  {String} path
   * @param  {Object} context
   * @return {Object}
   */
  var client = function (path, context) {
    var route = template(
      path, {}, context || {}
    ).replace(/^\/+/, '').split('/');

    return attachMethods(_.extend([], nodes, route), {}, allHttpMethods);
  };

  client[CONFIG_PROPERTY]      = nodes.config;
  client[CLIENT_PROPERTY]      = nodes.client;
  client[DESCRIPTION_PROPERTY] = CLIENT_DESCRIPTION;
  client[RETURN_PROPERTY]      = attachMethods(nodes, {}, allHttpMethods);

  attachResources(nodes, client, ast.resources);

  return client;
};

/**
 * Exports the client generator, which accepts the AST of a RAML document.
 *
 * @return {Object} Dynamic object for constructing API requests from the AST.
 */
module.exports = function (ast, config) {
  return generateClient(sanitizeAST(ast), config);
};

},{"./sanitize-ast":60,"escape-regexp":28,"mime-component":29,"uritemplate":56}],60:[function(require,module,exports){
/* global App */
var _ = App.Library._;

/**
 * Sanitize the secured by into an object.
 *
 * @param  {Array}  secured
 * @return {Object}
 */
var sanitizeSecuredBy = function (secured) {
  if (!Array.isArray(secured)) {
    return null;
  }

  var securedBy = {};

  // Since `securedBy` can either be an array of strings or array of objects
  // with only a single key, we merge it down to an object.
  _.each(secured, function (value) {
    if (value == null) {
      return; // Ignore `null` array values, shouldn't be useful to me.
    }

    if (_.isString(value)) {
      return securedBy[value] = true;
    }

    return _.extend(securedBy, value);
  });

  return securedBy;
};

/**
 * Sanitize the AST from the RAML parser into something easier to work with.
 *
 * @param  {Object} ast
 * @return {Object}
 */
module.exports = function (ast) {
  if (!_.isString(ast.baseUri)) {
    throw new Error('A baseUri is required');
  }

  // Create the base sanitized ast with only the properties we want.
  var sanitizedAst = _.pick(ast, [
    'title',
    'version',
    'baseUri',
    'baseUriParameters'
  ]);

  // Merge an array of objects into a single object using `_.extend` and
  // `apply` (since `_.extend` accepts unlimited number of arguments).
  if (ast.securitySchemes) {
    sanitizedAst.securitySchemes = _.extend.apply(_, ast.securitySchemes);
  }

  // Sanitize secured by which is a bit more complicated than extending.
  if (ast.securedBy) {
    sanitizedAst.securedBy = sanitizeSecuredBy(ast.securedBy);
  }

  // Recurse through the resources and move URIs to be the key names.
  sanitizedAst.resources = (function flattenResources (resources) {
    var map = {};

    // Resources are provided as an array, we'll move them to be an object.
    _.each(resources, function (resource) {
      var sanitizedResource = {};

      // Methods are implemented as arrays of objects too, but not recursively.
      // TODO: If the endpoint is the final route and has no methods, implement
      // backtracking and remove access to it from the AST.
      if (resource.methods) {
        sanitizedResource.methods = _.object(
          _.pluck(resource.methods, 'method'),
          _.map(resource.methods, function (method) {
            // Create the sanitized method by including the properties we want.
            var sanitizedMethod = _.pick(method, [
              'method',
              'body',
              'headers',
              'description',
              'queryParameters'
            ]);

            // Sanitize the `securedBy` method.
            if (method.securedBy) {
              sanitizedMethod.securedBy = sanitizeSecuredBy(method.securedBy);
            }

            return sanitizedMethod;
          })
        );
      }

      if (resource.resources) {
        sanitizedResource.resources = flattenResources(resource.resources);
      }

      (function attachResource (map, segments) {
        var segment = segments.shift();
        var part    = map[segment] = {};

        // Currently on the last url segment, embed the full resource.
        if (!segments.length) {
          part = map[segment] = sanitizedResource;
        }

        // Pull any possible tags out of the relative uri part.
        var tags = _.map(segment.match(/\{([^\}]+)\}/g), function (tag) {
          return tag.slice(1, -1);
        });

        // Add only the used tags to the current resource segment.
        if (tags.length) {
          part.uriParameters = _.pick(resource.uriParameters, tags);
        }

        // If we have more segment parts left, recursively embed resources.
        if (segments.length) {
          part.resources = part.resources || {};

          return attachResource(part.resources, segments);
        }
      })(map, resource.relativeUri.substr(1).split('/'));
    });

    return map;
  })(ast.resources);

  return sanitizedAst;
};

},{}],61:[function(require,module,exports){
/* global App */
var _               = App._;
var ramlParser      = require('raml-parser');
var authenticate    = require('./authenticate');
var clientGenerator = require('./client-generator');
var fromPath        = require('../../lib/from-path');

/**
 * Implementation helpers.
 */
require('./inject-api-keys');
require('./insert-api-client');

/**
 * Provided a special documentation property for functionsw with another plugin.
 *
 * @type {String}
 */
var DESCRIPTION_PROPERTY = '!description';

/**
 * Custom file reader for RAML specs.
 *
 * @param  {String}  url
 * @return {Q.defer}
 */
var createReader = function (config) {
  return new ramlParser.FileReader(function (url) {
    var deferred = this.q.defer();

    App.middleware.trigger('ajax', {
      url: url,
      proxy: config.proxy,
      headers: {
        'Accept': 'application/raml+yaml, */*'
      }
    }, function (err, xhr) {
      if (err) {
        return deferred.reject(err);
      }

      if (Math.floor(xhr.status / 100) !== 2) {
        return deferred.reject(
          new Error('Received status code ' + xhr.status + ' loading ' + url)
        );
      }

      return deferred.resolve(xhr.responseText);
    });

    return deferred.promise;
  });
};

/**
 * The Api object is used in the execution context.
 *
 * @type {Object}
 */
var API = {};

/**
 * Responsible for loading RAML documents and return API clients.
 *
 * @param {String}   name
 * @param {String}   [url]
 * @param {Function} done
 */
API.createClient = function (name, url, config, done) {
  if (!_.isString(name)) {
    throw new Error('Provide a name for the generated client');
  }

  if (!_.isString(url)) {
    throw new Error('Provide a URL for the ' + name + ' RAML document');
  }

  // Allow the config object to be skipped.
  if (typeof config === 'function') {
    done   = arguments[2];
    config = {};
  }

  App._executeContext.timeout(Infinity);
  done   = done   || App._executeContext.async();
  config = config || {};

  // Pass our url to the RAML parser for processing and transform the promise
  // back into a callback format.
  ramlParser.loadFile(url, {
    reader: createReader(config)
  }).then(function (data) {
    var client;

    try {
      client = clientGenerator(data, config);
      fromPath(App._executeWindow, name.split('.'), client);
    } catch (e) {
      return done(e);
    }

    return done(
      null,
      'Create a new code cell and type \'' + name + '.\' ' +
      'to explore this API.'
    );
  }, done);
};

/**
 * Description of the create client function.
 */
API.createClient[DESCRIPTION_PROPERTY] = {
  '!type': 'fn(alias, url, options?, cb?)',
  '!args': [{
    '!type': 'string'
  }, {
    '!type': 'string'
  }, {
    '!type': 'object',
    '!doc': [
      'Initialize the client with default config options. Valid options:',
      '* **proxy**: Set to a custom proxy or `false` to disable entirely',
      '* **body**: Set a fallback request body',
      '* **uriParameters**: Set fallback uri parameters to inject',
      '* **baseUriParameters**: Inject base uri parameters to override',
      '* **headers**: Set default headers to send with every request',
      '* **query**: Set a default query string to send with every request'
    ].join('\n')
  }, {
    '!type': 'fn(error, client)',
    '!doc': [
      'Pass in a custom callback to run when the client has loaded.'
    ].join('\n')
  }],
  '!doc': [
    'Generate an API client from a RAML document and alias it on the window.'
  ].join(' ')
};

/**
 * Set a configuration value on a client.
 *
 * @param {Function} client
 * @param {String}   key
 * @param {*}        value
 */
API.set = function (client, key, value) {
  // If we don't have enough arguments for a key and value, assume we have
  // a fresh configuration object.
  if (arguments.length < 3) {
    return _.extend(client['!config'], key);
  }

  return client['!config'][key] = value;
};

/**
 * Set the description of the API client configuration setter.
 */
API.set[DESCRIPTION_PROPERTY] = {
  '!type': 'fn(client, key, value)',
  '!args': [{
    '!type': 'function',
    '!doc': 'A function generated by `API.createClient`.'
  }, {
    '!type': 'string'
  }],
  '!doc': 'Set a configuration option of a RAML API client.'
};

/**
 * Retrieve a value from the client config object.
 *
 * @param  {Function} client
 * @param  {String}   key
 * @return {*}
 */
API.get = function (client, key) {
  if (arguments.length < 2) {
    return client['!config'];
  }

  return client['!config'][key];
};

/**
 * Set the description of the API client configuration getter.
 */
API.get[DESCRIPTION_PROPERTY] = {
  '!type': 'fn(client, key)',
  '!args': [{
    '!type': 'function',
    '!doc': 'A function generated by `API.createClient`.'
  }, {
    '!type': 'string'
  }],
  '!doc': 'Get a configuration option from a RAML API client.'
};

/**
 * Unset a key from the client configuration.
 *
 * @param  {Function} client
 * @param  {String}   key
 * @return {Boolean}
 */
API.unset = function (client, key) {
  if (arguments.length < 2) {
    _.each(client['!config'], function (value, key, obj) {
      delete obj[key];
    });

    return true;
  }

  return delete client['!config'][key];
};

/**
 * Set the description of the API client configuration unsetter.
 */
API.unset[DESCRIPTION_PROPERTY] = {
  '!type': 'fn(client, key)',
  '!args': [{
    '!type': 'function',
    '!doc': 'A function generated by `API.createClient`.'
  }, {
    '!type': 'string'
  }],
  '!doc': 'Unset a configuration option from a RAML API client.'
};

/**
 * Authenticate a RAML API client passing an optional method and accompanying
 * options object.
 *
 * @param {Function} client
 * @param {String}   method
 * @param {Object}   options
 * @param {Function} done
 */
API.authenticate = function (client, method, options, done) {
  App._executeContext.timeout(10 * 60 * 1000);
  done = done || App._executeContext.async();

  var clientOption    = client['!client'];
  var securitySchemes = clientOption.securitySchemes;

  /**
   * The callback is used to handle the persistence of data to the client.
   *
   * @param  {Error}    err
   * @param  {Object}   scheme
   * @param  {Object}   options
   * @param  {Object}   tokens
   * @return {Function}
   */
  var cb = function (err, scheme, options, tokens) {
    if (err) {
      return done(err);
    }

    // Alias onto the client object for future use.
    clientOption.authentication[scheme.type] = _.extend({}, options, tokens);

    return done(null, tokens);
  };

  return authenticate(securitySchemes, method, options, cb);
};

/**
 * Set the description of the API client authenticator.
 */
API.authenticate[DESCRIPTION_PROPERTY] = {
  '!type': [
    'fn(client, method?, options?, cb?)'
  ].join(''),
  '!args': [{
    '!type': 'function',
    '!doc': 'A function generated by `API.createClient`.'
  }, {
    '!type': 'string',
    '!doc': 'Select an authentication method defined in the RAML file.'
  }, {
    '!type': 'object',
    '!doc': 'Coverride the default selected authentication method options.'
  }, {
    '!type': 'function'
  }],
  '!doc': [
    'Authentication parameters are optional. For popular APIs, we provide',
    'keys. If we need your keys we will prompt you via a modal. Never enter',
    'keys directly into a notebook unless you explicitly intend to share',
    'them. If you would like to know more about authenticating',
    'with this API, see \'securityScheme.settings\' in the RAML file.'
  ].join(' ')
};

/**
 * Alter the context to include the RAML client generator.
 *
 * @param {Object}   data
 * @param {Function} next
 */
exports['sandbox:context'] = function (context, next) {
  // This is extremely janky, but is required for Safari 7.0 which seems to
  // be ignoring direct property assignments under certain conditions.
  Object.defineProperty(context, 'API', { value: API });
  return next();
};

},{"../../lib/from-path":57,"./authenticate":58,"./client-generator":59,"./inject-api-keys":62,"./insert-api-client":63,"raml-parser":40}],62:[function(require,module,exports){
/* global App */
var apiKeys = {}.ramlClient;

/**
 * Check against our OAuth tokens and inject the tokens we have available.
 *
 * @param {Object}   data
 * @param {Function} next
 */
App.middleware.register('ramlClient:token', function (scheme, next, done) {
  var authUri = scheme.settings.authorizationUri;

  if (scheme.type === 'OAuth 1.0' && apiKeys.oauth1[authUri]) {
    return done(null, apiKeys.oauth1[authUri]);
  }

  if (scheme.type === 'OAuth 2.0' && apiKeys.oauth2[authUri]) {
    return done(null, apiKeys.oauth2[authUri]);
  }

  return next();
});

},{}],63:[function(require,module,exports){
/* global App */
var _          = App.Library._;
var Backbone   = App.Library.Backbone;
var changeCase = App.Library.changeCase;

/**
 * Create an api client cell that can load the selected api document.
 *
 * @param  {Cell}     cell
 * @param  {String}   invoke
 * @return {Function}
 */
var createApiClientCell = function (cell, invoke) {
  return function (err, api) {
    if (err) { return; }

    var url      = api.ramlUrl;
    var variable = changeCase.camelCase(api.title);
    var code     = [
      '// Read about the ' + api.title + ' at ' + api.portalUrl,
      'API.createClient(\'' + variable + '\', \'' + url + '\');'
    ].join('\n');

    var view = cell.notebook[invoke + 'CodeView'](cell.el, code).execute();

    cell.focus();

    // Trigger a raml client insertion message.
    App.messages.trigger('ramlClient:insert');

    return view;
  };
};

/**
 * Load all the API definitions and return the items as an array.
 *
 * @param {Function} done
 */
var loadAPIDefinitions = function (done) {
  return App.middleware.trigger('ajax', {
    url: 'http://api.apihub.com/v1/apis?specFormat=RAML'
  }, function (err, xhr) {
    return done(err, JSON.parse(xhr.responseText).items);
  });
};

/**
 * Show RAML definitions to users in a modal, and upon selection pass the
 * selected definition back to the callback.
 *
 * @param {Function} done
 */
var selectAPIDefinition = function (done) {
  // Trigger modal display messages.
  App.messages.trigger('ramlClient:modal');

  return App.middleware.trigger('ui:modal', {
    title: 'Insert an API Client',
    content: function (done) {
      return loadAPIDefinitions(function (err, items) {
        if (err) { return done(err); }

        return done(null, '<div class="modal-instructions">' +
          'Insert an API client from a RAML specification.' +
          ' An API client is a JavaScript representation of an API' +
          ' that you can use to explore available endpoints and' +
          ' their parameters. ' +
          '<a href="http://raml.org/" target="_blank">' +
          'Learn more about RAML</a>.' +
          '</div>' +
          '<div class="form-group">' +
          '<input class="item-search" placeholder="Search">' +
          '</div>' +
          '<ul class="item-list">' +
          _.map(items, function (item) {
            return '<li data-title="' + item.title + '" ' +
              'data-raml="' + item.specs.RAML.url + '" ' +
              'data-title="' + item.title + '" ' +
              'data-portal="' + item.apihubPortal + '">' +
              '<div class="item-action">' +
              '<a href="#" class="btn btn-primary btn-small">Add</a>' +
              '</div>' +
              '<div class="item-description">' + item.title +
              '<a href="#" class="item-details-link" data-details>details</a>' +
              '<div class="item-details">' + item.description + '</div>' +
              '</div>' +
              '</li>';
          }).join('') + '</ul>' +
          '<p class="hide item-list-unavailable">No matching APIs found. ' +
          'Please search on the <a ' +
          'href="http://api-portal.anypoint.mulesoft.com/" target="_blank">' +
          'Anypoint API Portal</a> and submit a request for more ' +
          'documentation for this API.</p>'
        );
      });
    },
    show: function (modal) {
      Backbone.$(modal.el)
        .on('click', '[data-details]', function (e, target) {
          e.preventDefault();
          e.stopImmediatePropagation();

          var classList = target.parentNode.parentNode.classList;

          if (!classList.contains('item-details-visible')) {
            classList.add('item-details-visible');
          } else {
            classList.remove('item-details-visible');
          }
        })
        .on('click', '[data-raml]', function (e, target) {
          e.preventDefault();

          // Close the modal behind ourselves.
          modal.close();

          return done(null, {
            title:     target.getAttribute('data-title'),
            ramlUrl:   target.getAttribute('data-raml'),
            portalUrl: target.getAttribute('data-portal')
          });
        })
        .on('keyup', '.item-search', function (e) {
          var listItemEls   = modal.el.querySelectorAll('.item-list > li');
          var unavailableEl = modal.el.querySelector('.item-list-unavailable');

          var hasResults = _.filter(listItemEls, function (el) {
            var title   = el.getAttribute('data-title').toLowerCase();
            var matches = title.indexOf(e.target.value.toLowerCase()) > -1;

            el.classList[matches ? 'remove' : 'add']('hide');
            return matches;
          }).length;

          unavailableEl.classList[hasResults ? 'add' : 'remove']('hide');
        });
    }
  });
};

/**
 * Inserts a new code cell above with a RAML API client and executes it.
 */
App.View.EditorCell.prototype.newRAMLAbove = function () {
  return selectAPIDefinition(createApiClientCell(this, 'prepend'));
};

/**
 * Inserts a new code cell below with a RAML API client and executes it.
 */
App.View.EditorCell.prototype.newRAMLBelow = function () {
  return selectAPIDefinition(createApiClientCell(this, 'append'));
};

/**
 * Insert a RAML document by using the cell border buttons.
 */
App.View.CellButtons.controls.push({
  label:   'Insert API Client',
  command: 'newRAML'
});

/**
 * Insert a RAML document by using the cell menu buttons.
 */
App.View.CodeCell.prototype.cellControls.push({
  label:   'Insert API Client',
  command: 'newRAMLBelow'
});

},{}]},{},[61])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L2xpYi9fZW1wdHkuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaHR0cC1icm93c2VyaWZ5L2luZGV4LmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaHR0cC1icm93c2VyaWZ5L2xpYi9yZXF1ZXN0LmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaHR0cC1icm93c2VyaWZ5L2xpYi9yZXNwb25zZS5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2h0dHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvQmFzZTY0L2Jhc2U2NC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2h0dHBzLWJyb3dzZXJpZnkvaW5kZXguanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9uYXRpdmUtYnVmZmVyLWJyb3dzZXJpZnkvaW5kZXguanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9uYXRpdmUtYnVmZmVyLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvbmF0aXZlLWJ1ZmZlci1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9kZWNvZGUuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9lbmNvZGUuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9pbmRleC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2R1cGxleC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvcGFzc3Rocm91Z2guanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9yZWFkYWJsZS5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L3RyYW5zZm9ybS5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L3dyaXRhYmxlLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvaW5kZXguanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2VzY2FwZS1yZWdleHAvaW5kZXguanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9taW1lLWNvbXBvbmVudC9pbmRleC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL21pbWUtY29tcG9uZW50L3R5cGVzLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL2NvbXBvc2VyLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL2NvbnN0cnVjdC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9lcnJvcnMuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9yYW1sLXBhcnNlci9saWIvZXZlbnRzLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL2pvaW5lci5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9sb2FkZXIuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9yYW1sLXBhcnNlci9saWIvbm9kZXMuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9yYW1sLXBhcnNlci9saWIvcGFyc2VyLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL3Byb3RvY29scy5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9yYW1sLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL3JlYWRlci5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9yZXNvbHZlci5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9yZXNvdXJjZVR5cGVzLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL3NjYW5uZXIuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9yYW1sLXBhcnNlci9saWIvc2NoZW1hcy5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi9zZWN1cml0eVNjaGVtZXMuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9yYW1sLXBhcnNlci9saWIvdG9rZW5zLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbGliL3RyYWl0cy5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi90cmFuc2Zvcm1hdGlvbnMuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9yYW1sLXBhcnNlci9saWIvdXRpbC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL2xpYi92YWxpZGF0b3IuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9yYW1sLXBhcnNlci9ub2RlX21vZHVsZXMvaW5mbGVjdGlvbi9saWIvaW5mbGVjdGlvbi5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3JhbWwtcGFyc2VyL25vZGVfbW9kdWxlcy9qc29uLWxpbnQvanNvbmxpbnQuanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9yYW1sLXBhcnNlci9ub2RlX21vZHVsZXMvcS9xLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvcmFtbC1wYXJzZXIvbm9kZV9tb2R1bGVzL3htbGh0dHByZXF1ZXN0L2xpYi9YTUxIdHRwUmVxdWVzdC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL3VyaXRlbXBsYXRlL2Jpbi91cml0ZW1wbGF0ZS5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvbGliL2Zyb20tcGF0aC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvcGx1Z2lucy9yYW1sLWNsaWVudC1nZW5lcmF0b3IvYXV0aGVudGljYXRlLmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy9wbHVnaW5zL3JhbWwtY2xpZW50LWdlbmVyYXRvci9jbGllbnQtZ2VuZXJhdG9yL2luZGV4LmpzIiwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9wdWJsaWMvc2NyaXB0cy9wbHVnaW5zL3JhbWwtY2xpZW50LWdlbmVyYXRvci9jbGllbnQtZ2VuZXJhdG9yL3Nhbml0aXplLWFzdC5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvcGx1Z2lucy9yYW1sLWNsaWVudC1nZW5lcmF0b3IvaW5kZXguanMiLCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL3B1YmxpYy9zY3JpcHRzL3BsdWdpbnMvcmFtbC1jbGllbnQtZ2VuZXJhdG9yL2luamVjdC1hcGkta2V5cy5qcyIsIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svcHVibGljL3NjcmlwdHMvcGx1Z2lucy9yYW1sLWNsaWVudC1nZW5lcmF0b3IvaW5zZXJ0LWFwaS1jbGllbnQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoaUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Y2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDam1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy85Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25nQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsbnVsbCwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIHZhciBtO1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gMDtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbWl0dGVyLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IDE7XG4gIGVsc2VcbiAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwidmFyIGh0dHAgPSBtb2R1bGUuZXhwb3J0cztcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4vbGliL3JlcXVlc3QnKTtcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKVxuXG5odHRwLnJlcXVlc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJhbXMgPSB1cmwucGFyc2UocGFyYW1zKVxuICAgIH1cbiAgICBpZiAoIXBhcmFtcykgcGFyYW1zID0ge307XG4gICAgaWYgKCFwYXJhbXMuaG9zdCAmJiAhcGFyYW1zLnBvcnQpIHtcbiAgICAgICAgcGFyYW1zLnBvcnQgPSBwYXJzZUludCh3aW5kb3cubG9jYXRpb24ucG9ydCwgMTApO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcy5ob3N0ICYmIHBhcmFtcy5ob3N0bmFtZSkge1xuICAgICAgICBwYXJhbXMuaG9zdCA9IHBhcmFtcy5ob3N0bmFtZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCFwYXJhbXMuc2NoZW1lKSBwYXJhbXMuc2NoZW1lID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sLnNwbGl0KCc6JylbMF07XG4gICAgaWYgKCFwYXJhbXMuaG9zdCkge1xuICAgICAgICBwYXJhbXMuaG9zdCA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSB8fCB3aW5kb3cubG9jYXRpb24uaG9zdDtcbiAgICB9XG4gICAgaWYgKC86Ly50ZXN0KHBhcmFtcy5ob3N0KSkge1xuICAgICAgICBpZiAoIXBhcmFtcy5wb3J0KSB7XG4gICAgICAgICAgICBwYXJhbXMucG9ydCA9IHBhcmFtcy5ob3N0LnNwbGl0KCc6JylbMV07XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLmhvc3QgPSBwYXJhbXMuaG9zdC5zcGxpdCgnOicpWzBdO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcy5wb3J0KSBwYXJhbXMucG9ydCA9IHBhcmFtcy5zY2hlbWUgPT0gJ2h0dHBzJyA/IDQ0MyA6IDgwO1xuICAgIFxuICAgIHZhciByZXEgPSBuZXcgUmVxdWVzdChuZXcgeGhySHR0cCwgcGFyYW1zKTtcbiAgICBpZiAoY2IpIHJlcS5vbigncmVzcG9uc2UnLCBjYik7XG4gICAgcmV0dXJuIHJlcTtcbn07XG5cbmh0dHAuZ2V0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2IpIHtcbiAgICBwYXJhbXMubWV0aG9kID0gJ0dFVCc7XG4gICAgdmFyIHJlcSA9IGh0dHAucmVxdWVzdChwYXJhbXMsIGNiKTtcbiAgICByZXEuZW5kKCk7XG4gICAgcmV0dXJuIHJlcTtcbn07XG5cbmh0dHAuQWdlbnQgPSBmdW5jdGlvbiAoKSB7fTtcbmh0dHAuQWdlbnQuZGVmYXVsdE1heFNvY2tldHMgPSA0O1xuXG52YXIgeGhySHR0cCA9IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gd2luZG93IG9iamVjdCBwcmVzZW50Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gd2luZG93LlhNTEh0dHBSZXF1ZXN0O1xuICAgIH1cbiAgICBlbHNlIGlmICh3aW5kb3cuQWN0aXZlWE9iamVjdCkge1xuICAgICAgICB2YXIgYXhzID0gW1xuICAgICAgICAgICAgJ01zeG1sMi5YTUxIVFRQLjYuMCcsXG4gICAgICAgICAgICAnTXN4bWwyLlhNTEhUVFAuMy4wJyxcbiAgICAgICAgICAgICdNaWNyb3NvZnQuWE1MSFRUUCdcbiAgICAgICAgXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4ID0gbmV3KHdpbmRvdy5BY3RpdmVYT2JqZWN0KShheHNbaV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChheCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF4XyA9IGF4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYXggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF4XztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcod2luZG93LkFjdGl2ZVhPYmplY3QpKGF4c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhamF4IG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWpheCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xuICAgIH1cbn0pKCk7XG4iLCJ2YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG52YXIgUmVzcG9uc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlJyk7XG52YXIgQmFzZTY0ID0gcmVxdWlyZSgnQmFzZTY0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG52YXIgUmVxdWVzdCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHhociwgcGFyYW1zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgIHNlbGYueGhyID0geGhyO1xuICAgIHNlbGYuYm9keSA9IFtdO1xuICAgIFxuICAgIHNlbGYudXJpID0gKHBhcmFtcy5zY2hlbWUgfHwgJ2h0dHAnKSArICc6Ly8nXG4gICAgICAgICsgcGFyYW1zLmhvc3RcbiAgICAgICAgKyAocGFyYW1zLnBvcnQgPyAnOicgKyBwYXJhbXMucG9ydCA6ICcnKVxuICAgICAgICArIChwYXJhbXMucGF0aCB8fCAnLycpXG4gICAgO1xuICAgIFxuICAgIHRyeSB7IHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlIH1cbiAgICBjYXRjaCAoZSkge31cbiAgICBcbiAgICB4aHIub3BlbihcbiAgICAgICAgcGFyYW1zLm1ldGhvZCB8fCAnR0VUJyxcbiAgICAgICAgc2VsZi51cmksXG4gICAgICAgIHRydWVcbiAgICApO1xuICAgIFxuICAgIGlmIChwYXJhbXMuaGVhZGVycykge1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMocGFyYW1zLmhlYWRlcnMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlzU2FmZVJlcXVlc3RIZWFkZXIoa2V5KSkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXMuaGVhZGVyc1trZXldO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbHVlW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpXG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKHBhcmFtcy5hdXRoKSB7XG4gICAgICAgIC8vYmFzaWMgYXV0aFxuICAgICAgICB0aGlzLnNldEhlYWRlcignQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgQmFzZTY0LmJ0b2EocGFyYW1zLmF1dGgpKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0gbmV3IFJlc3BvbnNlO1xuICAgIHJlcy5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXMub24oJ3JlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgcmVzKTtcbiAgICB9KTtcbiAgICBcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXMuaGFuZGxlKHhocik7XG4gICAgfTtcbn07XG5cbmluaGVyaXRzKFJlcXVlc3QsIFN0cmVhbSk7XG5cblJlcXVlc3QucHJvdG90eXBlLnNldEhlYWRlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgfVxufTtcblxuUmVxdWVzdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocykge1xuICAgIHRoaXMuYm9keS5wdXNoKHMpO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAocykge1xuICAgIGlmIChzICE9PSB1bmRlZmluZWQpIHRoaXMuYm9keS5wdXNoKHMpO1xuICAgIGlmICh0aGlzLmJvZHkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMueGhyLnNlbmQoJycpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5ib2R5WzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLnhoci5zZW5kKHRoaXMuYm9keS5qb2luKCcnKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXJyYXkodGhpcy5ib2R5WzBdKSkge1xuICAgICAgICB2YXIgYm9keSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm9keS5wdXNoLmFwcGx5KGJvZHksIHRoaXMuYm9keVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54aHIuc2VuZChib2R5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoL0FycmF5Ly50ZXN0KE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzLmJvZHlbMF0pKSkge1xuICAgICAgICB2YXIgbGVuID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxlbiArPSB0aGlzLmJvZHlbaV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHZhciBib2R5ID0gbmV3KHRoaXMuYm9keVswXS5jb25zdHJ1Y3RvcikobGVuKTtcbiAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBiID0gdGhpcy5ib2R5W2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgYm9keVtrKytdID0gYltqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnhoci5zZW5kKGJvZHkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGJvZHkgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5ib2R5W2ldLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54aHIuc2VuZChib2R5KTtcbiAgICB9XG59O1xuXG4vLyBUYWtlbiBmcm9tIGh0dHA6Ly9keHIubW96aWxsYS5vcmcvbW96aWxsYS9tb3ppbGxhLWNlbnRyYWwvY29udGVudC9iYXNlL3NyYy9uc1hNTEh0dHBSZXF1ZXN0LmNwcC5odG1sXG5SZXF1ZXN0LnVuc2FmZUhlYWRlcnMgPSBbXG4gICAgXCJhY2NlcHQtY2hhcnNldFwiLFxuICAgIFwiYWNjZXB0LWVuY29kaW5nXCIsXG4gICAgXCJhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LWhlYWRlcnNcIixcbiAgICBcImFjY2Vzcy1jb250cm9sLXJlcXVlc3QtbWV0aG9kXCIsXG4gICAgXCJjb25uZWN0aW9uXCIsXG4gICAgXCJjb250ZW50LWxlbmd0aFwiLFxuICAgIFwiY29va2llXCIsXG4gICAgXCJjb29raWUyXCIsXG4gICAgXCJjb250ZW50LXRyYW5zZmVyLWVuY29kaW5nXCIsXG4gICAgXCJkYXRlXCIsXG4gICAgXCJleHBlY3RcIixcbiAgICBcImhvc3RcIixcbiAgICBcImtlZXAtYWxpdmVcIixcbiAgICBcIm9yaWdpblwiLFxuICAgIFwicmVmZXJlclwiLFxuICAgIFwidGVcIixcbiAgICBcInRyYWlsZXJcIixcbiAgICBcInRyYW5zZmVyLWVuY29kaW5nXCIsXG4gICAgXCJ1cGdyYWRlXCIsXG4gICAgXCJ1c2VyLWFnZW50XCIsXG4gICAgXCJ2aWFcIlxuXTtcblxuUmVxdWVzdC5wcm90b3R5cGUuaXNTYWZlUmVxdWVzdEhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXJOYW1lKSB7XG4gICAgaWYgKCFoZWFkZXJOYW1lKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGluZGV4T2YoUmVxdWVzdC51bnNhZmVIZWFkZXJzLCBoZWFkZXJOYW1lLnRvTG93ZXJDYXNlKCkpID09PSAtMTtcbn07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIGtleXM7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgaW5kZXhPZiA9IGZ1bmN0aW9uICh4cywgeCkge1xuICAgIGlmICh4cy5pbmRleE9mKSByZXR1cm4geHMuaW5kZXhPZih4KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn07XG4iLCJ2YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIFJlc3BvbnNlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlO1xufTtcblxudXRpbC5pbmhlcml0cyhSZXNwb25zZSwgU3RyZWFtKTtcblxudmFyIGNhcGFibGUgPSB7XG4gICAgc3RyZWFtaW5nIDogdHJ1ZSxcbiAgICBzdGF0dXMyIDogdHJ1ZVxufTtcblxuZnVuY3Rpb24gcGFyc2VIZWFkZXJzIChyZXMpIHtcbiAgICB2YXIgbGluZXMgPSByZXMuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkuc3BsaXQoL1xccj9cXG4vKTtcbiAgICB2YXIgaGVhZGVycyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgaWYgKGxpbmUgPT09ICcnKSBjb250aW51ZTtcbiAgICAgICAgXG4gICAgICAgIHZhciBtID0gbGluZS5tYXRjaCgvXihbXjpdKyk6XFxzKiguKikvKTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBtWzFdLnRvTG93ZXJDYXNlKCksIHZhbHVlID0gbVsyXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGhlYWRlcnNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShoZWFkZXJzW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IFsgaGVhZGVyc1trZXldLCB2YWx1ZSBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGVhZGVyc1tsaW5lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG5cblJlc3BvbnNlLnByb3RvdHlwZS5nZXRSZXNwb25zZSA9IGZ1bmN0aW9uICh4aHIpIHtcbiAgICB2YXIgcmVzcFR5cGUgPSBTdHJpbmcoeGhyLnJlc3BvbnNlVHlwZSkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAocmVzcFR5cGUgPT09ICdibG9iJykgcmV0dXJuIHhoci5yZXNwb25zZUJsb2IgfHwgeGhyLnJlc3BvbnNlO1xuICAgIGlmIChyZXNwVHlwZSA9PT0gJ2FycmF5YnVmZmVyJykgcmV0dXJuIHhoci5yZXNwb25zZTtcbiAgICByZXR1cm4geGhyLnJlc3BvbnNlVGV4dDtcbn1cblxuUmVzcG9uc2UucHJvdG90eXBlLmdldEhlYWRlciA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXTtcbn07XG5cblJlc3BvbnNlLnByb3RvdHlwZS5oYW5kbGUgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgaWYgKHJlcy5yZWFkeVN0YXRlID09PSAyICYmIGNhcGFibGUuc3RhdHVzMikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IHBhcnNlSGVhZGVycyhyZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNhcGFibGUuc3RhdHVzMiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoY2FwYWJsZS5zdGF0dXMyKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWR5Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY2FwYWJsZS5zdHJlYW1pbmcgJiYgcmVzLnJlYWR5U3RhdGUgPT09IDMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBwYXJzZUhlYWRlcnMocmVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWR5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge31cbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0RGF0YShyZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNhcGFibGUuc3RyZWFtaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocmVzLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXM7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW1pdERhdGEocmVzKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChyZXMuZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCB0aGlzLmdldFJlc3BvbnNlKHJlcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgICB9XG59O1xuXG5SZXNwb25zZS5wcm90b3R5cGUuX2VtaXREYXRhID0gZnVuY3Rpb24gKHJlcykge1xuICAgIHZhciByZXNwQm9keSA9IHRoaXMuZ2V0UmVzcG9uc2UocmVzKTtcbiAgICBpZiAocmVzcEJvZHkudG9TdHJpbmcoKS5tYXRjaCgvQXJyYXlCdWZmZXIvKSkge1xuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBuZXcgVWludDhBcnJheShyZXNwQm9keSwgdGhpcy5vZmZzZXQpKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSByZXNwQm9keS5ieXRlTGVuZ3RoO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZXNwQm9keS5sZW5ndGggPiB0aGlzLm9mZnNldCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCByZXNwQm9keS5zbGljZSh0aGlzLm9mZnNldCkpO1xuICAgICAgICB0aGlzLm9mZnNldCA9IHJlc3BCb2R5Lmxlbmd0aDtcbiAgICB9XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiOyhmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIG9iamVjdCA9IHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnID8gZXhwb3J0cyA6IHRoaXM7IC8vICM4OiB3ZWIgd29ya2Vyc1xuICB2YXIgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuXG4gIGZ1bmN0aW9uIEludmFsaWRDaGFyYWN0ZXJFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuICBJbnZhbGlkQ2hhcmFjdGVyRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yO1xuICBJbnZhbGlkQ2hhcmFjdGVyRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnSW52YWxpZENoYXJhY3RlckVycm9yJztcblxuICAvLyBlbmNvZGVyXG4gIC8vIFtodHRwczovL2dpc3QuZ2l0aHViLmNvbS85OTkxNjZdIGJ5IFtodHRwczovL2dpdGh1Yi5jb20vbmlnbmFnXVxuICBvYmplY3QuYnRvYSB8fCAoXG4gIG9iamVjdC5idG9hID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgZm9yIChcbiAgICAgIC8vIGluaXRpYWxpemUgcmVzdWx0IGFuZCBjb3VudGVyXG4gICAgICB2YXIgYmxvY2ssIGNoYXJDb2RlLCBpZHggPSAwLCBtYXAgPSBjaGFycywgb3V0cHV0ID0gJyc7XG4gICAgICAvLyBpZiB0aGUgbmV4dCBpbnB1dCBpbmRleCBkb2VzIG5vdCBleGlzdDpcbiAgICAgIC8vICAgY2hhbmdlIHRoZSBtYXBwaW5nIHRhYmxlIHRvIFwiPVwiXG4gICAgICAvLyAgIGNoZWNrIGlmIGQgaGFzIG5vIGZyYWN0aW9uYWwgZGlnaXRzXG4gICAgICBpbnB1dC5jaGFyQXQoaWR4IHwgMCkgfHwgKG1hcCA9ICc9JywgaWR4ICUgMSk7XG4gICAgICAvLyBcIjggLSBpZHggJSAxICogOFwiIGdlbmVyYXRlcyB0aGUgc2VxdWVuY2UgMiwgNCwgNiwgOFxuICAgICAgb3V0cHV0ICs9IG1hcC5jaGFyQXQoNjMgJiBibG9jayA+PiA4IC0gaWR4ICUgMSAqIDgpXG4gICAgKSB7XG4gICAgICBjaGFyQ29kZSA9IGlucHV0LmNoYXJDb2RlQXQoaWR4ICs9IDMvNCk7XG4gICAgICBpZiAoY2hhckNvZGUgPiAweEZGKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQ2hhcmFjdGVyRXJyb3IoXCInYnRvYScgZmFpbGVkOiBUaGUgc3RyaW5nIHRvIGJlIGVuY29kZWQgY29udGFpbnMgY2hhcmFjdGVycyBvdXRzaWRlIG9mIHRoZSBMYXRpbjEgcmFuZ2UuXCIpO1xuICAgICAgfVxuICAgICAgYmxvY2sgPSBibG9jayA8PCA4IHwgY2hhckNvZGU7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0pO1xuXG4gIC8vIGRlY29kZXJcbiAgLy8gW2h0dHBzOi8vZ2lzdC5naXRodWIuY29tLzEwMjAzOTZdIGJ5IFtodHRwczovL2dpdGh1Yi5jb20vYXRrXVxuICBvYmplY3QuYXRvYiB8fCAoXG4gIG9iamVjdC5hdG9iID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC89KyQvLCAnJyk7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCAlIDQgPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRDaGFyYWN0ZXJFcnJvcihcIidhdG9iJyBmYWlsZWQ6IFRoZSBzdHJpbmcgdG8gYmUgZGVjb2RlZCBpcyBub3QgY29ycmVjdGx5IGVuY29kZWQuXCIpO1xuICAgIH1cbiAgICBmb3IgKFxuICAgICAgLy8gaW5pdGlhbGl6ZSByZXN1bHQgYW5kIGNvdW50ZXJzXG4gICAgICB2YXIgYmMgPSAwLCBicywgYnVmZmVyLCBpZHggPSAwLCBvdXRwdXQgPSAnJztcbiAgICAgIC8vIGdldCBuZXh0IGNoYXJhY3RlclxuICAgICAgYnVmZmVyID0gaW5wdXQuY2hhckF0KGlkeCsrKTtcbiAgICAgIC8vIGNoYXJhY3RlciBmb3VuZCBpbiB0YWJsZT8gaW5pdGlhbGl6ZSBiaXQgc3RvcmFnZSBhbmQgYWRkIGl0cyBhc2NpaSB2YWx1ZTtcbiAgICAgIH5idWZmZXIgJiYgKGJzID0gYmMgJSA0ID8gYnMgKiA2NCArIGJ1ZmZlciA6IGJ1ZmZlcixcbiAgICAgICAgLy8gYW5kIGlmIG5vdCBmaXJzdCBvZiBlYWNoIDQgY2hhcmFjdGVycyxcbiAgICAgICAgLy8gY29udmVydCB0aGUgZmlyc3QgOCBiaXRzIHRvIG9uZSBhc2NpaSBjaGFyYWN0ZXJcbiAgICAgICAgYmMrKyAlIDQpID8gb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMjU1ICYgYnMgPj4gKC0yICogYmMgJiA2KSkgOiAwXG4gICAgKSB7XG4gICAgICAvLyB0cnkgdG8gZmluZCBjaGFyYWN0ZXIgaW4gdGFibGUgKDAtNjMsIG5vdCBmb3VuZCA9PiAtMSlcbiAgICAgIGJ1ZmZlciA9IGNoYXJzLmluZGV4T2YoYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSk7XG5cbn0oKSk7XG4iLCJ2YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcblxudmFyIGh0dHBzID0gbW9kdWxlLmV4cG9ydHM7XG5cbmZvciAodmFyIGtleSBpbiBodHRwKSB7XG4gICAgaWYgKGh0dHAuaGFzT3duUHJvcGVydHkoa2V5KSkgaHR0cHNba2V5XSA9IGh0dHBba2V5XTtcbn07XG5cbmh0dHBzLnJlcXVlc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICAgIGlmICghcGFyYW1zKSBwYXJhbXMgPSB7fTtcbiAgICBwYXJhbXMuc2NoZW1lID0gJ2h0dHBzJztcbiAgICByZXR1cm4gaHR0cC5yZXF1ZXN0LmNhbGwodGhpcywgcGFyYW1zLCBjYik7XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbiIsInZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5fdXNlVHlwZWRBcnJheXNgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAoY29tcGF0aWJsZSBkb3duIHRvIElFNilcbiAqL1xuQnVmZmVyLl91c2VUeXBlZEFycmF5cyA9IChmdW5jdGlvbiAoKSB7XG4gICAvLyBEZXRlY3QgaWYgYnJvd3NlciBzdXBwb3J0cyBUeXBlZCBBcnJheXMuIFN1cHBvcnRlZCBicm93c2VycyBhcmUgSUUgMTArLFxuICAgLy8gRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKywgT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICAgaWYgKHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKVxuICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgLy8gRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IGFkZGluZyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXM/IElmXG4gIC8vIG5vdCwgdGhlbiB0aGF0J3MgdGhlIHNhbWUgYXMgbm8gYFVpbnQ4QXJyYXlgIHN1cHBvcnQuIFdlIG5lZWQgdG8gYmUgYWJsZSB0b1xuICAvLyBhZGQgYWxsIHRoZSBub2RlIEJ1ZmZlciBBUEkgbWV0aG9kcy5cbiAgLy8gUmVsZXZhbnQgRmlyZWZveCBidWc6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOFxuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgwKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiZcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAvLyBDaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG5cbiAgLy8gV29ya2Fyb3VuZDogbm9kZSdzIGJhc2U2NCBpbXBsZW1lbnRhdGlvbiBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgc3RyaW5nc1xuICAvLyB3aGlsZSBiYXNlNjQtanMgZG9lcyBub3QuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcgJiYgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzdWJqZWN0ID0gc3RyaW5ndHJpbShzdWJqZWN0KVxuICAgIHdoaWxlIChzdWJqZWN0Lmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0ICsgJz0nXG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gIHZhciBsZW5ndGhcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKVxuICAgIGxlbmd0aCA9IGNvZXJjZShzdWJqZWN0KVxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJylcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpXG4gICAgbGVuZ3RoID0gY29lcmNlKHN1YmplY3QubGVuZ3RoKSAvLyBBc3N1bWUgb2JqZWN0IGlzIGFuIGFycmF5XG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgbnVtYmVyLCBhcnJheSBvciBzdHJpbmcuJylcblxuICB2YXIgYnVmXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IGF1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIFRISVMgaW5zdGFuY2Ugb2YgQnVmZmVyIChjcmVhdGVkIGJ5IGBuZXdgKVxuICAgIGJ1ZiA9IHRoaXNcbiAgICBidWYubGVuZ3RoID0gbGVuZ3RoXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzICYmIHR5cGVvZiBVaW50OEFycmF5ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICBzdWJqZWN0IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIFVpbnQ4QXJyYXlcbiAgICBidWYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkpXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgICBlbHNlXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3RbaV1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIUJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgJiYgIW5vWmVybykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYnVmW2ldID0gMFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuLy8gU1RBVElDIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiAoYikge1xuICByZXR1cm4gISEoYiAhPT0gbnVsbCAmJiBiICE9PSB1bmRlZmluZWQgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIgKyAnJ1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoIC8gMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdyYXcnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAqIDJcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGFzc2VydChpc0FycmF5KGxpc3QpLCAnVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdCwgW3RvdGFsTGVuZ3RoXSlcXG4nICtcbiAgICAgICdsaXN0IHNob3VsZCBiZSBhbiBBcnJheS4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB0b3RhbExlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICB0b3RhbExlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWxMZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcih0b3RhbExlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyBCVUZGRVIgSU5TVEFOQ0UgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gX2hleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgYXNzZXJ0KHN0ckxlbiAlIDIgPT09IDAsICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBhc3NlcnQoIWlzTmFOKGJ5dGUpLCAnSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlXG4gIH1cbiAgQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBpICogMlxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBfdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX2FzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX2JpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIF9hc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gX2Jhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIF9oZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICd1Y3MyJzogLy8gVE9ETzogTm8gc3VwcG9ydCBmb3IgdWNzMiBvciB1dGYxNmxlIGVuY29kaW5ncyB5ZXRcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIF91dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gX2FzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIF9iaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gX2Jhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcbiAgc3RhcnQgPSBOdW1iZXIoc3RhcnQpIHx8IDBcbiAgZW5kID0gKGVuZCAhPT0gdW5kZWZpbmVkKVxuICAgID8gTnVtYmVyKGVuZClcbiAgICA6IGVuZCA9IHNlbGYubGVuZ3RoXG5cbiAgLy8gRmFzdHBhdGggZW1wdHkgc3RyaW5nc1xuICBpZiAoZW5kID09PSBzdGFydClcbiAgICByZXR1cm4gJydcblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiBfaGV4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAndWNzMic6IC8vIFRPRE86IE5vIHN1cHBvcnQgZm9yIHVjczIgb3IgdXRmMTZsZSBlbmNvZGluZ3MgeWV0XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiBfdXRmOFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0dXJuIF9hc2NpaVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiBfYmluYXJ5U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIF9iYXNlNjRTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpc1xuXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICghdGFyZ2V0X3N0YXJ0KSB0YXJnZXRfc3RhcnQgPSAwXG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgc291cmNlLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnc291cmNlRW5kIDwgc291cmNlU3RhcnQnKVxuICBhc3NlcnQodGFyZ2V0X3N0YXJ0ID49IDAgJiYgdGFyZ2V0X3N0YXJ0IDwgdGFyZ2V0Lmxlbmd0aCxcbiAgICAgICd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCBzb3VyY2UubGVuZ3RoLCAnc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gc291cmNlLmxlbmd0aCwgJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpXG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydClcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0ICsgc3RhcnRcblxuICAvLyBjb3B5IVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyBpKyspXG4gICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gX3V0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXMgPSAnJ1xuICB2YXIgdG1wID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICAgICAgdG1wID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wICs9ICclJyArIGJ1ZltpXS50b1N0cmluZygxNilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKVxufVxuXG5mdW5jdGlvbiBfYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIF9iaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBfYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIF9oZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbi8vIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9idWZmZXIuaHRtbCNidWZmZXJfYnVmX3NsaWNlX3N0YXJ0X2VuZFxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IGNsYW1wKHN0YXJ0LCBsZW4sIDApXG4gIGVuZCA9IGNsYW1wKGVuZCwgbGVuLCBsZW4pXG5cbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICByZXR1cm4gYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgdmFyIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCwgdHJ1ZSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgICByZXR1cm4gbmV3QnVmXG4gIH1cbn1cblxuLy8gYGdldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIF9yZWFkVUludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV1cbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZFVJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDJdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgICB2YWwgfD0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApXG4gIH0gZWxzZSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMV0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMl0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAzXVxuICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0XSA8PCAyNCA+Pj4gMClcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICB2YXIgbmVnID0gdGhpc1tvZmZzZXRdICYgMHg4MFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gX3JlYWRJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSBfcmVhZFVJbnQxNihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gX3JlYWRVSW50MzIoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMDAwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZmZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkRmxvYXQgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWREb3VibGUgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWREb3VibGUodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWREb3VibGUodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuXG5cbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbn1cblxuZnVuY3Rpb24gX3dyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAgICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZmZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICB0aGlzLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICB0aGlzLndyaXRlVUludDgoMHhmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgX3dyaXRlVUludDE2KGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIF93cml0ZVVJbnQxNihidWYsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIF93cml0ZVVJbnQzMihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICBfd3JpdGVVSW50MzIoYnVmLCAweGZmZmZmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApXG4gIH1cblxuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpLCAndmFsdWUgaXMgbm90IGEgbnVtYmVyJylcbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgdGhpcy5sZW5ndGgsICdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSB0aGlzLmxlbmd0aCwgJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHRoaXNbaV0gPSB2YWx1ZVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG91dCA9IFtdXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpc1tpXSlcbiAgICBpZiAoaSA9PT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIG91dC5qb2luKCcgJykgKyAnPidcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSlcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCB0aGUgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5mdW5jdGlvbiBhdWdtZW50IChhcnIpIHtcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbi8vIHNsaWNlKHN0YXJ0LCBlbmQpXG5mdW5jdGlvbiBjbGFtcCAoaW5kZXgsIGxlbiwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSByZXR1cm4gZGVmYXVsdFZhbHVlXG4gIGluZGV4ID0gfn5pbmRleDsgIC8vIENvZXJjZSB0byBpbnRlZ2VyLlxuICBpZiAoaW5kZXggPj0gbGVuKSByZXR1cm4gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgaW5kZXggKz0gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gY29lcmNlIChsZW5ndGgpIHtcbiAgLy8gQ29lcmNlIGxlbmd0aCB0byBhIG51bWJlciAocG9zc2libHkgTmFOKSwgcm91bmQgdXBcbiAgLy8gaW4gY2FzZSBpdCdzIGZyYWN0aW9uYWwgKGUuZy4gMTIzLjQ1NikgdGhlbiBkbyBhXG4gIC8vIGRvdWJsZSBuZWdhdGUgdG8gY29lcmNlIGEgTmFOIHRvIDAuIEVhc3ksIHJpZ2h0P1xuICBsZW5ndGggPSB+fk1hdGguY2VpbCgrbGVuZ3RoKVxuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGhcbn1cblxuZnVuY3Rpb24gaXNBcnJheSAoc3ViamVjdCkge1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHN1YmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBBcnJheV0nXG4gIH0pKHN1YmplY3QpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlpc2ggKHN1YmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGIgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGlmIChiIDw9IDB4N0YpXG4gICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSlcbiAgICBlbHNlIHtcbiAgICAgIHZhciBzdGFydCA9IGlcbiAgICAgIGlmIChiID49IDB4RDgwMCAmJiBiIDw9IDB4REZGRikgaSsrXG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuc2xpY2Uoc3RhcnQsIGkrMSkpLnN1YnN0cigxKS5zcGxpdCgnJScpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGgubGVuZ3RoOyBqKyspXG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShzdHIpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgcG9zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyIChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuXG4vKlxuICogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYSB2YWxpZCBpbnRlZ2VyLiBUaGlzIG1lYW5zIHRoYXQgaXRcbiAqIGlzIG5vbi1uZWdhdGl2ZS4gSXQgaGFzIG5vIGZyYWN0aW9uYWwgY29tcG9uZW50IGFuZCB0aGF0IGl0IGRvZXMgbm90XG4gKiBleGNlZWQgdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ1aW50ICh2YWx1ZSwgbWF4KSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlID49IDAsXG4gICAgICAnc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmc2ludCh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJylcbn1cblxuZnVuY3Rpb24gYXNzZXJ0ICh0ZXN0LCBtZXNzYWdlKSB7XG4gIGlmICghdGVzdCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0ZhaWxlZCBhc3NlcnRpb24nKVxufVxuIiwidmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBaRVJPICAgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0bW9kdWxlLmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0oKSlcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgbkJpdHMgPSAtNyxcbiAgICAgIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgIGQgPSBpc0xFID8gLTEgOiAxLFxuICAgICAgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICBpICs9IGQ7XG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIHMgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBlTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgZSA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpO1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKTtcbn07XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSksXG4gICAgICBkID0gaXNMRSA/IDEgOiAtMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyohIGh0dHA6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjIuNCBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0bW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teIC1+XS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9cXHgyRXxcXHUzMDAyfFxcdUZGMEV8XFx1RkY2MS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdGFycmF5W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIGFycmF5O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHRyZXR1cm4gbWFwKHN0cmluZy5zcGxpdChyZWdleFNlcGFyYXRvcnMpLCBmbikuam9pbignLicpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIHRvIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHlcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIHRvIFVuaWNvZGUuIE9ubHkgdGhlXG5cdCAqIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS4gaXQgZG9lc24ndFxuXHQgKiBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGNvbnZlcnRlZCB0b1xuXHQgKiBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgUHVueWNvZGUgZG9tYWluIG5hbWUgdG8gY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGRvbWFpbikge1xuXHRcdHJldHVybiBtYXBEb21haW4oZG9tYWluLCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSB0byBQdW55Y29kZS4gT25seSB0aGVcblx0ICogbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLiBpdCBkb2Vzbid0XG5cdCAqIG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgdG8gY29udmVydCwgYXMgYSBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZS5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoZG9tYWluKSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihkb21haW4sIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjIuNCcsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG9ialtrXS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIHNldEltbWVkaWF0ZSA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9yZWFkYWJsZS5qcycpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi93cml0YWJsZS5qcycpO1xuXG5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxuRHVwbGV4LnByb3RvdHlwZS53cml0ZSA9IFdyaXRhYmxlLnByb3RvdHlwZS53cml0ZTtcbkR1cGxleC5wcm90b3R5cGUuZW5kID0gV3JpdGFibGUucHJvdG90eXBlLmVuZDtcbkR1cGxleC5wcm90b3R5cGUuX3dyaXRlID0gV3JpdGFibGUucHJvdG90eXBlLl93cml0ZTtcblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpXG4gICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLmVuZCgpO1xuICB9KTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCcuL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCcuL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgnLi9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL3RyYW5zZm9ybS5qcycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpXG4gICAgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW5kZXguanMnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG52YXIgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IDE2ICogMTAyNDtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH5+dGhpcy5oaWdoV2F0ZXJNYXJrO1xuXG4gIHRoaXMuYnVmZmVyID0gW107XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IGZhbHNlO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBJbiBzdHJlYW1zIHRoYXQgbmV2ZXIgaGF2ZSBhbnkgZGF0YSwgYW5kIGRvIHB1c2gobnVsbCkgcmlnaHQgYXdheSxcbiAgLy8gdGhlIGNvbnN1bWVyIGNhbiBtaXNzIHRoZSAnZW5kJyBldmVudCBpZiB0aGV5IGRvIHNvbWUgSS9PIGJlZm9yZVxuICAvLyBjb25zdW1pbmcgdGhlIHN0cmVhbS4gIFNvLCB3ZSBkb24ndCBlbWl0KCdlbmQnKSB1bnRpbCBzb21lIHJlYWRpbmdcbiAgLy8gaGFwcGVucy5cbiAgdGhpcy5jYWxsZWRSZWFkID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY3Vhc2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcblxuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHdoZW4gcGlwaW5nLCB3ZSBvbmx5IGNhcmUgYWJvdXQgJ3JlYWRhYmxlJyBldmVudHMgdGhhdCBoYXBwZW5cbiAgLy8gYWZ0ZXIgcmVhZCgpaW5nIGFsbCB0aGUgYnl0ZXMgYW5kIG5vdCBnZXR0aW5nIGFueSBwdXNoYmFjay5cbiAgdGhpcy5yYW5PdXQgPSBmYWxzZTtcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2RlcicpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKVxuICAgIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBmYWxzZSk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKVxuICAgICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZylcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKVxuICAgICAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuXG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICAoc3RhdGUubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24oZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDEyOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDJcbiAgICBuLS07XG4gICAgZm9yICh2YXIgcCA9IDE7IHAgPCAzMjsgcCA8PD0gMSkgbiB8PSBuID4+IHA7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpXG4gICAgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcblxuICBpZiAoaXNOYU4obikgfHwgbiA9PT0gbnVsbCkge1xuICAgIC8vIG9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICByZXR1cm4gc3RhdGUuYnVmZmVyWzBdLmxlbmd0aDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG4gPD0gMClcbiAgICByZXR1cm4gMDtcblxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgdGFyZ2V0IGJ1ZmZlciBsZXZlbCxcbiAgLy8gdGhlbiByYWlzZSB0aGUgd2F0ZXIgbWFyay4gIEJ1bXAgdXAgdG8gdGhlIG5leHQgaGlnaGVzdFxuICAvLyBwb3dlciBvZiAyLCB0byBwcmV2ZW50IGluY3JlYXNpbmcgaXQgZXhjZXNzaXZlbHkgaW4gdGlueVxuICAvLyBhbW91bnRzLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgc3RhdGUuaGlnaFdhdGVyTWFyayA9IHJvdW5kVXBUb05leHRQb3dlck9mMihuKTtcblxuICAvLyBkb24ndCBoYXZlIHRoYXQgbXVjaC4gIHJldHVybiBudWxsLCB1bmxlc3Mgd2UndmUgZW5kZWQuXG4gIGlmIChuID4gc3RhdGUubGVuZ3RoKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLmNhbGxlZFJlYWQgPSB0cnVlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA+IDApXG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJlxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlICYmXG4gICAgICAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCAtIG4gPD0gc3RhdGUuaGlnaFdhdGVyTWFyaylcbiAgICBkb1JlYWQgPSB0cnVlO1xuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpXG4gICAgZG9SZWFkID0gZmFsc2U7XG5cbiAgaWYgKGRvUmVhZCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgX3JlYWQgY2FsbGVkIGl0cyBjYWxsYmFjayBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYFxuICAvLyB3aWxsIGJlIGZhbHNlLCBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlXG4gIC8vIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gIGlmIChkb1JlYWQgJiYgIXN0YXRlLnJlYWRpbmcpXG4gICAgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApXG4gICAgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO1xuICBlbHNlXG4gICAgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfVxuXG4gIHN0YXRlLmxlbmd0aCAtPSBuO1xuXG4gIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLmVuZGVkKVxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gSWYgd2UgaGFwcGVuZWQgdG8gcmVhZCgpIGV4YWN0bHkgdGhlIHJlbWFpbmluZyBhbW91bnQgaW4gdGhlXG4gIC8vIGJ1ZmZlciwgYW5kIHRoZSBFT0YgaGFzIGJlZW4gc2VlbiBhdCB0aGlzIHBvaW50LCB0aGVuIG1ha2Ugc3VyZVxuICAvLyB0aGF0IHdlIGVtaXQgJ2VuZCcgb24gdGhlIHZlcnkgbmV4dCB0aWNrLlxuICBpZiAoc3RhdGUuZW5kZWQgJiYgIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKVxuICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlciA9IG51bGw7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgJ3N0cmluZycgIT09IHR5cGVvZiBjaHVuayAmJlxuICAgICAgY2h1bmsgIT09IG51bGwgJiZcbiAgICAgIGNodW5rICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlICYmXG4gICAgICAhZXIpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQgYW5kIHdlIGhhdmUgc29tZSBkYXRhIGxlZnQsIHRoZW4gZW1pdFxuICAvLyAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKVxuICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICBlbHNlXG4gICAgZW5kUmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSlcbiAgICByZXR1cm47XG5cbiAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgaWYgKHN0YXRlLnN5bmMpXG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgIH0pO1xuICBlbHNlXG4gICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbn1cblxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgICBlbHNlXG4gICAgICBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpXG4gICAgc2V0SW1tZWRpYXRlKGVuZEZuKTtcbiAgZWxzZVxuICAgIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSkge1xuICAgIGlmIChyZWFkYWJsZSAhPT0gc3JjKSByZXR1cm47XG4gICAgY2xlYW51cCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pXG4gICAgICBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICAvLyBjaGVjayBmb3IgbGlzdGVuZXJzIGJlZm9yZSBlbWl0IHJlbW92ZXMgb25lLXRpbWUgbGlzdGVuZXJzLlxuICB2YXIgZXJyTGlzdGVuZXJzID0gRUUubGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKTtcbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIHVucGlwZSgpO1xuICAgIGlmIChlcnJMaXN0ZW5lcnMgPT09IDAgJiYgRUUubGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMClcbiAgICAgIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cbiAgZGVzdC5vbmNlKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICAvLyB0aGUgaGFuZGxlciB0aGF0IHdhaXRzIGZvciByZWFkYWJsZSBldmVudHMgYWZ0ZXIgYWxsXG4gICAgLy8gdGhlIGRhdGEgZ2V0cyBzdWNrZWQgb3V0IGluIGZsb3cuXG4gICAgLy8gVGhpcyB3b3VsZCBiZSBlYXNpZXIgdG8gZm9sbG93IHdpdGggYSAub25jZSgpIGhhbmRsZXJcbiAgICAvLyBpbiBmbG93KCksIGJ1dCB0aGF0IGlzIHRvbyBzbG93LlxuICAgIHRoaXMub24oJ3JlYWRhYmxlJywgcGlwZU9uUmVhZGFibGUpO1xuXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZXN0ID0gdGhpcztcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwKVxuICAgICAgZmxvdyhzcmMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmbG93KHNyYykge1xuICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBjaHVuaztcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG5cbiAgZnVuY3Rpb24gd3JpdGUoZGVzdCwgaSwgbGlzdCkge1xuICAgIHZhciB3cml0dGVuID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSB3cml0dGVuKSB7XG4gICAgICBzdGF0ZS5hd2FpdERyYWluKys7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKHN0YXRlLnBpcGVzQ291bnQgJiYgbnVsbCAhPT0gKGNodW5rID0gc3JjLnJlYWQoKSkpIHtcblxuICAgIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKVxuICAgICAgd3JpdGUoc3RhdGUucGlwZXMsIDAsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIGZvckVhY2goc3RhdGUucGlwZXMsIHdyaXRlKTtcblxuICAgIHNyYy5lbWl0KCdkYXRhJywgY2h1bmspO1xuXG4gICAgLy8gaWYgYW55b25lIG5lZWRzIGEgZHJhaW4sIHRoZW4gd2UgaGF2ZSB0byB3YWl0IGZvciB0aGF0LlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID4gMClcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGlmIGV2ZXJ5IGRlc3RpbmF0aW9uIHdhcyB1bnBpcGVkLCBlaXRoZXIgYmVmb3JlIGVudGVyaW5nIHRoaXNcbiAgLy8gZnVuY3Rpb24sIG9yIGluIHRoZSB3aGlsZSBsb29wLCB0aGVuIHN0b3AgZmxvd2luZy5cbiAgLy9cbiAgLy8gTkI6IFRoaXMgaXMgYSBwcmV0dHkgcmFyZSBlZGdlIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSB7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgLy8gaWYgdGhlcmUgd2VyZSBkYXRhIGV2ZW50IGxpc3RlbmVycyBhZGRlZCwgdGhlbiBzd2l0Y2ggdG8gb2xkIG1vZGUuXG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpID4gMClcbiAgICAgIGVtaXREYXRhRXZlbnRzKHNyYyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gYXQgdGhpcyBwb2ludCwgbm8gb25lIG5lZWRlZCBhIGRyYWluLCBzbyB3ZSBqdXN0IHJhbiBvdXQgb2YgZGF0YVxuICAvLyBvbiB0aGUgbmV4dCByZWFkYWJsZSBldmVudCwgc3RhcnQgaXQgb3ZlciBhZ2Fpbi5cbiAgc3RhdGUucmFuT3V0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGlwZU9uUmVhZGFibGUoKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLnJhbk91dCkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmFuT3V0ID0gZmFsc2U7XG4gICAgZmxvdyh0aGlzKTtcbiAgfVxufVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbihkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdClcbiAgICAgIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIHBpcGVPblJlYWRhYmxlKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpXG4gICAgICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIHBpcGVPblJlYWRhYmxlKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaSA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaSA9PT0gLTEpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGksIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKVxuICAgIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpXG4gICAgZW1pdERhdGFFdmVudHModGhpcyk7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnICYmIHRoaXMucmVhZGFibGUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICB0aGlzLnJlYWQoMCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIGVtaXREYXRhRXZlbnRzKHRoaXMpO1xuICB0aGlzLnJlYWQoMCk7XG4gIHRoaXMuZW1pdCgncmVzdW1lJyk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgZW1pdERhdGFFdmVudHModGhpcywgdHJ1ZSk7XG4gIHRoaXMuZW1pdCgncGF1c2UnKTtcbn07XG5cbmZ1bmN0aW9uIGVtaXREYXRhRXZlbnRzKHN0cmVhbSwgc3RhcnRQYXVzZWQpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5mbG93aW5nKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lzYWFjcy9yZWFkYWJsZS1zdHJlYW0vaXNzdWVzLzE2XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3dpdGNoIHRvIG9sZCBtb2RlIG5vdy4nKTtcbiAgfVxuXG4gIHZhciBwYXVzZWQgPSBzdGFydFBhdXNlZCB8fCBmYWxzZTtcbiAgdmFyIHJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gY29udmVydCB0byBhbiBvbGQtc3R5bGUgc3RyZWFtLlxuICBzdHJlYW0ucmVhZGFibGUgPSB0cnVlO1xuICBzdHJlYW0ucGlwZSA9IFN0cmVhbS5wcm90b3R5cGUucGlwZTtcbiAgc3RyZWFtLm9uID0gc3RyZWFtLmFkZExpc3RlbmVyID0gU3RyZWFtLnByb3RvdHlwZS5vbjtcblxuICBzdHJlYW0ub24oJ3JlYWRhYmxlJywgZnVuY3Rpb24oKSB7XG4gICAgcmVhZGFibGUgPSB0cnVlO1xuXG4gICAgdmFyIGM7XG4gICAgd2hpbGUgKCFwYXVzZWQgJiYgKG51bGwgIT09IChjID0gc3RyZWFtLnJlYWQoKSkpKVxuICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjKTtcblxuICAgIGlmIChjID09PSBudWxsKSB7XG4gICAgICByZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgfVxuICB9KTtcblxuICBzdHJlYW0ucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICBwYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfTtcblxuICBzdHJlYW0ucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgcGF1c2VkID0gZmFsc2U7XG4gICAgaWYgKHJlYWRhYmxlKVxuICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIHRoaXMucmVhZCgwKTtcbiAgICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xuICB9O1xuXG4gIC8vIG5vdyBtYWtlIGl0IHN0YXJ0LCBqdXN0IGluIGNhc2UgaXQgaGFkbid0IGFscmVhZHkuXG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpXG4gICAgICAgIHNlbGYucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKVxuICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICBpZiAoIWNodW5rIHx8ICFzdGF0ZS5vYmplY3RNb2RlICYmICFjaHVuay5sZW5ndGgpXG4gICAgICByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgdGhpc1tpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbihtZXRob2QpIHsgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgfX0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICB2YXIgZXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24oZXYpIHtcbiAgICBzdHJlYW0ub24oZXYsIGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gc2VsZi5lbWl0LmFwcGx5KHNlbGYsIGV2LCB4KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5cblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICB2YXIgbGlzdCA9IHN0YXRlLmJ1ZmZlcjtcbiAgdmFyIGxlbmd0aCA9IHN0YXRlLmxlbmd0aDtcbiAgdmFyIHN0cmluZ01vZGUgPSAhIXN0YXRlLmRlY29kZXI7XG4gIHZhciBvYmplY3RNb2RlID0gISFzdGF0ZS5vYmplY3RNb2RlO1xuICB2YXIgcmV0O1xuXG4gIC8vIG5vdGhpbmcgaW4gdGhlIGxpc3QsIGRlZmluaXRlbHkgZW1wdHkuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAobGVuZ3RoID09PSAwKVxuICAgIHJldCA9IG51bGw7XG4gIGVsc2UgaWYgKG9iamVjdE1vZGUpXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICBlbHNlIGlmICghbiB8fCBuID49IGxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgYXJyYXkuXG4gICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICByZXQgPSBsaXN0LmpvaW4oJycpO1xuICAgIGVsc2VcbiAgICAgIHJldCA9IEJ1ZmZlci5jb25jYXQobGlzdCwgbGVuZ3RoKTtcbiAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBqdXN0IHNvbWUgb2YgaXQuXG4gICAgaWYgKG4gPCBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8ganVzdCB0YWtlIGEgcGFydCBvZiB0aGUgZmlyc3QgbGlzdCBpdGVtLlxuICAgICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgIHJldCA9IGJ1Zi5zbGljZSgwLCBuKTtcbiAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgfSBlbHNlIGlmIChuID09PSBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8gZmlyc3QgbGlzdCBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcGxleCBjYXNlLlxuICAgICAgLy8gd2UgaGF2ZSBlbm91Z2ggdG8gY292ZXIgaXQsIGJ1dCBpdCBzcGFucyBwYXN0IHRoZSBmaXJzdCBidWZmZXIuXG4gICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgcmV0ID0gJyc7XG4gICAgICBlbHNlXG4gICAgICAgIHJldCA9IG5ldyBCdWZmZXIobik7XG5cbiAgICAgIHZhciBjID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsICYmIGMgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICAgIHZhciBjcHkgPSBNYXRoLm1pbihuIC0gYywgYnVmLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgICAgcmV0ICs9IGJ1Zi5zbGljZSgwLCBjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYnVmLmNvcHkocmV0LCBjLCAwLCBjcHkpO1xuXG4gICAgICAgIGlmIChjcHkgPCBidWYubGVuZ3RoKVxuICAgICAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2UoY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcblxuICAgICAgICBjICs9IGNweTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZFJlYWRhYmxlIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmNhbGxlZFJlYWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gICAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZiAoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiKSkiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vZHVwbGV4LmpzJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24oZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgaWYgKGNiKVxuICAgIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHRoaXMuX2ZsdXNoKVxuICAgICAgdGhpcy5fZmx1c2goZnVuY3Rpb24oZXIpIHtcbiAgICAgICAgZG9uZShzdHJlYW0sIGVyKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIGRvbmUoc3RyZWFtKTtcbiAgfSk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8XG4gICAgICAgIHJzLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKVxuICAgICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHdzLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbnZhciBpc1VpbnQ4QXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCdcbiAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfVxuICA6IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHggJiYgeC5jb25zdHJ1Y3RvciAmJiB4LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5J1xuICB9XG47XG52YXIgaXNBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCdcbiAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIH1cbiAgOiBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB4ICYmIHguY29uc3RydWN0b3IgJiYgeC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXlCdWZmZXInXG4gIH1cbjtcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2luZGV4LmpzJyk7XG52YXIgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogMTYgKiAxMDI0O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWN1YXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24oZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRob3VnaCB0aGV5J3JlIG5vdFxuICAvLyBpbnN0YW5jZW9mIFdyaXRhYmxlLCB0aGV5J3JlIGluc3RhbmNlb2YgUmVhZGFibGUuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgU3RyZWFtLkR1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUuIE5vdCByZWFkYWJsZS4nKSk7XG59O1xuXG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgY2IoZXIpO1xuICB9KTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICdzdHJpbmcnICE9PSB0eXBlb2YgY2h1bmsgJiZcbiAgICAgIGNodW5rICE9PSBudWxsICYmXG4gICAgICBjaHVuayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIHZhciBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgaXNVaW50OEFycmF5KGNodW5rKSlcbiAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmspO1xuICBpZiAoaXNBcnJheUJ1ZmZlcihjaHVuaykgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShjaHVuaykpO1xuICBcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgZWxzZSBpZiAoIWVuY29kaW5nKVxuICAgIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpXG4gICAgY2IgPSBmdW5jdGlvbigpIHt9O1xuXG4gIGlmIChzdGF0ZS5lbmRlZClcbiAgICB3cml0ZUFmdGVyRW5kKHRoaXMsIHN0YXRlLCBjYik7XG4gIGVsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpXG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmXG4gICAgICBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJlxuICAgICAgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgc3RhdGUubmVlZERyYWluID0gIXJldDtcblxuICBpZiAoc3RhdGUud3JpdGluZylcbiAgICBzdGF0ZS5idWZmZXIucHVzaChuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikpO1xuICBlbHNlXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgaWYgKHN5bmMpXG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICBlbHNlXG4gICAgY2IoZXIpO1xuXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpXG4gICAgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7XG4gIGVsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZClcbiAgICBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIGNiKCk7XG4gIGlmIChmaW5pc2hlZClcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG5cbiAgZm9yICh2YXIgYyA9IDA7IGMgPCBzdGF0ZS5idWZmZXIubGVuZ3RoOyBjKyspIHtcbiAgICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJbY107XG4gICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgYysrO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuICBpZiAoYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgc3RhdGUuYnVmZmVyID0gc3RhdGUuYnVmZmVyLnNsaWNlKGMpO1xuICBlbHNlXG4gICAgc3RhdGUuYnVmZmVyLmxlbmd0aCA9IDA7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3VuZGVmaW5lZCcgJiYgY2h1bmsgIT09IG51bGwpXG4gICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKVxuICAgIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICByZXR1cm4gKHN0YXRlLmVuZGluZyAmJlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICFzdGF0ZS5maW5pc2hlZCAmJlxuICAgICAgICAgICFzdGF0ZS53cml0aW5nKTtcbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZClcbiAgICAgIHNldEltbWVkaWF0ZShjYik7XG4gICAgZWxzZVxuICAgICAgc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cbn1cblxudmFyIFN0cmluZ0RlY29kZXIgPSBleHBvcnRzLlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBCYXNlLTY0IHN0b3JlcyAzIGJ5dGVzIGluIDQgY2hhcnMsIGFuZCBwYWRzIHRoZSByZW1haW5kZXIuXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgY2hhclN0ciA9ICcnO1xuICB2YXIgb2Zmc2V0ID0gMDtcblxuICAvLyBpZiBvdXIgbGFzdCB3cml0ZSBlbmRlZCB3aXRoIGFuIGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlclxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgICAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIG9mZnNldCwgaSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gKGkgLSBvZmZzZXQpO1xuICAgIG9mZnNldCA9IGk7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgY2hhclN0ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICBpZiAoaSA9PSBidWZmZXIubGVuZ3RoKSByZXR1cm4gY2hhclN0cjtcblxuICAgIC8vIG90aGVyd2lzZSBjdXQgb2ZmIHRoZSBjaGFyYWN0ZXJzIGVuZCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBidWZmZXJcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoaSwgYnVmZmVyLmxlbmd0aCk7XG4gICAgYnJlYWs7XG4gIH1cblxuICB2YXIgbGVuSW5jb21wbGV0ZSA9IHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gbGVuSW5jb21wbGV0ZSwgZW5kKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IGxlbkluY29tcGxldGU7XG4gICAgZW5kIC09IGxlbkluY29tcGxldGU7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICB0aGlzLmNoYXJCdWZmZXIud3JpdGUoY2hhclN0ci5jaGFyQXQoY2hhclN0ci5sZW5ndGggLSAxKSwgdGhpcy5lbmNvZGluZyk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gMykgPyAzIDogYnVmZmVyLmxlbmd0aDtcblxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gIC8vIGluY29tcGxldGUgY2hhci5cbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgLy8gMTEwWFhYWFhcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMFhYWFhcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMTBYWFhcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB2YXIgaW5jb21wbGV0ZSA9IHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gIHRoaXMuY2hhckxlbmd0aCA9IGluY29tcGxldGUgPyAyIDogMDtcbiAgcmV0dXJuIGluY29tcGxldGU7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB2YXIgaW5jb21wbGV0ZSA9IHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IGluY29tcGxldGUgPyAzIDogMDtcbiAgcmV0dXJuIGluY29tcGxldGU7XG59XG4iLCIvKmpzaGludCBzdHJpY3Q6dHJ1ZSBub2RlOnRydWUgZXM1OnRydWUgb25ldmFyOnRydWUgbGF4Y29tbWE6dHJ1ZSBsYXhicmVhazp0cnVlIGVxZXFlcTp0cnVlIGltbWVkOnRydWUgbGF0ZWRlZjp0cnVlKi9cbihmdW5jdGlvbiAoKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnficsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KGRlbGltcyksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddXG4gICAgICAuY29uY2F0KHVud2lzZSkuY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIG5vbkF1dGhDaGFycyA9IFsnLycsICdAJywgJz8nLCAnIyddLmNvbmNhdChkZWxpbXMpLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlthLXpBLVowLTldW2EtejAtOUEtWl8tXXswLDYyfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oW2EtekEtWjAtOV1bYS16MC05QS1aXy1dezAsNjJ9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGhhdmUgYSBwYXRoIGNvbXBvbmVudC5cbiAgICBwYXRoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdHlwZW9mKHVybCkgPT09ICdvYmplY3QnICYmIHVybC5ocmVmKSByZXR1cm4gdXJsO1xuXG4gIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICB2YXIgb3V0ID0ge30sXG4gICAgICByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICBvdXQucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICBvdXQuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvLyBkb24ndCBlbmZvcmNlIGZ1bGwgUkZDIGNvcnJlY3RuZXNzLCBqdXN0IGJlIHVuc3R1cGlkIGFib3V0IGl0LlxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBAIHNpZ24sIHVubGVzcyBzb21lIG5vbi1hdXRoIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIHZhciBhdFNpZ24gPSByZXN0LmluZGV4T2YoJ0AnKTtcbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgdmFyIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG5cbiAgICAgIC8vIHRoZXJlICptYXkgYmUqIGFuIGF1dGhcbiAgICAgIHZhciBoYXNBdXRoID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9uQXV0aENoYXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXV0aC5pbmRleE9mKG5vbkF1dGhDaGFyc1tpXSkgIT09IC0xKSB7XG4gICAgICAgICAgLy8gbm90IGEgdmFsaWQgYXV0aC4gIFNvbWV0aGluZyBsaWtlIGh0dHA6Ly9mb28uY29tL2JhckBiYXovXG4gICAgICAgICAgaGFzQXV0aCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNBdXRoKSB7XG4gICAgICAgIC8vIHBsdWNrIG9mZiB0aGUgYXV0aCBwb3J0aW9uLlxuICAgICAgICBvdXQuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKGF0U2lnbiArIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmaXJzdE5vbkhvc3QgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBpbmRleCA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSAmJlxuICAgICAgICAgIChmaXJzdE5vbkhvc3QgPCAwIHx8IGluZGV4IDwgZmlyc3ROb25Ib3N0KSkgZmlyc3ROb25Ib3N0ID0gaW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0Tm9uSG9zdCAhPT0gLTEpIHtcbiAgICAgIG91dC5ob3N0ID0gcmVzdC5zdWJzdHIoMCwgZmlyc3ROb25Ib3N0KTtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cihmaXJzdE5vbkhvc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQuaG9zdCA9IHJlc3Q7XG4gICAgICByZXN0ID0gJyc7XG4gICAgfVxuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB2YXIgcCA9IHBhcnNlSG9zdChvdXQuaG9zdCk7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIG91dFtrZXldID0gcFtrZXldO1xuICAgIH1cblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICBvdXQuaG9zdG5hbWUgPSBvdXQuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSBvdXQuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICBvdXQuaG9zdG5hbWVbb3V0Lmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAob3V0Lmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICBvdXQuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2UgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSBvdXQuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0Lmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgIG91dC5ob3N0bmFtZSA9IG91dC5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnkgY29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgdGhlIHBhcnQgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhcyBub24gQVNDSUkgY2hhcmFjdGVycy4gSS5lLiBpdCBkb3NlbnQgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBpbiBBU0NJSS5cbiAgICAgIHZhciBkb21haW5BcnJheSA9IG91dC5ob3N0bmFtZS5zcGxpdCgnLicpO1xuICAgICAgdmFyIG5ld091dCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb21haW5BcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcyA9IGRvbWFpbkFycmF5W2ldO1xuICAgICAgICBuZXdPdXQucHVzaChzLm1hdGNoKC9bXkEtWmEtejAtOV8tXS8pID9cbiAgICAgICAgICAgICd4bi0tJyArIHB1bnljb2RlLmVuY29kZShzKSA6IHMpO1xuICAgICAgfVxuICAgICAgb3V0Lmhvc3RuYW1lID0gbmV3T3V0LmpvaW4oJy4nKTtcbiAgICB9XG5cbiAgICBvdXQuaG9zdCA9IChvdXQuaG9zdG5hbWUgfHwgJycpICtcbiAgICAgICAgKChvdXQucG9ydCkgPyAnOicgKyBvdXQucG9ydCA6ICcnKTtcbiAgICBvdXQuaHJlZiArPSBvdXQuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICBvdXQuaG9zdG5hbWUgPSBvdXQuaG9zdG5hbWUuc3Vic3RyKDEsIG91dC5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgb3V0Lmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIG91dC5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgb3V0LnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgb3V0LnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2Uob3V0LnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIG91dC5zZWFyY2ggPSAnJztcbiAgICBvdXQucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgb3V0LnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIG91dC5ob3N0bmFtZSAmJiAhb3V0LnBhdGhuYW1lKSB7XG4gICAgb3V0LnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAob3V0LnBhdGhuYW1lIHx8IG91dC5zZWFyY2gpIHtcbiAgICBvdXQucGF0aCA9IChvdXQucGF0aG5hbWUgPyBvdXQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgKG91dC5zZWFyY2ggPyBvdXQuc2VhcmNoIDogJycpO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIG91dC5ocmVmID0gdXJsRm9ybWF0KG91dCk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodHlwZW9mKG9iaikgPT09ICdzdHJpbmcnKSBvYmogPSB1cmxQYXJzZShvYmopO1xuXG4gIHZhciBhdXRoID0gb2JqLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IG9iai5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gb2JqLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IG9iai5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAob2JqLmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIGhvc3QgPSBhdXRoICsgb2JqLmhvc3Q7XG4gIH0gZWxzZSBpZiAob2JqLmhvc3RuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBob3N0ID0gYXV0aCArIChvYmouaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIG9iai5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIG9iai5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKG9iai5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIG9iai5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmIChvYmoucXVlcnkgJiYgdHlwZW9mIG9iai5xdWVyeSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIE9iamVjdC5rZXlzKG9iai5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkob2JqLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSBvYmouc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmIChvYmouc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsRm9ybWF0KHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkpO1xufVxuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcblxuICBzb3VyY2UgPSB1cmxQYXJzZSh1cmxGb3JtYXQoc291cmNlKSwgZmFsc2UsIHRydWUpO1xuICByZWxhdGl2ZSA9IHVybFBhcnNlKHVybEZvcm1hdChyZWxhdGl2ZSksIGZhbHNlLCB0cnVlKTtcblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgc291cmNlLmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHNvdXJjZS5ocmVmID0gdXJsRm9ybWF0KHNvdXJjZSk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICByZWxhdGl2ZS5wcm90b2NvbCA9IHNvdXJjZS5wcm90b2NvbDtcbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdICYmXG4gICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lICYmICFyZWxhdGl2ZS5wYXRobmFtZSkge1xuICAgICAgcmVsYXRpdmUucGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lID0gJy8nO1xuICAgIH1cbiAgICByZWxhdGl2ZS5ocmVmID0gdXJsRm9ybWF0KHJlbGF0aXZlKTtcbiAgICByZXR1cm4gcmVsYXRpdmU7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHNvdXJjZS5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHJlbGF0aXZlLmhyZWYgPSB1cmxGb3JtYXQocmVsYXRpdmUpO1xuICAgICAgcmV0dXJuIHJlbGF0aXZlO1xuICAgIH1cbiAgICBzb3VyY2UucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZWxhdGl2ZS5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH1cbiAgICBzb3VyY2UucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICBzb3VyY2Uuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHNvdXJjZS5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNvdXJjZS5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICBzb3VyY2UuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgc291cmNlLmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICBzb3VyY2UucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChzb3VyY2UucGF0aG5hbWUgIT09IHVuZGVmaW5lZCB8fCBzb3VyY2Uuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNvdXJjZS5wYXRoID0gKHNvdXJjZS5wYXRobmFtZSA/IHNvdXJjZS5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChzb3VyY2Uuc2VhcmNoID8gc291cmNlLnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgc291cmNlLnNsYXNoZXMgPSBzb3VyY2Uuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHNvdXJjZS5ocmVmID0gdXJsRm9ybWF0KHNvdXJjZSk7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChzb3VyY2UucGF0aG5hbWUgJiYgc291cmNlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAoc291cmNlLmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHNvdXJjZS5wYXRobmFtZSAmJiBzb3VyY2UucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gc291cmNlLnByb3RvY29sICYmXG4gICAgICAgICAgIXNsYXNoZWRQcm90b2NvbFtzb3VyY2UucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHNvdXJjZS5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG5cbiAgICBkZWxldGUgc291cmNlLmhvc3RuYW1lO1xuICAgIGRlbGV0ZSBzb3VyY2UucG9ydDtcbiAgICBpZiAoc291cmNlLmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHNvdXJjZS5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQoc291cmNlLmhvc3QpO1xuICAgIH1cbiAgICBkZWxldGUgc291cmNlLmhvc3Q7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICBkZWxldGUgcmVsYXRpdmUuaG9zdG5hbWU7XG4gICAgICBkZWxldGUgcmVsYXRpdmUucG9ydDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHJlbGF0aXZlLmhvc3Q7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHNvdXJjZS5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogc291cmNlLmhvc3Q7XG4gICAgc291cmNlLmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogc291cmNlLmhvc3RuYW1lO1xuICAgIHNvdXJjZS5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgc291cmNlLnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgc291cmNlLnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICBzb3VyY2UucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICgnc2VhcmNoJyBpbiByZWxhdGl2ZSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHNvdXJjZS5ob3N0bmFtZSA9IHNvdXJjZS5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHNvdXJjZS5ob3N0ICYmIHNvdXJjZS5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICBzb3VyY2UuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgc291cmNlLmhvc3QgPSBzb3VyY2UuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZS5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgc291cmNlLnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChzb3VyY2UucGF0aG5hbWUgIT09IHVuZGVmaW5lZCB8fCBzb3VyY2Uuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNvdXJjZS5wYXRoID0gKHNvdXJjZS5wYXRobmFtZSA/IHNvdXJjZS5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChzb3VyY2Uuc2VhcmNoID8gc291cmNlLnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgc291cmNlLmhyZWYgPSB1cmxGb3JtYXQoc291cmNlKTtcbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICBkZWxldGUgc291cmNlLnBhdGhuYW1lO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXNvdXJjZS5zZWFyY2gpIHtcbiAgICAgIHNvdXJjZS5wYXRoID0gJy8nICsgc291cmNlLnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHNvdXJjZS5wYXRoO1xuICAgIH1cbiAgICBzb3VyY2UuaHJlZiA9IHVybEZvcm1hdChzb3VyY2UpO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChzb3VyY2UuaG9zdCB8fCByZWxhdGl2ZS5ob3N0KSAmJiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8XG4gICAgICBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICBzb3VyY2UuaG9zdG5hbWUgPSBzb3VyY2UuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSBzb3VyY2UuaG9zdCAmJiBzb3VyY2UuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgc291cmNlLmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICBzb3VyY2UuaG9zdCA9IHNvdXJjZS5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAoc291cmNlLmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIHNvdXJjZS5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmIChzb3VyY2UucGF0aG5hbWUgIT09IHVuZGVmaW5lZCB8fCBzb3VyY2Uuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2UucGF0aCA9IChzb3VyY2UucGF0aG5hbWUgPyBzb3VyY2UucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNvdXJjZS5zZWFyY2ggPyBzb3VyY2Uuc2VhcmNoIDogJycpO1xuICB9XG4gIHNvdXJjZS5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCBzb3VyY2UuYXV0aDtcbiAgc291cmNlLnNsYXNoZXMgPSBzb3VyY2Uuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICBzb3VyY2UuaHJlZiA9IHVybEZvcm1hdChzb3VyY2UpO1xuICByZXR1cm4gc291cmNlO1xufVxuXG5mdW5jdGlvbiBwYXJzZUhvc3QoaG9zdCkge1xuICB2YXIgb3V0ID0ge307XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICBvdXQucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIG91dC5ob3N0bmFtZSA9IGhvc3Q7XG4gIHJldHVybiBvdXQ7XG59XG5cbn0oKSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiL1VzZXJzL2JsYWtlZW1icmV5L1Byb2plY3RzL2FwaS1ub3RlYm9vay9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIlxuLyoqXG4gKiBFc2NhcGUgcmVnZXhwIHNwZWNpYWwgY2hhcmFjdGVycyBpbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UoLyhbLiorPz1eIToke30oKXxbXFxdXFwvXFxcXF0pL2csICdcXFxcJDEnKTtcbn07IiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuXG4vKipcbiAqIEV4cG9zZSB0aGUgdHlwZXMuXG4gKi9cblxuZXhwb3J0cy50eXBlcyA9IHR5cGVzO1xuXG4vKipcbiAqIExvb2t1cCB3aXRoIGBleHRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5sb29rdXAgPSBmdW5jdGlvbihleHQpe1xuICBpZiAoJy4nID09IGV4dFswXSkgZXh0ID0gZXh0LnNsaWNlKDEpO1xuICByZXR1cm4gdHlwZXNbZXh0XTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7ICcxMjMnOiAnYXBwbGljYXRpb24vdm5kLmxvdHVzLTEtMi0zJyxcbiAgZXo6ICdhcHBsaWNhdGlvbi9hbmRyZXctaW5zZXQnLFxuICBhdzogJ2FwcGxpY2F0aW9uL2FwcGxpeHdhcmUnLFxuICBhdG9tOiAnYXBwbGljYXRpb24vYXRvbSt4bWwnLFxuICBhdG9tY2F0OiAnYXBwbGljYXRpb24vYXRvbWNhdCt4bWwnLFxuICBhdG9tc3ZjOiAnYXBwbGljYXRpb24vYXRvbXN2Yyt4bWwnLFxuICBjY3htbDogJ2FwcGxpY2F0aW9uL2NjeG1sK3htbCcsXG4gIGNkbWlhOiAnYXBwbGljYXRpb24vY2RtaS1jYXBhYmlsaXR5JyxcbiAgY2RtaWM6ICdhcHBsaWNhdGlvbi9jZG1pLWNvbnRhaW5lcicsXG4gIGNkbWlkOiAnYXBwbGljYXRpb24vY2RtaS1kb21haW4nLFxuICBjZG1pbzogJ2FwcGxpY2F0aW9uL2NkbWktb2JqZWN0JyxcbiAgY2RtaXE6ICdhcHBsaWNhdGlvbi9jZG1pLXF1ZXVlJyxcbiAgY3U6ICdhcHBsaWNhdGlvbi9jdS1zZWVtZScsXG4gIGRhdm1vdW50OiAnYXBwbGljYXRpb24vZGF2bW91bnQreG1sJyxcbiAgZGJrOiAnYXBwbGljYXRpb24vZG9jYm9vayt4bWwnLFxuICBkc3NjOiAnYXBwbGljYXRpb24vZHNzYytkZXInLFxuICB4ZHNzYzogJ2FwcGxpY2F0aW9uL2Rzc2MreG1sJyxcbiAgZWNtYTogJ2FwcGxpY2F0aW9uL2VjbWFzY3JpcHQnLFxuICBlbW1hOiAnYXBwbGljYXRpb24vZW1tYSt4bWwnLFxuICBlcHViOiAnYXBwbGljYXRpb24vZXB1Yit6aXAnLFxuICBleGk6ICdhcHBsaWNhdGlvbi9leGknLFxuICBwZnI6ICdhcHBsaWNhdGlvbi9mb250LXRkcGZyJyxcbiAgZ21sOiAnYXBwbGljYXRpb24vZ21sK3htbCcsXG4gIGdweDogJ2FwcGxpY2F0aW9uL2dweCt4bWwnLFxuICBneGY6ICdhcHBsaWNhdGlvbi9neGYnLFxuICBzdGs6ICdhcHBsaWNhdGlvbi9oeXBlcnN0dWRpbycsXG4gIGluazogJ2FwcGxpY2F0aW9uL2lua21sK3htbCcsXG4gIGlua21sOiAnYXBwbGljYXRpb24vaW5rbWwreG1sJyxcbiAgaXBmaXg6ICdhcHBsaWNhdGlvbi9pcGZpeCcsXG4gIGphcjogJ2FwcGxpY2F0aW9uL2phdmEtYXJjaGl2ZScsXG4gIHNlcjogJ2FwcGxpY2F0aW9uL2phdmEtc2VyaWFsaXplZC1vYmplY3QnLFxuICBjbGFzczogJ2FwcGxpY2F0aW9uL2phdmEtdm0nLFxuICBqczogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLFxuICBqc29uOiAnYXBwbGljYXRpb24vanNvbicsXG4gIGpzb25tbDogJ2FwcGxpY2F0aW9uL2pzb25tbCtqc29uJyxcbiAgbG9zdHhtbDogJ2FwcGxpY2F0aW9uL2xvc3QreG1sJyxcbiAgaHF4OiAnYXBwbGljYXRpb24vbWFjLWJpbmhleDQwJyxcbiAgY3B0OiAnYXBwbGljYXRpb24vbWFjLWNvbXBhY3Rwcm8nLFxuICBtYWRzOiAnYXBwbGljYXRpb24vbWFkcyt4bWwnLFxuICBtcmM6ICdhcHBsaWNhdGlvbi9tYXJjJyxcbiAgbXJjeDogJ2FwcGxpY2F0aW9uL21hcmN4bWwreG1sJyxcbiAgbWE6ICdhcHBsaWNhdGlvbi9tYXRoZW1hdGljYScsXG4gIG5iOiAnYXBwbGljYXRpb24vbWF0aGVtYXRpY2EnLFxuICBtYjogJ2FwcGxpY2F0aW9uL21hdGhlbWF0aWNhJyxcbiAgbWF0aG1sOiAnYXBwbGljYXRpb24vbWF0aG1sK3htbCcsXG4gIG1ib3g6ICdhcHBsaWNhdGlvbi9tYm94JyxcbiAgbXNjbWw6ICdhcHBsaWNhdGlvbi9tZWRpYXNlcnZlcmNvbnRyb2wreG1sJyxcbiAgbWV0YWxpbms6ICdhcHBsaWNhdGlvbi9tZXRhbGluayt4bWwnLFxuICBtZXRhNDogJ2FwcGxpY2F0aW9uL21ldGFsaW5rNCt4bWwnLFxuICBtZXRzOiAnYXBwbGljYXRpb24vbWV0cyt4bWwnLFxuICBtb2RzOiAnYXBwbGljYXRpb24vbW9kcyt4bWwnLFxuICBtMjE6ICdhcHBsaWNhdGlvbi9tcDIxJyxcbiAgbXAyMTogJ2FwcGxpY2F0aW9uL21wMjEnLFxuICBtcDRzOiAnYXBwbGljYXRpb24vbXA0JyxcbiAgZG9jOiAnYXBwbGljYXRpb24vbXN3b3JkJyxcbiAgZG90OiAnYXBwbGljYXRpb24vbXN3b3JkJyxcbiAgbXhmOiAnYXBwbGljYXRpb24vbXhmJyxcbiAgYmluOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgZG1zOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgbHJmOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgbWFyOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgc286ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLFxuICBkaXN0OiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgZGlzdHo6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLFxuICBwa2c6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLFxuICBicGs6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLFxuICBkdW1wOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgZWxjOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgZGVwbG95OiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgb2RhOiAnYXBwbGljYXRpb24vb2RhJyxcbiAgb3BmOiAnYXBwbGljYXRpb24vb2VicHMtcGFja2FnZSt4bWwnLFxuICBvZ3g6ICdhcHBsaWNhdGlvbi9vZ2cnLFxuICBvbWRvYzogJ2FwcGxpY2F0aW9uL29tZG9jK3htbCcsXG4gIG9uZXRvYzogJ2FwcGxpY2F0aW9uL29uZW5vdGUnLFxuICBvbmV0b2MyOiAnYXBwbGljYXRpb24vb25lbm90ZScsXG4gIG9uZXRtcDogJ2FwcGxpY2F0aW9uL29uZW5vdGUnLFxuICBvbmVwa2c6ICdhcHBsaWNhdGlvbi9vbmVub3RlJyxcbiAgb3hwczogJ2FwcGxpY2F0aW9uL294cHMnLFxuICB4ZXI6ICdhcHBsaWNhdGlvbi9wYXRjaC1vcHMtZXJyb3IreG1sJyxcbiAgcGRmOiAnYXBwbGljYXRpb24vcGRmJyxcbiAgcGdwOiAnYXBwbGljYXRpb24vcGdwLWVuY3J5cHRlZCcsXG4gIGFzYzogJ2FwcGxpY2F0aW9uL3BncC1zaWduYXR1cmUnLFxuICBzaWc6ICdhcHBsaWNhdGlvbi9wZ3Atc2lnbmF0dXJlJyxcbiAgcHJmOiAnYXBwbGljYXRpb24vcGljcy1ydWxlcycsXG4gIHAxMDogJ2FwcGxpY2F0aW9uL3BrY3MxMCcsXG4gIHA3bTogJ2FwcGxpY2F0aW9uL3BrY3M3LW1pbWUnLFxuICBwN2M6ICdhcHBsaWNhdGlvbi9wa2NzNy1taW1lJyxcbiAgcDdzOiAnYXBwbGljYXRpb24vcGtjczctc2lnbmF0dXJlJyxcbiAgcDg6ICdhcHBsaWNhdGlvbi9wa2NzOCcsXG4gIGFjOiAnYXBwbGljYXRpb24vcGtpeC1hdHRyLWNlcnQnLFxuICBjZXI6ICdhcHBsaWNhdGlvbi9wa2l4LWNlcnQnLFxuICBjcmw6ICdhcHBsaWNhdGlvbi9wa2l4LWNybCcsXG4gIHBraXBhdGg6ICdhcHBsaWNhdGlvbi9wa2l4LXBraXBhdGgnLFxuICBwa2k6ICdhcHBsaWNhdGlvbi9wa2l4Y21wJyxcbiAgcGxzOiAnYXBwbGljYXRpb24vcGxzK3htbCcsXG4gIGFpOiAnYXBwbGljYXRpb24vcG9zdHNjcmlwdCcsXG4gIGVwczogJ2FwcGxpY2F0aW9uL3Bvc3RzY3JpcHQnLFxuICBwczogJ2FwcGxpY2F0aW9uL3Bvc3RzY3JpcHQnLFxuICBjd3c6ICdhcHBsaWNhdGlvbi9wcnMuY3d3JyxcbiAgcHNrY3htbDogJ2FwcGxpY2F0aW9uL3Bza2MreG1sJyxcbiAgcmRmOiAnYXBwbGljYXRpb24vcmRmK3htbCcsXG4gIHJpZjogJ2FwcGxpY2F0aW9uL3JlZ2luZm8reG1sJyxcbiAgcm5jOiAnYXBwbGljYXRpb24vcmVsYXgtbmctY29tcGFjdC1zeW50YXgnLFxuICBybDogJ2FwcGxpY2F0aW9uL3Jlc291cmNlLWxpc3RzK3htbCcsXG4gIHJsZDogJ2FwcGxpY2F0aW9uL3Jlc291cmNlLWxpc3RzLWRpZmYreG1sJyxcbiAgcnM6ICdhcHBsaWNhdGlvbi9ybHMtc2VydmljZXMreG1sJyxcbiAgZ2JyOiAnYXBwbGljYXRpb24vcnBraS1naG9zdGJ1c3RlcnMnLFxuICBtZnQ6ICdhcHBsaWNhdGlvbi9ycGtpLW1hbmlmZXN0JyxcbiAgcm9hOiAnYXBwbGljYXRpb24vcnBraS1yb2EnLFxuICByc2Q6ICdhcHBsaWNhdGlvbi9yc2QreG1sJyxcbiAgcnNzOiAnYXBwbGljYXRpb24vcnNzK3htbCcsXG4gIHJ0ZjogJ2FwcGxpY2F0aW9uL3J0ZicsXG4gIHNibWw6ICdhcHBsaWNhdGlvbi9zYm1sK3htbCcsXG4gIHNjcTogJ2FwcGxpY2F0aW9uL3NjdnAtY3YtcmVxdWVzdCcsXG4gIHNjczogJ2FwcGxpY2F0aW9uL3NjdnAtY3YtcmVzcG9uc2UnLFxuICBzcHE6ICdhcHBsaWNhdGlvbi9zY3ZwLXZwLXJlcXVlc3QnLFxuICBzcHA6ICdhcHBsaWNhdGlvbi9zY3ZwLXZwLXJlc3BvbnNlJyxcbiAgc2RwOiAnYXBwbGljYXRpb24vc2RwJyxcbiAgc2V0cGF5OiAnYXBwbGljYXRpb24vc2V0LXBheW1lbnQtaW5pdGlhdGlvbicsXG4gIHNldHJlZzogJ2FwcGxpY2F0aW9uL3NldC1yZWdpc3RyYXRpb24taW5pdGlhdGlvbicsXG4gIHNoZjogJ2FwcGxpY2F0aW9uL3NoZit4bWwnLFxuICBzbWk6ICdhcHBsaWNhdGlvbi9zbWlsK3htbCcsXG4gIHNtaWw6ICdhcHBsaWNhdGlvbi9zbWlsK3htbCcsXG4gIHJxOiAnYXBwbGljYXRpb24vc3BhcnFsLXF1ZXJ5JyxcbiAgc3J4OiAnYXBwbGljYXRpb24vc3BhcnFsLXJlc3VsdHMreG1sJyxcbiAgZ3JhbTogJ2FwcGxpY2F0aW9uL3NyZ3MnLFxuICBncnhtbDogJ2FwcGxpY2F0aW9uL3NyZ3MreG1sJyxcbiAgc3J1OiAnYXBwbGljYXRpb24vc3J1K3htbCcsXG4gIHNzZGw6ICdhcHBsaWNhdGlvbi9zc2RsK3htbCcsXG4gIHNzbWw6ICdhcHBsaWNhdGlvbi9zc21sK3htbCcsXG4gIHRlaTogJ2FwcGxpY2F0aW9uL3RlaSt4bWwnLFxuICB0ZWljb3JwdXM6ICdhcHBsaWNhdGlvbi90ZWkreG1sJyxcbiAgdGZpOiAnYXBwbGljYXRpb24vdGhyYXVkK3htbCcsXG4gIHRzZDogJ2FwcGxpY2F0aW9uL3RpbWVzdGFtcGVkLWRhdGEnLFxuICBwbGI6ICdhcHBsaWNhdGlvbi92bmQuM2dwcC5waWMtYnctbGFyZ2UnLFxuICBwc2I6ICdhcHBsaWNhdGlvbi92bmQuM2dwcC5waWMtYnctc21hbGwnLFxuICBwdmI6ICdhcHBsaWNhdGlvbi92bmQuM2dwcC5waWMtYnctdmFyJyxcbiAgdGNhcDogJ2FwcGxpY2F0aW9uL3ZuZC4zZ3BwMi50Y2FwJyxcbiAgcHduOiAnYXBwbGljYXRpb24vdm5kLjNtLnBvc3QtaXQtbm90ZXMnLFxuICBhc286ICdhcHBsaWNhdGlvbi92bmQuYWNjcGFjLnNpbXBseS5hc28nLFxuICBpbXA6ICdhcHBsaWNhdGlvbi92bmQuYWNjcGFjLnNpbXBseS5pbXAnLFxuICBhY3U6ICdhcHBsaWNhdGlvbi92bmQuYWN1Y29ib2wnLFxuICBhdGM6ICdhcHBsaWNhdGlvbi92bmQuYWN1Y29ycCcsXG4gIGFjdXRjOiAnYXBwbGljYXRpb24vdm5kLmFjdWNvcnAnLFxuICBhaXI6ICdhcHBsaWNhdGlvbi92bmQuYWRvYmUuYWlyLWFwcGxpY2F0aW9uLWluc3RhbGxlci1wYWNrYWdlK3ppcCcsXG4gIGZjZHQ6ICdhcHBsaWNhdGlvbi92bmQuYWRvYmUuZm9ybXNjZW50cmFsLmZjZHQnLFxuICBmeHA6ICdhcHBsaWNhdGlvbi92bmQuYWRvYmUuZnhwJyxcbiAgZnhwbDogJ2FwcGxpY2F0aW9uL3ZuZC5hZG9iZS5meHAnLFxuICB4ZHA6ICdhcHBsaWNhdGlvbi92bmQuYWRvYmUueGRwK3htbCcsXG4gIHhmZGY6ICdhcHBsaWNhdGlvbi92bmQuYWRvYmUueGZkZicsXG4gIGFoZWFkOiAnYXBwbGljYXRpb24vdm5kLmFoZWFkLnNwYWNlJyxcbiAgYXpmOiAnYXBwbGljYXRpb24vdm5kLmFpcnppcC5maWxlc2VjdXJlLmF6ZicsXG4gIGF6czogJ2FwcGxpY2F0aW9uL3ZuZC5haXJ6aXAuZmlsZXNlY3VyZS5henMnLFxuICBhenc6ICdhcHBsaWNhdGlvbi92bmQuYW1hem9uLmVib29rJyxcbiAgYWNjOiAnYXBwbGljYXRpb24vdm5kLmFtZXJpY2FuZHluYW1pY3MuYWNjJyxcbiAgYW1pOiAnYXBwbGljYXRpb24vdm5kLmFtaWdhLmFtaScsXG4gIGFwazogJ2FwcGxpY2F0aW9uL3ZuZC5hbmRyb2lkLnBhY2thZ2UtYXJjaGl2ZScsXG4gIGNpaTogJ2FwcGxpY2F0aW9uL3ZuZC5hbnNlci13ZWItY2VydGlmaWNhdGUtaXNzdWUtaW5pdGlhdGlvbicsXG4gIGZ0aTogJ2FwcGxpY2F0aW9uL3ZuZC5hbnNlci13ZWItZnVuZHMtdHJhbnNmZXItaW5pdGlhdGlvbicsXG4gIGF0eDogJ2FwcGxpY2F0aW9uL3ZuZC5hbnRpeC5nYW1lLWNvbXBvbmVudCcsXG4gIG1wa2c6ICdhcHBsaWNhdGlvbi92bmQuYXBwbGUuaW5zdGFsbGVyK3htbCcsXG4gIG0zdTg6ICdhcHBsaWNhdGlvbi92bmQuYXBwbGUubXBlZ3VybCcsXG4gIHN3aTogJ2FwcGxpY2F0aW9uL3ZuZC5hcmlzdGFuZXR3b3Jrcy5zd2knLFxuICBpb3RhOiAnYXBwbGljYXRpb24vdm5kLmFzdHJhZWEtc29mdHdhcmUuaW90YScsXG4gIGFlcDogJ2FwcGxpY2F0aW9uL3ZuZC5hdWRpb2dyYXBoJyxcbiAgbXBtOiAnYXBwbGljYXRpb24vdm5kLmJsdWVpY2UubXVsdGlwYXNzJyxcbiAgYm1pOiAnYXBwbGljYXRpb24vdm5kLmJtaScsXG4gIHJlcDogJ2FwcGxpY2F0aW9uL3ZuZC5idXNpbmVzc29iamVjdHMnLFxuICBjZHhtbDogJ2FwcGxpY2F0aW9uL3ZuZC5jaGVtZHJhdyt4bWwnLFxuICBtbWQ6ICdhcHBsaWNhdGlvbi92bmQuY2hpcG51dHMua2FyYW9rZS1tbWQnLFxuICBjZHk6ICdhcHBsaWNhdGlvbi92bmQuY2luZGVyZWxsYScsXG4gIGNsYTogJ2FwcGxpY2F0aW9uL3ZuZC5jbGF5bW9yZScsXG4gIHJwOTogJ2FwcGxpY2F0aW9uL3ZuZC5jbG9hbnRvLnJwOScsXG4gIGM0ZzogJ2FwcGxpY2F0aW9uL3ZuZC5jbG9uay5jNGdyb3VwJyxcbiAgYzRkOiAnYXBwbGljYXRpb24vdm5kLmNsb25rLmM0Z3JvdXAnLFxuICBjNGY6ICdhcHBsaWNhdGlvbi92bmQuY2xvbmsuYzRncm91cCcsXG4gIGM0cDogJ2FwcGxpY2F0aW9uL3ZuZC5jbG9uay5jNGdyb3VwJyxcbiAgYzR1OiAnYXBwbGljYXRpb24vdm5kLmNsb25rLmM0Z3JvdXAnLFxuICBjMTFhbWM6ICdhcHBsaWNhdGlvbi92bmQuY2x1ZXRydXN0LmNhcnRvbW9iaWxlLWNvbmZpZycsXG4gIGMxMWFtejogJ2FwcGxpY2F0aW9uL3ZuZC5jbHVldHJ1c3QuY2FydG9tb2JpbGUtY29uZmlnLXBrZycsXG4gIGNzcDogJ2FwcGxpY2F0aW9uL3ZuZC5jb21tb25zcGFjZScsXG4gIGNkYmNtc2c6ICdhcHBsaWNhdGlvbi92bmQuY29udGFjdC5jbXNnJyxcbiAgY21jOiAnYXBwbGljYXRpb24vdm5kLmNvc21vY2FsbGVyJyxcbiAgY2xreDogJ2FwcGxpY2F0aW9uL3ZuZC5jcmljay5jbGlja2VyJyxcbiAgY2xrazogJ2FwcGxpY2F0aW9uL3ZuZC5jcmljay5jbGlja2VyLmtleWJvYXJkJyxcbiAgY2xrcDogJ2FwcGxpY2F0aW9uL3ZuZC5jcmljay5jbGlja2VyLnBhbGV0dGUnLFxuICBjbGt0OiAnYXBwbGljYXRpb24vdm5kLmNyaWNrLmNsaWNrZXIudGVtcGxhdGUnLFxuICBjbGt3OiAnYXBwbGljYXRpb24vdm5kLmNyaWNrLmNsaWNrZXIud29yZGJhbmsnLFxuICB3YnM6ICdhcHBsaWNhdGlvbi92bmQuY3JpdGljYWx0b29scy53YnMreG1sJyxcbiAgcG1sOiAnYXBwbGljYXRpb24vdm5kLmN0Yy1wb3NtbCcsXG4gIHBwZDogJ2FwcGxpY2F0aW9uL3ZuZC5jdXBzLXBwZCcsXG4gIGNhcjogJ2FwcGxpY2F0aW9uL3ZuZC5jdXJsLmNhcicsXG4gIHBjdXJsOiAnYXBwbGljYXRpb24vdm5kLmN1cmwucGN1cmwnLFxuICBkYXJ0OiAnYXBwbGljYXRpb24vdm5kLmRhcnQnLFxuICByZHo6ICdhcHBsaWNhdGlvbi92bmQuZGF0YS12aXNpb24ucmR6JyxcbiAgdXZmOiAnYXBwbGljYXRpb24vdm5kLmRlY2UuZGF0YScsXG4gIHV2dmY6ICdhcHBsaWNhdGlvbi92bmQuZGVjZS5kYXRhJyxcbiAgdXZkOiAnYXBwbGljYXRpb24vdm5kLmRlY2UuZGF0YScsXG4gIHV2dmQ6ICdhcHBsaWNhdGlvbi92bmQuZGVjZS5kYXRhJyxcbiAgdXZ0OiAnYXBwbGljYXRpb24vdm5kLmRlY2UudHRtbCt4bWwnLFxuICB1dnZ0OiAnYXBwbGljYXRpb24vdm5kLmRlY2UudHRtbCt4bWwnLFxuICB1dng6ICdhcHBsaWNhdGlvbi92bmQuZGVjZS51bnNwZWNpZmllZCcsXG4gIHV2dng6ICdhcHBsaWNhdGlvbi92bmQuZGVjZS51bnNwZWNpZmllZCcsXG4gIHV2ejogJ2FwcGxpY2F0aW9uL3ZuZC5kZWNlLnppcCcsXG4gIHV2dno6ICdhcHBsaWNhdGlvbi92bmQuZGVjZS56aXAnLFxuICBmZV9sYXVuY2g6ICdhcHBsaWNhdGlvbi92bmQuZGVub3ZvLmZjc2VsYXlvdXQtbGluaycsXG4gIGRuYTogJ2FwcGxpY2F0aW9uL3ZuZC5kbmEnLFxuICBtbHA6ICdhcHBsaWNhdGlvbi92bmQuZG9sYnkubWxwJyxcbiAgZHBnOiAnYXBwbGljYXRpb24vdm5kLmRwZ3JhcGgnLFxuICBkZmFjOiAnYXBwbGljYXRpb24vdm5kLmRyZWFtZmFjdG9yeScsXG4gIGtweHg6ICdhcHBsaWNhdGlvbi92bmQuZHMta2V5cG9pbnQnLFxuICBhaXQ6ICdhcHBsaWNhdGlvbi92bmQuZHZiLmFpdCcsXG4gIHN2YzogJ2FwcGxpY2F0aW9uL3ZuZC5kdmIuc2VydmljZScsXG4gIGdlbzogJ2FwcGxpY2F0aW9uL3ZuZC5keW5hZ2VvJyxcbiAgbWFnOiAnYXBwbGljYXRpb24vdm5kLmVjb3dpbi5jaGFydCcsXG4gIG5tbDogJ2FwcGxpY2F0aW9uL3ZuZC5lbmxpdmVuJyxcbiAgZXNmOiAnYXBwbGljYXRpb24vdm5kLmVwc29uLmVzZicsXG4gIG1zZjogJ2FwcGxpY2F0aW9uL3ZuZC5lcHNvbi5tc2YnLFxuICBxYW06ICdhcHBsaWNhdGlvbi92bmQuZXBzb24ucXVpY2thbmltZScsXG4gIHNsdDogJ2FwcGxpY2F0aW9uL3ZuZC5lcHNvbi5zYWx0JyxcbiAgc3NmOiAnYXBwbGljYXRpb24vdm5kLmVwc29uLnNzZicsXG4gIGVzMzogJ2FwcGxpY2F0aW9uL3ZuZC5lc3ppZ25vMyt4bWwnLFxuICBldDM6ICdhcHBsaWNhdGlvbi92bmQuZXN6aWdubzMreG1sJyxcbiAgZXoyOiAnYXBwbGljYXRpb24vdm5kLmV6cGl4LWFsYnVtJyxcbiAgZXozOiAnYXBwbGljYXRpb24vdm5kLmV6cGl4LXBhY2thZ2UnLFxuICBmZGY6ICdhcHBsaWNhdGlvbi92bmQuZmRmJyxcbiAgbXNlZWQ6ICdhcHBsaWNhdGlvbi92bmQuZmRzbi5tc2VlZCcsXG4gIHNlZWQ6ICdhcHBsaWNhdGlvbi92bmQuZmRzbi5zZWVkJyxcbiAgZGF0YWxlc3M6ICdhcHBsaWNhdGlvbi92bmQuZmRzbi5zZWVkJyxcbiAgZ3BoOiAnYXBwbGljYXRpb24vdm5kLmZsb2dyYXBoaXQnLFxuICBmdGM6ICdhcHBsaWNhdGlvbi92bmQuZmx1eHRpbWUuY2xpcCcsXG4gIGZtOiAnYXBwbGljYXRpb24vdm5kLmZyYW1lbWFrZXInLFxuICBmcmFtZTogJ2FwcGxpY2F0aW9uL3ZuZC5mcmFtZW1ha2VyJyxcbiAgbWFrZXI6ICdhcHBsaWNhdGlvbi92bmQuZnJhbWVtYWtlcicsXG4gIGJvb2s6ICdhcHBsaWNhdGlvbi92bmQuZnJhbWVtYWtlcicsXG4gIGZuYzogJ2FwcGxpY2F0aW9uL3ZuZC5mcm9nYW5zLmZuYycsXG4gIGx0ZjogJ2FwcGxpY2F0aW9uL3ZuZC5mcm9nYW5zLmx0ZicsXG4gIGZzYzogJ2FwcGxpY2F0aW9uL3ZuZC5mc2Mud2VibGF1bmNoJyxcbiAgb2FzOiAnYXBwbGljYXRpb24vdm5kLmZ1aml0c3Uub2FzeXMnLFxuICBvYTI6ICdhcHBsaWNhdGlvbi92bmQuZnVqaXRzdS5vYXN5czInLFxuICBvYTM6ICdhcHBsaWNhdGlvbi92bmQuZnVqaXRzdS5vYXN5czMnLFxuICBmZzU6ICdhcHBsaWNhdGlvbi92bmQuZnVqaXRzdS5vYXN5c2dwJyxcbiAgYmgyOiAnYXBwbGljYXRpb24vdm5kLmZ1aml0c3Uub2FzeXNwcnMnLFxuICBkZGQ6ICdhcHBsaWNhdGlvbi92bmQuZnVqaXhlcm94LmRkZCcsXG4gIHhkdzogJ2FwcGxpY2F0aW9uL3ZuZC5mdWppeGVyb3guZG9jdXdvcmtzJyxcbiAgeGJkOiAnYXBwbGljYXRpb24vdm5kLmZ1aml4ZXJveC5kb2N1d29ya3MuYmluZGVyJyxcbiAgZnpzOiAnYXBwbGljYXRpb24vdm5kLmZ1enp5c2hlZXQnLFxuICB0eGQ6ICdhcHBsaWNhdGlvbi92bmQuZ2Vub21hdGl4LnR1eGVkbycsXG4gIGdnYjogJ2FwcGxpY2F0aW9uL3ZuZC5nZW9nZWJyYS5maWxlJyxcbiAgZ2d0OiAnYXBwbGljYXRpb24vdm5kLmdlb2dlYnJhLnRvb2wnLFxuICBnZXg6ICdhcHBsaWNhdGlvbi92bmQuZ2VvbWV0cnktZXhwbG9yZXInLFxuICBncmU6ICdhcHBsaWNhdGlvbi92bmQuZ2VvbWV0cnktZXhwbG9yZXInLFxuICBneHQ6ICdhcHBsaWNhdGlvbi92bmQuZ2VvbmV4dCcsXG4gIGcydzogJ2FwcGxpY2F0aW9uL3ZuZC5nZW9wbGFuJyxcbiAgZzN3OiAnYXBwbGljYXRpb24vdm5kLmdlb3NwYWNlJyxcbiAgZ214OiAnYXBwbGljYXRpb24vdm5kLmdteCcsXG4gIGttbDogJ2FwcGxpY2F0aW9uL3ZuZC5nb29nbGUtZWFydGgua21sK3htbCcsXG4gIGttejogJ2FwcGxpY2F0aW9uL3ZuZC5nb29nbGUtZWFydGgua216JyxcbiAgZ3FmOiAnYXBwbGljYXRpb24vdm5kLmdyYWZlcScsXG4gIGdxczogJ2FwcGxpY2F0aW9uL3ZuZC5ncmFmZXEnLFxuICBnYWM6ICdhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLWFjY291bnQnLFxuICBnaGY6ICdhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLWhlbHAnLFxuICBnaW06ICdhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLWlkZW50aXR5LW1lc3NhZ2UnLFxuICBncnY6ICdhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLWluamVjdG9yJyxcbiAgZ3RtOiAnYXBwbGljYXRpb24vdm5kLmdyb292ZS10b29sLW1lc3NhZ2UnLFxuICB0cGw6ICdhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLXRvb2wtdGVtcGxhdGUnLFxuICB2Y2c6ICdhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLXZjYXJkJyxcbiAgaGFsOiAnYXBwbGljYXRpb24vdm5kLmhhbCt4bWwnLFxuICB6bW06ICdhcHBsaWNhdGlvbi92bmQuaGFuZGhlbGQtZW50ZXJ0YWlubWVudCt4bWwnLFxuICBoYmNpOiAnYXBwbGljYXRpb24vdm5kLmhiY2knLFxuICBsZXM6ICdhcHBsaWNhdGlvbi92bmQuaGhlLmxlc3Nvbi1wbGF5ZXInLFxuICBocGdsOiAnYXBwbGljYXRpb24vdm5kLmhwLWhwZ2wnLFxuICBocGlkOiAnYXBwbGljYXRpb24vdm5kLmhwLWhwaWQnLFxuICBocHM6ICdhcHBsaWNhdGlvbi92bmQuaHAtaHBzJyxcbiAgamx0OiAnYXBwbGljYXRpb24vdm5kLmhwLWpseXQnLFxuICBwY2w6ICdhcHBsaWNhdGlvbi92bmQuaHAtcGNsJyxcbiAgcGNseGw6ICdhcHBsaWNhdGlvbi92bmQuaHAtcGNseGwnLFxuICAnc2ZkLWhkc3R4JzogJ2FwcGxpY2F0aW9uL3ZuZC5oeWRyb3N0YXRpeC5zb2YtZGF0YScsXG4gIG1weTogJ2FwcGxpY2F0aW9uL3ZuZC5pYm0ubWluaXBheScsXG4gIGFmcDogJ2FwcGxpY2F0aW9uL3ZuZC5pYm0ubW9kY2FwJyxcbiAgbGlzdGFmcDogJ2FwcGxpY2F0aW9uL3ZuZC5pYm0ubW9kY2FwJyxcbiAgbGlzdDM4MjA6ICdhcHBsaWNhdGlvbi92bmQuaWJtLm1vZGNhcCcsXG4gIGlybTogJ2FwcGxpY2F0aW9uL3ZuZC5pYm0ucmlnaHRzLW1hbmFnZW1lbnQnLFxuICBzYzogJ2FwcGxpY2F0aW9uL3ZuZC5pYm0uc2VjdXJlLWNvbnRhaW5lcicsXG4gIGljYzogJ2FwcGxpY2F0aW9uL3ZuZC5pY2Nwcm9maWxlJyxcbiAgaWNtOiAnYXBwbGljYXRpb24vdm5kLmljY3Byb2ZpbGUnLFxuICBpZ2w6ICdhcHBsaWNhdGlvbi92bmQuaWdsb2FkZXInLFxuICBpdnA6ICdhcHBsaWNhdGlvbi92bmQuaW1tZXJ2aXNpb24taXZwJyxcbiAgaXZ1OiAnYXBwbGljYXRpb24vdm5kLmltbWVydmlzaW9uLWl2dScsXG4gIGlnbTogJ2FwcGxpY2F0aW9uL3ZuZC5pbnNvcnMuaWdtJyxcbiAgeHB3OiAnYXBwbGljYXRpb24vdm5kLmludGVyY29uLmZvcm1uZXQnLFxuICB4cHg6ICdhcHBsaWNhdGlvbi92bmQuaW50ZXJjb24uZm9ybW5ldCcsXG4gIGkyZzogJ2FwcGxpY2F0aW9uL3ZuZC5pbnRlcmdlbycsXG4gIHFibzogJ2FwcGxpY2F0aW9uL3ZuZC5pbnR1LnFibycsXG4gIHFmeDogJ2FwcGxpY2F0aW9uL3ZuZC5pbnR1LnFmeCcsXG4gIHJjcHJvZmlsZTogJ2FwcGxpY2F0aW9uL3ZuZC5pcHVucGx1Z2dlZC5yY3Byb2ZpbGUnLFxuICBpcnA6ICdhcHBsaWNhdGlvbi92bmQuaXJlcG9zaXRvcnkucGFja2FnZSt4bWwnLFxuICB4cHI6ICdhcHBsaWNhdGlvbi92bmQuaXMteHByJyxcbiAgZmNzOiAnYXBwbGljYXRpb24vdm5kLmlzYWMuZmNzJyxcbiAgamFtOiAnYXBwbGljYXRpb24vdm5kLmphbScsXG4gIHJtczogJ2FwcGxpY2F0aW9uL3ZuZC5qY3AuamF2YW1lLm1pZGxldC1ybXMnLFxuICBqaXNwOiAnYXBwbGljYXRpb24vdm5kLmppc3AnLFxuICBqb2RhOiAnYXBwbGljYXRpb24vdm5kLmpvb3N0LmpvZGEtYXJjaGl2ZScsXG4gIGt0ejogJ2FwcGxpY2F0aW9uL3ZuZC5rYWhvb3R6JyxcbiAga3RyOiAnYXBwbGljYXRpb24vdm5kLmthaG9vdHonLFxuICBrYXJib246ICdhcHBsaWNhdGlvbi92bmQua2RlLmthcmJvbicsXG4gIGNocnQ6ICdhcHBsaWNhdGlvbi92bmQua2RlLmtjaGFydCcsXG4gIGtmbzogJ2FwcGxpY2F0aW9uL3ZuZC5rZGUua2Zvcm11bGEnLFxuICBmbHc6ICdhcHBsaWNhdGlvbi92bmQua2RlLmtpdmlvJyxcbiAga29uOiAnYXBwbGljYXRpb24vdm5kLmtkZS5rb250b3VyJyxcbiAga3ByOiAnYXBwbGljYXRpb24vdm5kLmtkZS5rcHJlc2VudGVyJyxcbiAga3B0OiAnYXBwbGljYXRpb24vdm5kLmtkZS5rcHJlc2VudGVyJyxcbiAga3NwOiAnYXBwbGljYXRpb24vdm5kLmtkZS5rc3ByZWFkJyxcbiAga3dkOiAnYXBwbGljYXRpb24vdm5kLmtkZS5rd29yZCcsXG4gIGt3dDogJ2FwcGxpY2F0aW9uL3ZuZC5rZGUua3dvcmQnLFxuICBodGtlOiAnYXBwbGljYXRpb24vdm5kLmtlbmFtZWFhcHAnLFxuICBraWE6ICdhcHBsaWNhdGlvbi92bmQua2lkc3BpcmF0aW9uJyxcbiAga25lOiAnYXBwbGljYXRpb24vdm5kLmtpbmFyJyxcbiAga25wOiAnYXBwbGljYXRpb24vdm5kLmtpbmFyJyxcbiAgc2twOiAnYXBwbGljYXRpb24vdm5kLmtvYW4nLFxuICBza2Q6ICdhcHBsaWNhdGlvbi92bmQua29hbicsXG4gIHNrdDogJ2FwcGxpY2F0aW9uL3ZuZC5rb2FuJyxcbiAgc2ttOiAnYXBwbGljYXRpb24vdm5kLmtvYW4nLFxuICBzc2U6ICdhcHBsaWNhdGlvbi92bmQua29kYWstZGVzY3JpcHRvcicsXG4gIGxhc3htbDogJ2FwcGxpY2F0aW9uL3ZuZC5sYXMubGFzK3htbCcsXG4gIGxiZDogJ2FwcGxpY2F0aW9uL3ZuZC5sbGFtYWdyYXBoaWNzLmxpZmUtYmFsYW5jZS5kZXNrdG9wJyxcbiAgbGJlOiAnYXBwbGljYXRpb24vdm5kLmxsYW1hZ3JhcGhpY3MubGlmZS1iYWxhbmNlLmV4Y2hhbmdlK3htbCcsXG4gIGFwcjogJ2FwcGxpY2F0aW9uL3ZuZC5sb3R1cy1hcHByb2FjaCcsXG4gIHByZTogJ2FwcGxpY2F0aW9uL3ZuZC5sb3R1cy1mcmVlbGFuY2UnLFxuICBuc2Y6ICdhcHBsaWNhdGlvbi92bmQubG90dXMtbm90ZXMnLFxuICBvcmc6ICdhcHBsaWNhdGlvbi92bmQubG90dXMtb3JnYW5pemVyJyxcbiAgc2NtOiAnYXBwbGljYXRpb24vdm5kLmxvdHVzLXNjcmVlbmNhbScsXG4gIGx3cDogJ2FwcGxpY2F0aW9uL3ZuZC5sb3R1cy13b3JkcHJvJyxcbiAgcG9ydHBrZzogJ2FwcGxpY2F0aW9uL3ZuZC5tYWNwb3J0cy5wb3J0cGtnJyxcbiAgbWNkOiAnYXBwbGljYXRpb24vdm5kLm1jZCcsXG4gIG1jMTogJ2FwcGxpY2F0aW9uL3ZuZC5tZWRjYWxjZGF0YScsXG4gIGNka2V5OiAnYXBwbGljYXRpb24vdm5kLm1lZGlhc3RhdGlvbi5jZGtleScsXG4gIG13ZjogJ2FwcGxpY2F0aW9uL3ZuZC5tZmVyJyxcbiAgbWZtOiAnYXBwbGljYXRpb24vdm5kLm1mbXAnLFxuICBmbG86ICdhcHBsaWNhdGlvbi92bmQubWljcm9ncmFmeC5mbG8nLFxuICBpZ3g6ICdhcHBsaWNhdGlvbi92bmQubWljcm9ncmFmeC5pZ3gnLFxuICBtaWY6ICdhcHBsaWNhdGlvbi92bmQubWlmJyxcbiAgZGFmOiAnYXBwbGljYXRpb24vdm5kLm1vYml1cy5kYWYnLFxuICBkaXM6ICdhcHBsaWNhdGlvbi92bmQubW9iaXVzLmRpcycsXG4gIG1iazogJ2FwcGxpY2F0aW9uL3ZuZC5tb2JpdXMubWJrJyxcbiAgbXF5OiAnYXBwbGljYXRpb24vdm5kLm1vYml1cy5tcXknLFxuICBtc2w6ICdhcHBsaWNhdGlvbi92bmQubW9iaXVzLm1zbCcsXG4gIHBsYzogJ2FwcGxpY2F0aW9uL3ZuZC5tb2JpdXMucGxjJyxcbiAgdHhmOiAnYXBwbGljYXRpb24vdm5kLm1vYml1cy50eGYnLFxuICBtcG46ICdhcHBsaWNhdGlvbi92bmQubW9waHVuLmFwcGxpY2F0aW9uJyxcbiAgbXBjOiAnYXBwbGljYXRpb24vdm5kLm1vcGh1bi5jZXJ0aWZpY2F0ZScsXG4gIHh1bDogJ2FwcGxpY2F0aW9uL3ZuZC5tb3ppbGxhLnh1bCt4bWwnLFxuICBjaWw6ICdhcHBsaWNhdGlvbi92bmQubXMtYXJ0Z2FscnknLFxuICBjYWI6ICdhcHBsaWNhdGlvbi92bmQubXMtY2FiLWNvbXByZXNzZWQnLFxuICB4bHM6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLFxuICB4bG06ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLFxuICB4bGE6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLFxuICB4bGM6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLFxuICB4bHQ6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLFxuICB4bHc6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLFxuICB4bGFtOiAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLmFkZGluLm1hY3JvZW5hYmxlZC4xMicsXG4gIHhsc2I6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwuc2hlZXQuYmluYXJ5Lm1hY3JvZW5hYmxlZC4xMicsXG4gIHhsc206ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwuc2hlZXQubWFjcm9lbmFibGVkLjEyJyxcbiAgeGx0bTogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC50ZW1wbGF0ZS5tYWNyb2VuYWJsZWQuMTInLFxuICBlb3Q6ICdhcHBsaWNhdGlvbi92bmQubXMtZm9udG9iamVjdCcsXG4gIGNobTogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1odG1saGVscCcsXG4gIGltczogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1pbXMnLFxuICBscm06ICdhcHBsaWNhdGlvbi92bmQubXMtbHJtJyxcbiAgdGhteDogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1vZmZpY2V0aGVtZScsXG4gIGNhdDogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wa2kuc2VjY2F0JyxcbiAgc3RsOiAnYXBwbGljYXRpb24vdm5kLm1zLXBraS5zdGwnLFxuICBwcHQ6ICdhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludCcsXG4gIHBwczogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50JyxcbiAgcG90OiAnYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQnLFxuICBwcGFtOiAnYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQuYWRkaW4ubWFjcm9lbmFibGVkLjEyJyxcbiAgcHB0bTogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LnByZXNlbnRhdGlvbi5tYWNyb2VuYWJsZWQuMTInLFxuICBzbGRtOiAnYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQuc2xpZGUubWFjcm9lbmFibGVkLjEyJyxcbiAgcHBzbTogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LnNsaWRlc2hvdy5tYWNyb2VuYWJsZWQuMTInLFxuICBwb3RtOiAnYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQudGVtcGxhdGUubWFjcm9lbmFibGVkLjEyJyxcbiAgbXBwOiAnYXBwbGljYXRpb24vdm5kLm1zLXByb2plY3QnLFxuICBtcHQ6ICdhcHBsaWNhdGlvbi92bmQubXMtcHJvamVjdCcsXG4gIGRvY206ICdhcHBsaWNhdGlvbi92bmQubXMtd29yZC5kb2N1bWVudC5tYWNyb2VuYWJsZWQuMTInLFxuICBkb3RtOiAnYXBwbGljYXRpb24vdm5kLm1zLXdvcmQudGVtcGxhdGUubWFjcm9lbmFibGVkLjEyJyxcbiAgd3BzOiAnYXBwbGljYXRpb24vdm5kLm1zLXdvcmtzJyxcbiAgd2tzOiAnYXBwbGljYXRpb24vdm5kLm1zLXdvcmtzJyxcbiAgd2NtOiAnYXBwbGljYXRpb24vdm5kLm1zLXdvcmtzJyxcbiAgd2RiOiAnYXBwbGljYXRpb24vdm5kLm1zLXdvcmtzJyxcbiAgd3BsOiAnYXBwbGljYXRpb24vdm5kLm1zLXdwbCcsXG4gIHhwczogJ2FwcGxpY2F0aW9uL3ZuZC5tcy14cHNkb2N1bWVudCcsXG4gIG1zZXE6ICdhcHBsaWNhdGlvbi92bmQubXNlcScsXG4gIG11czogJ2FwcGxpY2F0aW9uL3ZuZC5tdXNpY2lhbicsXG4gIG1zdHk6ICdhcHBsaWNhdGlvbi92bmQubXV2ZWUuc3R5bGUnLFxuICB0YWdsZXQ6ICdhcHBsaWNhdGlvbi92bmQubXluZmMnLFxuICBubHU6ICdhcHBsaWNhdGlvbi92bmQubmV1cm9sYW5ndWFnZS5ubHUnLFxuICBudGY6ICdhcHBsaWNhdGlvbi92bmQubml0ZicsXG4gIG5pdGY6ICdhcHBsaWNhdGlvbi92bmQubml0ZicsXG4gIG5uZDogJ2FwcGxpY2F0aW9uL3ZuZC5ub2JsZW5ldC1kaXJlY3RvcnknLFxuICBubnM6ICdhcHBsaWNhdGlvbi92bmQubm9ibGVuZXQtc2VhbGVyJyxcbiAgbm53OiAnYXBwbGljYXRpb24vdm5kLm5vYmxlbmV0LXdlYicsXG4gIG5nZGF0OiAnYXBwbGljYXRpb24vdm5kLm5va2lhLm4tZ2FnZS5kYXRhJyxcbiAgJ24tZ2FnZSc6ICdhcHBsaWNhdGlvbi92bmQubm9raWEubi1nYWdlLnN5bWJpYW4uaW5zdGFsbCcsXG4gIHJwc3Q6ICdhcHBsaWNhdGlvbi92bmQubm9raWEucmFkaW8tcHJlc2V0JyxcbiAgcnBzczogJ2FwcGxpY2F0aW9uL3ZuZC5ub2tpYS5yYWRpby1wcmVzZXRzJyxcbiAgZWRtOiAnYXBwbGljYXRpb24vdm5kLm5vdmFkaWdtLmVkbScsXG4gIGVkeDogJ2FwcGxpY2F0aW9uL3ZuZC5ub3ZhZGlnbS5lZHgnLFxuICBleHQ6ICdhcHBsaWNhdGlvbi92bmQubm92YWRpZ20uZXh0JyxcbiAgb2RjOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5jaGFydCcsXG4gIG90YzogJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuY2hhcnQtdGVtcGxhdGUnLFxuICBvZGI6ICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmRhdGFiYXNlJyxcbiAgb2RmOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5mb3JtdWxhJyxcbiAgb2RmdDogJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuZm9ybXVsYS10ZW1wbGF0ZScsXG4gIG9kZzogJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuZ3JhcGhpY3MnLFxuICBvdGc6ICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmdyYXBoaWNzLXRlbXBsYXRlJyxcbiAgb2RpOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5pbWFnZScsXG4gIG90aTogJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuaW1hZ2UtdGVtcGxhdGUnLFxuICBvZHA6ICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnByZXNlbnRhdGlvbicsXG4gIG90cDogJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQucHJlc2VudGF0aW9uLXRlbXBsYXRlJyxcbiAgb2RzOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5zcHJlYWRzaGVldCcsXG4gIG90czogJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuc3ByZWFkc2hlZXQtdGVtcGxhdGUnLFxuICBvZHQ6ICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQnLFxuICBvZG06ICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQtbWFzdGVyJyxcbiAgb3R0OiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC50ZXh0LXRlbXBsYXRlJyxcbiAgb3RoOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC50ZXh0LXdlYicsXG4gIHhvOiAnYXBwbGljYXRpb24vdm5kLm9scGMtc3VnYXInLFxuICBkZDI6ICdhcHBsaWNhdGlvbi92bmQub21hLmRkMit4bWwnLFxuICBveHQ6ICdhcHBsaWNhdGlvbi92bmQub3Blbm9mZmljZW9yZy5leHRlbnNpb24nLFxuICBwcHR4OiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnByZXNlbnRhdGlvbicsXG4gIHNsZHg6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwuc2xpZGUnLFxuICBwcHN4OiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnNsaWRlc2hvdycsXG4gIHBvdHg6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwudGVtcGxhdGUnLFxuICB4bHN4OiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXQnLFxuICB4bHR4OiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwudGVtcGxhdGUnLFxuICBkb2N4OiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQnLFxuICBkb3R4OiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwudGVtcGxhdGUnLFxuICBtZ3A6ICdhcHBsaWNhdGlvbi92bmQub3NnZW8ubWFwZ3VpZGUucGFja2FnZScsXG4gIGRwOiAnYXBwbGljYXRpb24vdm5kLm9zZ2kuZHAnLFxuICBlc2E6ICdhcHBsaWNhdGlvbi92bmQub3NnaS5zdWJzeXN0ZW0nLFxuICBwZGI6ICdhcHBsaWNhdGlvbi92bmQucGFsbScsXG4gIHBxYTogJ2FwcGxpY2F0aW9uL3ZuZC5wYWxtJyxcbiAgb3ByYzogJ2FwcGxpY2F0aW9uL3ZuZC5wYWxtJyxcbiAgcGF3OiAnYXBwbGljYXRpb24vdm5kLnBhd2FhZmlsZScsXG4gIHN0cjogJ2FwcGxpY2F0aW9uL3ZuZC5wZy5mb3JtYXQnLFxuICBlaTY6ICdhcHBsaWNhdGlvbi92bmQucGcub3Nhc2xpJyxcbiAgZWZpZjogJ2FwcGxpY2F0aW9uL3ZuZC5waWNzZWwnLFxuICB3ZzogJ2FwcGxpY2F0aW9uL3ZuZC5wbWkud2lkZ2V0JyxcbiAgcGxmOiAnYXBwbGljYXRpb24vdm5kLnBvY2tldGxlYXJuJyxcbiAgcGJkOiAnYXBwbGljYXRpb24vdm5kLnBvd2VyYnVpbGRlcjYnLFxuICBib3g6ICdhcHBsaWNhdGlvbi92bmQucHJldmlld3N5c3RlbXMuYm94JyxcbiAgbWd6OiAnYXBwbGljYXRpb24vdm5kLnByb3RldXMubWFnYXppbmUnLFxuICBxcHM6ICdhcHBsaWNhdGlvbi92bmQucHVibGlzaGFyZS1kZWx0YS10cmVlJyxcbiAgcHRpZDogJ2FwcGxpY2F0aW9uL3ZuZC5wdmkucHRpZDEnLFxuICBxeGQ6ICdhcHBsaWNhdGlvbi92bmQucXVhcmsucXVhcmt4cHJlc3MnLFxuICBxeHQ6ICdhcHBsaWNhdGlvbi92bmQucXVhcmsucXVhcmt4cHJlc3MnLFxuICBxd2Q6ICdhcHBsaWNhdGlvbi92bmQucXVhcmsucXVhcmt4cHJlc3MnLFxuICBxd3Q6ICdhcHBsaWNhdGlvbi92bmQucXVhcmsucXVhcmt4cHJlc3MnLFxuICBxeGw6ICdhcHBsaWNhdGlvbi92bmQucXVhcmsucXVhcmt4cHJlc3MnLFxuICBxeGI6ICdhcHBsaWNhdGlvbi92bmQucXVhcmsucXVhcmt4cHJlc3MnLFxuICBiZWQ6ICdhcHBsaWNhdGlvbi92bmQucmVhbHZuYy5iZWQnLFxuICBteGw6ICdhcHBsaWNhdGlvbi92bmQucmVjb3JkYXJlLm11c2ljeG1sJyxcbiAgbXVzaWN4bWw6ICdhcHBsaWNhdGlvbi92bmQucmVjb3JkYXJlLm11c2ljeG1sK3htbCcsXG4gIGNyeXB0b25vdGU6ICdhcHBsaWNhdGlvbi92bmQucmlnLmNyeXB0b25vdGUnLFxuICBjb2Q6ICdhcHBsaWNhdGlvbi92bmQucmltLmNvZCcsXG4gIHJtOiAnYXBwbGljYXRpb24vdm5kLnJuLXJlYWxtZWRpYScsXG4gIHJtdmI6ICdhcHBsaWNhdGlvbi92bmQucm4tcmVhbG1lZGlhLXZicicsXG4gIGxpbms2NjogJ2FwcGxpY2F0aW9uL3ZuZC5yb3V0ZTY2Lmxpbms2Nit4bWwnLFxuICBzdDogJ2FwcGxpY2F0aW9uL3ZuZC5zYWlsaW5ndHJhY2tlci50cmFjaycsXG4gIHNlZTogJ2FwcGxpY2F0aW9uL3ZuZC5zZWVtYWlsJyxcbiAgc2VtYTogJ2FwcGxpY2F0aW9uL3ZuZC5zZW1hJyxcbiAgc2VtZDogJ2FwcGxpY2F0aW9uL3ZuZC5zZW1kJyxcbiAgc2VtZjogJ2FwcGxpY2F0aW9uL3ZuZC5zZW1mJyxcbiAgaWZtOiAnYXBwbGljYXRpb24vdm5kLnNoYW5hLmluZm9ybWVkLmZvcm1kYXRhJyxcbiAgaXRwOiAnYXBwbGljYXRpb24vdm5kLnNoYW5hLmluZm9ybWVkLmZvcm10ZW1wbGF0ZScsXG4gIGlpZjogJ2FwcGxpY2F0aW9uL3ZuZC5zaGFuYS5pbmZvcm1lZC5pbnRlcmNoYW5nZScsXG4gIGlwazogJ2FwcGxpY2F0aW9uL3ZuZC5zaGFuYS5pbmZvcm1lZC5wYWNrYWdlJyxcbiAgdHdkOiAnYXBwbGljYXRpb24vdm5kLnNpbXRlY2gtbWluZG1hcHBlcicsXG4gIHR3ZHM6ICdhcHBsaWNhdGlvbi92bmQuc2ltdGVjaC1taW5kbWFwcGVyJyxcbiAgbW1mOiAnYXBwbGljYXRpb24vdm5kLnNtYWYnLFxuICB0ZWFjaGVyOiAnYXBwbGljYXRpb24vdm5kLnNtYXJ0LnRlYWNoZXInLFxuICBzZGttOiAnYXBwbGljYXRpb24vdm5kLnNvbGVudC5zZGttK3htbCcsXG4gIHNka2Q6ICdhcHBsaWNhdGlvbi92bmQuc29sZW50LnNka20reG1sJyxcbiAgZHhwOiAnYXBwbGljYXRpb24vdm5kLnNwb3RmaXJlLmR4cCcsXG4gIHNmczogJ2FwcGxpY2F0aW9uL3ZuZC5zcG90ZmlyZS5zZnMnLFxuICBzZGM6ICdhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLmNhbGMnLFxuICBzZGE6ICdhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLmRyYXcnLFxuICBzZGQ6ICdhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLmltcHJlc3MnLFxuICBzbWY6ICdhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLm1hdGgnLFxuICBzZHc6ICdhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLndyaXRlcicsXG4gIHZvcjogJ2FwcGxpY2F0aW9uL3ZuZC5zdGFyZGl2aXNpb24ud3JpdGVyJyxcbiAgc2dsOiAnYXBwbGljYXRpb24vdm5kLnN0YXJkaXZpc2lvbi53cml0ZXItZ2xvYmFsJyxcbiAgc216aXA6ICdhcHBsaWNhdGlvbi92bmQuc3RlcG1hbmlhLnBhY2thZ2UnLFxuICBzbTogJ2FwcGxpY2F0aW9uL3ZuZC5zdGVwbWFuaWEuc3RlcGNoYXJ0JyxcbiAgc3hjOiAnYXBwbGljYXRpb24vdm5kLnN1bi54bWwuY2FsYycsXG4gIHN0YzogJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmNhbGMudGVtcGxhdGUnLFxuICBzeGQ6ICdhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC5kcmF3JyxcbiAgc3RkOiAnYXBwbGljYXRpb24vdm5kLnN1bi54bWwuZHJhdy50ZW1wbGF0ZScsXG4gIHN4aTogJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmltcHJlc3MnLFxuICBzdGk6ICdhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC5pbXByZXNzLnRlbXBsYXRlJyxcbiAgc3htOiAnYXBwbGljYXRpb24vdm5kLnN1bi54bWwubWF0aCcsXG4gIHN4dzogJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLndyaXRlcicsXG4gIHN4ZzogJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLndyaXRlci5nbG9iYWwnLFxuICBzdHc6ICdhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC53cml0ZXIudGVtcGxhdGUnLFxuICBzdXM6ICdhcHBsaWNhdGlvbi92bmQuc3VzLWNhbGVuZGFyJyxcbiAgc3VzcDogJ2FwcGxpY2F0aW9uL3ZuZC5zdXMtY2FsZW5kYXInLFxuICBzdmQ6ICdhcHBsaWNhdGlvbi92bmQuc3ZkJyxcbiAgc2lzOiAnYXBwbGljYXRpb24vdm5kLnN5bWJpYW4uaW5zdGFsbCcsXG4gIHNpc3g6ICdhcHBsaWNhdGlvbi92bmQuc3ltYmlhbi5pbnN0YWxsJyxcbiAgeHNtOiAnYXBwbGljYXRpb24vdm5kLnN5bmNtbCt4bWwnLFxuICBiZG06ICdhcHBsaWNhdGlvbi92bmQuc3luY21sLmRtK3dieG1sJyxcbiAgeGRtOiAnYXBwbGljYXRpb24vdm5kLnN5bmNtbC5kbSt4bWwnLFxuICB0YW86ICdhcHBsaWNhdGlvbi92bmQudGFvLmludGVudC1tb2R1bGUtYXJjaGl2ZScsXG4gIHBjYXA6ICdhcHBsaWNhdGlvbi92bmQudGNwZHVtcC5wY2FwJyxcbiAgY2FwOiAnYXBwbGljYXRpb24vdm5kLnRjcGR1bXAucGNhcCcsXG4gIGRtcDogJ2FwcGxpY2F0aW9uL3ZuZC50Y3BkdW1wLnBjYXAnLFxuICB0bW86ICdhcHBsaWNhdGlvbi92bmQudG1vYmlsZS1saXZldHYnLFxuICB0cHQ6ICdhcHBsaWNhdGlvbi92bmQudHJpZC50cHQnLFxuICBteHM6ICdhcHBsaWNhdGlvbi92bmQudHJpc2NhcGUubXhzJyxcbiAgdHJhOiAnYXBwbGljYXRpb24vdm5kLnRydWVhcHAnLFxuICB1ZmQ6ICdhcHBsaWNhdGlvbi92bmQudWZkbCcsXG4gIHVmZGw6ICdhcHBsaWNhdGlvbi92bmQudWZkbCcsXG4gIHV0ejogJ2FwcGxpY2F0aW9uL3ZuZC51aXEudGhlbWUnLFxuICB1bWo6ICdhcHBsaWNhdGlvbi92bmQudW1hamluJyxcbiAgdW5pdHl3ZWI6ICdhcHBsaWNhdGlvbi92bmQudW5pdHknLFxuICB1b21sOiAnYXBwbGljYXRpb24vdm5kLnVvbWwreG1sJyxcbiAgdmN4OiAnYXBwbGljYXRpb24vdm5kLnZjeCcsXG4gIHZzZDogJ2FwcGxpY2F0aW9uL3ZuZC52aXNpbycsXG4gIHZzdDogJ2FwcGxpY2F0aW9uL3ZuZC52aXNpbycsXG4gIHZzczogJ2FwcGxpY2F0aW9uL3ZuZC52aXNpbycsXG4gIHZzdzogJ2FwcGxpY2F0aW9uL3ZuZC52aXNpbycsXG4gIHZpczogJ2FwcGxpY2F0aW9uL3ZuZC52aXNpb25hcnknLFxuICB2c2Y6ICdhcHBsaWNhdGlvbi92bmQudnNmJyxcbiAgd2J4bWw6ICdhcHBsaWNhdGlvbi92bmQud2FwLndieG1sJyxcbiAgd21sYzogJ2FwcGxpY2F0aW9uL3ZuZC53YXAud21sYycsXG4gIHdtbHNjOiAnYXBwbGljYXRpb24vdm5kLndhcC53bWxzY3JpcHRjJyxcbiAgd3RiOiAnYXBwbGljYXRpb24vdm5kLndlYnR1cmJvJyxcbiAgbmJwOiAnYXBwbGljYXRpb24vdm5kLndvbGZyYW0ucGxheWVyJyxcbiAgd3BkOiAnYXBwbGljYXRpb24vdm5kLndvcmRwZXJmZWN0JyxcbiAgd3FkOiAnYXBwbGljYXRpb24vdm5kLndxZCcsXG4gIHN0ZjogJ2FwcGxpY2F0aW9uL3ZuZC53dC5zdGYnLFxuICB4YXI6ICdhcHBsaWNhdGlvbi92bmQueGFyYScsXG4gIHhmZGw6ICdhcHBsaWNhdGlvbi92bmQueGZkbCcsXG4gIGh2ZDogJ2FwcGxpY2F0aW9uL3ZuZC55YW1haGEuaHYtZGljJyxcbiAgaHZzOiAnYXBwbGljYXRpb24vdm5kLnlhbWFoYS5odi1zY3JpcHQnLFxuICBodnA6ICdhcHBsaWNhdGlvbi92bmQueWFtYWhhLmh2LXZvaWNlJyxcbiAgb3NmOiAnYXBwbGljYXRpb24vdm5kLnlhbWFoYS5vcGVuc2NvcmVmb3JtYXQnLFxuICBvc2Zwdmc6ICdhcHBsaWNhdGlvbi92bmQueWFtYWhhLm9wZW5zY29yZWZvcm1hdC5vc2ZwdmcreG1sJyxcbiAgc2FmOiAnYXBwbGljYXRpb24vdm5kLnlhbWFoYS5zbWFmLWF1ZGlvJyxcbiAgc3BmOiAnYXBwbGljYXRpb24vdm5kLnlhbWFoYS5zbWFmLXBocmFzZScsXG4gIGNtcDogJ2FwcGxpY2F0aW9uL3ZuZC55ZWxsb3dyaXZlci1jdXN0b20tbWVudScsXG4gIHppcjogJ2FwcGxpY2F0aW9uL3ZuZC56dWwnLFxuICB6aXJ6OiAnYXBwbGljYXRpb24vdm5kLnp1bCcsXG4gIHphejogJ2FwcGxpY2F0aW9uL3ZuZC56emF6ei5kZWNrK3htbCcsXG4gIHZ4bWw6ICdhcHBsaWNhdGlvbi92b2ljZXhtbCt4bWwnLFxuICB3Z3Q6ICdhcHBsaWNhdGlvbi93aWRnZXQnLFxuICBobHA6ICdhcHBsaWNhdGlvbi93aW5obHAnLFxuICB3c2RsOiAnYXBwbGljYXRpb24vd3NkbCt4bWwnLFxuICB3c3BvbGljeTogJ2FwcGxpY2F0aW9uL3dzcG9saWN5K3htbCcsXG4gICc3eic6ICdhcHBsaWNhdGlvbi94LTd6LWNvbXByZXNzZWQnLFxuICBhYnc6ICdhcHBsaWNhdGlvbi94LWFiaXdvcmQnLFxuICBhY2U6ICdhcHBsaWNhdGlvbi94LWFjZS1jb21wcmVzc2VkJyxcbiAgZG1nOiAnYXBwbGljYXRpb24veC1hcHBsZS1kaXNraW1hZ2UnLFxuICBhYWI6ICdhcHBsaWNhdGlvbi94LWF1dGhvcndhcmUtYmluJyxcbiAgeDMyOiAnYXBwbGljYXRpb24veC1hdXRob3J3YXJlLWJpbicsXG4gIHUzMjogJ2FwcGxpY2F0aW9uL3gtYXV0aG9yd2FyZS1iaW4nLFxuICB2b3g6ICdhcHBsaWNhdGlvbi94LWF1dGhvcndhcmUtYmluJyxcbiAgYWFtOiAnYXBwbGljYXRpb24veC1hdXRob3J3YXJlLW1hcCcsXG4gIGFhczogJ2FwcGxpY2F0aW9uL3gtYXV0aG9yd2FyZS1zZWcnLFxuICBiY3BpbzogJ2FwcGxpY2F0aW9uL3gtYmNwaW8nLFxuICB0b3JyZW50OiAnYXBwbGljYXRpb24veC1iaXR0b3JyZW50JyxcbiAgYmxiOiAnYXBwbGljYXRpb24veC1ibG9yYicsXG4gIGJsb3JiOiAnYXBwbGljYXRpb24veC1ibG9yYicsXG4gIGJ6OiAnYXBwbGljYXRpb24veC1iemlwJyxcbiAgYnoyOiAnYXBwbGljYXRpb24veC1iemlwMicsXG4gIGJvejogJ2FwcGxpY2F0aW9uL3gtYnppcDInLFxuICBjYnI6ICdhcHBsaWNhdGlvbi94LWNicicsXG4gIGNiYTogJ2FwcGxpY2F0aW9uL3gtY2JyJyxcbiAgY2J0OiAnYXBwbGljYXRpb24veC1jYnInLFxuICBjYno6ICdhcHBsaWNhdGlvbi94LWNicicsXG4gIGNiNzogJ2FwcGxpY2F0aW9uL3gtY2JyJyxcbiAgdmNkOiAnYXBwbGljYXRpb24veC1jZGxpbmsnLFxuICBjZnM6ICdhcHBsaWNhdGlvbi94LWNmcy1jb21wcmVzc2VkJyxcbiAgY2hhdDogJ2FwcGxpY2F0aW9uL3gtY2hhdCcsXG4gIHBnbjogJ2FwcGxpY2F0aW9uL3gtY2hlc3MtcGduJyxcbiAgbnNjOiAnYXBwbGljYXRpb24veC1jb25mZXJlbmNlJyxcbiAgY3BpbzogJ2FwcGxpY2F0aW9uL3gtY3BpbycsXG4gIGNzaDogJ2FwcGxpY2F0aW9uL3gtY3NoJyxcbiAgZGViOiAnYXBwbGljYXRpb24veC1kZWJpYW4tcGFja2FnZScsXG4gIHVkZWI6ICdhcHBsaWNhdGlvbi94LWRlYmlhbi1wYWNrYWdlJyxcbiAgZGdjOiAnYXBwbGljYXRpb24veC1kZ2MtY29tcHJlc3NlZCcsXG4gIGRpcjogJ2FwcGxpY2F0aW9uL3gtZGlyZWN0b3InLFxuICBkY3I6ICdhcHBsaWNhdGlvbi94LWRpcmVjdG9yJyxcbiAgZHhyOiAnYXBwbGljYXRpb24veC1kaXJlY3RvcicsXG4gIGNzdDogJ2FwcGxpY2F0aW9uL3gtZGlyZWN0b3InLFxuICBjY3Q6ICdhcHBsaWNhdGlvbi94LWRpcmVjdG9yJyxcbiAgY3h0OiAnYXBwbGljYXRpb24veC1kaXJlY3RvcicsXG4gIHczZDogJ2FwcGxpY2F0aW9uL3gtZGlyZWN0b3InLFxuICBmZ2Q6ICdhcHBsaWNhdGlvbi94LWRpcmVjdG9yJyxcbiAgc3dhOiAnYXBwbGljYXRpb24veC1kaXJlY3RvcicsXG4gIHdhZDogJ2FwcGxpY2F0aW9uL3gtZG9vbScsXG4gIG5jeDogJ2FwcGxpY2F0aW9uL3gtZHRibmN4K3htbCcsXG4gIGR0YjogJ2FwcGxpY2F0aW9uL3gtZHRib29rK3htbCcsXG4gIHJlczogJ2FwcGxpY2F0aW9uL3gtZHRicmVzb3VyY2UreG1sJyxcbiAgZHZpOiAnYXBwbGljYXRpb24veC1kdmknLFxuICBldnk6ICdhcHBsaWNhdGlvbi94LWVudm95JyxcbiAgZXZhOiAnYXBwbGljYXRpb24veC1ldmEnLFxuICBiZGY6ICdhcHBsaWNhdGlvbi94LWZvbnQtYmRmJyxcbiAgZ3NmOiAnYXBwbGljYXRpb24veC1mb250LWdob3N0c2NyaXB0JyxcbiAgcHNmOiAnYXBwbGljYXRpb24veC1mb250LWxpbnV4LXBzZicsXG4gIG90ZjogJ2FwcGxpY2F0aW9uL3gtZm9udC1vdGYnLFxuICBwY2Y6ICdhcHBsaWNhdGlvbi94LWZvbnQtcGNmJyxcbiAgc25mOiAnYXBwbGljYXRpb24veC1mb250LXNuZicsXG4gIHR0ZjogJ2FwcGxpY2F0aW9uL3gtZm9udC10dGYnLFxuICB0dGM6ICdhcHBsaWNhdGlvbi94LWZvbnQtdHRmJyxcbiAgcGZhOiAnYXBwbGljYXRpb24veC1mb250LXR5cGUxJyxcbiAgcGZiOiAnYXBwbGljYXRpb24veC1mb250LXR5cGUxJyxcbiAgcGZtOiAnYXBwbGljYXRpb24veC1mb250LXR5cGUxJyxcbiAgYWZtOiAnYXBwbGljYXRpb24veC1mb250LXR5cGUxJyxcbiAgd29mZjogJ2FwcGxpY2F0aW9uL3gtZm9udC13b2ZmJyxcbiAgYXJjOiAnYXBwbGljYXRpb24veC1mcmVlYXJjJyxcbiAgc3BsOiAnYXBwbGljYXRpb24veC1mdXR1cmVzcGxhc2gnLFxuICBnY2E6ICdhcHBsaWNhdGlvbi94LWdjYS1jb21wcmVzc2VkJyxcbiAgdWx4OiAnYXBwbGljYXRpb24veC1nbHVseCcsXG4gIGdudW1lcmljOiAnYXBwbGljYXRpb24veC1nbnVtZXJpYycsXG4gIGdyYW1wczogJ2FwcGxpY2F0aW9uL3gtZ3JhbXBzLXhtbCcsXG4gIGd0YXI6ICdhcHBsaWNhdGlvbi94LWd0YXInLFxuICBoZGY6ICdhcHBsaWNhdGlvbi94LWhkZicsXG4gIGluc3RhbGw6ICdhcHBsaWNhdGlvbi94LWluc3RhbGwtaW5zdHJ1Y3Rpb25zJyxcbiAgaXNvOiAnYXBwbGljYXRpb24veC1pc285NjYwLWltYWdlJyxcbiAgam5scDogJ2FwcGxpY2F0aW9uL3gtamF2YS1qbmxwLWZpbGUnLFxuICBsYXRleDogJ2FwcGxpY2F0aW9uL3gtbGF0ZXgnLFxuICBsemg6ICdhcHBsaWNhdGlvbi94LWx6aC1jb21wcmVzc2VkJyxcbiAgbGhhOiAnYXBwbGljYXRpb24veC1semgtY29tcHJlc3NlZCcsXG4gIG1pZTogJ2FwcGxpY2F0aW9uL3gtbWllJyxcbiAgcHJjOiAnYXBwbGljYXRpb24veC1tb2JpcG9ja2V0LWVib29rJyxcbiAgbW9iaTogJ2FwcGxpY2F0aW9uL3gtbW9iaXBvY2tldC1lYm9vaycsXG4gIGFwcGxpY2F0aW9uOiAnYXBwbGljYXRpb24veC1tcy1hcHBsaWNhdGlvbicsXG4gIGxuazogJ2FwcGxpY2F0aW9uL3gtbXMtc2hvcnRjdXQnLFxuICB3bWQ6ICdhcHBsaWNhdGlvbi94LW1zLXdtZCcsXG4gIHdtejogJ2FwcGxpY2F0aW9uL3gtbXNtZXRhZmlsZScsXG4gIHhiYXA6ICdhcHBsaWNhdGlvbi94LW1zLXhiYXAnLFxuICBtZGI6ICdhcHBsaWNhdGlvbi94LW1zYWNjZXNzJyxcbiAgb2JkOiAnYXBwbGljYXRpb24veC1tc2JpbmRlcicsXG4gIGNyZDogJ2FwcGxpY2F0aW9uL3gtbXNjYXJkZmlsZScsXG4gIGNscDogJ2FwcGxpY2F0aW9uL3gtbXNjbGlwJyxcbiAgZXhlOiAnYXBwbGljYXRpb24veC1tc2Rvd25sb2FkJyxcbiAgZGxsOiAnYXBwbGljYXRpb24veC1tc2Rvd25sb2FkJyxcbiAgY29tOiAnYXBwbGljYXRpb24veC1tc2Rvd25sb2FkJyxcbiAgYmF0OiAnYXBwbGljYXRpb24veC1tc2Rvd25sb2FkJyxcbiAgbXNpOiAnYXBwbGljYXRpb24veC1tc2Rvd25sb2FkJyxcbiAgbXZiOiAnYXBwbGljYXRpb24veC1tc21lZGlhdmlldycsXG4gIG0xMzogJ2FwcGxpY2F0aW9uL3gtbXNtZWRpYXZpZXcnLFxuICBtMTQ6ICdhcHBsaWNhdGlvbi94LW1zbWVkaWF2aWV3JyxcbiAgd21mOiAnYXBwbGljYXRpb24veC1tc21ldGFmaWxlJyxcbiAgZW1mOiAnYXBwbGljYXRpb24veC1tc21ldGFmaWxlJyxcbiAgZW16OiAnYXBwbGljYXRpb24veC1tc21ldGFmaWxlJyxcbiAgbW55OiAnYXBwbGljYXRpb24veC1tc21vbmV5JyxcbiAgcHViOiAnYXBwbGljYXRpb24veC1tc3B1Ymxpc2hlcicsXG4gIHNjZDogJ2FwcGxpY2F0aW9uL3gtbXNzY2hlZHVsZScsXG4gIHRybTogJ2FwcGxpY2F0aW9uL3gtbXN0ZXJtaW5hbCcsXG4gIHdyaTogJ2FwcGxpY2F0aW9uL3gtbXN3cml0ZScsXG4gIG5jOiAnYXBwbGljYXRpb24veC1uZXRjZGYnLFxuICBjZGY6ICdhcHBsaWNhdGlvbi94LW5ldGNkZicsXG4gIG56YjogJ2FwcGxpY2F0aW9uL3gtbnpiJyxcbiAgcDEyOiAnYXBwbGljYXRpb24veC1wa2NzMTInLFxuICBwZng6ICdhcHBsaWNhdGlvbi94LXBrY3MxMicsXG4gIHA3YjogJ2FwcGxpY2F0aW9uL3gtcGtjczctY2VydGlmaWNhdGVzJyxcbiAgc3BjOiAnYXBwbGljYXRpb24veC1wa2NzNy1jZXJ0aWZpY2F0ZXMnLFxuICBwN3I6ICdhcHBsaWNhdGlvbi94LXBrY3M3LWNlcnRyZXFyZXNwJyxcbiAgcmFyOiAnYXBwbGljYXRpb24veC1yYXItY29tcHJlc3NlZCcsXG4gIHJpczogJ2FwcGxpY2F0aW9uL3gtcmVzZWFyY2gtaW5mby1zeXN0ZW1zJyxcbiAgc2g6ICdhcHBsaWNhdGlvbi94LXNoJyxcbiAgc2hhcjogJ2FwcGxpY2F0aW9uL3gtc2hhcicsXG4gIHN3ZjogJ2FwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoJyxcbiAgeGFwOiAnYXBwbGljYXRpb24veC1zaWx2ZXJsaWdodC1hcHAnLFxuICBzcWw6ICdhcHBsaWNhdGlvbi94LXNxbCcsXG4gIHNpdDogJ2FwcGxpY2F0aW9uL3gtc3R1ZmZpdCcsXG4gIHNpdHg6ICdhcHBsaWNhdGlvbi94LXN0dWZmaXR4JyxcbiAgc3J0OiAnYXBwbGljYXRpb24veC1zdWJyaXAnLFxuICBzdjRjcGlvOiAnYXBwbGljYXRpb24veC1zdjRjcGlvJyxcbiAgc3Y0Y3JjOiAnYXBwbGljYXRpb24veC1zdjRjcmMnLFxuICB0MzogJ2FwcGxpY2F0aW9uL3gtdDN2bS1pbWFnZScsXG4gIGdhbTogJ2FwcGxpY2F0aW9uL3gtdGFkcycsXG4gIHRhcjogJ2FwcGxpY2F0aW9uL3gtdGFyJyxcbiAgdGNsOiAnYXBwbGljYXRpb24veC10Y2wnLFxuICB0ZXg6ICdhcHBsaWNhdGlvbi94LXRleCcsXG4gIHRmbTogJ2FwcGxpY2F0aW9uL3gtdGV4LXRmbScsXG4gIHRleGluZm86ICdhcHBsaWNhdGlvbi94LXRleGluZm8nLFxuICB0ZXhpOiAnYXBwbGljYXRpb24veC10ZXhpbmZvJyxcbiAgb2JqOiAnYXBwbGljYXRpb24veC10Z2lmJyxcbiAgdXN0YXI6ICdhcHBsaWNhdGlvbi94LXVzdGFyJyxcbiAgc3JjOiAnYXBwbGljYXRpb24veC13YWlzLXNvdXJjZScsXG4gIGRlcjogJ2FwcGxpY2F0aW9uL3gteDUwOS1jYS1jZXJ0JyxcbiAgY3J0OiAnYXBwbGljYXRpb24veC14NTA5LWNhLWNlcnQnLFxuICBmaWc6ICdhcHBsaWNhdGlvbi94LXhmaWcnLFxuICB4bGY6ICdhcHBsaWNhdGlvbi94LXhsaWZmK3htbCcsXG4gIHhwaTogJ2FwcGxpY2F0aW9uL3gteHBpbnN0YWxsJyxcbiAgeHo6ICdhcHBsaWNhdGlvbi94LXh6JyxcbiAgejE6ICdhcHBsaWNhdGlvbi94LXptYWNoaW5lJyxcbiAgejI6ICdhcHBsaWNhdGlvbi94LXptYWNoaW5lJyxcbiAgejM6ICdhcHBsaWNhdGlvbi94LXptYWNoaW5lJyxcbiAgejQ6ICdhcHBsaWNhdGlvbi94LXptYWNoaW5lJyxcbiAgejU6ICdhcHBsaWNhdGlvbi94LXptYWNoaW5lJyxcbiAgejY6ICdhcHBsaWNhdGlvbi94LXptYWNoaW5lJyxcbiAgejc6ICdhcHBsaWNhdGlvbi94LXptYWNoaW5lJyxcbiAgejg6ICdhcHBsaWNhdGlvbi94LXptYWNoaW5lJyxcbiAgeGFtbDogJ2FwcGxpY2F0aW9uL3hhbWwreG1sJyxcbiAgeGRmOiAnYXBwbGljYXRpb24veGNhcC1kaWZmK3htbCcsXG4gIHhlbmM6ICdhcHBsaWNhdGlvbi94ZW5jK3htbCcsXG4gIHhodG1sOiAnYXBwbGljYXRpb24veGh0bWwreG1sJyxcbiAgeGh0OiAnYXBwbGljYXRpb24veGh0bWwreG1sJyxcbiAgeG1sOiAnYXBwbGljYXRpb24veG1sJyxcbiAgeHNsOiAnYXBwbGljYXRpb24veG1sJyxcbiAgZHRkOiAnYXBwbGljYXRpb24veG1sLWR0ZCcsXG4gIHhvcDogJ2FwcGxpY2F0aW9uL3hvcCt4bWwnLFxuICB4cGw6ICdhcHBsaWNhdGlvbi94cHJvYyt4bWwnLFxuICB4c2x0OiAnYXBwbGljYXRpb24veHNsdCt4bWwnLFxuICB4c3BmOiAnYXBwbGljYXRpb24veHNwZit4bWwnLFxuICBteG1sOiAnYXBwbGljYXRpb24veHYreG1sJyxcbiAgeGh2bWw6ICdhcHBsaWNhdGlvbi94dit4bWwnLFxuICB4dm1sOiAnYXBwbGljYXRpb24veHYreG1sJyxcbiAgeHZtOiAnYXBwbGljYXRpb24veHYreG1sJyxcbiAgeWFuZzogJ2FwcGxpY2F0aW9uL3lhbmcnLFxuICB5aW46ICdhcHBsaWNhdGlvbi95aW4reG1sJyxcbiAgemlwOiAnYXBwbGljYXRpb24vemlwJyxcbiAgYWRwOiAnYXVkaW8vYWRwY20nLFxuICBhdTogJ2F1ZGlvL2Jhc2ljJyxcbiAgc25kOiAnYXVkaW8vYmFzaWMnLFxuICBtaWQ6ICdhdWRpby9taWRpJyxcbiAgbWlkaTogJ2F1ZGlvL21pZGknLFxuICBrYXI6ICdhdWRpby9taWRpJyxcbiAgcm1pOiAnYXVkaW8vbWlkaScsXG4gIG1wNGE6ICdhdWRpby9tcDQnLFxuICBtcGdhOiAnYXVkaW8vbXBlZycsXG4gIG1wMjogJ2F1ZGlvL21wZWcnLFxuICBtcDJhOiAnYXVkaW8vbXBlZycsXG4gIG1wMzogJ2F1ZGlvL21wZWcnLFxuICBtMmE6ICdhdWRpby9tcGVnJyxcbiAgbTNhOiAnYXVkaW8vbXBlZycsXG4gIG9nYTogJ2F1ZGlvL29nZycsXG4gIG9nZzogJ2F1ZGlvL29nZycsXG4gIHNweDogJ2F1ZGlvL29nZycsXG4gIHMzbTogJ2F1ZGlvL3MzbScsXG4gIHNpbDogJ2F1ZGlvL3NpbGsnLFxuICB1dmE6ICdhdWRpby92bmQuZGVjZS5hdWRpbycsXG4gIHV2dmE6ICdhdWRpby92bmQuZGVjZS5hdWRpbycsXG4gIGVvbDogJ2F1ZGlvL3ZuZC5kaWdpdGFsLXdpbmRzJyxcbiAgZHJhOiAnYXVkaW8vdm5kLmRyYScsXG4gIGR0czogJ2F1ZGlvL3ZuZC5kdHMnLFxuICBkdHNoZDogJ2F1ZGlvL3ZuZC5kdHMuaGQnLFxuICBsdnA6ICdhdWRpby92bmQubHVjZW50LnZvaWNlJyxcbiAgcHlhOiAnYXVkaW8vdm5kLm1zLXBsYXlyZWFkeS5tZWRpYS5weWEnLFxuICBlY2VscDQ4MDA6ICdhdWRpby92bmQubnVlcmEuZWNlbHA0ODAwJyxcbiAgZWNlbHA3NDcwOiAnYXVkaW8vdm5kLm51ZXJhLmVjZWxwNzQ3MCcsXG4gIGVjZWxwOTYwMDogJ2F1ZGlvL3ZuZC5udWVyYS5lY2VscDk2MDAnLFxuICByaXA6ICdhdWRpby92bmQucmlwJyxcbiAgd2ViYTogJ2F1ZGlvL3dlYm0nLFxuICBhYWM6ICdhdWRpby94LWFhYycsXG4gIGFpZjogJ2F1ZGlvL3gtYWlmZicsXG4gIGFpZmY6ICdhdWRpby94LWFpZmYnLFxuICBhaWZjOiAnYXVkaW8veC1haWZmJyxcbiAgY2FmOiAnYXVkaW8veC1jYWYnLFxuICBmbGFjOiAnYXVkaW8veC1mbGFjJyxcbiAgbWthOiAnYXVkaW8veC1tYXRyb3NrYScsXG4gIG0zdTogJ2F1ZGlvL3gtbXBlZ3VybCcsXG4gIHdheDogJ2F1ZGlvL3gtbXMtd2F4JyxcbiAgd21hOiAnYXVkaW8veC1tcy13bWEnLFxuICByYW06ICdhdWRpby94LXBuLXJlYWxhdWRpbycsXG4gIHJhOiAnYXVkaW8veC1wbi1yZWFsYXVkaW8nLFxuICBybXA6ICdhdWRpby94LXBuLXJlYWxhdWRpby1wbHVnaW4nLFxuICB3YXY6ICdhdWRpby94LXdhdicsXG4gIHhtOiAnYXVkaW8veG0nLFxuICBjZHg6ICdjaGVtaWNhbC94LWNkeCcsXG4gIGNpZjogJ2NoZW1pY2FsL3gtY2lmJyxcbiAgY21kZjogJ2NoZW1pY2FsL3gtY21kZicsXG4gIGNtbDogJ2NoZW1pY2FsL3gtY21sJyxcbiAgY3NtbDogJ2NoZW1pY2FsL3gtY3NtbCcsXG4gIHh5ejogJ2NoZW1pY2FsL3gteHl6JyxcbiAgYm1wOiAnaW1hZ2UvYm1wJyxcbiAgY2dtOiAnaW1hZ2UvY2dtJyxcbiAgZzM6ICdpbWFnZS9nM2ZheCcsXG4gIGdpZjogJ2ltYWdlL2dpZicsXG4gIGllZjogJ2ltYWdlL2llZicsXG4gIGpwZWc6ICdpbWFnZS9qcGVnJyxcbiAganBnOiAnaW1hZ2UvanBlZycsXG4gIGpwZTogJ2ltYWdlL2pwZWcnLFxuICBrdHg6ICdpbWFnZS9rdHgnLFxuICBwbmc6ICdpbWFnZS9wbmcnLFxuICBidGlmOiAnaW1hZ2UvcHJzLmJ0aWYnLFxuICBzZ2k6ICdpbWFnZS9zZ2knLFxuICBzdmc6ICdpbWFnZS9zdmcreG1sJyxcbiAgc3ZnejogJ2ltYWdlL3N2Zyt4bWwnLFxuICB0aWZmOiAnaW1hZ2UvdGlmZicsXG4gIHRpZjogJ2ltYWdlL3RpZmYnLFxuICBwc2Q6ICdpbWFnZS92bmQuYWRvYmUucGhvdG9zaG9wJyxcbiAgdXZpOiAnaW1hZ2Uvdm5kLmRlY2UuZ3JhcGhpYycsXG4gIHV2dmk6ICdpbWFnZS92bmQuZGVjZS5ncmFwaGljJyxcbiAgdXZnOiAnaW1hZ2Uvdm5kLmRlY2UuZ3JhcGhpYycsXG4gIHV2dmc6ICdpbWFnZS92bmQuZGVjZS5ncmFwaGljJyxcbiAgc3ViOiAndGV4dC92bmQuZHZiLnN1YnRpdGxlJyxcbiAgZGp2dTogJ2ltYWdlL3ZuZC5kanZ1JyxcbiAgZGp2OiAnaW1hZ2Uvdm5kLmRqdnUnLFxuICBkd2c6ICdpbWFnZS92bmQuZHdnJyxcbiAgZHhmOiAnaW1hZ2Uvdm5kLmR4ZicsXG4gIGZiczogJ2ltYWdlL3ZuZC5mYXN0Ymlkc2hlZXQnLFxuICBmcHg6ICdpbWFnZS92bmQuZnB4JyxcbiAgZnN0OiAnaW1hZ2Uvdm5kLmZzdCcsXG4gIG1tcjogJ2ltYWdlL3ZuZC5mdWppeGVyb3guZWRtaWNzLW1tcicsXG4gIHJsYzogJ2ltYWdlL3ZuZC5mdWppeGVyb3guZWRtaWNzLXJsYycsXG4gIG1kaTogJ2ltYWdlL3ZuZC5tcy1tb2RpJyxcbiAgd2RwOiAnaW1hZ2Uvdm5kLm1zLXBob3RvJyxcbiAgbnB4OiAnaW1hZ2Uvdm5kLm5ldC1mcHgnLFxuICB3Ym1wOiAnaW1hZ2Uvdm5kLndhcC53Ym1wJyxcbiAgeGlmOiAnaW1hZ2Uvdm5kLnhpZmYnLFxuICB3ZWJwOiAnaW1hZ2Uvd2VicCcsXG4gICczZHMnOiAnaW1hZ2UveC0zZHMnLFxuICByYXM6ICdpbWFnZS94LWNtdS1yYXN0ZXInLFxuICBjbXg6ICdpbWFnZS94LWNteCcsXG4gIGZoOiAnaW1hZ2UveC1mcmVlaGFuZCcsXG4gIGZoYzogJ2ltYWdlL3gtZnJlZWhhbmQnLFxuICBmaDQ6ICdpbWFnZS94LWZyZWVoYW5kJyxcbiAgZmg1OiAnaW1hZ2UveC1mcmVlaGFuZCcsXG4gIGZoNzogJ2ltYWdlL3gtZnJlZWhhbmQnLFxuICBpY286ICdpbWFnZS94LWljb24nLFxuICBzaWQ6ICdpbWFnZS94LW1yc2lkLWltYWdlJyxcbiAgcGN4OiAnaW1hZ2UveC1wY3gnLFxuICBwaWM6ICdpbWFnZS94LXBpY3QnLFxuICBwY3Q6ICdpbWFnZS94LXBpY3QnLFxuICBwbm06ICdpbWFnZS94LXBvcnRhYmxlLWFueW1hcCcsXG4gIHBibTogJ2ltYWdlL3gtcG9ydGFibGUtYml0bWFwJyxcbiAgcGdtOiAnaW1hZ2UveC1wb3J0YWJsZS1ncmF5bWFwJyxcbiAgcHBtOiAnaW1hZ2UveC1wb3J0YWJsZS1waXhtYXAnLFxuICByZ2I6ICdpbWFnZS94LXJnYicsXG4gIHRnYTogJ2ltYWdlL3gtdGdhJyxcbiAgeGJtOiAnaW1hZ2UveC14Yml0bWFwJyxcbiAgeHBtOiAnaW1hZ2UveC14cGl4bWFwJyxcbiAgeHdkOiAnaW1hZ2UveC14d2luZG93ZHVtcCcsXG4gIGVtbDogJ21lc3NhZ2UvcmZjODIyJyxcbiAgbWltZTogJ21lc3NhZ2UvcmZjODIyJyxcbiAgaWdzOiAnbW9kZWwvaWdlcycsXG4gIGlnZXM6ICdtb2RlbC9pZ2VzJyxcbiAgbXNoOiAnbW9kZWwvbWVzaCcsXG4gIG1lc2g6ICdtb2RlbC9tZXNoJyxcbiAgc2lsbzogJ21vZGVsL21lc2gnLFxuICBkYWU6ICdtb2RlbC92bmQuY29sbGFkYSt4bWwnLFxuICBkd2Y6ICdtb2RlbC92bmQuZHdmJyxcbiAgZ2RsOiAnbW9kZWwvdm5kLmdkbCcsXG4gIGd0dzogJ21vZGVsL3ZuZC5ndHcnLFxuICBtdHM6ICdtb2RlbC92bmQubXRzJyxcbiAgdnR1OiAnbW9kZWwvdm5kLnZ0dScsXG4gIHdybDogJ21vZGVsL3ZybWwnLFxuICB2cm1sOiAnbW9kZWwvdnJtbCcsXG4gIHgzZGI6ICdtb2RlbC94M2QrYmluYXJ5JyxcbiAgeDNkYno6ICdtb2RlbC94M2QrYmluYXJ5JyxcbiAgeDNkdjogJ21vZGVsL3gzZCt2cm1sJyxcbiAgeDNkdno6ICdtb2RlbC94M2QrdnJtbCcsXG4gIHgzZDogJ21vZGVsL3gzZCt4bWwnLFxuICB4M2R6OiAnbW9kZWwveDNkK3htbCcsXG4gIGFwcGNhY2hlOiAndGV4dC9jYWNoZS1tYW5pZmVzdCcsXG4gIGljczogJ3RleHQvY2FsZW5kYXInLFxuICBpZmI6ICd0ZXh0L2NhbGVuZGFyJyxcbiAgY3NzOiAndGV4dC9jc3MnLFxuICBjc3Y6ICd0ZXh0L2NzdicsXG4gIGh0bWw6ICd0ZXh0L2h0bWwnLFxuICBodG06ICd0ZXh0L2h0bWwnLFxuICBuMzogJ3RleHQvbjMnLFxuICB0eHQ6ICd0ZXh0L3BsYWluJyxcbiAgdGV4dDogJ3RleHQvcGxhaW4nLFxuICBjb25mOiAndGV4dC9wbGFpbicsXG4gIGRlZjogJ3RleHQvcGxhaW4nLFxuICBsaXN0OiAndGV4dC9wbGFpbicsXG4gIGxvZzogJ3RleHQvcGxhaW4nLFxuICBpbjogJ3RleHQvcGxhaW4nLFxuICBkc2M6ICd0ZXh0L3Bycy5saW5lcy50YWcnLFxuICBydHg6ICd0ZXh0L3JpY2h0ZXh0JyxcbiAgc2dtbDogJ3RleHQvc2dtbCcsXG4gIHNnbTogJ3RleHQvc2dtbCcsXG4gIHRzdjogJ3RleHQvdGFiLXNlcGFyYXRlZC12YWx1ZXMnLFxuICB0OiAndGV4dC90cm9mZicsXG4gIHRyOiAndGV4dC90cm9mZicsXG4gIHJvZmY6ICd0ZXh0L3Ryb2ZmJyxcbiAgbWFuOiAndGV4dC90cm9mZicsXG4gIG1lOiAndGV4dC90cm9mZicsXG4gIG1zOiAndGV4dC90cm9mZicsXG4gIHR0bDogJ3RleHQvdHVydGxlJyxcbiAgdXJpOiAndGV4dC91cmktbGlzdCcsXG4gIHVyaXM6ICd0ZXh0L3VyaS1saXN0JyxcbiAgdXJsczogJ3RleHQvdXJpLWxpc3QnLFxuICB2Y2FyZDogJ3RleHQvdmNhcmQnLFxuICBjdXJsOiAndGV4dC92bmQuY3VybCcsXG4gIGRjdXJsOiAndGV4dC92bmQuY3VybC5kY3VybCcsXG4gIHNjdXJsOiAndGV4dC92bmQuY3VybC5zY3VybCcsXG4gIG1jdXJsOiAndGV4dC92bmQuY3VybC5tY3VybCcsXG4gIGZseTogJ3RleHQvdm5kLmZseScsXG4gIGZseDogJ3RleHQvdm5kLmZtaS5mbGV4c3RvcicsXG4gIGd2OiAndGV4dC92bmQuZ3JhcGh2aXonLFxuICAnM2RtbCc6ICd0ZXh0L3ZuZC5pbjNkLjNkbWwnLFxuICBzcG90OiAndGV4dC92bmQuaW4zZC5zcG90JyxcbiAgamFkOiAndGV4dC92bmQuc3VuLmoybWUuYXBwLWRlc2NyaXB0b3InLFxuICB3bWw6ICd0ZXh0L3ZuZC53YXAud21sJyxcbiAgd21sczogJ3RleHQvdm5kLndhcC53bWxzY3JpcHQnLFxuICBzOiAndGV4dC94LWFzbScsXG4gIGFzbTogJ3RleHQveC1hc20nLFxuICBjOiAndGV4dC94LWMnLFxuICBjYzogJ3RleHQveC1jJyxcbiAgY3h4OiAndGV4dC94LWMnLFxuICBjcHA6ICd0ZXh0L3gtYycsXG4gIGg6ICd0ZXh0L3gtYycsXG4gIGhoOiAndGV4dC94LWMnLFxuICBkaWM6ICd0ZXh0L3gtYycsXG4gIGY6ICd0ZXh0L3gtZm9ydHJhbicsXG4gIGZvcjogJ3RleHQveC1mb3J0cmFuJyxcbiAgZjc3OiAndGV4dC94LWZvcnRyYW4nLFxuICBmOTA6ICd0ZXh0L3gtZm9ydHJhbicsXG4gIGphdmE6ICd0ZXh0L3gtamF2YS1zb3VyY2UnLFxuICBvcG1sOiAndGV4dC94LW9wbWwnLFxuICBwOiAndGV4dC94LXBhc2NhbCcsXG4gIHBhczogJ3RleHQveC1wYXNjYWwnLFxuICBuZm86ICd0ZXh0L3gtbmZvJyxcbiAgZXR4OiAndGV4dC94LXNldGV4dCcsXG4gIHNmdjogJ3RleHQveC1zZnYnLFxuICB1dTogJ3RleHQveC11dWVuY29kZScsXG4gIHZjczogJ3RleHQveC12Y2FsZW5kYXInLFxuICB2Y2Y6ICd0ZXh0L3gtdmNhcmQnLFxuICAnM2dwJzogJ3ZpZGVvLzNncHAnLFxuICAnM2cyJzogJ3ZpZGVvLzNncHAyJyxcbiAgaDI2MTogJ3ZpZGVvL2gyNjEnLFxuICBoMjYzOiAndmlkZW8vaDI2MycsXG4gIGgyNjQ6ICd2aWRlby9oMjY0JyxcbiAganBndjogJ3ZpZGVvL2pwZWcnLFxuICBqcG06ICd2aWRlby9qcG0nLFxuICBqcGdtOiAndmlkZW8vanBtJyxcbiAgbWoyOiAndmlkZW8vbWoyJyxcbiAgbWpwMjogJ3ZpZGVvL21qMicsXG4gIG1wNDogJ3ZpZGVvL21wNCcsXG4gIG1wNHY6ICd2aWRlby9tcDQnLFxuICBtcGc0OiAndmlkZW8vbXA0JyxcbiAgbXBlZzogJ3ZpZGVvL21wZWcnLFxuICBtcGc6ICd2aWRlby9tcGVnJyxcbiAgbXBlOiAndmlkZW8vbXBlZycsXG4gIG0xdjogJ3ZpZGVvL21wZWcnLFxuICBtMnY6ICd2aWRlby9tcGVnJyxcbiAgb2d2OiAndmlkZW8vb2dnJyxcbiAgcXQ6ICd2aWRlby9xdWlja3RpbWUnLFxuICBtb3Y6ICd2aWRlby9xdWlja3RpbWUnLFxuICB1dmg6ICd2aWRlby92bmQuZGVjZS5oZCcsXG4gIHV2dmg6ICd2aWRlby92bmQuZGVjZS5oZCcsXG4gIHV2bTogJ3ZpZGVvL3ZuZC5kZWNlLm1vYmlsZScsXG4gIHV2dm06ICd2aWRlby92bmQuZGVjZS5tb2JpbGUnLFxuICB1dnA6ICd2aWRlby92bmQuZGVjZS5wZCcsXG4gIHV2dnA6ICd2aWRlby92bmQuZGVjZS5wZCcsXG4gIHV2czogJ3ZpZGVvL3ZuZC5kZWNlLnNkJyxcbiAgdXZ2czogJ3ZpZGVvL3ZuZC5kZWNlLnNkJyxcbiAgdXZ2OiAndmlkZW8vdm5kLmRlY2UudmlkZW8nLFxuICB1dnZ2OiAndmlkZW8vdm5kLmRlY2UudmlkZW8nLFxuICBkdmI6ICd2aWRlby92bmQuZHZiLmZpbGUnLFxuICBmdnQ6ICd2aWRlby92bmQuZnZ0JyxcbiAgbXh1OiAndmlkZW8vdm5kLm1wZWd1cmwnLFxuICBtNHU6ICd2aWRlby92bmQubXBlZ3VybCcsXG4gIHB5djogJ3ZpZGVvL3ZuZC5tcy1wbGF5cmVhZHkubWVkaWEucHl2JyxcbiAgdXZ1OiAndmlkZW8vdm5kLnV2dnUubXA0JyxcbiAgdXZ2dTogJ3ZpZGVvL3ZuZC51dnZ1Lm1wNCcsXG4gIHZpdjogJ3ZpZGVvL3ZuZC52aXZvJyxcbiAgd2VibTogJ3ZpZGVvL3dlYm0nLFxuICBmNHY6ICd2aWRlby94LWY0dicsXG4gIGZsaTogJ3ZpZGVvL3gtZmxpJyxcbiAgZmx2OiAndmlkZW8veC1mbHYnLFxuICBtNHY6ICd2aWRlby94LW00dicsXG4gIG1rdjogJ3ZpZGVvL3gtbWF0cm9za2EnLFxuICBtazNkOiAndmlkZW8veC1tYXRyb3NrYScsXG4gIG1rczogJ3ZpZGVvL3gtbWF0cm9za2EnLFxuICBtbmc6ICd2aWRlby94LW1uZycsXG4gIGFzZjogJ3ZpZGVvL3gtbXMtYXNmJyxcbiAgYXN4OiAndmlkZW8veC1tcy1hc2YnLFxuICB2b2I6ICd2aWRlby94LW1zLXZvYicsXG4gIHdtOiAndmlkZW8veC1tcy13bScsXG4gIHdtdjogJ3ZpZGVvL3gtbXMtd212JyxcbiAgd214OiAndmlkZW8veC1tcy13bXgnLFxuICB3dng6ICd2aWRlby94LW1zLXd2eCcsXG4gIGF2aTogJ3ZpZGVvL3gtbXN2aWRlbycsXG4gIG1vdmllOiAndmlkZW8veC1zZ2ktbW92aWUnLFxuICBzbXY6ICd2aWRlby94LXNtdicsXG4gIGljZTogJ3gtY29uZmVyZW5jZS94LWNvb2x0YWxrJyB9XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBNYXJrZWRZQU1MRXJyb3IsIGV2ZW50cywgbm9kZXMsIHJhbWwsIHV0aWwsIF9yZWYsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgX19iaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfTtcblxuICBldmVudHMgPSByZXF1aXJlKCcuL2V2ZW50cycpO1xuXG4gIE1hcmtlZFlBTUxFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3JzJykuTWFya2VkWUFNTEVycm9yO1xuXG4gIG5vZGVzID0gcmVxdWlyZSgnLi9ub2RlcycpO1xuXG4gIHJhbWwgPSByZXF1aXJlKCcuL3JhbWwnKTtcblxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgdGhpcy5Db21wb3NlckVycm9yID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21wb3NlckVycm9yLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gQ29tcG9zZXJFcnJvcigpIHtcbiAgICAgIF9yZWYgPSBDb21wb3NlckVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIENvbXBvc2VyRXJyb3I7XG5cbiAgfSkoTWFya2VkWUFNTEVycm9yKTtcblxuICB0aGlzLkNvbXBvc2VyID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIENvbXBvc2VyKCkge1xuICAgICAgdGhpcy5jb21wb3NlUmFtbFRyZWUgPSBfX2JpbmQodGhpcy5jb21wb3NlUmFtbFRyZWUsIHRoaXMpO1xuICAgICAgdGhpcy5hbmNob3JzID0ge307XG4gICAgICB0aGlzLmZpbGVzVG9SZWFkID0gW107XG4gICAgfVxuXG4gICAgQ29tcG9zZXIucHJvdG90eXBlLmNoZWNrX25vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNoZWNrX2V2ZW50KGV2ZW50cy5TdHJlYW1TdGFydEV2ZW50KSkge1xuICAgICAgICB0aGlzLmdldF9ldmVudCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICF0aGlzLmNoZWNrX2V2ZW50KGV2ZW50cy5TdHJlYW1FbmRFdmVudCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgR2V0IHRoZSByb290IG5vZGUgb2YgdGhlIG5leHQgZG9jdW1lbnQuXG4gICAgKi9cblxuXG4gICAgQ29tcG9zZXIucHJvdG90eXBlLmdldF9ub2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY2hlY2tfZXZlbnQoZXZlbnRzLlN0cmVhbUVuZEV2ZW50KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb3NlX2RvY3VtZW50KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENvbXBvc2VyLnByb3RvdHlwZS5nZXRZYW1sUm9vdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRvY3VtZW50LCBldmVudDtcbiAgICAgIHRoaXMuZ2V0X2V2ZW50KCk7XG4gICAgICBkb2N1bWVudCA9IG51bGw7XG4gICAgICBpZiAoIXRoaXMuY2hlY2tfZXZlbnQoZXZlbnRzLlN0cmVhbUVuZEV2ZW50KSkge1xuICAgICAgICBkb2N1bWVudCA9IHRoaXMuY29tcG9zZV9kb2N1bWVudCgpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNoZWNrX2V2ZW50KGV2ZW50cy5TdHJlYW1FbmRFdmVudCkpIHtcbiAgICAgICAgZXZlbnQgPSB0aGlzLmdldF9ldmVudCgpO1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db21wb3NlckVycm9yKCdkb2N1bWVudCBzY2FuJywgZG9jdW1lbnQuc3RhcnRfbWFyaywgJ2V4cGVjdGVkIGEgc2luZ2xlIGRvY3VtZW50IGluIHRoZSBzdHJlYW0gYnV0IGZvdW5kIGFub3RoZXIgZG9jdW1lbnQnLCBldmVudC5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2V0X2V2ZW50KCk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfTtcblxuICAgIENvbXBvc2VyLnByb3RvdHlwZS5jb21wb3NlUmFtbFRyZWUgPSBmdW5jdGlvbihub2RlLCBzZXR0aW5ncykge1xuICAgICAgaWYgKHNldHRpbmdzLnZhbGlkYXRlIHx8IHNldHRpbmdzLnRyYW5zZm9ybSkge1xuICAgICAgICB0aGlzLmxvYWRfc2NoZW1hcyhub2RlKTtcbiAgICAgICAgdGhpcy5sb2FkX3RyYWl0cyhub2RlKTtcbiAgICAgICAgdGhpcy5sb2FkX3R5cGVzKG5vZGUpO1xuICAgICAgICB0aGlzLmxvYWRfc2VjdXJpdHlfc2NoZW1lcyhub2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0aW5ncy52YWxpZGF0ZSkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlX2RvY3VtZW50KG5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRpbmdzLnRyYW5zZm9ybSkge1xuICAgICAgICB0aGlzLmFwcGx5X3R5cGVzKG5vZGUpO1xuICAgICAgICB0aGlzLmFwcGx5X3RyYWl0cyhub2RlKTtcbiAgICAgICAgdGhpcy5hcHBseV9zY2hlbWFzKG5vZGUpO1xuICAgICAgICB0aGlzLmFwcGx5X3Byb3RvY29scyhub2RlKTtcbiAgICAgICAgdGhpcy5qb2luX3Jlc291cmNlcyhub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG5cbiAgICBDb21wb3Nlci5wcm90b3R5cGUuY29tcG9zZV9kb2N1bWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vZGU7XG4gICAgICB0aGlzLmdldF9ldmVudCgpO1xuICAgICAgbm9kZSA9IHRoaXMuY29tcG9zZV9ub2RlKCk7XG4gICAgICB0aGlzLmdldF9ldmVudCgpO1xuICAgICAgdGhpcy5hbmNob3JzID0ge307XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuXG4gICAgQ29tcG9zZXIucHJvdG90eXBlLmdldFBlbmRpbmdGaWxlc0xpc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbGVzVG9SZWFkO1xuICAgIH07XG5cbiAgICBDb21wb3Nlci5wcm90b3R5cGUuY29tcG9zZV9ub2RlID0gZnVuY3Rpb24ocGFyZW50LCBpbmRleCkge1xuICAgICAgdmFyIGFuY2hvciwgZXZlbnQsIG5vZGU7XG4gICAgICBpZiAodGhpcy5jaGVja19ldmVudChldmVudHMuQWxpYXNFdmVudCkpIHtcbiAgICAgICAgZXZlbnQgPSB0aGlzLmdldF9ldmVudCgpO1xuICAgICAgICBhbmNob3IgPSBldmVudC5hbmNob3I7XG4gICAgICAgIGlmICghKGFuY2hvciBpbiB0aGlzLmFuY2hvcnMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29tcG9zZXJFcnJvcihudWxsLCBudWxsLCBcImZvdW5kIHVuZGVmaW5lZCBhbGlhcyBcIiArIGFuY2hvciwgZXZlbnQuc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYW5jaG9yc1thbmNob3JdLmNsb25lKCk7XG4gICAgICB9XG4gICAgICBldmVudCA9IHRoaXMucGVla19ldmVudCgpO1xuICAgICAgYW5jaG9yID0gZXZlbnQuYW5jaG9yO1xuICAgICAgaWYgKGFuY2hvciAhPT0gbnVsbCAmJiBhbmNob3IgaW4gdGhpcy5hbmNob3JzKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbXBvc2VyRXJyb3IoXCJmb3VuZCBkdXBsaWNhdGUgYW5jaG9yIFwiICsgYW5jaG9yICsgXCI7IGZpcnN0IG9jY3VyZW5jZVwiLCB0aGlzLmFuY2hvcnNbYW5jaG9yXS5zdGFydF9tYXJrLCAnc2Vjb25kIG9jY3VycmVuY2UnLCBldmVudC5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVzY2VuZF9yZXNvbHZlcihwYXJlbnQsIGluZGV4KTtcbiAgICAgIGlmICh0aGlzLmNoZWNrX2V2ZW50KGV2ZW50cy5TY2FsYXJFdmVudCkpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMuY29tcG9zZV9zY2FsYXJfbm9kZShhbmNob3IsIHBhcmVudCwgaW5kZXgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNoZWNrX2V2ZW50KGV2ZW50cy5TZXF1ZW5jZVN0YXJ0RXZlbnQpKSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLmNvbXBvc2Vfc2VxdWVuY2Vfbm9kZShhbmNob3IpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNoZWNrX2V2ZW50KGV2ZW50cy5NYXBwaW5nU3RhcnRFdmVudCkpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMuY29tcG9zZV9tYXBwaW5nX25vZGUoYW5jaG9yKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXNjZW5kX3Jlc29sdmVyKCk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuXG4gICAgQ29tcG9zZXIucHJvdG90eXBlLmNvbXBvc2VfZml4ZWRfc2NhbGFyX25vZGUgPSBmdW5jdGlvbihhbmNob3IsIHZhbHVlKSB7XG4gICAgICB2YXIgZXZlbnQsIG5vZGU7XG4gICAgICBldmVudCA9IHRoaXMuZ2V0X2V2ZW50KCk7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLlNjYWxhck5vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsIHZhbHVlLCBldmVudC5zdGFydF9tYXJrLCBldmVudC5lbmRfbWFyaywgZXZlbnQuc3R5bGUpO1xuICAgICAgaWYgKGFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmFuY2hvcnNbYW5jaG9yXSA9IG5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuXG4gICAgQ29tcG9zZXIucHJvdG90eXBlLmNvbXBvc2Vfc2NhbGFyX25vZGUgPSBmdW5jdGlvbihhbmNob3IsIHBhcmVudCwga2V5KSB7XG4gICAgICB2YXIgZXZlbnQsIGV4dGVuc2lvbiwgZmlsZVR5cGUsIG5vZGUsIHRhZztcbiAgICAgIGV2ZW50ID0gdGhpcy5nZXRfZXZlbnQoKTtcbiAgICAgIHRhZyA9IGV2ZW50LnRhZztcbiAgICAgIG5vZGUgPSB7fTtcbiAgICAgIGlmICh0YWcgPT09IG51bGwgfHwgdGFnID09PSAnIScpIHtcbiAgICAgICAgdGFnID0gdGhpcy5yZXNvbHZlKG5vZGVzLlNjYWxhck5vZGUsIGV2ZW50LnZhbHVlLCBldmVudC5pbXBsaWNpdCk7XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQudGFnID09PSAnIWluY2x1ZGUnKSB7XG4gICAgICAgIGlmIChldmVudC52YWx1ZS5tYXRjaCgvXlxccyokLykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db21wb3NlckVycm9yKCd3aGlsZSBjb21wb3Npbmcgc2NhbGFyIG91dCBvZiAhaW5jbHVkZScsIG51bGwsIFwiZmlsZSBuYW1lL1VSTCBjYW5ub3QgYmUgbnVsbFwiLCBldmVudC5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBleHRlbnNpb24gPSBldmVudC52YWx1ZS5zcGxpdCgnLicpLnBvcCgpO1xuICAgICAgICBpZiAoZXh0ZW5zaW9uID09PSAneWFtbCcgfHwgZXh0ZW5zaW9uID09PSAneW1sJyB8fCBleHRlbnNpb24gPT09ICdyYW1sJykge1xuICAgICAgICAgIGZpbGVUeXBlID0gJ2ZyYWdtZW50JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWxlVHlwZSA9ICdzY2FsYXInO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlsZXNUb1JlYWQucHVzaCh7XG4gICAgICAgICAgdGFyZ2V0VXJpOiBldmVudC52YWx1ZSxcbiAgICAgICAgICB0eXBlOiBmaWxlVHlwZSxcbiAgICAgICAgICBwYXJlbnROb2RlOiBwYXJlbnQsXG4gICAgICAgICAgcGFyZW50S2V5OiBrZXksXG4gICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIGluY2x1ZGluZ0NvbnRleHQ6IHRoaXMuc3JjLFxuICAgICAgICAgIHRhcmdldEZpbGVVcmk6IGV2ZW50LnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBub2RlID0gdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IG5ldyBub2Rlcy5TY2FsYXJOb2RlKHRhZywgZXZlbnQudmFsdWUsIGV2ZW50LnN0YXJ0X21hcmssIGV2ZW50LmVuZF9tYXJrLCBldmVudC5zdHlsZSk7XG4gICAgICB9XG4gICAgICBpZiAoYW5jaG9yICYmIG5vZGUpIHtcbiAgICAgICAgdGhpcy5hbmNob3JzW2FuY2hvcl0gPSBub2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcblxuICAgIENvbXBvc2VyLnByb3RvdHlwZS5jb21wb3NlX3NlcXVlbmNlX25vZGUgPSBmdW5jdGlvbihhbmNob3IpIHtcbiAgICAgIHZhciBlbmRfZXZlbnQsIGluZGV4LCBub2RlLCBzdGFydF9ldmVudCwgdGFnLCB2YWx1ZTtcbiAgICAgIHN0YXJ0X2V2ZW50ID0gdGhpcy5nZXRfZXZlbnQoKTtcbiAgICAgIHRhZyA9IHN0YXJ0X2V2ZW50LnRhZztcbiAgICAgIGlmICh0YWcgPT09IG51bGwgfHwgdGFnID09PSAnIScpIHtcbiAgICAgICAgdGFnID0gdGhpcy5yZXNvbHZlKG5vZGVzLlNlcXVlbmNlTm9kZSwgbnVsbCwgc3RhcnRfZXZlbnQuaW1wbGljaXQpO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5TZXF1ZW5jZU5vZGUodGFnLCBbXSwgc3RhcnRfZXZlbnQuc3RhcnRfbWFyaywgbnVsbCwgc3RhcnRfZXZlbnQuZmxvd19zdHlsZSk7XG4gICAgICBpbmRleCA9IDA7XG4gICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yc1thbmNob3JdID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICghdGhpcy5jaGVja19ldmVudChldmVudHMuU2VxdWVuY2VFbmRFdmVudCkpIHtcbiAgICAgICAgaWYgKHZhbHVlID0gdGhpcy5jb21wb3NlX25vZGUobm9kZSwgaW5kZXgpKSB7XG4gICAgICAgICAgbm9kZS52YWx1ZVtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgICAgZW5kX2V2ZW50ID0gdGhpcy5nZXRfZXZlbnQoKTtcbiAgICAgIG5vZGUuZW5kX21hcmsgPSBlbmRfZXZlbnQuZW5kX21hcms7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuXG4gICAgQ29tcG9zZXIucHJvdG90eXBlLmNvbXBvc2VfbWFwcGluZ19ub2RlID0gZnVuY3Rpb24oYW5jaG9yKSB7XG4gICAgICB2YXIgZW5kX2V2ZW50LCBpdGVtX2tleSwgaXRlbV92YWx1ZSwgbm9kZSwgc3RhcnRfZXZlbnQsIHRhZztcbiAgICAgIHN0YXJ0X2V2ZW50ID0gdGhpcy5nZXRfZXZlbnQoKTtcbiAgICAgIHRhZyA9IHN0YXJ0X2V2ZW50LnRhZztcbiAgICAgIGlmICh0YWcgPT09IG51bGwgfHwgdGFnID09PSAnIScpIHtcbiAgICAgICAgdGFnID0gdGhpcy5yZXNvbHZlKG5vZGVzLk1hcHBpbmdOb2RlLCBudWxsLCBzdGFydF9ldmVudC5pbXBsaWNpdCk7XG4gICAgICB9XG4gICAgICBub2RlID0gbmV3IG5vZGVzLk1hcHBpbmdOb2RlKHRhZywgW10sIHN0YXJ0X2V2ZW50LnN0YXJ0X21hcmssIG51bGwsIHN0YXJ0X2V2ZW50LmZsb3dfc3R5bGUpO1xuICAgICAgaWYgKGFuY2hvciAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmFuY2hvcnNbYW5jaG9yXSA9IG5vZGU7XG4gICAgICB9XG4gICAgICB3aGlsZSAoIXRoaXMuY2hlY2tfZXZlbnQoZXZlbnRzLk1hcHBpbmdFbmRFdmVudCkpIHtcbiAgICAgICAgaXRlbV9rZXkgPSB0aGlzLmNvbXBvc2Vfbm9kZShub2RlKTtcbiAgICAgICAgaWYgKCF1dGlsLmlzU2NhbGFyKGl0ZW1fa2V5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbXBvc2VyRXJyb3IoJ3doaWxlIGNvbXBvc2luZyBtYXBwaW5nIGtleScsIG51bGwsIFwib25seSBzY2FsYXIgbWFwIGtleXMgYXJlIGFsbG93ZWQgaW4gUkFNTFwiLCBpdGVtX2tleS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbV92YWx1ZSA9IHRoaXMuY29tcG9zZV9ub2RlKG5vZGUsIGl0ZW1fa2V5KSkge1xuICAgICAgICAgIG5vZGUudmFsdWUucHVzaChbaXRlbV9rZXksIGl0ZW1fdmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZW5kX2V2ZW50ID0gdGhpcy5nZXRfZXZlbnQoKTtcbiAgICAgIG5vZGUuZW5kX21hcmsgPSBlbmRfZXZlbnQuZW5kX21hcms7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbXBvc2VyO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBNYXJrZWRZQU1MRXJyb3IsIG5vZGVzLCB1dGlsLCBfcmVmLCBfcmVmMSxcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBfX2luZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfTtcblxuICBNYXJrZWRZQU1MRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9ycycpLk1hcmtlZFlBTUxFcnJvcjtcblxuICBub2RlcyA9IHJlcXVpcmUoJy4vbm9kZXMnKTtcblxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgdGhpcy5Db25zdHJ1Y3RvckVycm9yID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25zdHJ1Y3RvckVycm9yLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gQ29uc3RydWN0b3JFcnJvcigpIHtcbiAgICAgIF9yZWYgPSBDb25zdHJ1Y3RvckVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIENvbnN0cnVjdG9yRXJyb3I7XG5cbiAgfSkoTWFya2VkWUFNTEVycm9yKTtcblxuICB0aGlzLkJhc2VDb25zdHJ1Y3RvciA9IChmdW5jdGlvbigpIHtcbiAgICBCYXNlQ29uc3RydWN0b3IucHJvdG90eXBlLnlhbWxfY29uc3RydWN0b3JzID0ge307XG5cbiAgICBCYXNlQ29uc3RydWN0b3IucHJvdG90eXBlLnlhbWxfbXVsdGlfY29uc3RydWN0b3JzID0ge307XG5cbiAgICBCYXNlQ29uc3RydWN0b3IuYWRkX2NvbnN0cnVjdG9yID0gZnVuY3Rpb24odGFnLCBjb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKCF0aGlzLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgneWFtbF9jb25zdHJ1Y3RvcnMnKSkge1xuICAgICAgICB0aGlzLnByb3RvdHlwZS55YW1sX2NvbnN0cnVjdG9ycyA9IHV0aWwuZXh0ZW5kKHt9LCB0aGlzLnByb3RvdHlwZS55YW1sX2NvbnN0cnVjdG9ycyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGUueWFtbF9jb25zdHJ1Y3RvcnNbdGFnXSA9IGNvbnN0cnVjdG9yO1xuICAgIH07XG5cbiAgICBCYXNlQ29uc3RydWN0b3IuYWRkX211bHRpX2NvbnN0cnVjdG9yID0gZnVuY3Rpb24odGFnX3ByZWZpeCwgbXVsdGlfY29uc3RydWN0b3IpIHtcbiAgICAgIGlmICghdGhpcy5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3lhbWxfbXVsdGlfY29uc3RydWN0b3JzJykpIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUueWFtbF9tdWx0aV9jb25zdHJ1Y3RvcnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5wcm90b3R5cGUueWFtbF9tdWx0aV9jb25zdHJ1Y3RvcnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucHJvdG90eXBlLnlhbWxfbXVsdGlfY29uc3RydWN0b3JzW3RhZ19wcmVmaXhdID0gbXVsdGlfY29uc3RydWN0b3I7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEJhc2VDb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0ZWRfb2JqZWN0cyA9IHt9O1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rpbmdfbm9kZXMgPSBbXTtcbiAgICAgIHRoaXMuZGVmZXJyZWRfY29uc3RydWN0b3JzID0gW107XG4gICAgfVxuXG4gICAgQmFzZUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfZG9jdW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgZGF0YTtcbiAgICAgIHRoaXMuYXBwbHlBc3RUcmFuc2Zvcm1hdGlvbnMobm9kZSk7XG4gICAgICBkYXRhID0gdGhpcy5jb25zdHJ1Y3Rfb2JqZWN0KG5vZGUpO1xuICAgICAgd2hpbGUgKCF1dGlsLmlzX2VtcHR5KHRoaXMuZGVmZXJyZWRfY29uc3RydWN0b3JzKSkge1xuICAgICAgICB0aGlzLmRlZmVycmVkX2NvbnN0cnVjdG9ycy5wb3AoKSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybWF0aW9ucyhkYXRhKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICBCYXNlQ29uc3RydWN0b3IucHJvdG90eXBlLmRlZmVyID0gZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmZXJyZWRfY29uc3RydWN0b3JzLnB1c2goZik7XG4gICAgfTtcblxuICAgIEJhc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X29iamVjdCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBjb25zdHJ1Y3Rvciwgb2JqZWN0LCB0YWdfcHJlZml4LCB0YWdfc3VmZml4LCBfcmVmMTtcbiAgICAgIGlmIChub2RlLnVuaXF1ZV9pZCBpbiB0aGlzLmNvbnN0cnVjdGVkX29iamVjdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0ZWRfb2JqZWN0c1tub2RlLnVuaXF1ZV9pZF07XG4gICAgICB9XG4gICAgICBpZiAoX3JlZjEgPSBub2RlLnVuaXF1ZV9pZCwgX19pbmRleE9mLmNhbGwodGhpcy5jb25zdHJ1Y3Rpbmdfbm9kZXMsIF9yZWYxKSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbnN0cnVjdG9yRXJyb3IobnVsbCwgbnVsbCwgJ2ZvdW5kIHVuY29uc3RydWN0YWJsZSByZWN1cnNpdmUgbm9kZScsIG5vZGUuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnN0cnVjdGluZ19ub2Rlcy5wdXNoKG5vZGUudW5pcXVlX2lkKTtcbiAgICAgIGNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgIHRhZ19zdWZmaXggPSBudWxsO1xuICAgICAgaWYgKG5vZGUudGFnIGluIHRoaXMueWFtbF9jb25zdHJ1Y3RvcnMpIHtcbiAgICAgICAgY29uc3RydWN0b3IgPSB0aGlzLnlhbWxfY29uc3RydWN0b3JzW25vZGUudGFnXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodGFnX3ByZWZpeCBpbiB0aGlzLnlhbWxfbXVsdGlfY29uc3RydWN0b3JzKSB7XG4gICAgICAgICAgaWYgKG5vZGUudGFnLmluZGV4T2YodGFnX3ByZWZpeCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHRhZ19zdWZmaXggPSBub2RlLnRhZy5zbGljZSh0YWdfcHJlZml4Lmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IHRoaXMueWFtbF9tdWx0aV9jb25zdHJ1Y3RvcnNbdGFnX3ByZWZpeF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09IG51bGwpIHtcbiAgICAgICAgICBpZiAobnVsbCBpbiB0aGlzLnlhbWxfbXVsdGlfY29uc3RydWN0b3JzKSB7XG4gICAgICAgICAgICB0YWdfc3VmZml4ID0gbm9kZS50YWc7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IHRoaXMueWFtbF9tdWx0aV9jb25zdHJ1Y3RvcnNbbnVsbF07XG4gICAgICAgICAgfSBlbHNlIGlmIChudWxsIGluIHRoaXMueWFtbF9jb25zdHJ1Y3RvcnMpIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gdGhpcy55YW1sX2NvbnN0cnVjdG9yc1tudWxsXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5TY2FsYXJOb2RlKSB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IHRoaXMuY29uc3RydWN0X3NjYWxhcjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5TZXF1ZW5jZU5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3Rfc2VxdWVuY2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuTWFwcGluZ05vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RfbWFwcGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IGNvbnN0cnVjdG9yLmNhbGwodGhpcywgdGFnX3N1ZmZpeCAhPSBudWxsID8gdGFnX3N1ZmZpeCA6IG5vZGUsIG5vZGUpO1xuICAgICAgdGhpcy5jb25zdHJ1Y3RlZF9vYmplY3RzW25vZGUudW5pcXVlX2lkXSA9IG9iamVjdDtcbiAgICAgIHRoaXMuY29uc3RydWN0aW5nX25vZGVzLnBvcCgpO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9O1xuXG4gICAgQmFzZUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rfc2NhbGFyID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIG5vZGVzLlNjYWxhck5vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbnN0cnVjdG9yRXJyb3IobnVsbCwgbnVsbCwgXCJleHBlY3RlZCBhIHNjYWxhciBub2RlIGJ1dCBmb3VuZCBcIiArIG5vZGUuaWQsIG5vZGUuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICB9O1xuXG4gICAgQmFzZUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rfc2VxdWVuY2UgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgY2hpbGQsIF9pLCBfbGVuLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICBpZiAoIShub2RlIGluc3RhbmNlb2Ygbm9kZXMuU2VxdWVuY2VOb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db25zdHJ1Y3RvckVycm9yKG51bGwsIG51bGwsIFwiZXhwZWN0ZWQgYW4gYXJyYXkgbm9kZSBidXQgZm91bmQgXCIgKyBub2RlLmlkLCBub2RlLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgX3JlZjEgPSBub2RlLnZhbHVlO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgY2hpbGQgPSBfcmVmMVtfaV07XG4gICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy5jb25zdHJ1Y3Rfb2JqZWN0KGNoaWxkKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIEJhc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X21hcHBpbmcgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIga2V5LCBrZXlfaXRlbSwga2V5X2l0ZW1fdmFsdWUsIGtleV9ub2RlLCBtYXBwaW5nLCB2YWx1ZSwgdmFsdWVfbm9kZSwgX2ksIF9qLCBfbGVuLCBfbGVuMSwgX3JlZjEsIF9yZWYyLCBfcmVmMztcbiAgICAgIGlmICghKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5NYXBwaW5nTm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29uc3RydWN0b3JFcnJvcihudWxsLCBudWxsLCBcImV4cGVjdGVkIGEgbWFwIG5vZGUgYnV0IGZvdW5kIFwiICsgbm9kZS5pZCwgbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIG1hcHBpbmcgPSB7fTtcbiAgICAgIF9yZWYxID0gbm9kZS52YWx1ZTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgX3JlZjIgPSBfcmVmMVtfaV0sIGtleV9ub2RlID0gX3JlZjJbMF0sIHZhbHVlX25vZGUgPSBfcmVmMlsxXTtcbiAgICAgICAga2V5ID0gdGhpcy5jb25zdHJ1Y3Rfb2JqZWN0KGtleV9ub2RlKTtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmNvbnN0cnVjdF9vYmplY3QodmFsdWVfbm9kZSk7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyAmJiBrZXlfbm9kZS50YWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnKSB7XG4gICAgICAgICAgX3JlZjMgPSBrZXlfbm9kZS52YWx1ZTtcbiAgICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmMy5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICAgIGtleV9pdGVtID0gX3JlZjNbX2pdO1xuICAgICAgICAgICAga2V5X2l0ZW1fdmFsdWUgPSB0aGlzLmNvbnN0cnVjdF9vYmplY3Qoa2V5X2l0ZW0pO1xuICAgICAgICAgICAgbWFwcGluZ1trZXlfaXRlbV92YWx1ZV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db25zdHJ1Y3RvckVycm9yKCd3aGlsZSBjb25zdHJ1Y3RpbmcgYSBtYXAnLCBub2RlLnN0YXJ0X21hcmssICdmb3VuZCB1bmhhc2hhYmxlIGtleScsIGtleV9ub2RlLnN0YXJ0X21hcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcHBpbmdba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwcGluZztcbiAgICB9O1xuXG4gICAgQmFzZUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfcGFpcnMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIga2V5LCBrZXlfbm9kZSwgcGFpcnMsIHZhbHVlLCB2YWx1ZV9ub2RlLCBfaSwgX2xlbiwgX3JlZjEsIF9yZWYyO1xuICAgICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIG5vZGVzLk1hcHBpbmdOb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db25zdHJ1Y3RvckVycm9yKG51bGwsIG51bGwsIFwiZXhwZWN0ZWQgYSBtYXAgbm9kZSBidXQgZm91bmQgXCIgKyBub2RlLmlkLCBub2RlLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgcGFpcnMgPSBbXTtcbiAgICAgIF9yZWYxID0gbm9kZS52YWx1ZTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgX3JlZjIgPSBfcmVmMVtfaV0sIGtleV9ub2RlID0gX3JlZjJbMF0sIHZhbHVlX25vZGUgPSBfcmVmMlsxXTtcbiAgICAgICAga2V5ID0gdGhpcy5jb25zdHJ1Y3Rfb2JqZWN0KGtleV9ub2RlKTtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmNvbnN0cnVjdF9vYmplY3QodmFsdWVfbm9kZSk7XG4gICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYWlycztcbiAgICB9O1xuXG4gICAgcmV0dXJuIEJhc2VDb25zdHJ1Y3RvcjtcblxuICB9KSgpO1xuXG4gIHRoaXMuQ29uc3RydWN0b3IgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgdmFyIEJPT0xfVkFMVUVTLCBUSU1FU1RBTVBfUEFSVFMsIFRJTUVTVEFNUF9SRUdFWDtcblxuICAgIF9fZXh0ZW5kcyhDb25zdHJ1Y3RvciwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIENvbnN0cnVjdG9yKCkge1xuICAgICAgX3JlZjEgPSBDb25zdHJ1Y3Rvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmMTtcbiAgICB9XG5cbiAgICBCT09MX1ZBTFVFUyA9IHtcbiAgICAgIFwidHJ1ZVwiOiB0cnVlLFxuICAgICAgXCJmYWxzZVwiOiBmYWxzZVxuICAgIH07XG5cbiAgICBUSU1FU1RBTVBfUkVHRVggPSAvXihbMC05XVswLTldWzAtOV1bMC05XSktKFswLTldWzAtOV0/KS0oWzAtOV1bMC05XT8pKD86KD86W1R0XXxbXFx4MjBcXHRdKykoWzAtOV1bMC05XT8pOihbMC05XVswLTldKTooWzAtOV1bMC05XSkoPzpcXC4oWzAtOV0qKSk/KD86W1xceDIwXFx0XSooWnwoWy0rXSkoWzAtOV1bMC05XT8pKD86OihbMC05XVswLTldKSk/KSk/KT8kLztcblxuICAgIFRJTUVTVEFNUF9QQVJUUyA9IHtcbiAgICAgIHllYXI6IDEsXG4gICAgICBtb250aDogMixcbiAgICAgIGRheTogMyxcbiAgICAgIGhvdXI6IDQsXG4gICAgICBtaW51dGU6IDUsXG4gICAgICBzZWNvbmQ6IDYsXG4gICAgICBmcmFjdGlvbjogNyxcbiAgICAgIHR6OiA4LFxuICAgICAgdHpfc2lnbjogOSxcbiAgICAgIHR6X2hvdXI6IDEwLFxuICAgICAgdHpfbWludXRlOiAxMVxuICAgIH07XG5cbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUueWFtbF9jb25zdHJ1Y3RvcnMgPSB7fTtcblxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS55YW1sX211bHRpX2NvbnN0cnVjdG9ycyA9IHt9O1xuXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF9zY2FsYXIgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIga2V5X25vZGUsIHZhbHVlX25vZGUsIF9pLCBfbGVuLCBfcmVmMiwgX3JlZjM7XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLk1hcHBpbmdOb2RlKSB7XG4gICAgICAgIF9yZWYyID0gbm9kZS52YWx1ZTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIF9yZWYzID0gX3JlZjJbX2ldLCBrZXlfbm9kZSA9IF9yZWYzWzBdLCB2YWx1ZV9ub2RlID0gX3JlZjNbMV07XG4gICAgICAgICAgaWYgKGtleV9ub2RlLnRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOnZhbHVlJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0X3NjYWxhcih2YWx1ZV9ub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBDb25zdHJ1Y3Rvci5fX3N1cGVyX18uY29uc3RydWN0X3NjYWxhci5jYWxsKHRoaXMsIG5vZGUpO1xuICAgIH07XG5cbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZmxhdHRlbl9tYXBwaW5nID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGluZGV4LCBrZXlfbm9kZSwgbWVyZ2UsIHN1Ym1lcmdlLCBzdWJub2RlLCB2YWx1ZSwgdmFsdWVfbm9kZSwgX2ksIF9qLCBfbGVuLCBfbGVuMSwgX3JlZjIsIF9yZWYzO1xuICAgICAgbWVyZ2UgPSBbXTtcbiAgICAgIGluZGV4ID0gMDtcbiAgICAgIHdoaWxlIChpbmRleCA8IG5vZGUudmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIF9yZWYyID0gbm9kZS52YWx1ZVtpbmRleF0sIGtleV9ub2RlID0gX3JlZjJbMF0sIHZhbHVlX25vZGUgPSBfcmVmMlsxXTtcbiAgICAgICAgaWYgKGtleV9ub2RlLnRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJykge1xuICAgICAgICAgIG5vZGUudmFsdWUuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBpZiAodmFsdWVfbm9kZSBpbnN0YW5jZW9mIG5vZGVzLk1hcHBpbmdOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmZsYXR0ZW5fbWFwcGluZyh2YWx1ZV9ub2RlKTtcbiAgICAgICAgICAgIG1lcmdlID0gbWVyZ2UuY29uY2F0KHZhbHVlX25vZGUudmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVfbm9kZSBpbnN0YW5jZW9mIG5vZGVzLlNlcXVlbmNlTm9kZSkge1xuICAgICAgICAgICAgc3VibWVyZ2UgPSBbXTtcbiAgICAgICAgICAgIF9yZWYzID0gdmFsdWVfbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgICAgc3Vibm9kZSA9IF9yZWYzW19pXTtcbiAgICAgICAgICAgICAgaWYgKCEoc3Vibm9kZSBpbnN0YW5jZW9mIG5vZGVzLk1hcHBpbmdOb2RlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbnN0cnVjdG9yRXJyb3IoJ3doaWxlIGNvbnN0cnVjdGluZyBhIG1hcCcsIG5vZGUuc3RhcnRfbWFyaywgXCJleHBlY3RlZCBhIG1hcCBmb3IgbWVyZ2luZywgYnV0IGZvdW5kIFwiICsgc3Vibm9kZS5pZCwgc3Vibm9kZS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLmZsYXR0ZW5fbWFwcGluZyhzdWJub2RlKTtcbiAgICAgICAgICAgICAgc3VibWVyZ2UucHVzaChzdWJub2RlLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1Ym1lcmdlLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IHN1Ym1lcmdlLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHN1Ym1lcmdlW19qXTtcbiAgICAgICAgICAgICAgbWVyZ2UgPSBtZXJnZS5jb25jYXQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db25zdHJ1Y3RvckVycm9yKCd3aGlsZSBjb25zdHJ1Y3RpbmcgYSBtYXAnLCBub2RlLnN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgYSBtYXAgb3IgYW4gYXJyYXkgb2YgbWFwcyBmb3IgICAgICAgICAgICBtZXJnaW5nIGJ1dCBmb3VuZCBcIiArIHZhbHVlX25vZGUuaWQsIHZhbHVlX25vZGUuc3RhcnRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGtleV9ub2RlLnRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOnZhbHVlJykge1xuICAgICAgICAgIGtleV9ub2RlLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInO1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lcmdlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZSA9IG1lcmdlLmNvbmNhdChub2RlLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF9tYXBwaW5nID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5NYXBwaW5nTm9kZSkge1xuICAgICAgICB0aGlzLmZsYXR0ZW5fbWFwcGluZyhub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBDb25zdHJ1Y3Rvci5fX3N1cGVyX18uY29uc3RydWN0X21hcHBpbmcuY2FsbCh0aGlzLCBub2RlKTtcbiAgICB9O1xuXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX251bGwgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdF9zY2FsYXIobm9kZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX2Jvb2wgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB2YWx1ZSA9IHRoaXMuY29uc3RydWN0X3NjYWxhcihub2RlKTtcbiAgICAgIHJldHVybiBCT09MX1ZBTFVFU1t2YWx1ZS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9O1xuXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX2ludCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBiYXNlLCBkaWdpdCwgZGlnaXRzLCBwYXJ0LCBzaWduLCB2YWx1ZSwgX2ksIF9sZW4sIF9yZWYyO1xuICAgICAgdmFsdWUgPSB0aGlzLmNvbnN0cnVjdF9zY2FsYXIobm9kZSk7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL18vZywgJycpO1xuICAgICAgc2lnbiA9IHZhbHVlWzBdID09PSAnLScgPyAtMSA6IDE7XG4gICAgICBpZiAoX3JlZjIgPSB2YWx1ZVswXSwgX19pbmRleE9mLmNhbGwoJystJywgX3JlZjIpID49IDApIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gJzAnKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5pbmRleE9mKCcwYicpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDIpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5pbmRleE9mKCcweCcpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIDE2KTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUuaW5kZXhPZignMG8nKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCA4KTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWVbMF0gPT09ICcwJykge1xuICAgICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLCA4KTtcbiAgICAgIH0gZWxzZSBpZiAoX19pbmRleE9mLmNhbGwodmFsdWUsICc6JykgPj0gMCkge1xuICAgICAgICBkaWdpdHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmMywgX3Jlc3VsdHM7XG4gICAgICAgICAgX3JlZjMgPSB2YWx1ZS5zcGxpdCgvOi9nKTtcbiAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgIHBhcnQgPSBfcmVmM1tfaV07XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHBhcnNlSW50KHBhcnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICB9KSgpO1xuICAgICAgICBkaWdpdHMucmV2ZXJzZSgpO1xuICAgICAgICBiYXNlID0gMTtcbiAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGRpZ2l0cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIGRpZ2l0ID0gZGlnaXRzW19pXTtcbiAgICAgICAgICB2YWx1ZSArPSBkaWdpdCAqIGJhc2U7XG4gICAgICAgICAgYmFzZSAqPSA2MDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2lnbiAqIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9mbG9hdCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBiYXNlLCBkaWdpdCwgZGlnaXRzLCBwYXJ0LCBzaWduLCB2YWx1ZSwgX2ksIF9sZW4sIF9yZWYyO1xuICAgICAgdmFsdWUgPSB0aGlzLmNvbnN0cnVjdF9zY2FsYXIobm9kZSk7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL18vZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBzaWduID0gdmFsdWVbMF0gPT09ICctJyA/IC0xIDogMTtcbiAgICAgIGlmIChfcmVmMiA9IHZhbHVlWzBdLCBfX2luZGV4T2YuY2FsbCgnKy0nLCBfcmVmMikgPj0gMCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSAnLmluZicpIHtcbiAgICAgICAgcmV0dXJuIHNpZ24gKiBJbmZpbml0eTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcubmFuJykge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfSBlbHNlIGlmIChfX2luZGV4T2YuY2FsbCh2YWx1ZSwgJzonKSA+PSAwKSB7XG4gICAgICAgIGRpZ2l0cyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZWYzLCBfcmVzdWx0cztcbiAgICAgICAgICBfcmVmMyA9IHZhbHVlLnNwbGl0KC86L2cpO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgcGFydCA9IF9yZWYzW19pXTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2gocGFyc2VGbG9hdChwYXJ0KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgZGlnaXRzLnJldmVyc2UoKTtcbiAgICAgICAgYmFzZSA9IDE7XG4gICAgICAgIHZhbHVlID0gMC4wO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGRpZ2l0cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIGRpZ2l0ID0gZGlnaXRzW19pXTtcbiAgICAgICAgICB2YWx1ZSArPSBkaWdpdCAqIGJhc2U7XG4gICAgICAgICAgYmFzZSAqPSA2MDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2lnbiAqIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX2JpbmFyeSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBlcnJvciwgdmFsdWU7XG4gICAgICB2YWx1ZSA9IHRoaXMuY29uc3RydWN0X3NjYWxhcihub2RlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBhdG9iKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdhc2NpaScpO1xuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGVycm9yID0gX2Vycm9yO1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db25zdHJ1Y3RvckVycm9yKG51bGwsIG51bGwsIFwiZmFpbGVkIHRvIGRlY29kZSBiYXNlNjQgZGF0YTogXCIgKyBlcnJvciwgbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX3RpbWVzdGFtcCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBkYXRlLCBkYXksIGZyYWN0aW9uLCBob3VyLCBpbmRleCwga2V5LCBtYXRjaCwgbWlsbGlzZWNvbmQsIG1pbnV0ZSwgbW9udGgsIHNlY29uZCwgdHpfaG91ciwgdHpfbWludXRlLCB0el9zaWduLCB2YWx1ZSwgdmFsdWVzLCB5ZWFyO1xuICAgICAgdmFsdWUgPSB0aGlzLmNvbnN0cnVjdF9zY2FsYXIobm9kZSk7XG4gICAgICBtYXRjaCA9IG5vZGUudmFsdWUubWF0Y2goVElNRVNUQU1QX1JFR0VYKTtcbiAgICAgIHZhbHVlcyA9IHt9O1xuICAgICAgZm9yIChrZXkgaW4gVElNRVNUQU1QX1BBUlRTKSB7XG4gICAgICAgIGluZGV4ID0gVElNRVNUQU1QX1BBUlRTW2tleV07XG4gICAgICAgIHZhbHVlc1trZXldID0gbWF0Y2hbaW5kZXhdO1xuICAgICAgfVxuICAgICAgeWVhciA9IHBhcnNlSW50KHZhbHVlcy55ZWFyKTtcbiAgICAgIG1vbnRoID0gcGFyc2VJbnQodmFsdWVzLm1vbnRoKSAtIDE7XG4gICAgICBkYXkgPSBwYXJzZUludCh2YWx1ZXMuZGF5KTtcbiAgICAgIGlmICghdmFsdWVzLmhvdXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXkpKTtcbiAgICAgIH1cbiAgICAgIGhvdXIgPSBwYXJzZUludCh2YWx1ZXMuaG91cik7XG4gICAgICBtaW51dGUgPSBwYXJzZUludCh2YWx1ZXMubWludXRlKTtcbiAgICAgIHNlY29uZCA9IHBhcnNlSW50KHZhbHVlcy5zZWNvbmQpO1xuICAgICAgbWlsbGlzZWNvbmQgPSAwO1xuICAgICAgaWYgKHZhbHVlcy5mcmFjdGlvbikge1xuICAgICAgICBmcmFjdGlvbiA9IHZhbHVlcy5mcmFjdGlvbi5zbGljZSgwLCA2KTtcbiAgICAgICAgd2hpbGUgKGZyYWN0aW9uLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgICBmcmFjdGlvbiArPSAnMCc7XG4gICAgICAgIH1cbiAgICAgICAgZnJhY3Rpb24gPSBwYXJzZUludChmcmFjdGlvbik7XG4gICAgICAgIG1pbGxpc2Vjb25kID0gTWF0aC5yb3VuZChmcmFjdGlvbiAvIDEwMDApO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlcy50el9zaWduKSB7XG4gICAgICAgIHR6X3NpZ24gPSB2YWx1ZXMudHpfc2lnbiA9PT0gJy0nID8gMSA6IC0xO1xuICAgICAgICBpZiAodHpfaG91ciA9IHBhcnNlSW50KHZhbHVlcy50el9ob3VyKSkge1xuICAgICAgICAgIGhvdXIgKz0gdHpfc2lnbiAqIHR6X2hvdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR6X21pbnV0ZSA9IHBhcnNlSW50KHZhbHVlcy50el9taW51dGUpKSB7XG4gICAgICAgICAgbWludXRlICs9IHR6X3NpZ24gKiB0el9taW51dGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQpKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH07XG5cbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfcGFpcl9saXN0ID0gZnVuY3Rpb24odHlwZSwgbm9kZSkge1xuICAgICAgdmFyIGxpc3QsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGxpc3QgPSBbXTtcbiAgICAgIGlmICghKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5TZXF1ZW5jZU5vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbnN0cnVjdG9yRXJyb3IoXCJ3aGlsZSBjb25zdHJ1Y3RpbmcgXCIgKyB0eXBlLCBub2RlLnN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgYW4gYXJyYXkgYnV0IGZvdW5kIFwiICsgbm9kZS5pZCwgbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVmZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBrZXksIGtleV9ub2RlLCBzdWJub2RlLCB2YWx1ZSwgdmFsdWVfbm9kZSwgX2ksIF9sZW4sIF9yZWYyLCBfcmVmMywgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYyID0gbm9kZS52YWx1ZTtcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHN1Ym5vZGUgPSBfcmVmMltfaV07XG4gICAgICAgICAgaWYgKCEoc3Vibm9kZSBpbnN0YW5jZW9mIG5vZGVzLk1hcHBpbmdOb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQ29uc3RydWN0b3JFcnJvcihcIndoaWxlIGNvbnN0cnVjdGluZyBcIiArIHR5cGUsIG5vZGUuc3RhcnRfbWFyaywgXCJleHBlY3RlZCBhIG1hcCBvZiBsZW5ndGggMSBidXQgZm91bmQgXCIgKyBzdWJub2RlLmlkLCBzdWJub2RlLnN0YXJ0X21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3Vibm9kZS52YWx1ZS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkNvbnN0cnVjdG9yRXJyb3IoXCJ3aGlsZSBjb25zdHJ1Y3RpbmcgXCIgKyB0eXBlLCBub2RlLnN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgYSBtYXAgb2YgbGVuZ3RoIDEgYnV0IGZvdW5kIFwiICsgc3Vibm9kZS5pZCwgc3Vibm9kZS5zdGFydF9tYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3JlZjMgPSBzdWJub2RlLnZhbHVlWzBdLCBrZXlfbm9kZSA9IF9yZWYzWzBdLCB2YWx1ZV9ub2RlID0gX3JlZjNbMV07XG4gICAgICAgICAga2V5ID0gX3RoaXMuY29uc3RydWN0X29iamVjdChrZXlfbm9kZSk7XG4gICAgICAgICAgdmFsdWUgPSBfdGhpcy5jb25zdHJ1Y3Rfb2JqZWN0KHZhbHVlX25vZGUpO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2gobGlzdC5wdXNoKFtrZXksIHZhbHVlXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfTtcblxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9vbWFwID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0X3lhbWxfcGFpcl9saXN0KCdhbiBvcmRlcmVkIG1hcCcsIG5vZGUpO1xuICAgIH07XG5cbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfcGFpcnMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RfeWFtbF9wYWlyX2xpc3QoJ3BhaXJzJywgbm9kZSk7XG4gICAgfTtcblxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9zZXQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgZGF0YSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgZGF0YSA9IFtdO1xuICAgICAgdGhpcy5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGl0ZW0sIF9yZXN1bHRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGl0ZW0gaW4gX3RoaXMuY29uc3RydWN0X21hcHBpbmcobm9kZSkpIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKGRhdGEucHVzaChpdGVtKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX3N0ciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdF9zY2FsYXIobm9kZSk7XG4gICAgfTtcblxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9zZXEgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgZGF0YSxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgZGF0YSA9IFtdO1xuICAgICAgdGhpcy5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGl0ZW0sIF9pLCBfbGVuLCBfcmVmMiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYyID0gX3RoaXMuY29uc3RydWN0X3NlcXVlbmNlKG5vZGUpO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYyLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IF9yZWYyW19pXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKGRhdGEucHVzaChpdGVtKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX21hcCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBkYXRhLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBkYXRhID0ge307XG4gICAgICB0aGlzLmRlZmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIga2V5LCB2YWx1ZSwgX3JlZjIsIF9yZXN1bHRzO1xuICAgICAgICBfcmVmMiA9IF90aGlzLmNvbnN0cnVjdF9tYXBwaW5nKG5vZGUpO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGtleSBpbiBfcmVmMikge1xuICAgICAgICAgIHZhbHVlID0gX3JlZjJba2V5XTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKGRhdGFba2V5XSA9IHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfb2JqZWN0ID0gZnVuY3Rpb24obm9kZSwga2xhc3MpIHtcbiAgICAgIHZhciBkYXRhLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBkYXRhID0gbmV3IGtsYXNzO1xuICAgICAgdGhpcy5kZWZlcihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGtleSwgdmFsdWUsIF9yZWYyLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZjIgPSBfdGhpcy5jb25zdHJ1Y3RfbWFwcGluZyhub2RlLCB0cnVlKTtcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChrZXkgaW4gX3JlZjIpIHtcbiAgICAgICAgICB2YWx1ZSA9IF9yZWYyW2tleV07XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChkYXRhW2tleV0gPSB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF91bmRlZmluZWQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB0aHJvdyBuZXcgZXhwb3J0cy5Db25zdHJ1Y3RvckVycm9yKG51bGwsIG51bGwsIFwiY291bGQgbm90IGRldGVybWluZSBhIGNvbnN0cnVjdG9yIGZvciB0aGUgdGFnIFwiICsgbm9kZS50YWcsIG5vZGUuc3RhcnRfbWFyayk7XG4gICAgfTtcblxuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcblxuICB9KSh0aGlzLkJhc2VDb25zdHJ1Y3Rvcik7XG5cbiAgdGhpcy5Db25zdHJ1Y3Rvci5hZGRfY29uc3RydWN0b3IoJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLCB0aGlzLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9udWxsKTtcblxuICB0aGlzLkNvbnN0cnVjdG9yLmFkZF9jb25zdHJ1Y3RvcigndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsIHRoaXMuQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX2Jvb2wpO1xuXG4gIHRoaXMuQ29uc3RydWN0b3IuYWRkX2NvbnN0cnVjdG9yKCd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLCB0aGlzLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfeWFtbF9pbnQpO1xuXG4gIHRoaXMuQ29uc3RydWN0b3IuYWRkX2NvbnN0cnVjdG9yKCd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsIHRoaXMuQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX2Zsb2F0KTtcblxuICB0aGlzLkNvbnN0cnVjdG9yLmFkZF9jb25zdHJ1Y3RvcigndGFnOnlhbWwub3JnLDIwMDI6YmluYXJ5JywgdGhpcy5Db25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfYmluYXJ5KTtcblxuICB0aGlzLkNvbnN0cnVjdG9yLmFkZF9jb25zdHJ1Y3RvcigndGFnOnlhbWwub3JnLDIwMDI6dGltZXN0YW1wJywgdGhpcy5Db25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfdGltZXN0YW1wKTtcblxuICB0aGlzLkNvbnN0cnVjdG9yLmFkZF9jb25zdHJ1Y3RvcigndGFnOnlhbWwub3JnLDIwMDI6b21hcCcsIHRoaXMuQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX29tYXApO1xuXG4gIHRoaXMuQ29uc3RydWN0b3IuYWRkX2NvbnN0cnVjdG9yKCd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycycsIHRoaXMuQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdF95YW1sX3BhaXJzKTtcblxuICB0aGlzLkNvbnN0cnVjdG9yLmFkZF9jb25zdHJ1Y3RvcigndGFnOnlhbWwub3JnLDIwMDI6c2V0JywgdGhpcy5Db25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfc2V0KTtcblxuICB0aGlzLkNvbnN0cnVjdG9yLmFkZF9jb25zdHJ1Y3RvcigndGFnOnlhbWwub3JnLDIwMDI6c3RyJywgdGhpcy5Db25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfc3RyKTtcblxuICB0aGlzLkNvbnN0cnVjdG9yLmFkZF9jb25zdHJ1Y3RvcigndGFnOnlhbWwub3JnLDIwMDI6c2VxJywgdGhpcy5Db25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfc2VxKTtcblxuICB0aGlzLkNvbnN0cnVjdG9yLmFkZF9jb25zdHJ1Y3RvcigndGFnOnlhbWwub3JnLDIwMDI6bWFwJywgdGhpcy5Db25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0X3lhbWxfbWFwKTtcblxuICB0aGlzLkNvbnN0cnVjdG9yLmFkZF9jb25zdHJ1Y3RvcihudWxsLCB0aGlzLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RfdW5kZWZpbmVkKTtcblxuICBtb2R1bGUuZXhwb3J0cy5Db25zdHJ1Y3RvciA9IHRoaXMuQ29uc3RydWN0b3I7XG5cbiAgbW9kdWxlLmV4cG9ydHMuQ29uc3RydWN0b3JFcnJvciA9IHRoaXMuQ29uc3RydWN0b3JFcnJvcjtcblxufSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKSIsIihmdW5jdGlvbigpIHtcbiAgdmFyIF9yZWYsXG4gICAgX19pbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH0sXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XG5cbiAgdGhpcy5NYXJrID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIE1hcmsobmFtZSwgbGluZSwgY29sdW1uLCBidWZmZXIsIHBvaW50ZXIpIHtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgIHRoaXMucG9pbnRlciA9IHBvaW50ZXI7XG4gICAgfVxuXG4gICAgTWFyay5wcm90b3R5cGUuZ2V0X3NuaXBwZXQgPSBmdW5jdGlvbihpbmRlbnQsIG1heF9sZW5ndGgpIHtcbiAgICAgIHZhciBicmVha19jaGFycywgZW5kLCBoZWFkLCBzdGFydCwgdGFpbCwgX3JlZiwgX3JlZjE7XG4gICAgICBpZiAoaW5kZW50ID09IG51bGwpIHtcbiAgICAgICAgaW5kZW50ID0gNDtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhfbGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgbWF4X2xlbmd0aCA9IDc1O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYnVmZmVyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBicmVha19jaGFycyA9ICdcXHgwMFxcclxcblxceDg1XFx1MjAyOFxcdTIwMjknO1xuICAgICAgaGVhZCA9ICcnO1xuICAgICAgc3RhcnQgPSB0aGlzLnBvaW50ZXI7XG4gICAgICB3aGlsZSAoc3RhcnQgPiAwICYmIChfcmVmID0gdGhpcy5idWZmZXJbc3RhcnQgLSAxXSwgX19pbmRleE9mLmNhbGwoYnJlYWtfY2hhcnMsIF9yZWYpIDwgMCkpIHtcbiAgICAgICAgc3RhcnQtLTtcbiAgICAgICAgaWYgKHRoaXMucG9pbnRlciAtIHN0YXJ0ID4gbWF4X2xlbmd0aCAvIDIgLSAxKSB7XG4gICAgICAgICAgaGVhZCA9ICcgLi4uICc7XG4gICAgICAgICAgc3RhcnQgKz0gNTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGFpbCA9ICcnO1xuICAgICAgZW5kID0gdGhpcy5wb2ludGVyO1xuICAgICAgd2hpbGUgKGVuZCA8IHRoaXMuYnVmZmVyLmxlbmd0aCAmJiAoX3JlZjEgPSB0aGlzLmJ1ZmZlcltlbmRdLCBfX2luZGV4T2YuY2FsbChicmVha19jaGFycywgX3JlZjEpIDwgMCkpIHtcbiAgICAgICAgZW5kKys7XG4gICAgICAgIGlmIChlbmQgLSB0aGlzLnBvaW50ZXIgPiBtYXhfbGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgICAgICB0YWlsID0gJyAuLi4gJztcbiAgICAgICAgICBlbmQgLT0gNTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCIgKyAoKG5ldyBBcnJheShpbmRlbnQpKS5qb2luKCcgJykpICsgaGVhZCArIHRoaXMuYnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpICsgdGFpbCArIFwiXFxuXCIgKyAoKG5ldyBBcnJheShpbmRlbnQgKyB0aGlzLnBvaW50ZXIgLSBzdGFydCArIGhlYWQubGVuZ3RoKSkuam9pbignICcpKSArIFwiXlwiO1xuICAgIH07XG5cbiAgICBNYXJrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNuaXBwZXQsIHdoZXJlO1xuICAgICAgc25pcHBldCA9IHRoaXMuZ2V0X3NuaXBwZXQoKTtcbiAgICAgIHdoZXJlID0gXCIgIGluIFxcXCJcIiArIHRoaXMubmFtZSArIFwiXFxcIiwgbGluZSBcIiArICh0aGlzLmxpbmUgKyAxKSArIFwiLCBjb2x1bW4gXCIgKyAodGhpcy5jb2x1bW4gKyAxKTtcbiAgICAgIGlmIChzbmlwcGV0KSB7XG4gICAgICAgIHJldHVybiB3aGVyZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgd2hlcmUgKyBcIjpcXG5cIiArIHNuaXBwZXQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBNYXJrO1xuXG4gIH0pKCk7XG5cbiAgdGhpcy5ZQU1MRXJyb3IgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFlBTUxFcnJvciwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFlBTUxFcnJvcigpIHtcbiAgICAgIFlBTUxFcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gWUFNTEVycm9yO1xuXG4gIH0pKEVycm9yKTtcblxuICB0aGlzLk1hcmtlZFlBTUxFcnJvciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFya2VkWUFNTEVycm9yLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gTWFya2VkWUFNTEVycm9yKGNvbnRleHQsIGNvbnRleHRfbWFyaywgbWVzc2FnZSwgcHJvYmxlbV9tYXJrLCBub3RlKSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5jb250ZXh0X21hcmsgPSBjb250ZXh0X21hcms7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgdGhpcy5wcm9ibGVtX21hcmsgPSBwcm9ibGVtX21hcms7XG4gICAgICB0aGlzLm5vdGUgPSBub3RlO1xuICAgICAgTWFya2VkWUFNTEVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICAgICAgaWYgKCF0aGlzLm1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5jb250ZXh0O1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnByb2JsZW1fbWFyaykge1xuICAgICAgICB0aGlzLnByb2JsZW1fbWFyayA9IHRoaXMuY29udGV4dF9tYXJrO1xuICAgICAgfVxuICAgIH1cblxuICAgIE1hcmtlZFlBTUxFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaW5lcztcbiAgICAgIGxpbmVzID0gW107XG4gICAgICBpZiAodGhpcy5jb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgbGluZXMucHVzaCh0aGlzLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgaWYgKCh0aGlzLmNvbnRleHRfbWFyayAhPSBudWxsKSAmJiAoKHRoaXMubWVzc2FnZSA9PSBudWxsKSB8fCAodGhpcy5wcm9ibGVtX21hcmsgPT0gbnVsbCkgfHwgdGhpcy5jb250ZXh0X21hcmsubmFtZSAhPT0gdGhpcy5wcm9ibGVtX21hcmsubmFtZSB8fCB0aGlzLmNvbnRleHRfbWFyay5saW5lICE9PSB0aGlzLnByb2JsZW1fbWFyay5saW5lIHx8IHRoaXMuY29udGV4dF9tYXJrLmNvbHVtbiAhPT0gdGhpcy5wcm9ibGVtX21hcmsuY29sdW1uKSkge1xuICAgICAgICBsaW5lcy5wdXNoKHRoaXMuY29udGV4dF9tYXJrLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWVzc2FnZSAhPSBudWxsKSB7XG4gICAgICAgIGxpbmVzLnB1c2godGhpcy5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnByb2JsZW1fbWFyayAhPSBudWxsKSB7XG4gICAgICAgIGxpbmVzLnB1c2godGhpcy5wcm9ibGVtX21hcmsudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ub3RlICE9IG51bGwpIHtcbiAgICAgICAgbGluZXMucHVzaCh0aGlzLm5vdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWFya2VkWUFNTEVycm9yO1xuXG4gIH0pKHRoaXMuWUFNTEVycm9yKTtcblxuICAvKlxuICBUaGUgVmFsaWRhdG9yIHRocm93cyB0aGVzZS5cbiAgKi9cblxuXG4gIHRoaXMuVmFsaWRhdGlvbkVycm9yID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWYWxpZGF0aW9uRXJyb3IsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBWYWxpZGF0aW9uRXJyb3IoKSB7XG4gICAgICBfcmVmID0gVmFsaWRhdGlvbkVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIFZhbGlkYXRpb25FcnJvcjtcblxuICB9KSh0aGlzLk1hcmtlZFlBTUxFcnJvcik7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBfcmVmLCBfcmVmMSwgX3JlZjIsIF9yZWYzLCBfcmVmNCwgX3JlZjUsIF9yZWY2LFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9O1xuXG4gIHRoaXMuRXZlbnQgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gRXZlbnQoc3RhcnRfbWFyaywgZW5kX21hcmspIHtcbiAgICAgIHRoaXMuc3RhcnRfbWFyayA9IHN0YXJ0X21hcms7XG4gICAgICB0aGlzLmVuZF9tYXJrID0gZW5kX21hcms7XG4gICAgfVxuXG4gICAgcmV0dXJuIEV2ZW50O1xuXG4gIH0pKCk7XG5cbiAgdGhpcy5Ob2RlRXZlbnQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE5vZGVFdmVudCwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIE5vZGVFdmVudChhbmNob3IsIHN0YXJ0X21hcmssIGVuZF9tYXJrKSB7XG4gICAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgIHRoaXMuc3RhcnRfbWFyayA9IHN0YXJ0X21hcms7XG4gICAgICB0aGlzLmVuZF9tYXJrID0gZW5kX21hcms7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5vZGVFdmVudDtcblxuICB9KSh0aGlzLkV2ZW50KTtcblxuICB0aGlzLkNvbGxlY3Rpb25TdGFydEV2ZW50ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb2xsZWN0aW9uU3RhcnRFdmVudCwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIENvbGxlY3Rpb25TdGFydEV2ZW50KGFuY2hvciwgdGFnLCBpbXBsaWNpdCwgc3RhcnRfbWFyaywgZW5kX21hcmspIHtcbiAgICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICB0aGlzLmltcGxpY2l0ID0gaW1wbGljaXQ7XG4gICAgICB0aGlzLnN0YXJ0X21hcmsgPSBzdGFydF9tYXJrO1xuICAgICAgdGhpcy5lbmRfbWFyayA9IGVuZF9tYXJrO1xuICAgIH1cblxuICAgIHJldHVybiBDb2xsZWN0aW9uU3RhcnRFdmVudDtcblxuICB9KSh0aGlzLk5vZGVFdmVudCk7XG5cbiAgdGhpcy5Db2xsZWN0aW9uRW5kRXZlbnQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbGxlY3Rpb25FbmRFdmVudCwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIENvbGxlY3Rpb25FbmRFdmVudCgpIHtcbiAgICAgIF9yZWYgPSBDb2xsZWN0aW9uRW5kRXZlbnQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjtcbiAgICB9XG5cbiAgICByZXR1cm4gQ29sbGVjdGlvbkVuZEV2ZW50O1xuXG4gIH0pKHRoaXMuRXZlbnQpO1xuXG4gIHRoaXMuU3RyZWFtU3RhcnRFdmVudCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3RyZWFtU3RhcnRFdmVudCwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFN0cmVhbVN0YXJ0RXZlbnQoc3RhcnRfbWFyaywgZW5kX21hcmssIGV4cGxpY2l0LCB2ZXJzaW9uLCB0YWdzKSB7XG4gICAgICB0aGlzLnN0YXJ0X21hcmsgPSBzdGFydF9tYXJrO1xuICAgICAgdGhpcy5lbmRfbWFyayA9IGVuZF9tYXJrO1xuICAgICAgdGhpcy5leHBsaWNpdCA9IGV4cGxpY2l0O1xuICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgIHRoaXMudGFncyA9IHRhZ3M7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmVhbVN0YXJ0RXZlbnQ7XG5cbiAgfSkodGhpcy5FdmVudCk7XG5cbiAgdGhpcy5TdHJlYW1FbmRFdmVudCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3RyZWFtRW5kRXZlbnQsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBTdHJlYW1FbmRFdmVudCgpIHtcbiAgICAgIF9yZWYxID0gU3RyZWFtRW5kRXZlbnQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjE7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmVhbUVuZEV2ZW50O1xuXG4gIH0pKHRoaXMuRXZlbnQpO1xuXG4gIHRoaXMuRG9jdW1lbnRTdGFydEV2ZW50ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEb2N1bWVudFN0YXJ0RXZlbnQsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBEb2N1bWVudFN0YXJ0RXZlbnQoc3RhcnRfbWFyaywgZW5kX21hcmssIGV4cGxpY2l0LCB2ZXJzaW9uLCB0YWdzKSB7XG4gICAgICB0aGlzLnN0YXJ0X21hcmsgPSBzdGFydF9tYXJrO1xuICAgICAgdGhpcy5lbmRfbWFyayA9IGVuZF9tYXJrO1xuICAgICAgdGhpcy5leHBsaWNpdCA9IGV4cGxpY2l0O1xuICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgIHRoaXMudGFncyA9IHRhZ3M7XG4gICAgfVxuXG4gICAgcmV0dXJuIERvY3VtZW50U3RhcnRFdmVudDtcblxuICB9KSh0aGlzLkV2ZW50KTtcblxuICB0aGlzLkRvY3VtZW50RW5kRXZlbnQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERvY3VtZW50RW5kRXZlbnQsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBEb2N1bWVudEVuZEV2ZW50KHN0YXJ0X21hcmssIGVuZF9tYXJrLCBleHBsaWNpdCkge1xuICAgICAgdGhpcy5zdGFydF9tYXJrID0gc3RhcnRfbWFyaztcbiAgICAgIHRoaXMuZW5kX21hcmsgPSBlbmRfbWFyaztcbiAgICAgIHRoaXMuZXhwbGljaXQgPSBleHBsaWNpdDtcbiAgICB9XG5cbiAgICByZXR1cm4gRG9jdW1lbnRFbmRFdmVudDtcblxuICB9KSh0aGlzLkV2ZW50KTtcblxuICB0aGlzLkFsaWFzRXZlbnQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFsaWFzRXZlbnQsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBBbGlhc0V2ZW50KCkge1xuICAgICAgX3JlZjIgPSBBbGlhc0V2ZW50Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWYyO1xuICAgIH1cblxuICAgIHJldHVybiBBbGlhc0V2ZW50O1xuXG4gIH0pKHRoaXMuTm9kZUV2ZW50KTtcblxuICB0aGlzLlNjYWxhckV2ZW50ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTY2FsYXJFdmVudCwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFNjYWxhckV2ZW50KGFuY2hvciwgdGFnLCBpbXBsaWNpdCwgdmFsdWUsIHN0YXJ0X21hcmssIGVuZF9tYXJrLCBzdHlsZSkge1xuICAgICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgIHRoaXMuaW1wbGljaXQgPSBpbXBsaWNpdDtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuc3RhcnRfbWFyayA9IHN0YXJ0X21hcms7XG4gICAgICB0aGlzLmVuZF9tYXJrID0gZW5kX21hcms7XG4gICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNjYWxhckV2ZW50O1xuXG4gIH0pKHRoaXMuTm9kZUV2ZW50KTtcblxuICB0aGlzLlNlcXVlbmNlU3RhcnRFdmVudCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VxdWVuY2VTdGFydEV2ZW50LCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gU2VxdWVuY2VTdGFydEV2ZW50KCkge1xuICAgICAgX3JlZjMgPSBTZXF1ZW5jZVN0YXJ0RXZlbnQuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjM7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNlcXVlbmNlU3RhcnRFdmVudDtcblxuICB9KSh0aGlzLkNvbGxlY3Rpb25TdGFydEV2ZW50KTtcblxuICB0aGlzLlNlcXVlbmNlRW5kRXZlbnQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlcXVlbmNlRW5kRXZlbnQsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBTZXF1ZW5jZUVuZEV2ZW50KCkge1xuICAgICAgX3JlZjQgPSBTZXF1ZW5jZUVuZEV2ZW50Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY0O1xuICAgIH1cblxuICAgIHJldHVybiBTZXF1ZW5jZUVuZEV2ZW50O1xuXG4gIH0pKHRoaXMuQ29sbGVjdGlvbkVuZEV2ZW50KTtcblxuICB0aGlzLk1hcHBpbmdTdGFydEV2ZW50ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXBwaW5nU3RhcnRFdmVudCwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIE1hcHBpbmdTdGFydEV2ZW50KCkge1xuICAgICAgX3JlZjUgPSBNYXBwaW5nU3RhcnRFdmVudC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmNTtcbiAgICB9XG5cbiAgICByZXR1cm4gTWFwcGluZ1N0YXJ0RXZlbnQ7XG5cbiAgfSkodGhpcy5Db2xsZWN0aW9uU3RhcnRFdmVudCk7XG5cbiAgdGhpcy5NYXBwaW5nRW5kRXZlbnQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hcHBpbmdFbmRFdmVudCwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIE1hcHBpbmdFbmRFdmVudCgpIHtcbiAgICAgIF9yZWY2ID0gTWFwcGluZ0VuZEV2ZW50Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY2O1xuICAgIH1cblxuICAgIHJldHVybiBNYXBwaW5nRW5kRXZlbnQ7XG5cbiAgfSkodGhpcy5Db2xsZWN0aW9uRW5kRXZlbnQpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgTWFya2VkWUFNTEVycm9yLCBub2RlcywgX3JlZixcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfTtcblxuICBNYXJrZWRZQU1MRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9ycycpLk1hcmtlZFlBTUxFcnJvcjtcblxuICBub2RlcyA9IHJlcXVpcmUoJy4vbm9kZXMnKTtcblxuICAvKlxuICBUaGUgVHJhaXRzIHRocm93cyB0aGVzZS5cbiAgKi9cblxuXG4gIHRoaXMuSm9pbkVycm9yID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhKb2luRXJyb3IsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBKb2luRXJyb3IoKSB7XG4gICAgICBfcmVmID0gSm9pbkVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIEpvaW5FcnJvcjtcblxuICB9KShNYXJrZWRZQU1MRXJyb3IpO1xuXG4gIC8qXG4gIFRoZSBKb2luZXIgY2xhc3MgZ3JvdXBzIHJlc291cmNlcyB1bmRlciByZXNvdXJjZSBwcm9wZXJ0eSBhbmQgZ3JvdXBzIG1ldGhvZHMgdW5kZXIgb3BlcmF0aW9ucyBwcm9wZXJ0eVxuICAqL1xuXG5cbiAgdGhpcy5Kb2luZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gSm9pbmVyKCkge31cblxuICAgIEpvaW5lci5wcm90b3R5cGUuam9pbl9yZXNvdXJjZXMgPSBmdW5jdGlvbihub2RlLCBjYWxsKSB7XG4gICAgICB2YXIgcmVzb3VyY2VzLCByZXNvdXJjZXNBcnJheSwgcmVzb3VyY2VzTmFtZSwgcmVzb3VyY2VzVmFsdWUsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGlmIChjYWxsID09IG51bGwpIHtcbiAgICAgICAgY2FsbCA9IDA7XG4gICAgICB9XG4gICAgICByZXNvdXJjZXMgPSBbXTtcbiAgICAgIGlmIChub2RlICE9IG51bGwgPyBub2RlLnZhbHVlIDogdm9pZCAwKSB7XG4gICAgICAgIHJlc291cmNlcyA9IG5vZGUudmFsdWUuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuICAgICAgICAgIHZhciBfcmVmMTtcbiAgICAgICAgICByZXR1cm4gKF9yZWYxID0gY2hpbGROb2RlWzBdKSAhPSBudWxsID8gX3JlZjEudmFsdWUubWF0Y2goL15cXC8vKSA6IHZvaWQgMDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXNvdXJjZXNBcnJheSA9IFtdO1xuICAgICAgaWYgKHJlc291cmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChub2RlICE9IG51bGwgPyBub2RlLnZhbHVlIDogdm9pZCAwKSB7XG4gICAgICAgICAgbm9kZS52YWx1ZSA9IG5vZGUudmFsdWUuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuICFjaGlsZE5vZGVbMF0udmFsdWUubWF0Y2goL15cXC8vKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXNvdXJjZXNOYW1lID0gbmV3IG5vZGVzLlNjYWxhck5vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsICdyZXNvdXJjZXMnLCByZXNvdXJjZXNbMF1bMF0uc3RhcnRfbWFyaywgcmVzb3VyY2VzW3Jlc291cmNlcy5sZW5ndGggLSAxXVsxXS5lbmRfbWFyayk7XG4gICAgICAgIHJlc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHJlc291cmNlKSB7XG4gICAgICAgICAgdmFyIHJlbGF0aXZlVXJpTmFtZSwgcmVsYXRpdmVVcmlWYWx1ZTtcbiAgICAgICAgICByZWxhdGl2ZVVyaU5hbWUgPSBuZXcgbm9kZXMuU2NhbGFyTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywgJ3JlbGF0aXZlVXJpJywgcmVzb3VyY2VbMF0uc3RhcnRfbWFyaywgcmVzb3VyY2VbMV0uZW5kX21hcmspO1xuICAgICAgICAgIHJlbGF0aXZlVXJpVmFsdWUgPSBuZXcgbm9kZXMuU2NhbGFyTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywgcmVzb3VyY2VbMF0udmFsdWUsIHJlc291cmNlWzBdLnN0YXJ0X21hcmssIHJlc291cmNlWzFdLmVuZF9tYXJrKTtcbiAgICAgICAgICBpZiAocmVzb3VyY2VbMV0udGFnID09PSBcInRhZzp5YW1sLm9yZywyMDAyOm51bGxcIikge1xuICAgICAgICAgICAgcmVzb3VyY2VbMV0gPSBuZXcgbm9kZXMuTWFwcGluZ05vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsIFtdLCByZXNvdXJjZVswXS5zdGFydF9tYXJrLCByZXNvdXJjZVsxXS5lbmRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc291cmNlWzFdLnZhbHVlLnB1c2goW3JlbGF0aXZlVXJpTmFtZSwgcmVsYXRpdmVVcmlWYWx1ZV0pO1xuICAgICAgICAgIHJlc291cmNlc0FycmF5LnB1c2gocmVzb3VyY2VbMV0pO1xuICAgICAgICAgIF90aGlzLmpvaW5fbWV0aG9kcyhyZXNvdXJjZVsxXSk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmpvaW5fcmVzb3VyY2VzKHJlc291cmNlWzFdLCArK2NhbGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzb3VyY2VzVmFsdWUgPSBuZXcgbm9kZXMuU2VxdWVuY2VOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLCByZXNvdXJjZXNBcnJheSwgcmVzb3VyY2VzWzBdWzBdLnN0YXJ0X21hcmssIHJlc291cmNlc1tyZXNvdXJjZXMubGVuZ3RoIC0gMV1bMV0uZW5kX21hcmspO1xuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZS5wdXNoKFtyZXNvdXJjZXNOYW1lLCByZXNvdXJjZXNWYWx1ZV0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBKb2luZXIucHJvdG90eXBlLmpvaW5fbWV0aG9kcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBtZXRob2RzLCBtZXRob2RzQXJyYXksIG1ldGhvZHNOYW1lLCBtZXRob2RzVmFsdWUsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIG1ldGhvZHMgPSBbXTtcbiAgICAgIGlmIChub2RlICYmIG5vZGUudmFsdWUpIHtcbiAgICAgICAgbWV0aG9kcyA9IG5vZGUudmFsdWUuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuICAgICAgICAgIHZhciBfcmVmMTtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuaXNIdHRwTWV0aG9kKChfcmVmMSA9IGNoaWxkTm9kZVswXSkgIT0gbnVsbCA/IF9yZWYxLnZhbHVlIDogdm9pZCAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBtZXRob2RzQXJyYXkgPSBbXTtcbiAgICAgIGlmIChtZXRob2RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbm9kZS52YWx1ZSA9IG5vZGUudmFsdWUuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuICAgICAgICAgIHJldHVybiAhX3RoaXMuaXNIdHRwTWV0aG9kKGNoaWxkTm9kZVswXS52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBtZXRob2RzTmFtZSA9IG5ldyBub2Rlcy5TY2FsYXJOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCAnbWV0aG9kcycsIG1ldGhvZHNbMF1bMF0uc3RhcnRfbWFyaywgbWV0aG9kc1ttZXRob2RzLmxlbmd0aCAtIDFdWzFdLmVuZF9tYXJrKTtcbiAgICAgICAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgIHZhciBtZXRob2ROYW1lLCBtZXRob2RWYWx1ZTtcbiAgICAgICAgICBtZXRob2ROYW1lID0gbmV3IG5vZGVzLlNjYWxhck5vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsICdtZXRob2QnLCBtZXRob2RbMF0uc3RhcnRfbWFyaywgbWV0aG9kWzFdLmVuZF9tYXJrKTtcbiAgICAgICAgICBtZXRob2RWYWx1ZSA9IG5ldyBub2Rlcy5TY2FsYXJOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCBtZXRob2RbMF0udmFsdWUsIG1ldGhvZFswXS5zdGFydF9tYXJrLCBtZXRob2RbMV0uZW5kX21hcmspO1xuICAgICAgICAgIGlmIChtZXRob2RbMV0udGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcpIHtcbiAgICAgICAgICAgIG1ldGhvZFsxXSA9IG5ldyBub2Rlcy5NYXBwaW5nTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6bWFwJywgW10sIG1ldGhvZFsxXS5zdGFydF9tYXJrLCBtZXRob2RbMV0uZW5kX21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZXRob2RbMV0udmFsdWUucHVzaChbbWV0aG9kTmFtZSwgbWV0aG9kVmFsdWVdKTtcbiAgICAgICAgICByZXR1cm4gbWV0aG9kc0FycmF5LnB1c2gobWV0aG9kWzFdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1ldGhvZHNWYWx1ZSA9IG5ldyBub2Rlcy5TZXF1ZW5jZU5vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOnNlcScsIG1ldGhvZHNBcnJheSwgbWV0aG9kc1swXVswXS5zdGFydF9tYXJrLCBtZXRob2RzW21ldGhvZHMubGVuZ3RoIC0gMV1bMV0uZW5kX21hcmspO1xuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZS5wdXNoKFttZXRob2RzTmFtZSwgbWV0aG9kc1ZhbHVlXSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBKb2luZXI7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIGNvbXBvc2VyLCBjb25zdHJ1Y3QsIGpvaW5lciwgcGFyc2VyLCBwcm90b2NvbHMsIHJlYWRlciwgcmVzb2x2ZXIsIHNjYW5uZXIsIHNjaGVtYXMsIHNlY3VyaXR5U2NoZW1lcywgdHJhaXRzLCB0cmFuc2Zvcm1hdGlvbnMsIHR5cGVzLCB1dGlsLCB2YWxpZGF0b3I7XG5cbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIHJlYWRlciA9IHJlcXVpcmUoJy4vcmVhZGVyJyk7XG5cbiAgc2Nhbm5lciA9IHJlcXVpcmUoJy4vc2Nhbm5lcicpO1xuXG4gIHBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyJyk7XG5cbiAgY29tcG9zZXIgPSByZXF1aXJlKCcuL2NvbXBvc2VyJyk7XG5cbiAgcmVzb2x2ZXIgPSByZXF1aXJlKCcuL3Jlc29sdmVyJyk7XG5cbiAgY29uc3RydWN0ID0gcmVxdWlyZSgnLi9jb25zdHJ1Y3QnKTtcblxuICB2YWxpZGF0b3IgPSByZXF1aXJlKCcuL3ZhbGlkYXRvcicpO1xuXG4gIGpvaW5lciA9IHJlcXVpcmUoJy4vam9pbmVyJyk7XG5cbiAgdHJhaXRzID0gcmVxdWlyZSgnLi90cmFpdHMnKTtcblxuICB0eXBlcyA9IHJlcXVpcmUoJy4vcmVzb3VyY2VUeXBlcycpO1xuXG4gIHNjaGVtYXMgPSByZXF1aXJlKCcuL3NjaGVtYXMnKTtcblxuICBwcm90b2NvbHMgPSByZXF1aXJlKCcuL3Byb3RvY29scycpO1xuXG4gIHNlY3VyaXR5U2NoZW1lcyA9IHJlcXVpcmUoJy4vc2VjdXJpdHlTY2hlbWVzJyk7XG5cbiAgdHJhbnNmb3JtYXRpb25zID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1hdGlvbnMnKTtcblxuICB0aGlzLm1ha2VfbG9hZGVyID0gZnVuY3Rpb24oUmVhZGVyLCBTY2FubmVyLCBQYXJzZXIsIENvbXBvc2VyLCBSZXNvbHZlciwgVmFsaWRhdG9yLCBSZXNvdXJjZVR5cGVzLCBUcmFpdHMsIFNjaGVtYXMsIFByb3RvY29scywgSm9pbmVyLCBTZWN1cml0eVNjaGVtZXMsIENvbnN0cnVjdG9yLCBUcmFuc2Zvcm1hdGlvbnMpIHtcbiAgICBpZiAoUmVhZGVyID09IG51bGwpIHtcbiAgICAgIFJlYWRlciA9IHJlYWRlci5SZWFkZXI7XG4gICAgfVxuICAgIGlmIChTY2FubmVyID09IG51bGwpIHtcbiAgICAgIFNjYW5uZXIgPSBzY2FubmVyLlNjYW5uZXI7XG4gICAgfVxuICAgIGlmIChQYXJzZXIgPT0gbnVsbCkge1xuICAgICAgUGFyc2VyID0gcGFyc2VyLlBhcnNlcjtcbiAgICB9XG4gICAgaWYgKENvbXBvc2VyID09IG51bGwpIHtcbiAgICAgIENvbXBvc2VyID0gY29tcG9zZXIuQ29tcG9zZXI7XG4gICAgfVxuICAgIGlmIChSZXNvbHZlciA9PSBudWxsKSB7XG4gICAgICBSZXNvbHZlciA9IHJlc29sdmVyLlJlc29sdmVyO1xuICAgIH1cbiAgICBpZiAoVmFsaWRhdG9yID09IG51bGwpIHtcbiAgICAgIFZhbGlkYXRvciA9IHZhbGlkYXRvci5WYWxpZGF0b3I7XG4gICAgfVxuICAgIGlmIChSZXNvdXJjZVR5cGVzID09IG51bGwpIHtcbiAgICAgIFJlc291cmNlVHlwZXMgPSB0eXBlcy5SZXNvdXJjZVR5cGVzO1xuICAgIH1cbiAgICBpZiAoVHJhaXRzID09IG51bGwpIHtcbiAgICAgIFRyYWl0cyA9IHRyYWl0cy5UcmFpdHM7XG4gICAgfVxuICAgIGlmIChTY2hlbWFzID09IG51bGwpIHtcbiAgICAgIFNjaGVtYXMgPSBzY2hlbWFzLlNjaGVtYXM7XG4gICAgfVxuICAgIGlmIChQcm90b2NvbHMgPT0gbnVsbCkge1xuICAgICAgUHJvdG9jb2xzID0gcHJvdG9jb2xzLlByb3RvY29scztcbiAgICB9XG4gICAgaWYgKEpvaW5lciA9PSBudWxsKSB7XG4gICAgICBKb2luZXIgPSBqb2luZXIuSm9pbmVyO1xuICAgIH1cbiAgICBpZiAoU2VjdXJpdHlTY2hlbWVzID09IG51bGwpIHtcbiAgICAgIFNlY3VyaXR5U2NoZW1lcyA9IHNlY3VyaXR5U2NoZW1lcy5TZWN1cml0eVNjaGVtZXM7XG4gICAgfVxuICAgIGlmIChDb25zdHJ1Y3RvciA9PSBudWxsKSB7XG4gICAgICBDb25zdHJ1Y3RvciA9IGNvbnN0cnVjdC5Db25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgaWYgKFRyYW5zZm9ybWF0aW9ucyA9PSBudWxsKSB7XG4gICAgICBUcmFuc2Zvcm1hdGlvbnMgPSB0cmFuc2Zvcm1hdGlvbnMuVHJhbnNmb3JtYXRpb25zO1xuICAgIH1cbiAgICByZXR1cm4gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvbXBvbmVudCwgY29tcG9uZW50cztcblxuICAgICAgY29tcG9uZW50cyA9IFtSZWFkZXIsIFNjYW5uZXIsIENvbXBvc2VyLCBUcmFuc2Zvcm1hdGlvbnMsIFBhcnNlciwgUmVzb2x2ZXIsIFZhbGlkYXRvciwgVHJhaXRzLCBSZXNvdXJjZVR5cGVzLCBTY2hlbWFzLCBQcm90b2NvbHMsIEpvaW5lciwgQ29uc3RydWN0b3IsIFNlY3VyaXR5U2NoZW1lc107XG5cbiAgICAgIHV0aWwuZXh0ZW5kLmFwcGx5KHV0aWwsIFtfQ2xhc3MucHJvdG90eXBlXS5jb25jYXQoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGNvbXBvbmVudHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzW19pXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKGNvbXBvbmVudC5wcm90b3R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pKCkpKTtcblxuICAgICAgZnVuY3Rpb24gX0NsYXNzKHN0cmVhbSwgbG9jYXRpb24sIHNldHRpbmdzLCBwYXJlbnQpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudCAhPSBudWxsID8gcGFyZW50IDogbnVsbDtcbiAgICAgICAgY29tcG9uZW50c1swXS5jYWxsKHRoaXMsIHN0cmVhbSwgbG9jYXRpb24pO1xuICAgICAgICBjb21wb25lbnRzWzFdLmNhbGwodGhpcywgc2V0dGluZ3MpO1xuICAgICAgICBjb21wb25lbnRzWzJdLmNhbGwodGhpcywgc2V0dGluZ3MpO1xuICAgICAgICBjb21wb25lbnRzWzNdLmNhbGwodGhpcywgc2V0dGluZ3MpO1xuICAgICAgICBfcmVmID0gY29tcG9uZW50cy5zbGljZSg0KTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgY29tcG9uZW50ID0gX3JlZltfaV07XG4gICAgICAgICAgY29tcG9uZW50LmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9DbGFzcztcblxuICAgIH0pKCk7XG4gIH07XG5cbiAgdGhpcy5Mb2FkZXIgPSB0aGlzLm1ha2VfbG9hZGVyKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBNYXJrZWRZQU1MRXJyb3IsIHVuaXF1ZV9pZCwgX3JlZiwgX3JlZjEsIF9yZWYyLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9O1xuXG4gIE1hcmtlZFlBTUxFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3JzJykuTWFya2VkWUFNTEVycm9yO1xuXG4gIHVuaXF1ZV9pZCA9IDA7XG5cbiAgdGhpcy5BcHBsaWNhdGlvbkVycm9yID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcHBsaWNhdGlvbkVycm9yLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gQXBwbGljYXRpb25FcnJvcigpIHtcbiAgICAgIF9yZWYgPSBBcHBsaWNhdGlvbkVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIEFwcGxpY2F0aW9uRXJyb3I7XG5cbiAgfSkoTWFya2VkWUFNTEVycm9yKTtcblxuICB0aGlzLk5vZGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTm9kZSh0YWcsIHZhbHVlLCBzdGFydF9tYXJrLCBlbmRfbWFyaykge1xuICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YXJ0X21hcmsgPSBzdGFydF9tYXJrO1xuICAgICAgdGhpcy5lbmRfbWFyayA9IGVuZF9tYXJrO1xuICAgICAgdGhpcy51bmlxdWVfaWQgPSBcIm5vZGVfXCIgKyAodW5pcXVlX2lkKyspO1xuICAgIH1cblxuICAgIE5vZGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGVtcDtcbiAgICAgIHRlbXAgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnRhZywgdGhpcy52YWx1ZSwgdGhpcy5zdGFydF9tYXJrLCB0aGlzLmVuZF9tYXJrKTtcbiAgICAgIHJldHVybiB0ZW1wO1xuICAgIH07XG5cbiAgICByZXR1cm4gTm9kZTtcblxuICB9KSgpO1xuXG4gIHRoaXMuU2NhbGFyTm9kZSA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2NhbGFyTm9kZSwgX3N1cGVyKTtcblxuICAgIFNjYWxhck5vZGUucHJvdG90eXBlLmlkID0gJ3NjYWxhcic7XG5cbiAgICBmdW5jdGlvbiBTY2FsYXJOb2RlKHRhZywgdmFsdWUsIHN0YXJ0X21hcmssIGVuZF9tYXJrLCBzdHlsZSkge1xuICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YXJ0X21hcmsgPSBzdGFydF9tYXJrO1xuICAgICAgdGhpcy5lbmRfbWFyayA9IGVuZF9tYXJrO1xuICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgICAgU2NhbGFyTm9kZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBTY2FsYXJOb2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRlbXA7XG4gICAgICB0ZW1wID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy50YWcsIHRoaXMudmFsdWUsIHRoaXMuc3RhcnRfbWFyaywgdGhpcy5lbmRfbWFyaywgdGhpcy5zdHlsZSk7XG4gICAgICByZXR1cm4gdGVtcDtcbiAgICB9O1xuXG4gICAgU2NhbGFyTm9kZS5wcm90b3R5cGUuY2xvbmVSZW1vdmVJcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgICB9O1xuXG4gICAgU2NhbGFyTm9kZS5wcm90b3R5cGUuY29tYmluZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmICh0aGlzLnRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnICYmIG5vZGUudGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6bWFwJykge1xuICAgICAgICB0aGlzLnZhbHVlID0gbmV3IGV4cG9ydHMuTWFwcGluZ05vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsIFtdLCBub2RlLnN0YXJ0X21hcmssIG5vZGUuZW5kX21hcmspO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5jb21iaW5lKG5vZGUpO1xuICAgICAgfSBlbHNlIGlmICghKG5vZGUgaW5zdGFuY2VvZiBleHBvcnRzLlNjYWxhck5vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkFwcGxpY2F0aW9uRXJyb3IoJ3doaWxlIGFwcGx5aW5nIG5vZGUnLCBudWxsLCAnZGlmZmVyZW50IFlBTUwgc3RydWN0dXJlcycsIHRoaXMuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgfTtcblxuICAgIFNjYWxhck5vZGUucHJvdG90eXBlLnJlbW92ZV9xdWVzdGlvbl9tYXJrX3Byb3BlcnRpZXMgPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgcmV0dXJuIFNjYWxhck5vZGU7XG5cbiAgfSkodGhpcy5Ob2RlKTtcblxuICB0aGlzLkNvbGxlY3Rpb25Ob2RlID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb2xsZWN0aW9uTm9kZSwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIENvbGxlY3Rpb25Ob2RlKHRhZywgdmFsdWUsIHN0YXJ0X21hcmssIGVuZF9tYXJrLCBmbG93X3N0eWxlKSB7XG4gICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuc3RhcnRfbWFyayA9IHN0YXJ0X21hcms7XG4gICAgICB0aGlzLmVuZF9tYXJrID0gZW5kX21hcms7XG4gICAgICB0aGlzLmZsb3dfc3R5bGUgPSBmbG93X3N0eWxlO1xuICAgICAgQ29sbGVjdGlvbk5vZGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIENvbGxlY3Rpb25Ob2RlO1xuXG4gIH0pKHRoaXMuTm9kZSk7XG5cbiAgdGhpcy5TZXF1ZW5jZU5vZGUgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlcXVlbmNlTm9kZSwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFNlcXVlbmNlTm9kZSgpIHtcbiAgICAgIF9yZWYxID0gU2VxdWVuY2VOb2RlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWYxO1xuICAgIH1cblxuICAgIFNlcXVlbmNlTm9kZS5wcm90b3R5cGUuaWQgPSAnc2VxdWVuY2UnO1xuXG4gICAgU2VxdWVuY2VOb2RlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGl0ZW0sIGl0ZW1zLCB0ZW1wLCB2YWx1ZSwgX2ksIF9sZW4sIF9yZWYyO1xuICAgICAgaXRlbXMgPSBbXTtcbiAgICAgIF9yZWYyID0gdGhpcy52YWx1ZTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjIubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgaXRlbSA9IF9yZWYyW19pXTtcbiAgICAgICAgdmFsdWUgPSBpdGVtLmNsb25lKCk7XG4gICAgICAgIGl0ZW1zLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgICAgdGVtcCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMudGFnLCBpdGVtcywgdGhpcy5zdGFydF9tYXJrLCB0aGlzLmVuZF9tYXJrLCB0aGlzLmZsb3dfc3R5bGUpO1xuICAgICAgcmV0dXJuIHRlbXA7XG4gICAgfTtcblxuICAgIFNlcXVlbmNlTm9kZS5wcm90b3R5cGUuY2xvbmVSZW1vdmVJcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgICB9O1xuXG4gICAgU2VxdWVuY2VOb2RlLnByb3RvdHlwZS5jb21iaW5lID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHByb3BlcnR5LCB2YWx1ZSwgX2ksIF9sZW4sIF9yZWYyLCBfcmVzdWx0cztcbiAgICAgIGlmICghKG5vZGUgaW5zdGFuY2VvZiBleHBvcnRzLlNlcXVlbmNlTm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuQXBwbGljYXRpb25FcnJvcignd2hpbGUgYXBwbHlpbmcgbm9kZScsIG51bGwsICdkaWZmZXJlbnQgWUFNTCBzdHJ1Y3R1cmVzJywgdGhpcy5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIF9yZWYyID0gbm9kZS52YWx1ZTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYyLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHByb3BlcnR5ID0gX3JlZjJbX2ldO1xuICAgICAgICB2YWx1ZSA9IHByb3BlcnR5LmNsb25lKCk7XG4gICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy52YWx1ZS5wdXNoKHZhbHVlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFNlcXVlbmNlTm9kZS5wcm90b3R5cGUucmVtb3ZlX3F1ZXN0aW9uX21hcmtfcHJvcGVydGllcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGl0ZW0sIF9pLCBfbGVuLCBfcmVmMiwgX3Jlc3VsdHM7XG4gICAgICBfcmVmMiA9IHRoaXMudmFsdWU7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBpdGVtID0gX3JlZjJbX2ldO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKGl0ZW0ucmVtb3ZlX3F1ZXN0aW9uX21hcmtfcHJvcGVydGllcygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNlcXVlbmNlTm9kZTtcblxuICB9KSh0aGlzLkNvbGxlY3Rpb25Ob2RlKTtcblxuICB0aGlzLk1hcHBpbmdOb2RlID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXBwaW5nTm9kZSwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIE1hcHBpbmdOb2RlKCkge1xuICAgICAgX3JlZjIgPSBNYXBwaW5nTm9kZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmMjtcbiAgICB9XG5cbiAgICBNYXBwaW5nTm9kZS5wcm90b3R5cGUuaWQgPSAnbWFwcGluZyc7XG5cbiAgICBNYXBwaW5nTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuYW1lLCBwcm9wZXJ0aWVzLCBwcm9wZXJ0eSwgdGVtcCwgdmFsdWUsIF9pLCBfbGVuLCBfcmVmMztcbiAgICAgIHByb3BlcnRpZXMgPSBbXTtcbiAgICAgIF9yZWYzID0gdGhpcy52YWx1ZTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcHJvcGVydHkgPSBfcmVmM1tfaV07XG4gICAgICAgIG5hbWUgPSBwcm9wZXJ0eVswXS5jbG9uZSgpO1xuICAgICAgICB2YWx1ZSA9IHByb3BlcnR5WzFdLmNsb25lKCk7XG4gICAgICAgIHByb3BlcnRpZXMucHVzaChbbmFtZSwgdmFsdWVdKTtcbiAgICAgIH1cbiAgICAgIHRlbXAgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnRhZywgcHJvcGVydGllcywgdGhpcy5zdGFydF9tYXJrLCB0aGlzLmVuZF9tYXJrLCB0aGlzLmZsb3dfc3R5bGUpO1xuICAgICAgcmV0dXJuIHRlbXA7XG4gICAgfTtcblxuICAgIE1hcHBpbmdOb2RlLnByb3RvdHlwZS5jbG9uZVJlbW92ZUlzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmFtZSwgcHJvcGVydGllcywgcHJvcGVydHksIHRlbXAsIHZhbHVlLCBfaSwgX2xlbiwgX3JlZjMsIF9yZWY0O1xuICAgICAgcHJvcGVydGllcyA9IFtdO1xuICAgICAgX3JlZjMgPSB0aGlzLnZhbHVlO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwcm9wZXJ0eSA9IF9yZWYzW19pXTtcbiAgICAgICAgbmFtZSA9IHByb3BlcnR5WzBdLmNsb25lUmVtb3ZlSXMoKTtcbiAgICAgICAgdmFsdWUgPSBwcm9wZXJ0eVsxXS5jbG9uZVJlbW92ZUlzKCk7XG4gICAgICAgIGlmICgoX3JlZjQgPSBuYW1lLnZhbHVlKSAhPT0gJ2lzJykge1xuICAgICAgICAgIHByb3BlcnRpZXMucHVzaChbbmFtZSwgdmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGVtcCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMudGFnLCBwcm9wZXJ0aWVzLCB0aGlzLnN0YXJ0X21hcmssIHRoaXMuZW5kX21hcmssIHRoaXMuZmxvd19zdHlsZSk7XG4gICAgICByZXR1cm4gdGVtcDtcbiAgICB9O1xuXG4gICAgTWFwcGluZ05vZGUucHJvdG90eXBlLmNsb25lRm9yVHJhaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuYW1lLCBwcm9wZXJ0aWVzLCBwcm9wZXJ0eSwgdGVtcCwgdmFsdWUsIF9pLCBfbGVuLCBfcmVmMywgX3JlZjQ7XG4gICAgICBwcm9wZXJ0aWVzID0gW107XG4gICAgICBfcmVmMyA9IHRoaXMudmFsdWU7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHByb3BlcnR5ID0gX3JlZjNbX2ldO1xuICAgICAgICBuYW1lID0gcHJvcGVydHlbMF0uY2xvbmUoKTtcbiAgICAgICAgdmFsdWUgPSBwcm9wZXJ0eVsxXS5jbG9uZSgpO1xuICAgICAgICBpZiAoKF9yZWY0ID0gbmFtZS52YWx1ZSkgIT09ICd1c2FnZScgJiYgX3JlZjQgIT09ICdkaXNwbGF5TmFtZScpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRlbXAgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnRhZywgcHJvcGVydGllcywgdGhpcy5zdGFydF9tYXJrLCB0aGlzLmVuZF9tYXJrLCB0aGlzLmZsb3dfc3R5bGUpO1xuICAgICAgcmV0dXJuIHRlbXA7XG4gICAgfTtcblxuICAgIE1hcHBpbmdOb2RlLnByb3RvdHlwZS5jbG9uZUZvclJlc291cmNlVHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5hbWUsIHByb3BlcnRpZXMsIHByb3BlcnR5LCB0ZW1wLCB2YWx1ZSwgX2ksIF9sZW4sIF9yZWYzLCBfcmVmNDtcbiAgICAgIHByb3BlcnRpZXMgPSBbXTtcbiAgICAgIF9yZWYzID0gdGhpcy52YWx1ZTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcHJvcGVydHkgPSBfcmVmM1tfaV07XG4gICAgICAgIG5hbWUgPSBwcm9wZXJ0eVswXS5jbG9uZVJlbW92ZUlzKCk7XG4gICAgICAgIHZhbHVlID0gcHJvcGVydHlbMV0uY2xvbmVSZW1vdmVJcygpO1xuICAgICAgICBpZiAoKF9yZWY0ID0gbmFtZS52YWx1ZSkgIT09ICdpcycgJiYgX3JlZjQgIT09ICd0eXBlJyAmJiBfcmVmNCAhPT0gJ3VzYWdlJyAmJiBfcmVmNCAhPT0gJ2Rpc3BsYXlOYW1lJykge1xuICAgICAgICAgIHByb3BlcnRpZXMucHVzaChbbmFtZSwgdmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGVtcCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMudGFnLCBwcm9wZXJ0aWVzLCB0aGlzLnN0YXJ0X21hcmssIHRoaXMuZW5kX21hcmssIHRoaXMuZmxvd19zdHlsZSk7XG4gICAgICByZXR1cm4gdGVtcDtcbiAgICB9O1xuXG4gICAgTWFwcGluZ05vZGUucHJvdG90eXBlLmNvbWJpbmUgPSBmdW5jdGlvbihyZXNvdXJjZU5vZGUpIHtcbiAgICAgIHZhciBuYW1lLCBub2RlX2hhc19wcm9wZXJ0eSwgbm9uTnVsbE5vZGUsIG93bk5vZGVQcm9wZXJ0eSwgb3duTm9kZVByb3BlcnR5TmFtZSwgcmVzb3VyY2VQcm9wZXJ0eSwgX2ksIF9sZW4sIF9yZWYzLCBfcmVzdWx0cztcbiAgICAgIGlmIChyZXNvdXJjZU5vZGUudGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcpIHtcbiAgICAgICAgcmVzb3VyY2VOb2RlID0gbmV3IGV4cG9ydHMuTWFwcGluZ05vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsIFtdLCByZXNvdXJjZU5vZGUuc3RhcnRfbWFyaywgcmVzb3VyY2VOb2RlLmVuZF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc291cmNlTm9kZSBpbnN0YW5jZW9mIGV4cG9ydHMuTWFwcGluZ05vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkFwcGxpY2F0aW9uRXJyb3IoJ3doaWxlIGFwcGx5aW5nIG5vZGUnLCBudWxsLCAnZGlmZmVyZW50IFlBTUwgc3RydWN0dXJlcycsIHRoaXMuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBfcmVmMyA9IHJlc291cmNlTm9kZS52YWx1ZTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHJlc291cmNlUHJvcGVydHkgPSBfcmVmM1tfaV07XG4gICAgICAgIG5hbWUgPSByZXNvdXJjZVByb3BlcnR5WzBdLnZhbHVlO1xuICAgICAgICBub2RlX2hhc19wcm9wZXJ0eSA9IHRoaXMudmFsdWUuc29tZShmdW5jdGlvbihzb21lUHJvcGVydHkpIHtcbiAgICAgICAgICByZXR1cm4gKHNvbWVQcm9wZXJ0eVswXS52YWx1ZSA9PT0gbmFtZSkgfHwgKChzb21lUHJvcGVydHlbMF0udmFsdWUgKyAnPycpID09PSBuYW1lKSB8fCAoc29tZVByb3BlcnR5WzBdLnZhbHVlID09PSAobmFtZSArICc/JykpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5vZGVfaGFzX3Byb3BlcnR5KSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgX2osIF9sZW4xLCBfcmVmNCwgX3Jlc3VsdHMxO1xuICAgICAgICAgICAgX3JlZjQgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgX3Jlc3VsdHMxID0gW107XG4gICAgICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmNC5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICAgICAgb3duTm9kZVByb3BlcnR5ID0gX3JlZjRbX2pdO1xuICAgICAgICAgICAgICBvd25Ob2RlUHJvcGVydHlOYW1lID0gb3duTm9kZVByb3BlcnR5WzBdLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoKG93bk5vZGVQcm9wZXJ0eU5hbWUgPT09IG5hbWUpIHx8ICgob3duTm9kZVByb3BlcnR5TmFtZSArICc/JykgPT09IG5hbWUpIHx8IChvd25Ob2RlUHJvcGVydHlOYW1lID09PSAobmFtZSArICc/JykpKSB7XG4gICAgICAgICAgICAgICAgaWYgKChvd25Ob2RlUHJvcGVydHlbMV0udGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcpICYmIChyZXNvdXJjZVByb3BlcnR5WzFdLnRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcpKSB7XG4gICAgICAgICAgICAgICAgICBub25OdWxsTm9kZSA9IG5ldyBleHBvcnRzLk1hcHBpbmdOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLCBbXSwgb3duTm9kZVByb3BlcnR5WzFdLnN0YXJ0X21hcmssIG93bk5vZGVQcm9wZXJ0eVsxXS5lbmRfbWFyayk7XG4gICAgICAgICAgICAgICAgICBvd25Ob2RlUHJvcGVydHlbMV0gPSBub25OdWxsTm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3duTm9kZVByb3BlcnR5WzFdLmNvbWJpbmUocmVzb3VyY2VQcm9wZXJ0eVsxXSk7XG4gICAgICAgICAgICAgICAgaWYgKCEoKG93bk5vZGVQcm9wZXJ0eVswXS52YWx1ZS5zbGljZSgtMSkgPT09ICc/JykgJiYgKHJlc291cmNlUHJvcGVydHlbMF0udmFsdWUuc2xpY2UoLTEpID09PSAnPycpKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKG93bk5vZGVQcm9wZXJ0eVswXS52YWx1ZS5zbGljZSgtMSkgPT09ICc/Jykge1xuICAgICAgICAgICAgICAgICAgICBfcmVzdWx0czEucHVzaChvd25Ob2RlUHJvcGVydHlbMF0udmFsdWUgPSBvd25Ob2RlUHJvcGVydHlbMF0udmFsdWUuc2xpY2UoMCwgLTEpKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9yZXN1bHRzMS5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIF9yZXN1bHRzMS5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9yZXN1bHRzMS5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgICAgICAgfSkuY2FsbCh0aGlzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLnZhbHVlLnB1c2goW3Jlc291cmNlUHJvcGVydHlbMF0uY2xvbmUoKSwgcmVzb3VyY2VQcm9wZXJ0eVsxXS5jbG9uZSgpXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIE1hcHBpbmdOb2RlLnByb3RvdHlwZS5yZW1vdmVfcXVlc3Rpb25fbWFya19wcm9wZXJ0aWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcHJvcGVydHksIF9pLCBfbGVuLCBfcmVmMywgX3Jlc3VsdHM7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5maWx0ZXIoZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5WzBdLnZhbHVlLnNsaWNlKC0xKSAhPT0gJz8nO1xuICAgICAgfSk7XG4gICAgICBfcmVmMyA9IHRoaXMudmFsdWU7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwcm9wZXJ0eSA9IF9yZWYzW19pXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChwcm9wZXJ0eVsxXS5yZW1vdmVfcXVlc3Rpb25fbWFya19wcm9wZXJ0aWVzKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICByZXR1cm4gTWFwcGluZ05vZGU7XG5cbiAgfSkodGhpcy5Db2xsZWN0aW9uTm9kZSk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBNYXJrZWRZQU1MRXJyb3IsIGV2ZW50cywgdG9rZW5zLCBfcmVmLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIF9fc2xpY2UgPSBbXS5zbGljZTtcblxuICBldmVudHMgPSByZXF1aXJlKCcuL2V2ZW50cycpO1xuXG4gIE1hcmtlZFlBTUxFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3JzJykuTWFya2VkWUFNTEVycm9yO1xuXG4gIHRva2VucyA9IHJlcXVpcmUoJy4vdG9rZW5zJyk7XG5cbiAgdGhpcy5QYXJzZXJFcnJvciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFyc2VyRXJyb3IsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBQYXJzZXJFcnJvcigpIHtcbiAgICAgIF9yZWYgPSBQYXJzZXJFcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmO1xuICAgIH1cblxuICAgIHJldHVybiBQYXJzZXJFcnJvcjtcblxuICB9KShNYXJrZWRZQU1MRXJyb3IpO1xuXG4gIHRoaXMuUGFyc2VyID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBERUZBVUxUX1RBR1M7XG5cbiAgICBERUZBVUxUX1RBR1MgPSB7XG4gICAgICAnISc6ICchJyxcbiAgICAgICchISc6ICd0YWc6eWFtbC5vcmcsMjAwMjonXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFBhcnNlcigpIHtcbiAgICAgIHRoaXMuY3VycmVudF9ldmVudCA9IG51bGw7XG4gICAgICB0aGlzLnlhbWxfdmVyc2lvbiA9IG51bGw7XG4gICAgICB0aGlzLnRhZ19oYW5kbGVzID0ge307XG4gICAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgICAgdGhpcy5tYXJrcyA9IFtdO1xuICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9zdHJlYW1fc3RhcnQnO1xuICAgIH1cblxuICAgIC8qXG4gICAgUmVzZXQgdGhlIHN0YXRlIGF0dHJpYnV0ZXMuXG4gICAgKi9cblxuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgIH07XG5cbiAgICAvKlxuICAgIENoZWNrIHRoZSB0eXBlIG9mIHRoZSBuZXh0IGV2ZW50LlxuICAgICovXG5cblxuICAgIFBhcnNlci5wcm90b3R5cGUuY2hlY2tfZXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaG9pY2UsIGNob2ljZXMsIF9pLCBfbGVuO1xuICAgICAgY2hvaWNlcyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgICBpZiAodGhpcy5jdXJyZW50X2V2ZW50ID09PSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRfZXZlbnQgPSB0aGlzW3RoaXMuc3RhdGVdKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRfZXZlbnQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGNob2ljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBjaG9pY2VzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgY2hvaWNlID0gY2hvaWNlc1tfaV07XG4gICAgICAgICAgaWYgKHRoaXMuY3VycmVudF9ldmVudCBpbnN0YW5jZW9mIGNob2ljZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qXG4gICAgR2V0IHRoZSBuZXh0IGV2ZW50LlxuICAgICovXG5cblxuICAgIFBhcnNlci5wcm90b3R5cGUucGVla19ldmVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudF9ldmVudCA9PT0gbnVsbCAmJiAodGhpcy5zdGF0ZSAhPSBudWxsKSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRfZXZlbnQgPSB0aGlzW3RoaXMuc3RhdGVdKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50X2V2ZW50O1xuICAgIH07XG5cbiAgICAvKlxuICAgIEdldCB0aGUgZXZlbnQgYW5kIHByb2NlZWQgZnVydGhlci5cbiAgICAqL1xuXG5cbiAgICBQYXJzZXIucHJvdG90eXBlLmdldF9ldmVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGV2ZW50O1xuICAgICAgaWYgKHRoaXMuY3VycmVudF9ldmVudCA9PT0gbnVsbCAmJiAodGhpcy5zdGF0ZSAhPSBudWxsKSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRfZXZlbnQgPSB0aGlzW3RoaXMuc3RhdGVdKCk7XG4gICAgICB9XG4gICAgICBldmVudCA9IHRoaXMuY3VycmVudF9ldmVudDtcbiAgICAgIHRoaXMuY3VycmVudF9ldmVudCA9IG51bGw7XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUGFyc2UgdGhlIHN0cmVhbSBzdGFydC5cbiAgICAqL1xuXG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX3N0cmVhbV9zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGV2ZW50LCB0b2tlbjtcbiAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5TdHJlYW1TdGFydEV2ZW50KHRva2VuLnN0YXJ0X21hcmssIHRva2VuLmVuZF9tYXJrKTtcbiAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfaW1wbGljaXRfZG9jdW1lbnRfc3RhcnQnO1xuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG5cbiAgICAvKlxuICAgIFBhcnNlIGFuIGltcGxpY2l0IGRvY3VtZW50LlxuICAgICovXG5cblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfaW1wbGljaXRfZG9jdW1lbnRfc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbmRfbWFyaywgZXZlbnQsIHN0YXJ0X21hcmssIHRva2VuO1xuICAgICAgaWYgKCF0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5EaXJlY3RpdmVUb2tlbiwgdG9rZW5zLkRvY3VtZW50U3RhcnRUb2tlbiwgdG9rZW5zLlN0cmVhbUVuZFRva2VuKSkge1xuICAgICAgICB0aGlzLnRhZ19oYW5kbGVzID0gREVGQVVMVF9UQUdTO1xuICAgICAgICB0b2tlbiA9IHRoaXMucGVla190b2tlbigpO1xuICAgICAgICBzdGFydF9tYXJrID0gZW5kX21hcmsgPSB0b2tlbi5zdGFydF9tYXJrO1xuICAgICAgICBldmVudCA9IG5ldyBldmVudHMuRG9jdW1lbnRTdGFydEV2ZW50KHN0YXJ0X21hcmssIGVuZF9tYXJrLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc3RhdGVzLnB1c2goJ3BhcnNlX2RvY3VtZW50X2VuZCcpO1xuICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Jsb2NrX25vZGUnO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZV9kb2N1bWVudF9zdGFydCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIFBhcnNlIGFuIGV4cGxpY2l0IGRvY3VtZW50LlxuICAgICovXG5cblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfZG9jdW1lbnRfc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbmRfbWFyaywgZXZlbnQsIHN0YXJ0X21hcmssIHRhZ3MsIHRva2VuLCB2ZXJzaW9uLCBfcmVmMTtcbiAgICAgIHdoaWxlICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5Eb2N1bWVudEVuZFRva2VuKSkge1xuICAgICAgICB0aGlzLmdldF90b2tlbigpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5TdHJlYW1FbmRUb2tlbikpIHtcbiAgICAgICAgc3RhcnRfbWFyayA9IHRoaXMucGVla190b2tlbigpLnN0YXJ0X21hcms7XG4gICAgICAgIF9yZWYxID0gdGhpcy5wcm9jZXNzX2RpcmVjdGl2ZXMoKSwgdmVyc2lvbiA9IF9yZWYxWzBdLCB0YWdzID0gX3JlZjFbMV07XG4gICAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuRG9jdW1lbnRTdGFydFRva2VuKSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlBhcnNlckVycm9yKFwiZXhwZWN0ZWQgJzxkb2N1bWVudCBzdGFydD4nLCBidXQgZm91bmQgXCIgKyAodGhpcy5wZWVrX3Rva2VuKCkuaWQpLCB0aGlzLnBlZWtfdG9rZW4oKS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgIGVuZF9tYXJrID0gdG9rZW4uZW5kX21hcms7XG4gICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5Eb2N1bWVudFN0YXJ0RXZlbnQoc3RhcnRfbWFyaywgZW5kX21hcmssIHRydWUsIHZlcnNpb24sIHRhZ3MpO1xuICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKCdwYXJzZV9kb2N1bWVudF9lbmQnKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9kb2N1bWVudF9jb250ZW50JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLlN0cmVhbUVuZEV2ZW50KHRva2VuLnN0YXJ0X21hcmssIHRva2VuLmVuZF9tYXJrKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzZXJ0aW9uIGVycm9yLCBzdGF0ZXMgc2hvdWxkIGJlIGVtcHR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWFya3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NlcnRpb24gZXJyb3IsIG1hcmtzIHNob3VsZCBiZSBlbXB0eScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG5cbiAgICAvKlxuICAgIFBhcnNlIHRoZSBkb2N1bWVudCBlbmQuXG4gICAgKi9cblxuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9kb2N1bWVudF9lbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbmRfbWFyaywgZXZlbnQsIGV4cGxpY2l0LCBzdGFydF9tYXJrLCB0b2tlbjtcbiAgICAgIHRva2VuID0gdGhpcy5wZWVrX3Rva2VuKCk7XG4gICAgICBzdGFydF9tYXJrID0gZW5kX21hcmsgPSB0b2tlbi5zdGFydF9tYXJrO1xuICAgICAgZXhwbGljaXQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5Eb2N1bWVudEVuZFRva2VuKSkge1xuICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgIGVuZF9tYXJrID0gdG9rZW4uZW5kX21hcms7XG4gICAgICAgIGV4cGxpY2l0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5Eb2N1bWVudEVuZEV2ZW50KHN0YXJ0X21hcmssIGVuZF9tYXJrLCBleHBsaWNpdCk7XG4gICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2RvY3VtZW50X3N0YXJ0JztcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9kb2N1bWVudF9jb250ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZXZlbnQ7XG4gICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuRGlyZWN0aXZlVG9rZW4sIHRva2Vucy5Eb2N1bWVudFN0YXJ0VG9rZW4sIHRva2Vucy5Eb2N1bWVudEVuZFRva2VuLCB0b2tlbnMuU3RyZWFtRW5kVG9rZW4pKSB7XG4gICAgICAgIGV2ZW50ID0gdGhpcy5wcm9jZXNzX2VtcHR5X3NjYWxhcih0aGlzLnBlZWtfdG9rZW4oKS5zdGFydF9tYXJrKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzLnBvcCgpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZV9ibG9ja19ub2RlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucHJvY2Vzc19kaXJlY3RpdmVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaGFuZGxlLCBtYWpvciwgbWlub3IsIHByZWZpeCwgdGFnX2hhbmRsZXNfY29weSwgdG9rZW4sIHZhbHVlLCBfcmVmMSwgX3JlZjIsIF9yZWYzO1xuICAgICAgdGhpcy55YW1sX3ZlcnNpb24gPSBudWxsO1xuICAgICAgdGhpcy50YWdfaGFuZGxlcyA9IHt9O1xuICAgICAgd2hpbGUgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkRpcmVjdGl2ZVRva2VuKSkge1xuICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgIGlmICh0b2tlbi5uYW1lID09PSAnWUFNTCcpIHtcbiAgICAgICAgICBpZiAodGhpcy55YW1sX3ZlcnNpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlBhcnNlckVycm9yKG51bGwsIG51bGwsICdmb3VuZCBkdXBsaWNhdGUgWUFNTCBkaXJlY3RpdmUnLCB0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3JlZjEgPSB0b2tlbi52YWx1ZSwgbWFqb3IgPSBfcmVmMVswXSwgbWlub3IgPSBfcmVmMVsxXTtcbiAgICAgICAgICBpZiAobWFqb3IgIT09IDEgfHwgbWlub3IgIT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlBhcnNlckVycm9yKG51bGwsIG51bGwsICdmb3VuZCBpbmNvbXBhdGlibGUgWUFNTCBkb2N1bWVudCAodmVyc2lvbiAxLjIgaXMgcmVxdWlyZWQpJywgdG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMueWFtbF92ZXJzaW9uID0gdG9rZW4udmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW4ubmFtZSA9PT0gJ1RBRycpIHtcbiAgICAgICAgICBfcmVmMiA9IHRva2VuLnZhbHVlLCBoYW5kbGUgPSBfcmVmMlswXSwgcHJlZml4ID0gX3JlZjJbMV07XG4gICAgICAgICAgaWYgKGhhbmRsZSBpbiB0aGlzLnRhZ19oYW5kbGVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5QYXJzZXJFcnJvcihudWxsLCBudWxsLCBcImR1cGxpY2F0ZSB0YWcgaGFuZGxlIFwiICsgaGFuZGxlLCB0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy50YWdfaGFuZGxlc1toYW5kbGVdID0gcHJlZml4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0YWdfaGFuZGxlc19jb3B5ID0gbnVsbDtcbiAgICAgIF9yZWYzID0gdGhpcy50YWdfaGFuZGxlcztcbiAgICAgIGZvciAoaGFuZGxlIGluIF9yZWYzKSB7XG4gICAgICAgIGlmICghX19oYXNQcm9wLmNhbGwoX3JlZjMsIGhhbmRsZSkpIGNvbnRpbnVlO1xuICAgICAgICBwcmVmaXggPSBfcmVmM1toYW5kbGVdO1xuICAgICAgICBpZiAodGFnX2hhbmRsZXNfY29weSA9PSBudWxsKSB7XG4gICAgICAgICAgdGFnX2hhbmRsZXNfY29weSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRhZ19oYW5kbGVzX2NvcHlbaGFuZGxlXSA9IHByZWZpeDtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gW3RoaXMueWFtbF92ZXJzaW9uLCB0YWdfaGFuZGxlc19jb3B5XTtcbiAgICAgIGZvciAoaGFuZGxlIGluIERFRkFVTFRfVEFHUykge1xuICAgICAgICBpZiAoIV9faGFzUHJvcC5jYWxsKERFRkFVTFRfVEFHUywgaGFuZGxlKSkgY29udGludWU7XG4gICAgICAgIHByZWZpeCA9IERFRkFVTFRfVEFHU1toYW5kbGVdO1xuICAgICAgICBpZiAoIShwcmVmaXggaW4gdGhpcy50YWdfaGFuZGxlcykpIHtcbiAgICAgICAgICB0aGlzLnRhZ19oYW5kbGVzW2hhbmRsZV0gPSBwcmVmaXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9ibG9ja19ub2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZV9ub2RlKHRydWUpO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2Zsb3dfbm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2Vfbm9kZSgpO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2Jsb2NrX25vZGVfb3JfaW5kZW50bGVzc19zZXF1ZW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2Vfbm9kZSh0cnVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9ub2RlID0gZnVuY3Rpb24oYmxvY2ssIGluZGVudGxlc3Nfc2VxdWVuY2UpIHtcbiAgICAgIHZhciBhbmNob3IsIGVuZF9tYXJrLCBldmVudCwgaGFuZGxlLCBpbXBsaWNpdCwgbm9kZSwgc3RhcnRfbWFyaywgc3VmZml4LCB0YWcsIHRhZ19tYXJrLCB0b2tlbjtcbiAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgIGJsb2NrID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZW50bGVzc19zZXF1ZW5jZSA9PSBudWxsKSB7XG4gICAgICAgIGluZGVudGxlc3Nfc2VxdWVuY2UgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5BbGlhc1Rva2VuKSkge1xuICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5BbGlhc0V2ZW50KHRva2VuLnZhbHVlLCB0b2tlbi5zdGFydF9tYXJrLCB0b2tlbi5lbmRfbWFyayk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlcy5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuY2hvciA9IG51bGw7XG4gICAgICAgIHRhZyA9IG51bGw7XG4gICAgICAgIHN0YXJ0X21hcmsgPSBlbmRfbWFyayA9IHRhZ19tYXJrID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkFuY2hvclRva2VuKSkge1xuICAgICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgICBzdGFydF9tYXJrID0gdG9rZW4uc3RhcnRfbWFyaztcbiAgICAgICAgICBlbmRfbWFyayA9IHRva2VuLmVuZF9tYXJrO1xuICAgICAgICAgIGFuY2hvciA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5UYWdUb2tlbikpIHtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgICAgIHRhZ19tYXJrID0gdG9rZW4uc3RhcnRfbWFyaztcbiAgICAgICAgICAgIGVuZF9tYXJrID0gdG9rZW4uZW5kX21hcms7XG4gICAgICAgICAgICB0YWcgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuVGFnVG9rZW4pKSB7XG4gICAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICAgIHN0YXJ0X21hcmsgPSB0YWdfbWFyayA9IHRva2VuLnN0YXJ0X21hcms7XG4gICAgICAgICAgZW5kX21hcmsgPSB0b2tlbi5lbmRfbWFyaztcbiAgICAgICAgICB0YWcgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuQW5jaG9yVG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgICAgICBlbmRfbWFyayA9IHRva2VuLmVuZF9tYXJrO1xuICAgICAgICAgICAgYW5jaG9yID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgIT09IG51bGwpIHtcbiAgICAgICAgICBoYW5kbGUgPSB0YWdbMF0sIHN1ZmZpeCA9IHRhZ1sxXTtcbiAgICAgICAgICBpZiAoaGFuZGxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIShoYW5kbGUgaW4gdGhpcy50YWdfaGFuZGxlcykpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuUGFyc2VyRXJyb3IoJ3doaWxlIHBhcnNpbmcgYSBub2RlJywgc3RhcnRfbWFyaywgXCJmb3VuZCB1bmRlZmluZWQgdGFnIGhhbmRsZSBcIiArIGhhbmRsZSwgdGFnX21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFnID0gdGhpcy50YWdfaGFuZGxlc1toYW5kbGVdICsgc3VmZml4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YWcgPSBzdWZmaXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydF9tYXJrID09PSBudWxsKSB7XG4gICAgICAgICAgc3RhcnRfbWFyayA9IGVuZF9tYXJrID0gdGhpcy5wZWVrX3Rva2VuKCkuc3RhcnRfbWFyaztcbiAgICAgICAgfVxuICAgICAgICBldmVudCA9IG51bGw7XG4gICAgICAgIGltcGxpY2l0ID0gdGFnID09PSBudWxsIHx8IHRhZyA9PT0gJyEnO1xuICAgICAgICBpZiAoaW5kZW50bGVzc19zZXF1ZW5jZSAmJiB0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5CbG9ja0VudHJ5VG9rZW4pKSB7XG4gICAgICAgICAgZW5kX21hcmsgPSB0aGlzLnBlZWtfdG9rZW4oKS5lbmRfbWFyaztcbiAgICAgICAgICBldmVudCA9IG5ldyBldmVudHMuU2VxdWVuY2VTdGFydEV2ZW50KGFuY2hvciwgdGFnLCBpbXBsaWNpdCwgc3RhcnRfbWFyaywgZW5kX21hcmspO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfaW5kZW50bGVzc19zZXF1ZW5jZV9lbnRyeSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLlNjYWxhclRva2VuKSkge1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICAgICAgZW5kX21hcmsgPSB0b2tlbi5lbmRfbWFyaztcbiAgICAgICAgICAgIGlmICgodG9rZW4ucGxhaW4gJiYgdGFnID09PSBudWxsKSB8fCB0YWcgPT09ICchJykge1xuICAgICAgICAgICAgICBpbXBsaWNpdCA9IFt0cnVlLCBmYWxzZV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBpbXBsaWNpdCA9IFtmYWxzZSwgdHJ1ZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbXBsaWNpdCA9IFtmYWxzZSwgZmFsc2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQgPSBuZXcgZXZlbnRzLlNjYWxhckV2ZW50KGFuY2hvciwgdGFnLCBpbXBsaWNpdCwgdG9rZW4udmFsdWUsIHN0YXJ0X21hcmssIGVuZF9tYXJrLCB0b2tlbi5zdHlsZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5GbG93U2VxdWVuY2VTdGFydFRva2VuKSkge1xuICAgICAgICAgICAgZW5kX21hcmsgPSB0aGlzLnBlZWtfdG9rZW4oKS5lbmRfbWFyaztcbiAgICAgICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5TZXF1ZW5jZVN0YXJ0RXZlbnQoYW5jaG9yLCB0YWcsIGltcGxpY2l0LCBzdGFydF9tYXJrLCBlbmRfbWFyaywgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Zsb3dfc2VxdWVuY2VfZmlyc3RfZW50cnknO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuRmxvd01hcHBpbmdTdGFydFRva2VuKSkge1xuICAgICAgICAgICAgZW5kX21hcmsgPSB0aGlzLnBlZWtfdG9rZW4oKS5lbmRfbWFyaztcbiAgICAgICAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5NYXBwaW5nU3RhcnRFdmVudChhbmNob3IsIHRhZywgaW1wbGljaXQsIHN0YXJ0X21hcmssIGVuZF9tYXJrLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfZmxvd19tYXBwaW5nX2ZpcnN0X2tleSc7XG4gICAgICAgICAgfSBlbHNlIGlmIChibG9jayAmJiB0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5CbG9ja1NlcXVlbmNlU3RhcnRUb2tlbikpIHtcbiAgICAgICAgICAgIGVuZF9tYXJrID0gdGhpcy5wZWVrX3Rva2VuKCkuZW5kX21hcms7XG4gICAgICAgICAgICBldmVudCA9IG5ldyBldmVudHMuU2VxdWVuY2VTdGFydEV2ZW50KGFuY2hvciwgdGFnLCBpbXBsaWNpdCwgc3RhcnRfbWFyaywgZW5kX21hcmssIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfYmxvY2tfc2VxdWVuY2VfZmlyc3RfZW50cnknO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYmxvY2sgJiYgdGhpcy5jaGVja190b2tlbih0b2tlbnMuQmxvY2tNYXBwaW5nU3RhcnRUb2tlbikpIHtcbiAgICAgICAgICAgIGVuZF9tYXJrID0gdGhpcy5wZWVrX3Rva2VuKCkuZW5kX21hcms7XG4gICAgICAgICAgICBldmVudCA9IG5ldyBldmVudHMuTWFwcGluZ1N0YXJ0RXZlbnQoYW5jaG9yLCB0YWcsIGltcGxpY2l0LCBzdGFydF9tYXJrLCBlbmRfbWFyaywgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9ibG9ja19tYXBwaW5nX2ZpcnN0X2tleSc7XG4gICAgICAgICAgfSBlbHNlIGlmIChhbmNob3IgIT09IG51bGwgfHwgdGFnICE9PSBudWxsKSB7XG4gICAgICAgICAgICBldmVudCA9IG5ldyBldmVudHMuU2NhbGFyRXZlbnQoYW5jaG9yLCB0YWcsIFtpbXBsaWNpdCwgZmFsc2VdLCAnJywgc3RhcnRfbWFyaywgZW5kX21hcmspO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzLnBvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgbm9kZSA9ICdibG9jayc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub2RlID0gJ2Zsb3cnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnBlZWtfdG9rZW4oKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlBhcnNlckVycm9yKFwid2hpbGUgcGFyc2luZyBhIFwiICsgbm9kZSArIFwiIG5vZGVcIiwgc3RhcnRfbWFyaywgXCJleHBlY3RlZCB0aGUgbm9kZSBjb250ZW50LCBidXQgZm91bmQgXCIgKyB0b2tlbi5pZCwgdG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfYmxvY2tfc2VxdWVuY2VfZmlyc3RfZW50cnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b2tlbjtcbiAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgIHRoaXMubWFya3MucHVzaCh0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Jsb2NrX3NlcXVlbmNlX2VudHJ5KCk7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfYmxvY2tfc2VxdWVuY2VfZW50cnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBldmVudCwgdG9rZW47XG4gICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuQmxvY2tFbnRyeVRva2VuKSkge1xuICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuQmxvY2tFbnRyeVRva2VuLCB0b2tlbnMuQmxvY2tFbmRUb2tlbikpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKCdwYXJzZV9ibG9ja19zZXF1ZW5jZV9lbnRyeScpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Jsb2NrX25vZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Jsb2NrX3NlcXVlbmNlX2VudHJ5JztcbiAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzX2VtcHR5X3NjYWxhcih0b2tlbi5lbmRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuQmxvY2tFbmRUb2tlbikpIHtcbiAgICAgICAgdG9rZW4gPSB0aGlzLnBlZWtfdG9rZW4oKTtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuUGFyc2VyRXJyb3IoJ3doaWxlIHBhcnNpbmcgYSBibG9jayBjb2xsZWN0aW9uJywgdGhpcy5tYXJrcy5zbGljZSgtMSlbMF0sIFwiZXhwZWN0ZWQgPGJsb2NrIGVuZD4sIGJ1dCBmb3VuZCBcIiArIHRva2VuLmlkLCB0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5TZXF1ZW5jZUVuZEV2ZW50KHRva2VuLnN0YXJ0X21hcmssIHRva2VuLmVuZF9tYXJrKTtcbiAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlcy5wb3AoKTtcbiAgICAgIHRoaXMubWFya3MucG9wKCk7XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfaW5kZW50bGVzc19zZXF1ZW5jZV9lbnRyeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGV2ZW50LCB0b2tlbjtcbiAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5CbG9ja0VudHJ5VG9rZW4pKSB7XG4gICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5CbG9ja0VudHJ5VG9rZW4sIHRva2Vucy5LZXlUb2tlbiwgdG9rZW5zLlZhbHVlVG9rZW4sIHRva2Vucy5CbG9ja0VuZFRva2VuKSkge1xuICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2goJ3BhcnNlX2luZGVudGxlc3Nfc2VxdWVuY2VfZW50cnknKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZV9ibG9ja19ub2RlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9pbmRlbnRsZXNzX3NlcXVlbmNlX2VudHJ5JztcbiAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzX2VtcHR5X3NjYWxhcih0b2tlbi5lbmRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRva2VuID0gdGhpcy5wZWVrX3Rva2VuKCk7XG4gICAgICBldmVudCA9IG5ldyBldmVudHMuU2VxdWVuY2VFbmRFdmVudCh0b2tlbi5zdGFydF9tYXJrLCB0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlcy5wb3AoKTtcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9ibG9ja19tYXBwaW5nX2ZpcnN0X2tleSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRva2VuO1xuICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgdGhpcy5tYXJrcy5wdXNoKHRva2VuLnN0YXJ0X21hcmspO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VfYmxvY2tfbWFwcGluZ19rZXkoKTtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9ibG9ja19tYXBwaW5nX2tleSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGV2ZW50LCB0b2tlbjtcbiAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5LZXlUb2tlbikpIHtcbiAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLktleVRva2VuLCB0b2tlbnMuVmFsdWVUb2tlbiwgdG9rZW5zLkJsb2NrRW5kVG9rZW4pKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCgncGFyc2VfYmxvY2tfbWFwcGluZ192YWx1ZScpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Jsb2NrX25vZGVfb3JfaW5kZW50bGVzc19zZXF1ZW5jZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfYmxvY2tfbWFwcGluZ192YWx1ZSc7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc19lbXB0eV9zY2FsYXIodG9rZW4uZW5kX21hcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkJsb2NrRW5kVG9rZW4pKSB7XG4gICAgICAgIHRva2VuID0gdGhpcy5wZWVrX3Rva2VuKCk7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlBhcnNlckVycm9yKCd3aGlsZSBwYXJzaW5nIGEgYmxvY2sgbWFwcGluZycsIHRoaXMubWFya3Muc2xpY2UoLTEpWzBdLCBcImV4cGVjdGVkIDxibG9jayBlbmQ+LCBidXQgZm91bmQgXCIgKyB0b2tlbi5pZCwgdG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICBldmVudCA9IG5ldyBldmVudHMuTWFwcGluZ0VuZEV2ZW50KHRva2VuLnN0YXJ0X21hcmssIHRva2VuLmVuZF9tYXJrKTtcbiAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlcy5wb3AoKTtcbiAgICAgIHRoaXMubWFya3MucG9wKCk7XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfYmxvY2tfbWFwcGluZ192YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRva2VuO1xuICAgICAgaWYgKHRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLlZhbHVlVG9rZW4pKSB7XG4gICAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5LZXlUb2tlbiwgdG9rZW5zLlZhbHVlVG9rZW4sIHRva2Vucy5CbG9ja0VuZFRva2VuKSkge1xuICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2goJ3BhcnNlX2Jsb2NrX21hcHBpbmdfa2V5Jyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VfYmxvY2tfbm9kZV9vcl9pbmRlbnRsZXNzX3NlcXVlbmNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9ibG9ja19tYXBwaW5nX2tleSc7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc19lbXB0eV9zY2FsYXIodG9rZW4uZW5kX21hcmspO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Jsb2NrX21hcHBpbmdfa2V5JztcbiAgICAgICAgdG9rZW4gPSB0aGlzLnBlZWtfdG9rZW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc19lbXB0eV9zY2FsYXIodG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfZmxvd19zZXF1ZW5jZV9maXJzdF9lbnRyeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRva2VuO1xuICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgdGhpcy5tYXJrcy5wdXNoKHRva2VuLnN0YXJ0X21hcmspO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VfZmxvd19zZXF1ZW5jZV9lbnRyeSh0cnVlKTtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9mbG93X3NlcXVlbmNlX2VudHJ5ID0gZnVuY3Rpb24oZmlyc3QpIHtcbiAgICAgIHZhciBldmVudCwgdG9rZW47XG4gICAgICBpZiAoZmlyc3QgPT0gbnVsbCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5GbG93U2VxdWVuY2VFbmRUb2tlbikpIHtcbiAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5GbG93RW50cnlUb2tlbikpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy5wZWVrX3Rva2VuKCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5QYXJzZXJFcnJvcignd2hpbGUgcGFyc2luZyBhIGZsb3cgc2VxdWVuY2UnLCB0aGlzLm1hcmtzLnNsaWNlKC0xKVswXSwgXCJleHBlY3RlZCAnLCcgb3IgJ10nLCBidXQgZ290IFwiICsgdG9rZW4uaWQsIHRva2VuLnN0YXJ0X21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuS2V5VG9rZW4pKSB7XG4gICAgICAgICAgdG9rZW4gPSB0aGlzLnBlZWtfdG9rZW4oKTtcbiAgICAgICAgICBldmVudCA9IG5ldyBldmVudHMuTWFwcGluZ1N0YXJ0RXZlbnQobnVsbCwgbnVsbCwgdHJ1ZSwgdG9rZW4uc3RhcnRfbWFyaywgdG9rZW4uZW5kX21hcmssIHRydWUpO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfZmxvd19zZXF1ZW5jZV9lbnRyeV9tYXBwaW5nX2tleSc7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5GbG93U2VxdWVuY2VFbmRUb2tlbikpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKCdwYXJzZV9mbG93X3NlcXVlbmNlX2VudHJ5Jyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VfZmxvd19ub2RlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5TZXF1ZW5jZUVuZEV2ZW50KHRva2VuLnN0YXJ0X21hcmssIHRva2VuLmVuZF9tYXJrKTtcbiAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlcy5wb3AoKTtcbiAgICAgIHRoaXMubWFya3MucG9wKCk7XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfZmxvd19zZXF1ZW5jZV9lbnRyeV9tYXBwaW5nX2tleSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRva2VuO1xuICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgaWYgKCF0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5WYWx1ZVRva2VuLCB0b2tlbnMuRmxvd0VudHJ5VG9rZW4sIHRva2Vucy5GbG93U2VxdWVuY2VFbmRUb2tlbikpIHtcbiAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCgncGFyc2VfZmxvd19zZXF1ZW5jZV9lbnRyeV9tYXBwaW5nX3ZhbHVlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Zsb3dfbm9kZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9mbG93X3NlcXVlbmNlX2VudHJ5X21hcHBpbmdfdmFsdWUnO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzX2VtcHR5X3NjYWxhcih0b2tlbi5lbmRfbWFyayk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfZmxvd19zZXF1ZW5jZV9lbnRyeV9tYXBwaW5nX3ZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdG9rZW47XG4gICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuVmFsdWVUb2tlbikpIHtcbiAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkZsb3dFbnRyeVRva2VuLCB0b2tlbnMuRmxvd1NlcXVlbmNlRW5kVG9rZW4pKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCgncGFyc2VfZmxvd19zZXF1ZW5jZV9lbnRyeV9tYXBwaW5nX2VuZCcpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlX2Zsb3dfbm9kZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfZmxvd19zZXF1ZW5jZV9lbnRyeV9tYXBwaW5nX2VuZCc7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc19lbXB0eV9zY2FsYXIodG9rZW4uZW5kX21hcmspO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Zsb3dfc2VxdWVuY2VfZW50cnlfbWFwcGluZ19lbmQnO1xuICAgICAgICB0b2tlbiA9IHRoaXMucGVla190b2tlbigpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzX2VtcHR5X3NjYWxhcih0b2tlbi5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9mbG93X3NlcXVlbmNlX2VudHJ5X21hcHBpbmdfZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdG9rZW47XG4gICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Zsb3dfc2VxdWVuY2VfZW50cnknO1xuICAgICAgdG9rZW4gPSB0aGlzLnBlZWtfdG9rZW4oKTtcbiAgICAgIHJldHVybiBuZXcgZXZlbnRzLk1hcHBpbmdFbmRFdmVudCh0b2tlbi5zdGFydF9tYXJrLCB0b2tlbi5zdGFydF9tYXJrKTtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9mbG93X21hcHBpbmdfZmlyc3Rfa2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdG9rZW47XG4gICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICB0aGlzLm1hcmtzLnB1c2godG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZV9mbG93X21hcHBpbmdfa2V5KHRydWUpO1xuICAgIH07XG5cbiAgICBQYXJzZXIucHJvdG90eXBlLnBhcnNlX2Zsb3dfbWFwcGluZ19rZXkgPSBmdW5jdGlvbihmaXJzdCkge1xuICAgICAgdmFyIGV2ZW50LCB0b2tlbjtcbiAgICAgIGlmIChmaXJzdCA9PSBudWxsKSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkZsb3dNYXBwaW5nRW5kVG9rZW4pKSB7XG4gICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuRmxvd0VudHJ5VG9rZW4pKSB7XG4gICAgICAgICAgICB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMucGVla190b2tlbigpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuUGFyc2VyRXJyb3IoJ3doaWxlIHBhcnNpbmcgYSBmbG93IG1hcHBpbmcnLCB0aGlzLm1hcmtzLnNsaWNlKC0xKVswXSwgXCJleHBlY3RlZCAnLCcgb3IgJ30nLCBidXQgZ290IFwiICsgdG9rZW4uaWQsIHRva2VuLnN0YXJ0X21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaGVja190b2tlbih0b2tlbnMuS2V5VG9rZW4pKSB7XG4gICAgICAgICAgdG9rZW4gPSB0aGlzLmdldF90b2tlbigpO1xuICAgICAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuVmFsdWVUb2tlbiwgdG9rZW5zLkZsb3dFbnRyeVRva2VuLCB0b2tlbnMuRmxvd01hcHBpbmdFbmRUb2tlbikpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2goJ3BhcnNlX2Zsb3dfbWFwcGluZ192YWx1ZScpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VfZmxvd19ub2RlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAncGFyc2VfZmxvd19tYXBwaW5nX3ZhbHVlJztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NfZW1wdHlfc2NhbGFyKHRva2VuLmVuZF9tYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuY2hlY2tfdG9rZW4odG9rZW5zLkZsb3dNYXBwaW5nRW5kVG9rZW4pKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZXMucHVzaCgncGFyc2VfZmxvd19tYXBwaW5nX2VtcHR5X3ZhbHVlJyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VfZmxvd19ub2RlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRva2VuID0gdGhpcy5nZXRfdG9rZW4oKTtcbiAgICAgIGV2ZW50ID0gbmV3IGV2ZW50cy5NYXBwaW5nRW5kRXZlbnQodG9rZW4uc3RhcnRfbWFyaywgdG9rZW4uZW5kX21hcmspO1xuICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzLnBvcCgpO1xuICAgICAgdGhpcy5tYXJrcy5wb3AoKTtcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9O1xuXG4gICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZV9mbG93X21hcHBpbmdfdmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b2tlbjtcbiAgICAgIGlmICh0aGlzLmNoZWNrX3Rva2VuKHRva2Vucy5WYWx1ZVRva2VuKSkge1xuICAgICAgICB0b2tlbiA9IHRoaXMuZ2V0X3Rva2VuKCk7XG4gICAgICAgIGlmICghdGhpcy5jaGVja190b2tlbih0b2tlbnMuRmxvd0VudHJ5VG9rZW4sIHRva2Vucy5GbG93TWFwcGluZ0VuZFRva2VuKSkge1xuICAgICAgICAgIHRoaXMuc3RhdGVzLnB1c2goJ3BhcnNlX2Zsb3dfbWFwcGluZ19rZXknKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZV9mbG93X25vZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Zsb3dfbWFwcGluZ19rZXknO1xuICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NfZW1wdHlfc2NhbGFyKHRva2VuLmVuZF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9ICdwYXJzZV9mbG93X21hcHBpbmdfa2V5JztcbiAgICAgICAgdG9rZW4gPSB0aGlzLnBlZWtfdG9rZW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc19lbXB0eV9zY2FsYXIodG9rZW4uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VfZmxvd19tYXBwaW5nX2VtcHR5X3ZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0YXRlID0gJ3BhcnNlX2Zsb3dfbWFwcGluZ19rZXknO1xuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc19lbXB0eV9zY2FsYXIodGhpcy5wZWVrX3Rva2VuKCkuc3RhcnRfbWFyayk7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucHJvY2Vzc19lbXB0eV9zY2FsYXIgPSBmdW5jdGlvbihtYXJrKSB7XG4gICAgICByZXR1cm4gbmV3IGV2ZW50cy5TY2FsYXJFdmVudChudWxsLCBudWxsLCBbdHJ1ZSwgZmFsc2VdLCAnJywgbWFyaywgbWFyayk7XG4gICAgfTtcblxuICAgIHJldHVybiBQYXJzZXI7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIE1hcmtlZFlBTUxFcnJvciwgbm9kZXMsIHVybCwgdXRpbCxcbiAgICBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9O1xuXG4gIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG4gIE1hcmtlZFlBTUxFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3JzJykuTWFya2VkWUFNTEVycm9yO1xuXG4gIG5vZGVzID0gcmVxdWlyZSgnLi9ub2RlcycpO1xuXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvKlxuICBUaGUgUHJvdG9jb2xzIGNsYXNzIGRlYWxzIHdpdGggYXBwbHlpbmcgcHJvdG9jb2xzIHRvIG1ldGhvZHMgYWNjb3JkaW5nIHRvIHRoZSBzcGVjXG4gICovXG5cblxuICB0aGlzLlByb3RvY29scyA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBQcm90b2NvbHMoKSB7XG4gICAgICB0aGlzLmFwcGx5X3Byb3RvY29scyA9IF9fYmluZCh0aGlzLmFwcGx5X3Byb3RvY29scywgdGhpcyk7XG4gICAgfVxuXG4gICAgUHJvdG9jb2xzLnByb3RvdHlwZS5hcHBseV9wcm90b2NvbHMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcHJvdG9jb2xzO1xuICAgICAgaWYgKHByb3RvY29scyA9IHRoaXMuYXBwbHlfcHJvdG9jb2xzX3RvX3Jvb3Qobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlfcHJvdG9jb2xzX3RvX3Jlc291cmNlcyhub2RlLCBwcm90b2NvbHMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBQcm90b2NvbHMucHJvdG90eXBlLmFwcGx5X3Byb3RvY29sc190b19yb290ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGJhc2VVcmksIHBhcnNlZEJhc2VVcmksIHByb3RvY29sLCBwcm90b2NvbHM7XG4gICAgICBpZiAodGhpcy5oYXNfcHJvcGVydHkobm9kZSwgJ3Byb3RvY29scycpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldF9wcm9wZXJ0eShub2RlLCAncHJvdG9jb2xzJyk7XG4gICAgICB9XG4gICAgICBpZiAoIShiYXNlVXJpID0gdGhpcy5wcm9wZXJ0eV92YWx1ZShub2RlLCAnYmFzZVVyaScpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwYXJzZWRCYXNlVXJpID0gdXJsLnBhcnNlKGJhc2VVcmkpO1xuICAgICAgcHJvdG9jb2wgPSAocGFyc2VkQmFzZVVyaS5wcm90b2NvbCB8fCAnaHR0cDonKS5zbGljZSgwLCAtMSkudG9VcHBlckNhc2UoKTtcbiAgICAgIHByb3RvY29scyA9IFtuZXcgbm9kZXMuU2NhbGFyTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywgJ3Byb3RvY29scycsIG5vZGUuc3RhcnRfbWFyaywgbm9kZS5lbmRfbWFyayksIG5ldyBub2Rlcy5TZXF1ZW5jZU5vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOnNlcScsIFtuZXcgbm9kZXMuU2NhbGFyTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywgcHJvdG9jb2wsIG5vZGUuc3RhcnRfbWFyaywgbm9kZS5lbmRfbWFyayldLCBub2RlLnN0YXJ0X21hcmssIG5vZGUuZW5kX21hcmspXTtcbiAgICAgIG5vZGUudmFsdWUucHVzaChwcm90b2NvbHMpO1xuICAgICAgcmV0dXJuIHByb3RvY29sc1sxXTtcbiAgICB9O1xuXG4gICAgUHJvdG9jb2xzLnByb3RvdHlwZS5hcHBseV9wcm90b2NvbHNfdG9fcmVzb3VyY2VzID0gZnVuY3Rpb24obm9kZSwgcHJvdG9jb2xzKSB7XG4gICAgICB2YXIgcmVzb3VyY2UsIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgIF9yZWYgPSB0aGlzLmNoaWxkX3Jlc291cmNlcyhub2RlKTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcmVzb3VyY2UgPSBfcmVmW19pXTtcbiAgICAgICAgdGhpcy5hcHBseV9wcm90b2NvbHNfdG9fcmVzb3VyY2VzKHJlc291cmNlLCBwcm90b2NvbHMpO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMuYXBwbHlfcHJvdG9jb2xzX3RvX21ldGhvZHMocmVzb3VyY2UsIHByb3RvY29scykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBQcm90b2NvbHMucHJvdG90eXBlLmFwcGx5X3Byb3RvY29sc190b19tZXRob2RzID0gZnVuY3Rpb24obm9kZSwgcHJvdG9jb2xzKSB7XG4gICAgICB2YXIgbWV0aG9kLCBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICBfcmVmID0gdGhpcy5jaGlsZF9tZXRob2RzKG5vZGVbMV0pO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBtZXRob2QgPSBfcmVmW19pXTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc19wcm9wZXJ0eShtZXRob2RbMV0sICdwcm90b2NvbHMnKSkge1xuICAgICAgICAgIGlmICghdXRpbC5pc01hcHBpbmcobWV0aG9kWzFdKSkge1xuICAgICAgICAgICAgbWV0aG9kWzFdID0gbmV3IG5vZGVzLk1hcHBpbmdOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLCBbXSwgbWV0aG9kWzFdLnN0YXJ0X21hcmssIG1ldGhvZFsxXS5lbmRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9yZXN1bHRzLnB1c2gobWV0aG9kWzFdLnZhbHVlLnB1c2goW25ldyBub2Rlcy5TY2FsYXJOb2RlKCd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCAncHJvdG9jb2xzJywgbWV0aG9kWzBdLnN0YXJ0X21hcmssIG1ldGhvZFswXS5lbmRfbWFyayksIHByb3RvY29scy5jbG9uZSgpXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICByZXR1cm4gUHJvdG9jb2xzO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBkZWZhdWx0U2V0dGluZ3MsIHV0aWwsIF9yZWYsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XG5cbiAgdGhpcy5lcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG4gIHRoaXMubG9hZGVyID0gcmVxdWlyZSgnLi9sb2FkZXInKTtcblxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgdGhpcy5GaWxlRXJyb3IgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZpbGVFcnJvciwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIEZpbGVFcnJvcigpIHtcbiAgICAgIF9yZWYgPSBGaWxlRXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjtcbiAgICB9XG5cbiAgICByZXR1cm4gRmlsZUVycm9yO1xuXG4gIH0pKHRoaXMuZXJyb3JzLk1hcmtlZFlBTUxFcnJvcik7XG5cbiAgdGhpcy5GaWxlUmVhZGVyID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIEZpbGVSZWFkZXIocmVhZEZpbGVBc3luY092ZXJyaWRlKSB7XG4gICAgICB0aGlzLnEgPSByZXF1aXJlKCdxJyk7XG4gICAgICB0aGlzLnVybCA9IHJlcXVpcmUoJ3VybCcpO1xuICAgICAgaWYgKHJlYWRGaWxlQXN5bmNPdmVycmlkZSkge1xuICAgICAgICB0aGlzLnJlYWRGaWxlQXN5bmNPdmVycmlkZSA9IHJlYWRGaWxlQXN5bmNPdmVycmlkZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgIFJlYWQgZmlsZSBlaXRoZXIgbG9jYWxseSBvciBmcm9tIHRoZSBuZXR3b3JrLlxuICAgICovXG5cblxuICAgIEZpbGVSZWFkZXIucHJvdG90eXBlLnJlYWRGaWxlQXN5bmMgPSBmdW5jdGlvbihmaWxlKSB7XG4gICAgICB2YXIgdGFyZ2VyVXJsO1xuICAgICAgaWYgKHRoaXMucmVhZEZpbGVBc3luY092ZXJyaWRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRGaWxlQXN5bmNPdmVycmlkZShmaWxlKTtcbiAgICAgIH1cbiAgICAgIHRhcmdlclVybCA9IHRoaXMudXJsLnBhcnNlKGZpbGUpO1xuICAgICAgaWYgKHRhcmdlclVybC5wcm90b2NvbCAhPSBudWxsKSB7XG4gICAgICAgIGlmICghdGFyZ2VyVXJsLnByb3RvY29sLm1hdGNoKC9eaHR0cHM/L2kpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuRmlsZUVycm9yKFwid2hpbGUgcmVhZGluZyBcIiArIGZpbGUsIG51bGwsIFwidW5rbm93biBwcm90b2NvbCBcIiArIHRhcmdlclVybC5wcm90b2NvbCwgdGhpcy5zdGFydF9tYXJrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEZpbGVBc3luYyhmaWxlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hGaWxlQXN5bmMoZmlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hMb2NhbEZpbGVBc3luYyhmaWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIFJlYWQgZmlsZSBmcm9tIHRoZSBkaXNrLlxuICAgICovXG5cblxuICAgIEZpbGVSZWFkZXIucHJvdG90eXBlLmZldGNoTG9jYWxGaWxlQXN5bmMgPSBmdW5jdGlvbihmaWxlKSB7XG4gICAgICB2YXIgZGVmZXJyZWQsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGRlZmVycmVkID0gdGhpcy5xLmRlZmVyKCk7XG4gICAgICByZXF1aXJlKCdmcycpLnJlYWRGaWxlKGZpbGUsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnJlamVjdChuZXcgZXhwb3J0cy5GaWxlRXJyb3IoXCJ3aGlsZSByZWFkaW5nIFwiICsgZmlsZSwgbnVsbCwgXCJjYW5ub3QgcmVhZCBcIiArIGZpbGUgKyBcIiAoXCIgKyBlcnIgKyBcIilcIiwgX3RoaXMuc3RhcnRfbWFyaykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5yZXNvbHZlKGRhdGEudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmVhZCBmaWxlIGZyb20gdGhlIG5ldHdvcmsuXG4gICAgKi9cblxuXG4gICAgRmlsZVJlYWRlci5wcm90b3R5cGUuZmV0Y2hGaWxlQXN5bmMgPSBmdW5jdGlvbihmaWxlKSB7XG4gICAgICB2YXIgZGVmZXJyZWQsIGVycm9yLCB4aHIsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGRlZmVycmVkID0gdGhpcy5xLmRlZmVyKCk7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgIT09IG51bGwpIHtcbiAgICAgICAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4aHIgPSBuZXcgKHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0JykuWE1MSHR0cFJlcXVlc3QpKCk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB4aHIub3BlbignR0VUJywgZmlsZSwgZmFsc2UpO1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQWNjZXB0JywgJ2FwcGxpY2F0aW9uL3JhbWwreWFtbCwgKi8qJyk7XG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIGlmICgodHlwZW9mIHhoci5zdGF0dXMgPT09ICdudW1iZXInICYmIHhoci5zdGF0dXMgPT09IDIwMCkgfHwgKHR5cGVvZiB4aHIuc3RhdHVzID09PSAnc3RyaW5nJyAmJiB4aHIuc3RhdHVzLm1hdGNoKC9eMjAwL2kpKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucmVzb2x2ZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5yZWplY3QobmV3IGV4cG9ydHMuRmlsZUVycm9yKFwid2hpbGUgZmV0Y2hpbmcgXCIgKyBmaWxlLCBudWxsLCBcImNhbm5vdCBmZXRjaCBcIiArIGZpbGUgKyBcIiAoXCIgKyB4aHIuc3RhdHVzVGV4dCArIFwiKVwiLCBfdGhpcy5zdGFydF9tYXJrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZXJyb3IgPSBfZXJyb3I7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkZpbGVFcnJvcihcIndoaWxlIGZldGNoaW5nIFwiICsgZmlsZSwgbnVsbCwgXCJjYW5ub3QgZmV0Y2ggXCIgKyBmaWxlICsgXCIgKFwiICsgZXJyb3IgKyBcIiksIGNoZWNrIHRoYXQgdGhlIHNlcnZlciBpcyB1cCBhbmQgdGhhdCBDT1JTIGlzIGVuYWJsZWRcIiwgdGhpcy5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIEZpbGVSZWFkZXI7XG5cbiAgfSkoKTtcblxuICAvKlxuICBPTyB2ZXJzaW9uIG9mIHRoZSBwYXJzZXIsIHN0YXRpYyBmdW5jdGlvbnMgd2lsbCBiZSByZW1vdmVkIGFmdGVyIGNvbnN1bWVycyBtb3ZlIG9uIHRvIHVzZSB0aGUgT08gdmVyc2lvblxuICBPTyB3aWxsIG9mZmVyIGNhY2hpbmdcbiAgKi9cblxuXG4gIHRoaXMuUmFtbFBhcnNlciA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBSYW1sUGFyc2VyKHNldHRpbmdzKSB7XG4gICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3MgIT0gbnVsbCA/IHNldHRpbmdzIDogZGVmYXVsdFNldHRpbmdzO1xuICAgICAgdGhpcy5xID0gcmVxdWlyZSgncScpO1xuICAgICAgdGhpcy51cmwgPSByZXF1aXJlKCd1cmwnKTtcbiAgICAgIHRoaXMubm9kZXMgPSByZXF1aXJlKCcuL25vZGVzJyk7XG4gICAgICB0aGlzLmxvYWREZWZhdWx0U2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIFJhbWxQYXJzZXIucHJvdG90eXBlLmxvYWREZWZhdWx0U2V0dGluZ3MgPSBmdW5jdGlvbihzZXR0aW5ncykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhkZWZhdWx0U2V0dGluZ3MpLmZvckVhY2goZnVuY3Rpb24oc2V0dGluZ05hbWUpIHtcbiAgICAgICAgaWYgKCEoc2V0dGluZ05hbWUgaW4gc2V0dGluZ3MpKSB7XG4gICAgICAgICAgcmV0dXJuIHNldHRpbmdzW3NldHRpbmdOYW1lXSA9IGRlZmF1bHRTZXR0aW5nc1tzZXR0aW5nTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBSYW1sUGFyc2VyLnByb3RvdHlwZS5sb2FkRmlsZSA9IGZ1bmN0aW9uKGZpbGUsIHNldHRpbmdzKSB7XG4gICAgICB2YXIgZXJyb3IsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGlmIChzZXR0aW5ncyA9PSBudWxsKSB7XG4gICAgICAgIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncztcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBzZXR0aW5ncy5yZWFkZXIucmVhZEZpbGVBc3luYyhmaWxlKS50aGVuKGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5sb2FkKHN0cmVhbSwgZmlsZSwgc2V0dGluZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlcnJvciA9IF9lcnJvcjtcbiAgICAgICAgcmV0dXJuIHRoaXMucS5mY2FsbChmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5GaWxlRXJyb3IoXCJ3aGlsZSBmZXRjaGluZyBcIiArIGZpbGUsIG51bGwsIFwiY2Fubm90IGZldGNoIFwiICsgZmlsZSArIFwiIChcIiArIGVycm9yICsgXCIpXCIsIG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUmFtbFBhcnNlci5wcm90b3R5cGUuY29tcG9zZUZpbGUgPSBmdW5jdGlvbihmaWxlLCBzZXR0aW5ncywgcGFyZW50KSB7XG4gICAgICB2YXIgZXJyb3IsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGlmIChzZXR0aW5ncyA9PSBudWxsKSB7XG4gICAgICAgIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncztcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBzZXR0aW5ncy5yZWFkZXIucmVhZEZpbGVBc3luYyhmaWxlKS50aGVuKGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5jb21wb3NlKHN0cmVhbSwgZmlsZSwgc2V0dGluZ3MsIHBhcmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGVycm9yID0gX2Vycm9yO1xuICAgICAgICByZXR1cm4gdGhpcy5xLmZjYWxsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLkZpbGVFcnJvcihcIndoaWxlIGZldGNoaW5nIFwiICsgZmlsZSwgbnVsbCwgXCJjYW5ub3QgZmV0Y2ggXCIgKyBmaWxlICsgXCIgKFwiICsgZXJyb3IgKyBcIilcIiwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBSYW1sUGFyc2VyLnByb3RvdHlwZS5jb21wb3NlID0gZnVuY3Rpb24oc3RyZWFtLCBsb2NhdGlvbiwgc2V0dGluZ3MsIHBhcmVudCkge1xuICAgICAgaWYgKHNldHRpbmdzID09IG51bGwpIHtcbiAgICAgICAgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudCA9PSBudWxsKSB7XG4gICAgICAgIHBhcmVudCA9IHtcbiAgICAgICAgICBzcmM6IGxvY2F0aW9uXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBzZXR0aW5ncy5jb21wb3NlID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVN0cmVhbShzdHJlYW0sIGxvY2F0aW9uLCBzZXR0aW5ncywgcGFyZW50KTtcbiAgICB9O1xuXG4gICAgUmFtbFBhcnNlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKHN0cmVhbSwgbG9jYXRpb24sIHNldHRpbmdzKSB7XG4gICAgICBpZiAoc2V0dGluZ3MgPT0gbnVsbCkge1xuICAgICAgICBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XG4gICAgICB9XG4gICAgICBzZXR0aW5ncy5jb21wb3NlID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlU3RyZWFtKHN0cmVhbSwgbG9jYXRpb24sIHNldHRpbmdzLCB7XG4gICAgICAgIHNyYzogbG9jYXRpb25cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBSYW1sUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSwgbG9jYXRpb24sIHNldHRpbmdzLCBwYXJlbnQpIHtcbiAgICAgIHZhciBsb2FkZXIsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGlmIChzZXR0aW5ncyA9PSBudWxsKSB7XG4gICAgICAgIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncztcbiAgICAgIH1cbiAgICAgIGxvYWRlciA9IG5ldyBleHBvcnRzLmxvYWRlci5Mb2FkZXIoc3RyZWFtLCBsb2NhdGlvbiwgc2V0dGluZ3MsIHBhcmVudCk7XG4gICAgICByZXR1cm4gdGhpcy5xLmZjYWxsKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbG9hZGVyLmdldFlhbWxSb290KCk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uKHBhcnRpYWxUcmVlKSB7XG4gICAgICAgIHZhciBmaWxlcztcbiAgICAgICAgZmlsZXMgPSBsb2FkZXIuZ2V0UGVuZGluZ0ZpbGVzTGlzdCgpO1xuICAgICAgICByZXR1cm4gX3RoaXMuZ2V0UGVuZGluZ0ZpbGVzKGxvYWRlciwgcGFydGlhbFRyZWUsIGZpbGVzKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24oZnVsbHlBc3NlbWJsZWRUcmVlKSB7XG4gICAgICAgIGxvYWRlci5jb21wb3NlUmFtbFRyZWUoZnVsbHlBc3NlbWJsZWRUcmVlLCBzZXR0aW5ncyk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5jb21wb3NlKSB7XG4gICAgICAgICAgaWYgKGZ1bGx5QXNzZW1ibGVkVHJlZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVyLmNvbnN0cnVjdF9kb2N1bWVudChmdWxseUFzc2VtYmxlZFRyZWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bGx5QXNzZW1ibGVkVHJlZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFJhbWxQYXJzZXIucHJvdG90eXBlLmdldFBlbmRpbmdGaWxlcyA9IGZ1bmN0aW9uKGxvYWRlciwgbm9kZSwgZmlsZXMpIHtcbiAgICAgIHZhciBmaWxlLCBsYXN0VmlzaXRlZE5vZGUsIGxvYywgX2ksIF9sZW4sXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGxvYyA9IFtdO1xuICAgICAgbGFzdFZpc2l0ZWROb2RlID0gdm9pZCAwO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBmaWxlcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBmaWxlID0gZmlsZXNbX2ldO1xuICAgICAgICBsb2MucHVzaCh0aGlzLmdldFBlbmRpbmdGaWxlKGxvYWRlciwgZmlsZSkudGhlbihmdW5jdGlvbihvdmVyd3JpdGluZ25vZGUpIHtcbiAgICAgICAgICBpZiAob3ZlcndyaXRpbmdub2RlICYmICFsYXN0VmlzaXRlZE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXN0VmlzaXRlZE5vZGUgPSBvdmVyd3JpdGluZ25vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5xLmFsbChsb2MpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChsYXN0VmlzaXRlZE5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbGFzdFZpc2l0ZWROb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgUmFtbFBhcnNlci5wcm90b3R5cGUuZ2V0UGVuZGluZ0ZpbGUgPSBmdW5jdGlvbihsb2FkZXIsIGZpbGVJbmZvKSB7XG4gICAgICB2YXIgZXJyb3IsIGV2ZW50LCBmaWxlVXJpLCBrZXksIG5vZGUsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIG5vZGUgPSBmaWxlSW5mby5wYXJlbnROb2RlO1xuICAgICAgZXZlbnQgPSBmaWxlSW5mby5ldmVudDtcbiAgICAgIGtleSA9IGZpbGVJbmZvLnBhcmVudEtleTtcbiAgICAgIGZpbGVVcmkgPSBmaWxlSW5mby50YXJnZXRGaWxlVXJpO1xuICAgICAgaWYgKGZpbGVJbmZvLmluY2x1ZGluZ0NvbnRleHQpIHtcbiAgICAgICAgZmlsZVVyaSA9IHRoaXMudXJsLnJlc29sdmUoZmlsZUluZm8uaW5jbHVkaW5nQ29udGV4dCwgZmlsZUluZm8udGFyZ2V0RmlsZVVyaSk7XG4gICAgICB9XG4gICAgICBpZiAobG9hZGVyLnBhcmVudCAmJiB0aGlzLmlzSW5JbmNsdWRlVGFnc1N0YWNrKGZpbGVVcmksIGxvYWRlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuRmlsZUVycm9yKCd3aGlsZSBjb21wb3Npbmcgc2NhbGFyIG91dCBvZiAhaW5jbHVkZScsIG51bGwsIFwiZGV0ZWN0ZWQgY2lyY3VsYXIgIWluY2x1ZGUgb2YgXCIgKyBldmVudC52YWx1ZSwgZXZlbnQuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZmlsZUluZm8udHlwZSA9PT0gJ2ZyYWdtZW50Jykge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLnJlYWRlci5yZWFkRmlsZUFzeW5jKGZpbGVVcmkpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY29tcG9zZShyZXN1bHQsIGZpbGVVcmksIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGU6IGZhbHNlLFxuICAgICAgICAgICAgICB0cmFuc2Zvcm06IGZhbHNlLFxuICAgICAgICAgICAgICBjb21wb3NlOiB0cnVlXG4gICAgICAgICAgICB9LCBsb2FkZXIpO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5hcHBlbmROZXdOb2RlVG9QYXJlbnQobm9kZSwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFkZENvbnRleHRUb0Vycm9yKGVycm9yLCBldmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MucmVhZGVyLnJlYWRGaWxlQXN5bmMoZmlsZVVyaSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IF90aGlzLm5vZGVzLlNjYWxhck5vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsIHJlc3VsdCwgZXZlbnQuc3RhcnRfbWFyaywgZXZlbnQuZW5kX21hcmssIGV2ZW50LnN0eWxlKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5hcHBlbmROZXdOb2RlVG9QYXJlbnQobm9kZSwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFkZENvbnRleHRUb0Vycm9yKGVycm9yLCBldmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlcnJvciA9IF9lcnJvcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkQ29udGV4dFRvRXJyb3IoZXJyb3IsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUmFtbFBhcnNlci5wcm90b3R5cGUuYWRkQ29udGV4dFRvRXJyb3IgPSBmdW5jdGlvbihlcnJvciwgZXZlbnQpIHtcbiAgICAgIGlmIChlcnJvci5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkZpbGVFcnJvclwiKSB7XG4gICAgICAgIGlmICghZXJyb3IucHJvYmxlbV9tYXJrKSB7XG4gICAgICAgICAgZXJyb3IucHJvYmxlbV9tYXJrID0gZXZlbnQuc3RhcnRfbWFyaztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLkZpbGVFcnJvcignd2hpbGUgcmVhZGluZyBmaWxlJywgbnVsbCwgXCJlcnJvcjogXCIgKyBlcnJvciwgZXZlbnQuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFJhbWxQYXJzZXIucHJvdG90eXBlLmlzSW5JbmNsdWRlVGFnc1N0YWNrID0gZnVuY3Rpb24oaW5jbHVkZSwgcGFyZW50KSB7XG4gICAgICB3aGlsZSAocGFyZW50ID0gcGFyZW50LnBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50LnNyYyA9PT0gaW5jbHVkZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIFJhbWxQYXJzZXIucHJvdG90eXBlLmFwcGVuZE5ld05vZGVUb1BhcmVudCA9IGZ1bmN0aW9uKG5vZGUsIGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIGlmICh1dGlsLmlzU2VxdWVuY2Uobm9kZSkpIHtcbiAgICAgICAgICBub2RlLnZhbHVlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnZhbHVlLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFJhbWxQYXJzZXI7XG5cbiAgfSkoKTtcblxuICAvKlxuICAgIHZhbGlkYXRlIGNvbnRyb2xzIHdoZXRoZXIgdGhlIHN0cmVhbSBtdXN0IGJlIHByb2Nlc3NlZCBhcyBhXG4gICovXG5cblxuICBkZWZhdWx0U2V0dGluZ3MgPSB7XG4gICAgdmFsaWRhdGU6IHRydWUsXG4gICAgdHJhbnNmb3JtOiB0cnVlLFxuICAgIGNvbXBvc2U6IHRydWUsXG4gICAgcmVhZGVyOiBuZXcgZXhwb3J0cy5GaWxlUmVhZGVyKG51bGwpXG4gIH07XG5cbiAgLypcbiAgUGFyc2UgdGhlIGZpcnN0IFJBTUwgZG9jdW1lbnQgaW4gYSBzdHJlYW0gYW5kIHByb2R1Y2UgdGhlIGNvcnJlc3BvbmRpbmdcbiAgSmF2YXNjcmlwdCBvYmplY3QuXG4gICovXG5cblxuICB0aGlzLmxvYWRGaWxlID0gZnVuY3Rpb24oZmlsZSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgcGFyc2VyO1xuICAgIGlmIChzZXR0aW5ncyA9PSBudWxsKSB7XG4gICAgICBzZXR0aW5ncyA9IGRlZmF1bHRTZXR0aW5ncztcbiAgICB9XG4gICAgcGFyc2VyID0gbmV3IGV4cG9ydHMuUmFtbFBhcnNlcihzZXR0aW5ncyk7XG4gICAgcmV0dXJuIHBhcnNlci5sb2FkRmlsZShmaWxlLCBzZXR0aW5ncyk7XG4gIH07XG5cbiAgLypcbiAgUGFyc2UgdGhlIGZpcnN0IFJBTUwgZG9jdW1lbnQgaW4gYSBmaWxlIGFuZCBwcm9kdWNlIHRoZSBjb3JyZXNwb25kaW5nXG4gIHJlcHJlc2VudGF0aW9uIHRyZWUuXG4gICovXG5cblxuICB0aGlzLmNvbXBvc2VGaWxlID0gZnVuY3Rpb24oZmlsZSwgc2V0dGluZ3MsIHBhcmVudCkge1xuICAgIHZhciBwYXJzZXI7XG4gICAgaWYgKHNldHRpbmdzID09IG51bGwpIHtcbiAgICAgIHNldHRpbmdzID0gZGVmYXVsdFNldHRpbmdzO1xuICAgIH1cbiAgICBpZiAocGFyZW50ID09IG51bGwpIHtcbiAgICAgIHBhcmVudCA9IGZpbGU7XG4gICAgfVxuICAgIHBhcnNlciA9IG5ldyBleHBvcnRzLlJhbWxQYXJzZXIoc2V0dGluZ3MpO1xuICAgIHJldHVybiBwYXJzZXIuY29tcG9zZUZpbGUoZmlsZSwgc2V0dGluZ3MsIHBhcmVudCk7XG4gIH07XG5cbiAgLypcbiAgUGFyc2UgdGhlIGZpcnN0IFJBTUwgZG9jdW1lbnQgaW4gYSBzdHJlYW0gYW5kIHByb2R1Y2UgdGhlIGNvcnJlc3BvbmRpbmdcbiAgcmVwcmVzZW50YXRpb24gdHJlZS5cbiAgKi9cblxuXG4gIHRoaXMuY29tcG9zZSA9IGZ1bmN0aW9uKHN0cmVhbSwgbG9jYXRpb24sIHNldHRpbmdzLCBwYXJlbnQpIHtcbiAgICB2YXIgcGFyc2VyO1xuICAgIGlmIChzZXR0aW5ncyA9PSBudWxsKSB7XG4gICAgICBzZXR0aW5ncyA9IGRlZmF1bHRTZXR0aW5ncztcbiAgICB9XG4gICAgaWYgKHBhcmVudCA9PSBudWxsKSB7XG4gICAgICBwYXJlbnQgPSBsb2NhdGlvbjtcbiAgICB9XG4gICAgcGFyc2VyID0gbmV3IGV4cG9ydHMuUmFtbFBhcnNlcihzZXR0aW5ncyk7XG4gICAgcmV0dXJuIHBhcnNlci5jb21wb3NlKHN0cmVhbSwgbG9jYXRpb24sIHNldHRpbmdzLCBwYXJlbnQpO1xuICB9O1xuXG4gIC8qXG4gIFBhcnNlIHRoZSBmaXJzdCBSQU1MIGRvY3VtZW50IGluIGEgc3RyZWFtIGFuZCBwcm9kdWNlIHRoZSBjb3JyZXNwb25kaW5nXG4gIEphdmFzY3JpcHQgb2JqZWN0LlxuICAqL1xuXG5cbiAgdGhpcy5sb2FkID0gZnVuY3Rpb24oc3RyZWFtLCBsb2NhdGlvbiwgc2V0dGluZ3MpIHtcbiAgICB2YXIgcGFyc2VyO1xuICAgIGlmIChzZXR0aW5ncyA9PSBudWxsKSB7XG4gICAgICBzZXR0aW5ncyA9IGRlZmF1bHRTZXR0aW5ncztcbiAgICB9XG4gICAgcGFyc2VyID0gbmV3IGV4cG9ydHMuUmFtbFBhcnNlcihzZXR0aW5ncyk7XG4gICAgcmV0dXJuIHBhcnNlci5sb2FkKHN0cmVhbSwgbG9jYXRpb24sIHNldHRpbmdzLCBudWxsKTtcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIE1hcmssIE1hcmtlZFlBTUxFcnJvciwgX3JlZiwgX3JlZjEsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgX19pbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH07XG5cbiAgX3JlZiA9IHJlcXVpcmUoJy4vZXJyb3JzJyksIE1hcmsgPSBfcmVmLk1hcmssIE1hcmtlZFlBTUxFcnJvciA9IF9yZWYuTWFya2VkWUFNTEVycm9yO1xuXG4gIHRoaXMuUmVhZGVyRXJyb3IgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlYWRlckVycm9yLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gUmVhZGVyRXJyb3IoKSB7XG4gICAgICBfcmVmMSA9IFJlYWRlckVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWYxO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFkZXJFcnJvcjtcblxuICB9KShNYXJrZWRZQU1MRXJyb3IpO1xuXG4gIC8qXG4gIFJlYWRlcjpcbiAgICBjaGVja3MgaWYgY2hhcmFjdGVycyBhcmUgd2l0aGluIHRoZSBhbGxvd2VkIHJhbmdlXG4gICAgYWRkICdcXHgwMCcgdG8gdGhlIGVuZFxuICAqL1xuXG5cbiAgdGhpcy5SZWFkZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIE5PTl9QUklOVEFCTEU7XG5cbiAgICBOT05fUFJJTlRBQkxFID0gL1teXFx4MDlcXHgwQVxceDBEXFx4MjAtXFx4N0VcXHg4NVxceEEwLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkRdLztcblxuICAgIGZ1bmN0aW9uIFJlYWRlcihzdHJpbmcsIHNyYykge1xuICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgICB0aGlzLnNyYyA9IHNyYztcbiAgICAgIHRoaXMubGluZSA9IDA7XG4gICAgICB0aGlzLmNvbHVtbiA9IDA7XG4gICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgIHRoaXMuc3RyaW5nICs9ICdcXHgwMCc7XG4gICAgfVxuXG4gICAgUmVhZGVyLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA9PSBudWxsKSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnN0cmluZ1t0aGlzLmluZGV4ICsgaW5kZXhdO1xuICAgIH07XG5cbiAgICBSZWFkZXIucHJvdG90eXBlLnByZWZpeCA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgICAgaWYgKGxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5pbmRleCwgdGhpcy5pbmRleCArIGxlbmd0aCk7XG4gICAgfTtcblxuICAgIFJlYWRlci5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgICAgdmFyIGNoYXIsIF9yZXN1bHRzO1xuICAgICAgaWYgKGxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICB9XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgd2hpbGUgKGxlbmd0aCkge1xuICAgICAgICBjaGFyID0gdGhpcy5zdHJpbmdbdGhpcy5pbmRleF07XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKCdcXG5cXHg4NVxcdTIwODJcXHUyMDI5JywgY2hhcikgPj0gMCB8fCAoY2hhciA9PT0gJ1xccicgJiYgdGhpcy5zdHJpbmdbdGhpcy5pbmRleF0gIT09ICdcXG4nKSkge1xuICAgICAgICAgIHRoaXMubGluZSsrO1xuICAgICAgICAgIHRoaXMuY29sdW1uID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNoZWNrX3ByaW50YWJsZShjaGFyKTtcbiAgICAgICAgICB0aGlzLmNvbHVtbisrO1xuICAgICAgICB9XG4gICAgICAgIF9yZXN1bHRzLnB1c2gobGVuZ3RoLS0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBSZWFkZXIucHJvdG90eXBlLmNyZWF0ZV9tYXJrID0gZnVuY3Rpb24obGluZSwgY29sdW1uKSB7XG4gICAgICBpZiAobGluZSA9PSBudWxsKSB7XG4gICAgICAgIGxpbmUgPSB0aGlzLmxpbmU7XG4gICAgICB9XG4gICAgICBpZiAoY29sdW1uID09IG51bGwpIHtcbiAgICAgICAgY29sdW1uID0gdGhpcy5jb2x1bW47XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IE1hcmsodGhpcy5zcmMsIGxpbmUsIGNvbHVtbiwgdGhpcy5zdHJpbmcsIHRoaXMuaW5kZXgpO1xuICAgIH07XG5cbiAgICBSZWFkZXIucHJvdG90eXBlLmdldF9tYXJrID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVfbWFyaygpO1xuICAgIH07XG5cbiAgICBSZWFkZXIucHJvdG90eXBlLmNoZWNrX3ByaW50YWJsZSA9IGZ1bmN0aW9uKGNoYXIpIHtcbiAgICAgIGlmIChOT05fUFJJTlRBQkxFLmV4ZWMoY2hhcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuUmVhZGVyRXJyb3IoJ3doaWxlIHJlYWRpbmcgZmlsZScsIG51bGwsIFwibm9uIHByaW50YWJsZSBjaGFyYWN0ZXJzIGFyZSBub3QgYWxsb3dlZCBjb2x1bW46IFwiICsgKHRoaXMuZ2V0X21hcmsoKS5jb2x1bW4pLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gUmVhZGVyO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBZQU1MRXJyb3IsIG5vZGVzLCB1dGlsLCBfcmVmLCBfcmVmMSxcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBfX2luZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfTtcblxuICBub2RlcyA9IHJlcXVpcmUoJy4vbm9kZXMnKTtcblxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgWUFNTEVycm9yID0gcmVxdWlyZSgnLi9lcnJvcnMnKS5ZQU1MRXJyb3I7XG5cbiAgdGhpcy5SZXNvbHZlckVycm9yID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXNvbHZlckVycm9yLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gUmVzb2x2ZXJFcnJvcigpIHtcbiAgICAgIF9yZWYgPSBSZXNvbHZlckVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlc29sdmVyRXJyb3I7XG5cbiAgfSkoWUFNTEVycm9yKTtcblxuICB0aGlzLkJhc2VSZXNvbHZlciA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgREVGQVVMVF9NQVBQSU5HX1RBRywgREVGQVVMVF9TQ0FMQVJfVEFHLCBERUZBVUxUX1NFUVVFTkNFX1RBRztcblxuICAgIERFRkFVTFRfU0NBTEFSX1RBRyA9ICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInO1xuXG4gICAgREVGQVVMVF9TRVFVRU5DRV9UQUcgPSAndGFnOnlhbWwub3JnLDIwMDI6c2VxJztcblxuICAgIERFRkFVTFRfTUFQUElOR19UQUcgPSAndGFnOnlhbWwub3JnLDIwMDI6bWFwJztcblxuICAgIEJhc2VSZXNvbHZlci5wcm90b3R5cGUueWFtbF9pbXBsaWNpdF9yZXNvbHZlcnMgPSB7fTtcblxuICAgIEJhc2VSZXNvbHZlci5wcm90b3R5cGUueWFtbF9wYXRoX3Jlc29sdmVycyA9IHt9O1xuXG4gICAgQmFzZVJlc29sdmVyLmFkZF9pbXBsaWNpdF9yZXNvbHZlciA9IGZ1bmN0aW9uKHRhZywgcmVnZXhwLCBmaXJzdCkge1xuICAgICAgdmFyIGNoYXIsIF9iYXNlLCBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICBpZiAoZmlyc3QgPT0gbnVsbCkge1xuICAgICAgICBmaXJzdCA9IFtudWxsXTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3lhbWxfaW1wbGljaXRfcmVzb2x2ZXJzJykpIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUueWFtbF9pbXBsaWNpdF9yZXNvbHZlcnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5wcm90b3R5cGUueWFtbF9pbXBsaWNpdF9yZXNvbHZlcnMpO1xuICAgICAgfVxuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gZmlyc3QubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgY2hhciA9IGZpcnN0W19pXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCgoKF9iYXNlID0gdGhpcy5wcm90b3R5cGUueWFtbF9pbXBsaWNpdF9yZXNvbHZlcnMpW2NoYXJdICE9IG51bGwgPyAoX2Jhc2UgPSB0aGlzLnByb3RvdHlwZS55YW1sX2ltcGxpY2l0X3Jlc29sdmVycylbY2hhcl0gOiBfYmFzZVtjaGFyXSA9IFtdKS5wdXNoKFt0YWcsIHJlZ2V4cF0pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gQmFzZVJlc29sdmVyKCkge1xuICAgICAgdGhpcy5yZXNvbHZlcl9leGFjdF9wYXRocyA9IFtdO1xuICAgICAgdGhpcy5yZXNvbHZlcl9wcmVmaXhfcGF0aHMgPSBbXTtcbiAgICB9XG5cbiAgICBCYXNlUmVzb2x2ZXIucHJvdG90eXBlLmRlc2NlbmRfcmVzb2x2ZXIgPSBmdW5jdGlvbihjdXJyZW50X25vZGUsIGN1cnJlbnRfaW5kZXgpIHtcbiAgICAgIHZhciBkZXB0aCwgZXhhY3RfcGF0aHMsIGtpbmQsIHBhdGgsIHByZWZpeF9wYXRocywgX2ksIF9qLCBfbGVuLCBfbGVuMSwgX3JlZjEsIF9yZWYyLCBfcmVmMywgX3JlZjQ7XG4gICAgICBpZiAodXRpbC5pc19lbXB0eSh0aGlzLnlhbWxfcGF0aF9yZXNvbHZlcnMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGV4YWN0X3BhdGhzID0ge307XG4gICAgICBwcmVmaXhfcGF0aHMgPSBbXTtcbiAgICAgIGlmIChjdXJyZW50X25vZGUpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVyX3ByZWZpeF9wYXRocy5sZW5ndGg7XG4gICAgICAgIF9yZWYxID0gdGhpcy5yZXNvbHZlcl9wcmVmaXhfcGF0aHMuc2xpY2UoLTEpWzBdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgX3JlZjIgPSBfcmVmMVtfaV0sIHBhdGggPSBfcmVmMlswXSwga2luZCA9IF9yZWYyWzFdO1xuICAgICAgICAgIGlmICh0aGlzLmNoZWNrX3Jlc29sdmVyX3ByZWZpeChkZXB0aCwgcGF0aCwga2luZCwgY3VycmVudF9ub2RlLCBjdXJyZW50X2luZGV4KSkge1xuICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gZGVwdGgpIHtcbiAgICAgICAgICAgICAgcHJlZml4X3BhdGhzLnB1c2goW3BhdGgsIGtpbmRdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV4YWN0X3BhdGhzW2tpbmRdID0gdGhpcy55YW1sX3BhdGhfcmVzb2x2ZXJzW3BhdGhdW2tpbmRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3JlZjMgPSB0aGlzLnlhbWxfcGF0aF9yZXNvbHZlcnM7XG4gICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYzLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgIF9yZWY0ID0gX3JlZjNbX2pdLCBwYXRoID0gX3JlZjRbMF0sIGtpbmQgPSBfcmVmNFsxXTtcbiAgICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgIGV4YWN0X3BhdGhzW2tpbmRdID0gdGhpcy55YW1sX3BhdGhfcmVzb2x2ZXJzW3BhdGhdW2tpbmRdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmVmaXhfcGF0aHMucHVzaChbcGF0aCwga2luZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5yZXNvbHZlcl9leGFjdF9wYXRocy5wdXNoKGV4YWN0X3BhdGhzKTtcbiAgICAgIHJldHVybiB0aGlzLnJlc29sdmVyX3ByZWZpeF9wYXRocy5wdXNoKHByZWZpeF9wYXRocyk7XG4gICAgfTtcblxuICAgIEJhc2VSZXNvbHZlci5wcm90b3R5cGUuYXNjZW5kX3Jlc29sdmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodXRpbC5pc19lbXB0eSh0aGlzLnlhbWxfcGF0aF9yZXNvbHZlcnMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzb2x2ZXJfZXhhY3RfcGF0aHMucG9wKCk7XG4gICAgICByZXR1cm4gdGhpcy5yZXNvbHZlcl9wcmVmaXhfcGF0aHMucG9wKCk7XG4gICAgfTtcblxuICAgIEJhc2VSZXNvbHZlci5wcm90b3R5cGUuY2hlY2tfcmVzb2x2ZXJfcHJlZml4ID0gZnVuY3Rpb24oZGVwdGgsIHBhdGgsIGtpbmQsIGN1cnJlbnRfbm9kZSwgY3VycmVudF9pbmRleCkge1xuICAgICAgdmFyIGluZGV4X2NoZWNrLCBub2RlX2NoZWNrLCBfcmVmMTtcbiAgICAgIF9yZWYxID0gcGF0aFtkZXB0aCAtIDFdLCBub2RlX2NoZWNrID0gX3JlZjFbMF0sIGluZGV4X2NoZWNrID0gX3JlZjFbMV07XG4gICAgICBpZiAodHlwZW9mIG5vZGVfY2hlY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChjdXJyZW50X25vZGUudGFnICE9PSBub2RlX2NoZWNrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGVfY2hlY2sgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCEoY3VycmVudF9ub2RlIGluc3RhbmNlb2Ygbm9kZV9jaGVjaykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbmRleF9jaGVjayA9PT0gdHJ1ZSAmJiBjdXJyZW50X2luZGV4ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgoaW5kZXhfY2hlY2sgPT09IGZhbHNlIHx8IGluZGV4X2NoZWNrID09PSBudWxsKSAmJiBjdXJyZW50X2luZGV4ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5kZXhfY2hlY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghKGN1cnJlbnRfaW5kZXggaW5zdGFuY2VvZiBub2Rlcy5TY2FsYXJOb2RlKSAmJiBpbmRleF9jaGVjayA9PT0gY3VycmVudF9pbmRleC52YWx1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5kZXhfY2hlY2sgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChpbmRleF9jaGVjayAhPT0gY3VycmVudF9pbmRleCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIEJhc2VSZXNvbHZlci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKGtpbmQsIHZhbHVlLCBpbXBsaWNpdCkge1xuICAgICAgdmFyIGVtcHR5LCBleGFjdF9wYXRocywgaywgcmVnZXhwLCByZXNvbHZlcnMsIHRhZywgX2ksIF9sZW4sIF9yZWYxLCBfcmVmMiwgX3JlZjMsIF9yZWY0O1xuICAgICAgaWYgKGtpbmQgPT09IG5vZGVzLlNjYWxhck5vZGUgJiYgaW1wbGljaXRbMF0pIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgIHJlc29sdmVycyA9IChfcmVmMSA9IHRoaXMueWFtbF9pbXBsaWNpdF9yZXNvbHZlcnNbJyddKSAhPSBudWxsID8gX3JlZjEgOiBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlcnMgPSAoX3JlZjIgPSB0aGlzLnlhbWxfaW1wbGljaXRfcmVzb2x2ZXJzW3ZhbHVlWzBdXSkgIT0gbnVsbCA/IF9yZWYyIDogW107XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZXJzID0gcmVzb2x2ZXJzLmNvbmNhdCgoX3JlZjMgPSB0aGlzLnlhbWxfaW1wbGljaXRfcmVzb2x2ZXJzW251bGxdKSAhPSBudWxsID8gX3JlZjMgOiBbXSk7XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gcmVzb2x2ZXJzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgX3JlZjQgPSByZXNvbHZlcnNbX2ldLCB0YWcgPSBfcmVmNFswXSwgcmVnZXhwID0gX3JlZjRbMV07XG4gICAgICAgICAgaWYgKHZhbHVlLm1hdGNoKHJlZ2V4cCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGltcGxpY2l0ID0gaW1wbGljaXRbMV07XG4gICAgICB9XG4gICAgICBlbXB0eSA9IHRydWU7XG4gICAgICBmb3IgKGsgaW4gdGhpcy55YW1sX3BhdGhfcmVzb2x2ZXJzKSB7XG4gICAgICAgIGlmICh7fVtrXSA9PSBudWxsKSB7XG4gICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFlbXB0eSkge1xuICAgICAgICBleGFjdF9wYXRocyA9IHRoaXMucmVzb2x2ZXJfZXhhY3RfcGF0aHMuc2xpY2UoLTEpWzBdO1xuICAgICAgICBpZiAoX19pbmRleE9mLmNhbGwoZXhhY3RfcGF0aHMsIGtpbmQpID49IDApIHtcbiAgICAgICAgICByZXR1cm4gZXhhY3RfcGF0aHNba2luZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKGV4YWN0X3BhdGhzLCBudWxsKSA+PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGV4YWN0X3BhdGhzW251bGxdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoa2luZCA9PT0gbm9kZXMuU2NhbGFyTm9kZSkge1xuICAgICAgICByZXR1cm4gREVGQVVMVF9TQ0FMQVJfVEFHO1xuICAgICAgfVxuICAgICAgaWYgKGtpbmQgPT09IG5vZGVzLlNlcXVlbmNlTm9kZSkge1xuICAgICAgICByZXR1cm4gREVGQVVMVF9TRVFVRU5DRV9UQUc7XG4gICAgICB9XG4gICAgICBpZiAoa2luZCA9PT0gbm9kZXMuTWFwcGluZ05vZGUpIHtcbiAgICAgICAgcmV0dXJuIERFRkFVTFRfTUFQUElOR19UQUc7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBCYXNlUmVzb2x2ZXI7XG5cbiAgfSkoKTtcblxuICB0aGlzLlJlc29sdmVyID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXNvbHZlciwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFJlc29sdmVyKCkge1xuICAgICAgX3JlZjEgPSBSZXNvbHZlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmMTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVzb2x2ZXI7XG5cbiAgfSkodGhpcy5CYXNlUmVzb2x2ZXIpO1xuXG4gIHRoaXMuUmVzb2x2ZXIuYWRkX2ltcGxpY2l0X3Jlc29sdmVyKCd0YWc6eWFtbC5vcmcsMjAwMjpib29sJywgL14oPzp0cnVlfFRydWV8VFJVRXxmYWxzZXxGYWxzZXxGQUxTRSkkLywgJ3RUZkYnKTtcblxuICB0aGlzLlJlc29sdmVyLmFkZF9pbXBsaWNpdF9yZXNvbHZlcigndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLCAvXig/OlstK10/KD86WzAtOV1bMC05X10qKVxcLlswLTlfXSooPzpbZUVdWy0rXVswLTldKyk/fFxcLlswLTlfXSsoPzpbZUVdWy0rXVswLTldKyk/fFstK10/WzAtOV1bMC05X10qKD86OlswLTVdP1swLTldKStcXC5bMC05X10qfFstK10/XFwuKD86aW5mfEluZnxJTkYpfFxcLig/Om5hbnxOYU58TkFOKSkkLywgJy0rMDEyMzQ1Njc4OS4nKTtcblxuICB0aGlzLlJlc29sdmVyLmFkZF9pbXBsaWNpdF9yZXNvbHZlcigndGFnOnlhbWwub3JnLDIwMDI6aW50JywgL14oPzpbLStdPzBiWzAxX10rfFstK10/MFswLTdfXSt8Wy0rXT8oPzowfFsxLTldWzAtOV9dKil8Wy0rXT8weFswLTlhLWZBLUZfXSt8Wy0rXT8wb1swLTdfXSt8Wy0rXT9bMS05XVswLTlfXSooPzo6WzAtNV0/WzAtOV0pKykkLywgJy0rMDEyMzQ1Njc4OScpO1xuXG4gIHRoaXMuUmVzb2x2ZXIuYWRkX2ltcGxpY2l0X3Jlc29sdmVyKCd0YWc6eWFtbC5vcmcsMjAwMjptZXJnZScsIC9eKD86PDwpJC8sICc8Jyk7XG5cbiAgdGhpcy5SZXNvbHZlci5hZGRfaW1wbGljaXRfcmVzb2x2ZXIoJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLCAvXig/On58bnVsbHxOdWxsfE5VTEx8KSQvLCBbJ34nLCAnbicsICdOJywgJyddKTtcblxuICB0aGlzLlJlc29sdmVyLmFkZF9pbXBsaWNpdF9yZXNvbHZlcigndGFnOnlhbWwub3JnLDIwMDI6dGltZXN0YW1wJywgL14oPzpbMC05XVswLTldWzAtOV1bMC05XS1bMC05XVswLTldLVswLTldWzAtOV18WzAtOV1bMC05XVswLTldWzAtOV0tWzAtOV1bMC05XT8tWzAtOV1bMC05XT8oPzpbVHRdfFtcXHgyMFxcdF0rKVswLTldWzAtOV0/OlswLTldWzAtOV06WzAtOV1bMC05XSg/OlxcLlswLTldKik/KD86W1xceDIwXFx0XSooPzpafFstK11bMC05XVswLTldPyg/OjpbMC05XVswLTldKT8pKT8pJC8sICcwMTIzNDU2Nzg5Jyk7XG5cbiAgdGhpcy5SZXNvbHZlci5hZGRfaW1wbGljaXRfcmVzb2x2ZXIoJ3RhZzp5YW1sLm9yZywyMDAyOnZhbHVlJywgL14oPzo9KSQvLCAnPScpO1xuXG4gIHRoaXMuUmVzb2x2ZXIuYWRkX2ltcGxpY2l0X3Jlc29sdmVyKCd0YWc6eWFtbC5vcmcsMjAwMjp5YW1sJywgL14oPzohfCZ8XFwqKSQvLCAnISYqJyk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBNYXJrZWRZQU1MRXJyb3IsIG5vZGVzLCB1dGlsLCBfcmVmLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH07XG5cbiAgTWFya2VkWUFNTEVycm9yID0gcmVxdWlyZSgnLi9lcnJvcnMnKS5NYXJrZWRZQU1MRXJyb3I7XG5cbiAgbm9kZXMgPSByZXF1aXJlKCcuL25vZGVzJyk7XG5cbiAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIC8qXG4gIFRoZSBSZXNvdXJjZVR5cGVzIHRocm93cyB0aGVzZS5cbiAgKi9cblxuXG4gIHRoaXMuUmVzb3VyY2VUeXBlRXJyb3IgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlc291cmNlVHlwZUVycm9yLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gUmVzb3VyY2VUeXBlRXJyb3IoKSB7XG4gICAgICBfcmVmID0gUmVzb3VyY2VUeXBlRXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVzb3VyY2VUeXBlRXJyb3I7XG5cbiAgfSkoTWFya2VkWUFNTEVycm9yKTtcblxuICAvKlxuICBUaGUgUmVzb3VyY2VUeXBlcyBjbGFzcyBkZWFscyB3aXRoIGFwcGx5aW5nIFJlc291cmNlVHlwZXMgdG8gcmVzb3VyY2VzIGFjY29yZGluZyB0byB0aGUgc3BlY1xuICAqL1xuXG5cbiAgdGhpcy5SZXNvdXJjZVR5cGVzID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFJlc291cmNlVHlwZXMoKSB7XG4gICAgICB0aGlzLmFwcGx5X3BhcmFtZXRlcnNfdG9fdHlwZSA9IF9fYmluZCh0aGlzLmFwcGx5X3BhcmFtZXRlcnNfdG9fdHlwZSwgdGhpcyk7XG4gICAgICB0aGlzLmFwcGx5X3R5cGUgPSBfX2JpbmQodGhpcy5hcHBseV90eXBlLCB0aGlzKTtcbiAgICAgIHRoaXMuYXBwbHlfdHlwZXMgPSBfX2JpbmQodGhpcy5hcHBseV90eXBlcywgdGhpcyk7XG4gICAgICB0aGlzLmdldF90eXBlID0gX19iaW5kKHRoaXMuZ2V0X3R5cGUsIHRoaXMpO1xuICAgICAgdGhpcy5oYXNfdHlwZXMgPSBfX2JpbmQodGhpcy5oYXNfdHlwZXMsIHRoaXMpO1xuICAgICAgdGhpcy5sb2FkX3R5cGVzID0gX19iaW5kKHRoaXMubG9hZF90eXBlcywgdGhpcyk7XG4gICAgICB0aGlzLmRlY2xhcmVkVHlwZXMgPSB7fTtcbiAgICB9XG5cbiAgICBSZXNvdXJjZVR5cGVzLnByb3RvdHlwZS5sb2FkX3R5cGVzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGFsbFR5cGVzLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLmxvYWRfZGVmYXVsdF9tZWRpYV90eXBlKG5vZGUpO1xuICAgICAgaWYgKHRoaXMuaGFzX3Byb3BlcnR5KG5vZGUsICdyZXNvdXJjZVR5cGVzJykpIHtcbiAgICAgICAgYWxsVHlwZXMgPSB0aGlzLnByb3BlcnR5X3ZhbHVlKG5vZGUsICdyZXNvdXJjZVR5cGVzJyk7XG4gICAgICAgIGlmIChhbGxUeXBlcyAmJiB0eXBlb2YgYWxsVHlwZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgcmV0dXJuIGFsbFR5cGVzLmZvckVhY2goZnVuY3Rpb24odHlwZV9pdGVtKSB7XG4gICAgICAgICAgICBpZiAodHlwZV9pdGVtICYmIHR5cGVvZiB0eXBlX2l0ZW0gPT09ICdvYmplY3QnICYmIHR5cGVvZiB0eXBlX2l0ZW0udmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0eXBlX2l0ZW0udmFsdWUuZm9yRWFjaChmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRlY2xhcmVkVHlwZXNbdHlwZVswXS52YWx1ZV0gPSB0eXBlO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBSZXNvdXJjZVR5cGVzLnByb3RvdHlwZS5oYXNfdHlwZXMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5kZWNsYXJlZFR5cGVzKS5sZW5ndGggPT09IDAgJiYgdGhpcy5oYXNfcHJvcGVydHkobm9kZSwgJ3Jlc291cmNlVHlwZXMnKSkge1xuICAgICAgICB0aGlzLmxvYWRfdHlwZXMobm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5kZWNsYXJlZFR5cGVzKS5sZW5ndGggPiAwO1xuICAgIH07XG5cbiAgICBSZXNvdXJjZVR5cGVzLnByb3RvdHlwZS5nZXRfdHlwZSA9IGZ1bmN0aW9uKHR5cGVOYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNsYXJlZFR5cGVzW3R5cGVOYW1lXTtcbiAgICB9O1xuXG4gICAgUmVzb3VyY2VUeXBlcy5wcm90b3R5cGUuYXBwbHlfdHlwZXMgPSBmdW5jdGlvbihub2RlLCByZXNvdXJjZVVyaSkge1xuICAgICAgdmFyIHJlc291cmNlcyxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHJlc291cmNlVXJpID09IG51bGwpIHtcbiAgICAgICAgcmVzb3VyY2VVcmkgPSBcIlwiO1xuICAgICAgfVxuICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyhub2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNfdHlwZXMobm9kZSkpIHtcbiAgICAgICAgcmVzb3VyY2VzID0gdGhpcy5jaGlsZF9yZXNvdXJjZXMobm9kZSk7XG4gICAgICAgIHJldHVybiByZXNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihyZXNvdXJjZSkge1xuICAgICAgICAgIHZhciB0eXBlO1xuICAgICAgICAgIF90aGlzLmFwcGx5X2RlZmF1bHRfbWVkaWFfdHlwZV90b19yZXNvdXJjZShyZXNvdXJjZVsxXSk7XG4gICAgICAgICAgaWYgKF90aGlzLmhhc19wcm9wZXJ0eShyZXNvdXJjZVsxXSwgJ3R5cGUnKSkge1xuICAgICAgICAgICAgdHlwZSA9IF90aGlzLmdldF9wcm9wZXJ0eShyZXNvdXJjZVsxXSwgJ3R5cGUnKTtcbiAgICAgICAgICAgIF90aGlzLmFwcGx5X3R5cGUocmVzb3VyY2VVcmkgKyByZXNvdXJjZVswXS52YWx1ZSwgcmVzb3VyY2UsIHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3RoaXMuYXBwbHlfdHlwZXMocmVzb3VyY2VbMV0sIHJlc291cmNlVXJpICsgcmVzb3VyY2VbMF0udmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc291cmNlcyA9IHRoaXMuY2hpbGRfcmVzb3VyY2VzKG5vZGUpO1xuICAgICAgICByZXR1cm4gcmVzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24ocmVzb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuYXBwbHlfZGVmYXVsdF9tZWRpYV90eXBlX3RvX3Jlc291cmNlKHJlc291cmNlWzFdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFJlc291cmNlVHlwZXMucHJvdG90eXBlLmFwcGx5X3R5cGUgPSBmdW5jdGlvbihyZXNvdXJjZVVyaSwgcmVzb3VyY2UsIHR5cGVLZXkpIHtcbiAgICAgIHZhciB0ZW1wVHlwZTtcbiAgICAgIHRlbXBUeXBlID0gdGhpcy5yZXNvbHZlX2luaGVyaXRhbmNlX2NoYWluKHJlc291cmNlVXJpLCB0eXBlS2V5KTtcbiAgICAgIHRlbXBUeXBlLmNvbWJpbmUocmVzb3VyY2VbMV0pO1xuICAgICAgcmVzb3VyY2VbMV0gPSB0ZW1wVHlwZTtcbiAgICAgIHJldHVybiByZXNvdXJjZVsxXS5yZW1vdmVfcXVlc3Rpb25fbWFya19wcm9wZXJ0aWVzKCk7XG4gICAgfTtcblxuICAgIFJlc291cmNlVHlwZXMucHJvdG90eXBlLnJlc29sdmVfaW5oZXJpdGFuY2VfY2hhaW4gPSBmdW5jdGlvbihyZXNvdXJjZVVyaSwgdHlwZUtleSkge1xuICAgICAgdmFyIGJhc2VUeXBlLCBjaGlsZFR5cGUsIGNoaWxkVHlwZU5hbWUsIGNoaWxkVHlwZVByb3BlcnR5LCBjb21waWxlZFR5cGVzLCBpbmhlcml0c0Zyb20sIHBhcmVudFR5cGUsIHBhcmVudFR5cGVOYW1lLCBwYXRoVG9DaXJjdWxhclJlZiwgcmVzdWx0LCByb290VHlwZSwgdHlwZXNUb0FwcGx5O1xuICAgICAgY2hpbGRUeXBlTmFtZSA9IHRoaXMua2V5X29yX3ZhbHVlKHR5cGVLZXkpO1xuICAgICAgY2hpbGRUeXBlID0gdGhpcy5hcHBseV9wYXJhbWV0ZXJzX3RvX3R5cGUocmVzb3VyY2VVcmksIGNoaWxkVHlwZU5hbWUsIHR5cGVLZXkpO1xuICAgICAgdHlwZXNUb0FwcGx5ID0gW2NoaWxkVHlwZU5hbWVdO1xuICAgICAgY29tcGlsZWRUeXBlcyA9IHt9O1xuICAgICAgY29tcGlsZWRUeXBlc1tjaGlsZFR5cGVOYW1lXSA9IGNoaWxkVHlwZTtcbiAgICAgIHRoaXMuYXBwbHlfZGVmYXVsdF9tZWRpYV90eXBlX3RvX3Jlc291cmNlKGNoaWxkVHlwZSk7XG4gICAgICB0aGlzLmFwcGx5X3RyYWl0c190b19yZXNvdXJjZShyZXNvdXJjZVVyaSwgY2hpbGRUeXBlLCBmYWxzZSk7XG4gICAgICB3aGlsZSAodGhpcy5oYXNfcHJvcGVydHkoY2hpbGRUeXBlLCAndHlwZScpKSB7XG4gICAgICAgIHR5cGVLZXkgPSB0aGlzLmdldF9wcm9wZXJ0eShjaGlsZFR5cGUsICd0eXBlJyk7XG4gICAgICAgIHBhcmVudFR5cGVOYW1lID0gdGhpcy5rZXlfb3JfdmFsdWUodHlwZUtleSk7XG4gICAgICAgIGlmIChwYXJlbnRUeXBlTmFtZSBpbiBjb21waWxlZFR5cGVzKSB7XG4gICAgICAgICAgcGF0aFRvQ2lyY3VsYXJSZWYgPSB0eXBlc1RvQXBwbHkuY29uY2F0KHBhcmVudFR5cGVOYW1lKS5qb2luKCcgLT4gJyk7XG4gICAgICAgICAgY2hpbGRUeXBlUHJvcGVydHkgPSB0aGlzLmdldF90eXBlKGNoaWxkVHlwZU5hbWUpWzBdO1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlJlc291cmNlVHlwZUVycm9yKCd3aGlsZSBhcHBseWluZyByZXNvdXJjZVR5cGVzJywgbnVsbCwgXCJjaXJjdWxhciByZWZlcmVuY2Ugb2YgXFxcIlwiICsgcGFyZW50VHlwZU5hbWUgKyBcIlxcXCIgaGFzIGJlZW4gZGV0ZWN0ZWQ6IFwiICsgcGF0aFRvQ2lyY3VsYXJSZWYsIGNoaWxkVHlwZVByb3BlcnR5LnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudFR5cGUgPSB0aGlzLmFwcGx5X3BhcmFtZXRlcnNfdG9fdHlwZShyZXNvdXJjZVVyaSwgcGFyZW50VHlwZU5hbWUsIHR5cGVLZXkpO1xuICAgICAgICB0aGlzLmFwcGx5X2RlZmF1bHRfbWVkaWFfdHlwZV90b19yZXNvdXJjZShwYXJlbnRUeXBlKTtcbiAgICAgICAgdGhpcy5hcHBseV90cmFpdHNfdG9fcmVzb3VyY2UocmVzb3VyY2VVcmksIHBhcmVudFR5cGUsIGZhbHNlKTtcbiAgICAgICAgY2hpbGRUeXBlTmFtZSA9IHBhcmVudFR5cGVOYW1lO1xuICAgICAgICBjaGlsZFR5cGUgPSBwYXJlbnRUeXBlO1xuICAgICAgICBjb21waWxlZFR5cGVzW2NoaWxkVHlwZU5hbWVdID0gY2hpbGRUeXBlO1xuICAgICAgICB0eXBlc1RvQXBwbHkucHVzaChjaGlsZFR5cGVOYW1lKTtcbiAgICAgIH1cbiAgICAgIHJvb3RUeXBlID0gdHlwZXNUb0FwcGx5LnBvcCgpO1xuICAgICAgYmFzZVR5cGUgPSBjb21waWxlZFR5cGVzW3Jvb3RUeXBlXS5jbG9uZUZvclJlc291cmNlVHlwZSgpO1xuICAgICAgcmVzdWx0ID0gYmFzZVR5cGU7XG4gICAgICB3aGlsZSAoaW5oZXJpdHNGcm9tID0gdHlwZXNUb0FwcGx5LnBvcCgpKSB7XG4gICAgICAgIGJhc2VUeXBlID0gY29tcGlsZWRUeXBlc1tpbmhlcml0c0Zyb21dLmNsb25lRm9yUmVzb3VyY2VUeXBlKCk7XG4gICAgICAgIHJlc3VsdC5jb21iaW5lKGJhc2VUeXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIFJlc291cmNlVHlwZXMucHJvdG90eXBlLmFwcGx5X3BhcmFtZXRlcnNfdG9fdHlwZSA9IGZ1bmN0aW9uKHJlc291cmNlVXJpLCB0eXBlTmFtZSwgdHlwZUtleSkge1xuICAgICAgdmFyIHBhcmFtZXRlcnMsIHR5cGU7XG4gICAgICBpZiAoISh0eXBlTmFtZSAhPSBudWxsID8gdHlwZU5hbWUudHJpbSgpIDogdm9pZCAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5SZXNvdXJjZVR5cGVFcnJvcignd2hpbGUgYXBwbHlpbmcgcmVzb3VyY2UgdHlwZScsIG51bGwsICdyZXNvdXJjZSB0eXBlIG5hbWUgbXVzdCBiZSBwcm92aWRlZCcsIHR5cGVLZXkuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBpZiAoISh0eXBlID0gdGhpcy5nZXRfdHlwZSh0eXBlTmFtZSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlJlc291cmNlVHlwZUVycm9yKCd3aGlsZSBhcHBseWluZyByZXNvdXJjZSB0eXBlJywgbnVsbCwgXCJ0aGVyZSBpcyBubyByZXNvdXJjZSB0eXBlIG5hbWVkIFwiICsgdHlwZU5hbWUsIHR5cGVLZXkuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICB0eXBlID0gdHlwZVsxXS5jbG9uZSgpO1xuICAgICAgcGFyYW1ldGVycyA9IHRoaXMuX2dldF9wYXJhbWV0ZXJzX2Zyb21fdHlwZV9rZXkocmVzb3VyY2VVcmksIHR5cGVLZXkpO1xuICAgICAgdGhpcy5hcHBseV9wYXJhbWV0ZXJzKHR5cGUsIHBhcmFtZXRlcnMsIHR5cGVLZXkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfTtcblxuICAgIFJlc291cmNlVHlwZXMucHJvdG90eXBlLl9nZXRfcGFyYW1ldGVyc19mcm9tX3R5cGVfa2V5ID0gZnVuY3Rpb24ocmVzb3VyY2VVcmksIHR5cGVLZXkpIHtcbiAgICAgIHZhciBwYXJhbWV0ZXIsIHBhcmFtZXRlcnMsIHJlc2VydmVkLCByZXN1bHQsIF9pLCBfbGVuLCBfcmVmMTtcbiAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgcmVzZXJ2ZWQgPSB7XG4gICAgICAgIHJlc291cmNlUGF0aDogcmVzb3VyY2VVcmkucmVwbGFjZSgvXFwvXFwvKi9nLCAnLycpLFxuICAgICAgICByZXNvdXJjZVBhdGhOYW1lOiB0aGlzLmV4dHJhY3RSZXNvdXJjZVBhdGhOYW1lKHJlc291cmNlVXJpKVxuICAgICAgfTtcbiAgICAgIGlmICh1dGlsLmlzTWFwcGluZyh0eXBlS2V5KSkge1xuICAgICAgICBwYXJhbWV0ZXJzID0gdGhpcy52YWx1ZV9vcl91bmRlZmluZWQodHlwZUtleSk7XG4gICAgICAgIGlmICh1dGlsLmlzTWFwcGluZyhwYXJhbWV0ZXJzWzBdWzFdKSkge1xuICAgICAgICAgIF9yZWYxID0gcGFyYW1ldGVyc1swXVsxXS52YWx1ZTtcbiAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXIgPSBfcmVmMVtfaV07XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVyWzBdLnZhbHVlIGluIHJlc2VydmVkKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlJlc291cmNlVHlwZUVycm9yKCd3aGlsZSBhcHBseWluZyBwYXJhbWV0ZXJzJywgbnVsbCwgXCJpbnZhbGlkIHBhcmFtZXRlciBuYW1lOiBcIiArIHBhcmFtZXRlclswXS52YWx1ZSArIFwiIGlzIHJlc2VydmVkXCIsIHBhcmFtZXRlclswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtwYXJhbWV0ZXJbMF0udmFsdWVdID0gcGFyYW1ldGVyWzFdLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHV0aWwuZXh0ZW5kKHJlc3VsdCwgcmVzZXJ2ZWQpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUmVzb3VyY2VUeXBlcztcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgTWFya2VkWUFNTEVycm9yLCBTaW1wbGVLZXksIHRva2VucywgdXRpbCwgX3JlZixcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBfX3NsaWNlID0gW10uc2xpY2UsXG4gICAgX19pbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH07XG5cbiAgTWFya2VkWUFNTEVycm9yID0gcmVxdWlyZSgnLi9lcnJvcnMnKS5NYXJrZWRZQU1MRXJyb3I7XG5cbiAgdG9rZW5zID0gcmVxdWlyZSgnLi90b2tlbnMnKTtcblxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLypcbiAgVGhlIFNjYW5uZXIgdGhyb3dzIHRoZXNlLlxuICAqL1xuXG5cbiAgdGhpcy5TY2FubmVyRXJyb3IgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNjYW5uZXJFcnJvciwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFNjYW5uZXJFcnJvcigpIHtcbiAgICAgIF9yZWYgPSBTY2FubmVyRXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjtcbiAgICB9XG5cbiAgICByZXR1cm4gU2Nhbm5lckVycm9yO1xuXG4gIH0pKE1hcmtlZFlBTUxFcnJvcik7XG5cbiAgLypcbiAgUmVwcmVzZW50cyBhIHBvc3NpYmxlIHNpbXBsZSBrZXkuXG4gICovXG5cblxuICBTaW1wbGVLZXkgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU2ltcGxlS2V5KHRva2VuX251bWJlciwgcmVxdWlyZWQsIGluZGV4LCBsaW5lLCBjb2x1bW4sIG1hcmspIHtcbiAgICAgIHRoaXMudG9rZW5fbnVtYmVyID0gdG9rZW5fbnVtYmVyO1xuICAgICAgdGhpcy5yZXF1aXJlZCA9IHJlcXVpcmVkO1xuICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG5cbiAgICByZXR1cm4gU2ltcGxlS2V5O1xuXG4gIH0pKCk7XG5cbiAgLypcbiAgVGhlIFNjYW5uZXIgY2xhc3MgZGVhbHMgd2l0aCBjb252ZXJ0aW5nIGEgWUFNTCBzdHJlYW0gaW50byBhIHRva2VuIHN0cmVhbS5cbiAgKi9cblxuXG4gIHRoaXMuU2Nhbm5lciA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgQ19MQiwgQ19OVU1CRVJTLCBDX1dTLCBFU0NBUEVfQ09ERVMsIEVTQ0FQRV9SRVBMQUNFTUVOVFMsIFJBTUxfVkVSU0lPTiwgUkFNTF9WRVJTSU9OX1JFO1xuXG4gICAgQ19MQiA9ICdcXHJcXG5cXHg4NVxcdTIwMjhcXHUyMDI5JztcblxuICAgIENfV1MgPSAnXFx0ICc7XG5cbiAgICBDX05VTUJFUlMgPSAnMDEyMzQ1Njc4OSc7XG5cbiAgICBFU0NBUEVfUkVQTEFDRU1FTlRTID0ge1xuICAgICAgJzAnOiAnXFx4MDAnLFxuICAgICAgJ2EnOiAnXFx4MDcnLFxuICAgICAgJ2InOiAnXFx4MDgnLFxuICAgICAgJ3QnOiAnXFx4MDknLFxuICAgICAgJ1xcdCc6ICdcXHgwOScsXG4gICAgICAnbic6ICdcXHgwQScsXG4gICAgICAndic6ICdcXHgwQicsXG4gICAgICAnZic6ICdcXHgwQycsXG4gICAgICAncic6ICdcXHgwRCcsXG4gICAgICAnZSc6ICdcXHgxQicsXG4gICAgICAnICc6ICdcXHgyMCcsXG4gICAgICAnXCInOiAnXCInLFxuICAgICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgICAnTic6ICdcXHg4NScsXG4gICAgICAnXyc6ICdcXHhBMCcsXG4gICAgICAnTCc6ICdcXHUyMDI4JyxcbiAgICAgICdQJzogJ1xcdTIwMjknXG4gICAgfTtcblxuICAgIEVTQ0FQRV9DT0RFUyA9IHtcbiAgICAgICd4JzogMixcbiAgICAgICd1JzogNCxcbiAgICAgICdVJzogOFxuICAgIH07XG5cbiAgICBSQU1MX1ZFUlNJT04gPSAnIyVSQU1MIDAuOCc7XG5cbiAgICBSQU1MX1ZFUlNJT05fUkUgPSAvXiMlUkFNTCAuKyQvO1xuXG4gICAgLypcbiAgICBJbml0aWFsaXNlIHRoZSBTY2FubmVyXG4gICAgKi9cblxuXG4gICAgZnVuY3Rpb24gU2Nhbm5lcihzZXR0aW5ncykge1xuICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLnJhbWxIZWFkZXJGb3VuZCA9ICF0aGlzLnNldHRpbmdzLnZhbGlkYXRlO1xuICAgICAgdGhpcy5mbG93X2xldmVsID0gMDtcbiAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICB0aGlzLmZldGNoX3N0cmVhbV9zdGFydCgpO1xuICAgICAgdGhpcy50b2tlbnNfdGFrZW4gPSAwO1xuICAgICAgdGhpcy5pbmRlbnQgPSAtMTtcbiAgICAgIHRoaXMuaW5kZW50cyA9IFtdO1xuICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gdHJ1ZTtcbiAgICAgIHRoaXMucG9zc2libGVfc2ltcGxlX2tleXMgPSB7fTtcbiAgICB9XG5cbiAgICAvKlxuICAgIENoZWNrIGlmIHRoZSBuZXh0IHRva2VuIGlzIG9uZSBvZiB0aGUgZ2l2ZW4gdHlwZXMuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuY2hlY2tfdG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaG9pY2UsIGNob2ljZXMsIF9pLCBfbGVuO1xuICAgICAgY2hvaWNlcyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgICB3aGlsZSAodGhpcy5uZWVkX21vcmVfdG9rZW5zKCkpIHtcbiAgICAgICAgdGhpcy5mZXRjaF9tb3JlX3Rva2VucygpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudG9rZW5zLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBpZiAoY2hvaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGNob2ljZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBjaG9pY2UgPSBjaG9pY2VzW19pXTtcbiAgICAgICAgICBpZiAodGhpcy50b2tlbnNbMF0gaW5zdGFuY2VvZiBjaG9pY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHVybiB0aGUgbmV4dCB0b2tlbiwgYnV0IGRvIG5vdCBkZWxldGUgaXQgZnJvbSB0aGUgcXVldWUuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUucGVla190b2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgd2hpbGUgKHRoaXMubmVlZF9tb3JlX3Rva2VucygpKSB7XG4gICAgICAgIHRoaXMuZmV0Y2hfbW9yZV90b2tlbnMoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRva2Vucy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zWzBdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIFJldHVybiB0aGUgbmV4dCB0b2tlbiwgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSBxdWV1ZS5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5nZXRfdG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHdoaWxlICh0aGlzLm5lZWRfbW9yZV90b2tlbnMoKSkge1xuICAgICAgICB0aGlzLmZldGNoX21vcmVfdG9rZW5zKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50b2tlbnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHRoaXMudG9rZW5zX3Rha2VuKys7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2Vucy5zaGlmdCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5uZWVkX21vcmVfdG9rZW5zID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YWxlX3Bvc3NpYmxlX3NpbXBsZV9rZXlzKCk7XG4gICAgICBpZiAodGhpcy5uZXh0X3Bvc3NpYmxlX3NpbXBsZV9rZXkoKSA9PT0gdGhpcy50b2tlbnNfdGFrZW4pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX21vcmVfdG9rZW5zID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2hhcjtcbiAgICAgIHRoaXMuc2Nhbl90b19uZXh0X3Rva2VuKCk7XG4gICAgICB0aGlzLnN0YWxlX3Bvc3NpYmxlX3NpbXBsZV9rZXlzKCk7XG4gICAgICB0aGlzLnVud2luZF9pbmRlbnQodGhpcy5jb2x1bW4pO1xuICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgaWYgKGNoYXIgPT09ICdcXHgwMCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfc3RyZWFtX2VuZCgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09ICclJyAmJiB0aGlzLmNoZWNrX2RpcmVjdGl2ZSgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX2RpcmVjdGl2ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09ICctJyAmJiB0aGlzLmNoZWNrX2RvY3VtZW50X3N0YXJ0KCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZG9jdW1lbnRfc3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSAnLicgJiYgdGhpcy5jaGVja19kb2N1bWVudF9lbmQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9kb2N1bWVudF9lbmQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSAnWycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZmxvd19zZXF1ZW5jZV9zdGFydCgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09ICd7Jykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9mbG93X21hcHBpbmdfc3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSAnXScpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZmxvd19zZXF1ZW5jZV9lbmQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSAnfScpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZmxvd19tYXBwaW5nX2VuZCgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09ICcsJykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9mbG93X2VudHJ5KCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gJy0nICYmIHRoaXMuY2hlY2tfYmxvY2tfZW50cnkoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9ibG9ja19lbnRyeSgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09ICc/JyAmJiB0aGlzLmNoZWNrX2tleSgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX2tleSgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09ICc6JyAmJiB0aGlzLmNoZWNrX3ZhbHVlKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfdmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSAnKicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfYWxpYXMoKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSAnJicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfYW5jaG9yKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gJyEnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoX3RhZygpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09ICd8JyAmJiB0aGlzLmZsb3dfbGV2ZWwgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfbGl0ZXJhbCgpO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09ICc+JyAmJiB0aGlzLmZsb3dfbGV2ZWwgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZm9sZGVkKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gJ1xcJycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfc2luZ2xlKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhciA9PT0gJ1wiJykge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaF9kb3VibGUoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNoZWNrX3BsYWluKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfcGxhaW4oKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgZm9yIHRoZSBuZXh0IHRva2VuJywgbnVsbCwgXCJmb3VuZCBjaGFyYWN0ZXIgXCIgKyBjaGFyICsgXCIgdGhhdCBjYW5ub3Qgc3RhcnQgYW55IHRva2VuXCIsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgUmV0dXJuIHRoZSBudW1iZXIgb2YgdGhlIG5lYXJlc3QgcG9zc2libGUgc2ltcGxlIGtleS5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5uZXh0X3Bvc3NpYmxlX3NpbXBsZV9rZXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrZXksIGxldmVsLCBtaW5fdG9rZW5fbnVtYmVyLCBfcmVmMTtcbiAgICAgIG1pbl90b2tlbl9udW1iZXIgPSBudWxsO1xuICAgICAgX3JlZjEgPSB0aGlzLnBvc3NpYmxlX3NpbXBsZV9rZXlzO1xuICAgICAgZm9yIChsZXZlbCBpbiBfcmVmMSkge1xuICAgICAgICBpZiAoIV9faGFzUHJvcC5jYWxsKF9yZWYxLCBsZXZlbCkpIGNvbnRpbnVlO1xuICAgICAgICBrZXkgPSBfcmVmMVtsZXZlbF07XG4gICAgICAgIGlmIChtaW5fdG9rZW5fbnVtYmVyID09PSBudWxsIHx8IGtleS50b2tlbl9udW1iZXIgPCBtaW5fdG9rZW5fbnVtYmVyKSB7XG4gICAgICAgICAgbWluX3Rva2VuX251bWJlciA9IGtleS50b2tlbl9udW1iZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtaW5fdG9rZW5fbnVtYmVyO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFJlbW92ZSBlbnRyaWVzIHRoYXQgYXJlIG5vIGxvbmdlciBwb3NzaWJsZSBzaW1wbGUga2V5cy4gIEFjY29yZGluZyB0byB0aGVcbiAgICBZQU1MIHNwZWMsIHNpbXBsZSBrZXlzOlxuICAgICAgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gYSBzaW5nbGUgbGluZVxuICAgICAgc2hvdWxkIGJlIG5vIGxvbmdlciB0aGFuIDEwMjQgY2hhcmFjdGVyc1xuICAgIERpc2FibGluZyB0aGlzIHByb2NlZHVyZSB3aWxsIGFsbG93IHNpbXBsZSBrZXlzIG9mIGFueSBsZW5ndGggYW5kIGhlaWdodFxuICAgIChtYXkgY2F1c2UgcHJvYmxlbXMgaWYgaW5kZW50YXRpb24gaXMgYnJva2VuIHRob3VnaCkuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc3RhbGVfcG9zc2libGVfc2ltcGxlX2tleXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrZXksIGxldmVsLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICBfcmVmMSA9IHRoaXMucG9zc2libGVfc2ltcGxlX2tleXM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChsZXZlbCBpbiBfcmVmMSkge1xuICAgICAgICBpZiAoIV9faGFzUHJvcC5jYWxsKF9yZWYxLCBsZXZlbCkpIGNvbnRpbnVlO1xuICAgICAgICBrZXkgPSBfcmVmMVtsZXZlbF07XG4gICAgICAgIGlmIChrZXkubGluZSA9PT0gdGhpcy5saW5lICYmIHRoaXMuaW5kZXggLSBrZXkuaW5kZXggPD0gMTAyNCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgha2V5LnJlcXVpcmVkKSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChkZWxldGUgdGhpcy5wb3NzaWJsZV9zaW1wbGVfa2V5c1tsZXZlbF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBzaW1wbGUga2V5Jywga2V5Lm1hcmssICdjb3VsZCBub3QgZmluZCBleHBlY3RlZCBcXCc6XFwnJywgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFRoZSBuZXh0IHRva2VuIG1heSBzdGFydCBhIHNpbXBsZSBrZXkuICBXZSBjaGVjayBpZiBpdCdzIHBvc3NpYmxlIGFuZCBzYXZlXG4gICAgaXRzIHBvc2l0aW9uLiAgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIEFMSUFTLCBBTkNIT1IsIFRBRyxcbiAgICBTQ0FMQVIgKGZsb3cpLCdbJyBhbmQgJ3snLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNhdmVfcG9zc2libGVfc2ltcGxlX2tleSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlcXVpcmVkLCB0b2tlbl9udW1iZXI7XG4gICAgICByZXF1aXJlZCA9IHRoaXMuZmxvd19sZXZlbCA9PT0gMCAmJiB0aGlzLmluZGVudCA9PT0gdGhpcy5jb2x1bW47XG4gICAgICBpZiAocmVxdWlyZWQgJiYgIXRoaXMuYWxsb3dfc2ltcGxlX2tleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvZ2ljIGZhaWx1cmUnKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5hbGxvd19zaW1wbGVfa2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVtb3ZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKTtcbiAgICAgIHRva2VuX251bWJlciA9IHRoaXMudG9rZW5zX3Rha2VuICsgdGhpcy50b2tlbnMubGVuZ3RoO1xuICAgICAgcmV0dXJuIHRoaXMucG9zc2libGVfc2ltcGxlX2tleXNbdGhpcy5mbG93X2xldmVsXSA9IG5ldyBTaW1wbGVLZXkodG9rZW5fbnVtYmVyLCByZXF1aXJlZCwgdGhpcy5pbmRleCwgdGhpcy5saW5lLCB0aGlzLmNvbHVtbiwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBSZW1vdmUgdGhlIHNhdmVkIHBvc3NpYmxlIHNpbXBsZSBrZXkgYXQgdGhlIGN1cnJlbnQgZmxvdyBsZXZlbC5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5yZW1vdmVfcG9zc2libGVfc2ltcGxlX2tleSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGtleTtcbiAgICAgIGlmICghKGtleSA9IHRoaXMucG9zc2libGVfc2ltcGxlX2tleXNbdGhpcy5mbG93X2xldmVsXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFrZXkucmVxdWlyZWQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZSB0aGlzLnBvc3NpYmxlX3NpbXBsZV9rZXlzW3RoaXMuZmxvd19sZXZlbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgc2ltcGxlIGtleScsIGtleS5tYXJrLCAnY291bGQgbm90IGZpbmQgZXhwZWN0ZWQgXFwnOlxcJycsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qXG4gICAgSW4gZmxvdyBjb250ZXh0LCB0b2tlbnMgc2hvdWxkIHJlc3BlY3QgaW5kZW50YXRpb24uXG4gICAgQWN0dWFsbHkgdGhlIGNvbmRpdGlvbiBzaG91bGQgYmUgYHNlbGYuaW5kZW50ID49IGNvbHVtbmAgYWNjb3JkaW5nIHRvXG4gICAgdGhlIHNwZWMuIEJ1dCB0aGlzIGNvbmRpdGlvbiB3aWxsIHByb2hpYml0IGludHVpdGl2ZWx5IGNvcnJlY3RcbiAgICBjb25zdHJ1Y3Rpb25zIHN1Y2ggYXNcbiAgICAgIGtleSA6IHtcbiAgICAgIH1cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS51bndpbmRfaW5kZW50ID0gZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICB2YXIgbWFyaywgX3Jlc3VsdHM7XG4gICAgICBpZiAodGhpcy5mbG93X2xldmVsICE9PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICB3aGlsZSAodGhpcy5pbmRlbnQgPiBjb2x1bW4pIHtcbiAgICAgICAgbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgICAgdGhpcy5pbmRlbnQgPSB0aGlzLmluZGVudHMucG9wKCk7XG4gICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy50b2tlbnMucHVzaChuZXcgdG9rZW5zLkJsb2NrRW5kVG9rZW4obWFyaywgbWFyaykpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgLypcbiAgICBDaGVjayBpZiB3ZSBuZWVkIHRvIGluY3JlYXNlIGluZGVudGF0aW9uLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmFkZF9pbmRlbnQgPSBmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgIGlmICghKGNvbHVtbiA+IHRoaXMuaW5kZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLmluZGVudHMucHVzaCh0aGlzLmluZGVudCk7XG4gICAgICB0aGlzLmluZGVudCA9IGNvbHVtbjtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9zdHJlYW1fc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXJrO1xuICAgICAgbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKG5ldyB0b2tlbnMuU3RyZWFtU3RhcnRUb2tlbihtYXJrLCBtYXJrLCB0aGlzLmVuY29kaW5nKSk7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX3N0cmVhbV9lbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXJrO1xuICAgICAgdGhpcy51bndpbmRfaW5kZW50KC0xKTtcbiAgICAgIHRoaXMucmVtb3ZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKTtcbiAgICAgIHRoaXMuYWxsb3dfcG9zc2libGVfc2ltcGxlX2tleSA9IGZhbHNlO1xuICAgICAgdGhpcy5wb3NzaWJsZV9zaW1wbGVfa2V5cyA9IHt9O1xuICAgICAgbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2gobmV3IHRva2Vucy5TdHJlYW1FbmRUb2tlbihtYXJrLCBtYXJrKSk7XG4gICAgICByZXR1cm4gdGhpcy5kb25lID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfZGlyZWN0aXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnVud2luZF9pbmRlbnQoLTEpO1xuICAgICAgdGhpcy5yZW1vdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnMucHVzaCh0aGlzLnNjYW5fZGlyZWN0aXZlKCkpO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9kb2N1bWVudF9zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfZG9jdW1lbnRfaW5kaWNhdG9yKHRva2Vucy5Eb2N1bWVudFN0YXJ0VG9rZW4pO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9kb2N1bWVudF9lbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoX2RvY3VtZW50X2luZGljYXRvcih0b2tlbnMuRG9jdW1lbnRFbmRUb2tlbik7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX2RvY3VtZW50X2luZGljYXRvciA9IGZ1bmN0aW9uKFRva2VuQ2xhc3MpIHtcbiAgICAgIHZhciBzdGFydF9tYXJrO1xuICAgICAgdGhpcy51bndpbmRfaW5kZW50KC0xKTtcbiAgICAgIHRoaXMucmVtb3ZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKTtcbiAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IGZhbHNlO1xuICAgICAgc3RhcnRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgIHRoaXMuZm9yd2FyZCgzKTtcbiAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKG5ldyBUb2tlbkNsYXNzKHN0YXJ0X21hcmssIHRoaXMuZ2V0X21hcmsoKSkpO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9mbG93X3NlcXVlbmNlX3N0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaF9mbG93X2NvbGxlY3Rpb25fc3RhcnQodG9rZW5zLkZsb3dTZXF1ZW5jZVN0YXJ0VG9rZW4pO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9mbG93X21hcHBpbmdfc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoX2Zsb3dfY29sbGVjdGlvbl9zdGFydCh0b2tlbnMuRmxvd01hcHBpbmdTdGFydFRva2VuKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfZmxvd19jb2xsZWN0aW9uX3N0YXJ0ID0gZnVuY3Rpb24oVG9rZW5DbGFzcykge1xuICAgICAgdmFyIHN0YXJ0X21hcms7XG4gICAgICB0aGlzLnNhdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgdGhpcy5mbG93X2xldmVsKys7XG4gICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSB0cnVlO1xuICAgICAgc3RhcnRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnB1c2gobmV3IFRva2VuQ2xhc3Moc3RhcnRfbWFyaywgdGhpcy5nZXRfbWFyaygpKSk7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX2Zsb3dfc2VxdWVuY2VfZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaF9mbG93X2NvbGxlY3Rpb25fZW5kKHRva2Vucy5GbG93U2VxdWVuY2VFbmRUb2tlbik7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX2Zsb3dfbWFwcGluZ19lbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoX2Zsb3dfY29sbGVjdGlvbl9lbmQodG9rZW5zLkZsb3dNYXBwaW5nRW5kVG9rZW4pO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9mbG93X2NvbGxlY3Rpb25fZW5kID0gZnVuY3Rpb24oVG9rZW5DbGFzcykge1xuICAgICAgdmFyIHN0YXJ0X21hcms7XG4gICAgICB0aGlzLnJlbW92ZV9wb3NzaWJsZV9zaW1wbGVfa2V5KCk7XG4gICAgICB0aGlzLmZsb3dfbGV2ZWwtLTtcbiAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IGZhbHNlO1xuICAgICAgc3RhcnRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnB1c2gobmV3IFRva2VuQ2xhc3Moc3RhcnRfbWFyaywgdGhpcy5nZXRfbWFyaygpKSk7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX2Zsb3dfZW50cnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdGFydF9tYXJrO1xuICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVtb3ZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKTtcbiAgICAgIHN0YXJ0X21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKG5ldyB0b2tlbnMuRmxvd0VudHJ5VG9rZW4oc3RhcnRfbWFyaywgdGhpcy5nZXRfbWFyaygpKSk7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX2Jsb2NrX2VudHJ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFyaywgc3RhcnRfbWFyaztcbiAgICAgIGlmICh0aGlzLmZsb3dfbGV2ZWwgPT09IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsbG93X3NpbXBsZV9rZXkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IobnVsbCwgbnVsbCwgJ3NlcXVlbmNlIGVudHJpZXMgYXJlIG5vdCBhbGxvd2VkIGhlcmUnLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFkZF9pbmRlbnQodGhpcy5jb2x1bW4pKSB7XG4gICAgICAgICAgbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKG5ldyB0b2tlbnMuQmxvY2tTZXF1ZW5jZVN0YXJ0VG9rZW4obWFyaywgbWFyaykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSB0cnVlO1xuICAgICAgdGhpcy5yZW1vdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgc3RhcnRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnB1c2gobmV3IHRva2Vucy5CbG9ja0VudHJ5VG9rZW4oc3RhcnRfbWFyaywgdGhpcy5nZXRfbWFyaygpKSk7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX2tleSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1hcmssIHN0YXJ0X21hcms7XG4gICAgICBpZiAodGhpcy5mbG93X2xldmVsID09PSAwKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxvd19zaW1wbGVfa2V5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKG51bGwsIG51bGwsICdtYXBwaW5nIGtleXMgYXJlIG5vdCBhbGxvd2VkIGhlcmUnLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFkZF9pbmRlbnQodGhpcy5jb2x1bW4pKSB7XG4gICAgICAgICAgbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKG5ldyB0b2tlbnMuQmxvY2tNYXBwaW5nU3RhcnRUb2tlbihtYXJrLCBtYXJrKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9ICF0aGlzLmZsb3dfbGV2ZWw7XG4gICAgICB0aGlzLnJlbW92ZV9wb3NzaWJsZV9zaW1wbGVfa2V5KCk7XG4gICAgICBzdGFydF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnMucHVzaChuZXcgdG9rZW5zLktleVRva2VuKHN0YXJ0X21hcmssIHRoaXMuZ2V0X21hcmsoKSkpO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF92YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGtleSwgbWFyaywgc3RhcnRfbWFyaztcbiAgICAgIGlmIChrZXkgPSB0aGlzLnBvc3NpYmxlX3NpbXBsZV9rZXlzW3RoaXMuZmxvd19sZXZlbF0pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMucG9zc2libGVfc2ltcGxlX2tleXNbdGhpcy5mbG93X2xldmVsXTtcbiAgICAgICAgdGhpcy50b2tlbnMuc3BsaWNlKGtleS50b2tlbl9udW1iZXIgLSB0aGlzLnRva2Vuc190YWtlbiwgMCwgbmV3IHRva2Vucy5LZXlUb2tlbihrZXkubWFyaywga2V5Lm1hcmspKTtcbiAgICAgICAgaWYgKHRoaXMuZmxvd19sZXZlbCA9PT0gMCkge1xuICAgICAgICAgIGlmICh0aGlzLmFkZF9pbmRlbnQoa2V5LmNvbHVtbikpIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW5zLnNwbGljZShrZXkudG9rZW5fbnVtYmVyIC0gdGhpcy50b2tlbnNfdGFrZW4sIDAsIG5ldyB0b2tlbnMuQmxvY2tNYXBwaW5nU3RhcnRUb2tlbihrZXkubWFyaywga2V5Lm1hcmspKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5mbG93X2xldmVsID09PSAwKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmFsbG93X3NpbXBsZV9rZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcihudWxsLCBudWxsLCAnbWFwcGluZyB2YWx1ZXMgYXJlIG5vdCBhbGxvd2VkIGhlcmUnLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5hZGRfaW5kZW50KHRoaXMuY29sdW1uKSkge1xuICAgICAgICAgICAgbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgICAgICAgIHRoaXMudG9rZW5zLnB1c2gobmV3IHRva2Vucy5CbG9ja01hcHBpbmdTdGFydFRva2VuKG1hcmssIG1hcmspKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gIXRoaXMuZmxvd19sZXZlbDtcbiAgICAgICAgdGhpcy5yZW1vdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgfVxuICAgICAgc3RhcnRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnB1c2gobmV3IHRva2Vucy5WYWx1ZVRva2VuKHN0YXJ0X21hcmssIHRoaXMuZ2V0X21hcmsoKSkpO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9hbGlhcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zYXZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKTtcbiAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnB1c2godGhpcy5zY2FuX2FuY2hvcih0b2tlbnMuQWxpYXNUb2tlbikpO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9hbmNob3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2F2ZV9wb3NzaWJsZV9zaW1wbGVfa2V5KCk7XG4gICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLnRva2Vucy5wdXNoKHRoaXMuc2Nhbl9hbmNob3IodG9rZW5zLkFuY2hvclRva2VuKSk7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX3RhZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zYXZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKTtcbiAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnB1c2godGhpcy5zY2FuX3RhZygpKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfbGl0ZXJhbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfYmxvY2tfc2NhbGFyKCd8Jyk7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX2ZvbGRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hfYmxvY2tfc2NhbGFyKCc+Jyk7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX2Jsb2NrX3NjYWxhciA9IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSB0cnVlO1xuICAgICAgdGhpcy5yZW1vdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnB1c2godGhpcy5zY2FuX2Jsb2NrX3NjYWxhcihzdHlsZSkpO1xuICAgIH07XG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5mZXRjaF9zaW5nbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoX2Zsb3dfc2NhbGFyKCdcXCcnKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaF9mbG93X3NjYWxhcignXCInKTtcbiAgICB9O1xuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuZmV0Y2hfZmxvd19zY2FsYXIgPSBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgdGhpcy5zYXZlX3Bvc3NpYmxlX3NpbXBsZV9rZXkoKTtcbiAgICAgIHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnB1c2godGhpcy5zY2FuX2Zsb3dfc2NhbGFyKHN0eWxlKSk7XG4gICAgfTtcblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmZldGNoX3BsYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNhdmVfcG9zc2libGVfc2ltcGxlX2tleSgpO1xuICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnMucHVzaCh0aGlzLnNjYW5fcGxhaW4oKSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgRElSRUNUSVZFOiBeICclJ1xuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmNoZWNrX2RpcmVjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY29sdW1uID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKlxuICAgIERPQ1VNRU5ULVNUQVJUOiBeICctLS0nICgnICd8J1xcbicpXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuY2hlY2tfZG9jdW1lbnRfc3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfcmVmMTtcbiAgICAgIGlmICh0aGlzLmNvbHVtbiA9PT0gMCAmJiB0aGlzLnByZWZpeCgzKSA9PT0gJy0tLScgJiYgKF9yZWYxID0gdGhpcy5wZWVrKDMpLCBfX2luZGV4T2YuY2FsbChDX0xCICsgQ19XUyArICdcXHgwMCcsIF9yZWYxKSA+PSAwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBET0NVTUVOVC1FTkQ6IF4gJy4uLicgKCcgJ3wnXFxuJylcbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5jaGVja19kb2N1bWVudF9lbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfcmVmMTtcbiAgICAgIGlmICh0aGlzLmNvbHVtbiA9PT0gMCAmJiB0aGlzLnByZWZpeCgzKSA9PT0gJy4uLicgJiYgKF9yZWYxID0gdGhpcy5wZWVrKDMpLCBfX2luZGV4T2YuY2FsbChDX0xCICsgQ19XUyArICdcXHgwMCcsIF9yZWYxKSA+PSAwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBCTE9DSy1FTlRSWTogJy0nICgnICd8J1xcbicpXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuY2hlY2tfYmxvY2tfZW50cnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfcmVmMTtcbiAgICAgIHJldHVybiBfcmVmMSA9IHRoaXMucGVlaygxKSwgX19pbmRleE9mLmNhbGwoQ19MQiArIENfV1MgKyAnXFx4MDAnLCBfcmVmMSkgPj0gMDtcbiAgICB9O1xuXG4gICAgLypcbiAgICBLRVkgKGZsb3cgY29udGV4dCk6ICAnPydcbiAgICBLRVkgKGJsb2NrIGNvbnRleHQpOiAnPycgKCcgJ3wnXFxuJylcbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5jaGVja19rZXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfcmVmMTtcbiAgICAgIGlmICh0aGlzLmZsb3dfbGV2ZWwgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3JlZjEgPSB0aGlzLnBlZWsoMSksIF9faW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwJywgX3JlZjEpID49IDA7XG4gICAgfTtcblxuICAgIC8qXG4gICAgVkFMVUUgKGZsb3cgY29udGV4dCk6ICAnOidcbiAgICBWQUxVRSAoYmxvY2sgY29udGV4dCk6ICc6JyAoJyAnfCdcXG4nKVxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLmNoZWNrX3ZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZjE7XG4gICAgICBpZiAodGhpcy5mbG93X2xldmVsICE9PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZWYxID0gdGhpcy5wZWVrKDEpLCBfX2luZGV4T2YuY2FsbChDX0xCICsgQ19XUyArICdcXHgwMCcsIF9yZWYxKSA+PSAwO1xuICAgIH07XG5cbiAgICAvKlxuICAgIEEgcGxhaW4gc2NhbGFyIG1heSBzdGFydCB3aXRoIGFueSBub24tc3BhY2UgY2hhcmFjdGVyIGV4Y2VwdDpcbiAgICAgICctJywgJz8nLCAnOicsICcsJywgJ1snLCAnXScsICd7JywgJ30nLFxuICAgICAgJyMnLCAnJicsICcqJywgJyEnLCAnfCcsICc+JywgJ1xcJycsICdcIicsXG4gICAgICAnJScsICdAJywgJ2AnLlxuICAgIFxuICAgIEl0IG1heSBhbHNvIHN0YXJ0IHdpdGhcbiAgICAgICctJywgJz8nLCAnOidcbiAgICBpZiBpdCBpcyBmb2xsb3dlZCBieSBhIG5vbi1zcGFjZSBjaGFyYWN0ZXIuXG4gICAgXG4gICAgTm90ZSB0aGF0IHdlIGxpbWl0IHRoZSBsYXN0IHJ1bGUgdG8gdGhlIGJsb2NrIGNvbnRleHQgKGV4Y2VwdCB0aGUgJy0nXG4gICAgY2hhcmFjdGVyKSBiZWNhdXNlIHdlIHdhbnQgdGhlIGZsb3cgY29udGV4dCB0byBiZSBzcGFjZSBpbmRlcGVuZGVudC5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5jaGVja19wbGFpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNoYXIsIF9yZWYxO1xuICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgcmV0dXJuIF9faW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwLT86LFtde30jJiohfD5cXCdcIiVAYCcsIGNoYXIpIDwgMCB8fCAoKF9yZWYxID0gdGhpcy5wZWVrKDEpLCBfX2luZGV4T2YuY2FsbChDX0xCICsgQ19XUyArICdcXHgwMCcsIF9yZWYxKSA8IDApICYmIChjaGFyID09PSAnLScgfHwgKHRoaXMuZmxvd19sZXZlbCA9PT0gMCAmJiBfX2luZGV4T2YuY2FsbCgnPzonLCBjaGFyKSA+PSAwKSkpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFdlIGlnbm9yZSBzcGFjZXMsIGxpbmUgYnJlYWtzIGFuZCBjb21tZW50cy5cbiAgICBJZiB3ZSBmaW5kIGEgbGluZSBicmVhayBpbiB0aGUgYmxvY2sgY29udGV4dCwgd2Ugc2V0IHRoZSBmbGFnXG4gICAgYGFsbG93X3NpbXBsZV9rZXlgIG9uLlxuICAgIFRoZSBieXRlIG9yZGVyIG1hcmsgaXMgc3RyaXBwZWQgaWYgaXQncyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSBzdHJlYW0uXG4gICAgV2UgZG8gbm90IHlldCBzdXBwb3J0IEJPTSBpbnNpZGUgdGhlIHN0cmVhbSBhcyB0aGUgc3BlY2lmaWNhdGlvbiByZXF1aXJlcy5cbiAgICBBbnkgc3VjaCBtYXJrIHdpbGwgYmUgY29uc2lkZXJlZCBhcyBhIHBhcnQgb2YgdGhlIGRvY3VtZW50LlxuICAgIFxuICAgIFRPRE86IFdlIG5lZWQgdG8gbWFrZSB0YWIgaGFuZGxpbmcgcnVsZXMgbW9yZSBzYW5lLiAgQSBnb29kIHJ1bGUgaXNcbiAgICAgIFRhYnMgY2Fubm90IHByZWNlZGUgdG9rZW5zIEJMT0NLLVNFUVVFTkNFLVNUQVJULCBCTE9DSy1NQVBQSU5HLVNUQVJULFxuICAgICAgQkxPQ0stRU5ELCBLRVkgKGJsb2NrIGNvbnRleHQpLCBWQUxVRSAoYmxvY2sgY29udGV4dCksIEJMT0NLLUVOVFJZXG4gICAgU28gdGhlIHRhYiBjaGVja2luZyBjb2RlIGlzXG4gICAgICBAYWxsb3dfc2ltcGxlX2tleSA9IG9mZiBpZiA8VEFCPlxuICAgIFdlIGFsc28gbmVlZCB0byBhZGQgdGhlIGNoZWNrIGZvciBgYWxsb3dfc2ltcGxlX2tleSBpcyBvbmAgdG9cbiAgICBgdW53aW5kX2luZGVudGAgYmVmb3JlIGlzc3VpbmcgQkxPQ0stRU5ELiAgU2Nhbm5lcnMgZm9yIGJsb2NrLCBmbG93IGFuZFxuICAgIHBsYWluIHNjYWxhcnMgbmVlZCB0byBiZSBtb2RpZmllZC5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX3RvX25leHRfdG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb21tZW50LCBmb3VuZCwgdHJpbW1lZENvbW1lbnQsIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgIGlmICh0aGlzLmluZGV4ID09PSAwICYmIHRoaXMucGVlaygpID09PSAnXFx1RkVGRicpIHtcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICB9XG4gICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIHdoaWxlICghZm91bmQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMucGVlaygpID09PSAnICcpIHtcbiAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb21tZW50ID0gJyc7XG4gICAgICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gJyMnKSB7XG4gICAgICAgICAgd2hpbGUgKF9yZWYxID0gdGhpcy5wZWVrKCksIF9faW5kZXhPZi5jYWxsKENfTEIgKyAnXFx4MDAnLCBfcmVmMSkgPCAwKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmFtbEhlYWRlckZvdW5kKSB7XG4gICAgICAgICAgICAgIGNvbW1lbnQgKz0gdGhpcy5wZWVrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnJhbWxIZWFkZXJGb3VuZCkge1xuICAgICAgICAgIHRyaW1tZWRDb21tZW50ID0gY29tbWVudC50cmltKCk7XG4gICAgICAgICAgaWYgKHRyaW1tZWRDb21tZW50ICYmIFJBTUxfVkVSU0lPTl9SRS50ZXN0KHRyaW1tZWRDb21tZW50KSkge1xuICAgICAgICAgICAgaWYgKHRyaW1tZWRDb21tZW50ID09PSBSQU1MX1ZFUlNJT04pIHtcbiAgICAgICAgICAgICAgdGhpcy5yYW1sSGVhZGVyRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd2ZXJzaW9uIHZhbGlkYXRpb24nLCBudWxsLCBcIlVuc3VwcG9ydGVkIFJBTUwgdmVyc2lvbjogJ1wiICsgY29tbWVudCArIFwiJ1wiLCB0aGlzLmNyZWF0ZV9tYXJrKDAsIDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd2ZXJzaW9uIHZhbGlkYXRpb24nLCBudWxsLCBcIlRoZSBmaXJzdCBsaW5lIG11c3QgYmU6ICdcIiArIFJBTUxfVkVSU0lPTiArIFwiJ1wiLCB0aGlzLmNyZWF0ZV9tYXJrKDAsIDApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2Nhbl9saW5lX2JyZWFrKCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5mbG93X2xldmVsID09PSAwKSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMuYWxsb3dfc2ltcGxlX2tleSA9IHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goZm91bmQgPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX2RpcmVjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVuZF9tYXJrLCBuYW1lLCBzdGFydF9tYXJrLCB2YWx1ZSwgX3JlZjE7XG4gICAgICBzdGFydF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICBuYW1lID0gdGhpcy5zY2FuX2RpcmVjdGl2ZV9uYW1lKHN0YXJ0X21hcmspO1xuICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgaWYgKG5hbWUgPT09ICdZQU1MJykge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuc2Nhbl95YW1sX2RpcmVjdGl2ZV92YWx1ZShzdGFydF9tYXJrKTtcbiAgICAgICAgZW5kX21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdUQUcnKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5zY2FuX3RhZ19kaXJlY3RpdmVfdmFsdWUoc3RhcnRfbWFyayk7XG4gICAgICAgIGVuZF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kX21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICAgIHdoaWxlIChfcmVmMSA9IHRoaXMucGVlaygpLCBfX2luZGV4T2YuY2FsbChDX0xCICsgJ1xceDAwJywgX3JlZjEpIDwgMCkge1xuICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnNjYW5fZGlyZWN0aXZlX2lnbm9yZWRfbGluZShzdGFydF9tYXJrKTtcbiAgICAgIHJldHVybiBuZXcgdG9rZW5zLkRpcmVjdGl2ZVRva2VuKG5hbWUsIHZhbHVlLCBzdGFydF9tYXJrLCBlbmRfbWFyayk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fZGlyZWN0aXZlX25hbWUgPSBmdW5jdGlvbihzdGFydF9tYXJrKSB7XG4gICAgICB2YXIgY2hhciwgbGVuZ3RoLCB2YWx1ZTtcbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgICBjaGFyID0gdGhpcy5wZWVrKGxlbmd0aCk7XG4gICAgICB3aGlsZSAoKCcwJyA8PSBjaGFyICYmIGNoYXIgPD0gJzknKSB8fCAoJ0EnIDw9IGNoYXIgJiYgY2hhciA8PSAnWicpIHx8ICgnYScgPD0gY2hhciAmJiBjaGFyIDw9ICd6JykgfHwgX19pbmRleE9mLmNhbGwoJy1fJywgY2hhcikgPj0gMCkge1xuICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgY2hhciA9IHRoaXMucGVlayhsZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgZGlyZWN0aXZlJywgc3RhcnRfbWFyaywgXCJleHBlY3RlZCBhbHBoYW51bWVyaWMgb3IgbnVtZXJpYyBjaGFyYWN0ZXIgYnV0IGZvdW5kIFwiICsgY2hhciwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdGhpcy5wcmVmaXgobGVuZ3RoKTtcbiAgICAgIHRoaXMuZm9yd2FyZChsZW5ndGgpO1xuICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKENfTEIgKyAnXFx4MDAgJywgY2hhcikgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBkaXJlY3RpdmUnLCBzdGFydF9tYXJrLCBcImV4cGVjdGVkIGFscGhhbnVtZXJpYyBvciBudW1lcmljIGNoYXJhY3RlciBidXQgZm91bmQgXCIgKyBjaGFyLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX3lhbWxfZGlyZWN0aXZlX3ZhbHVlID0gZnVuY3Rpb24oc3RhcnRfbWFyaykge1xuICAgICAgdmFyIG1ham9yLCBtaW5vciwgX3JlZjE7XG4gICAgICB3aGlsZSAodGhpcy5wZWVrKCkgPT09ICcgJykge1xuICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIH1cbiAgICAgIG1ham9yID0gdGhpcy5zY2FuX3lhbWxfZGlyZWN0aXZlX251bWJlcihzdGFydF9tYXJrKTtcbiAgICAgIGlmICh0aGlzLnBlZWsoKSAhPT0gJy4nKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBkaXJlY3RpdmUnLCBzdGFydF9tYXJrLCBcImV4cGVjdGVkIGEgZGlnaXQgb3IgJy4nIGJ1dCBmb3VuZCBcIiArICh0aGlzLnBlZWsoKSksIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIG1pbm9yID0gdGhpcy5zY2FuX3lhbWxfZGlyZWN0aXZlX251bWJlcihzdGFydF9tYXJrKTtcbiAgICAgIGlmIChfcmVmMSA9IHRoaXMucGVlaygpLCBfX2luZGV4T2YuY2FsbChDX0xCICsgJ1xceDAwICcsIF9yZWYxKSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIGRpcmVjdGl2ZScsIHN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgYSBkaWdpdCBvciAnICcgYnV0IGZvdW5kIFwiICsgKHRoaXMucGVlaygpKSwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbbWFqb3IsIG1pbm9yXTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl95YW1sX2RpcmVjdGl2ZV9udW1iZXIgPSBmdW5jdGlvbihzdGFydF9tYXJrKSB7XG4gICAgICB2YXIgY2hhciwgbGVuZ3RoLCB2YWx1ZSwgX3JlZjE7XG4gICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICBpZiAoISgoJzAnIDw9IGNoYXIgJiYgY2hhciA8PSAnOScpKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgZGlyZWN0aXZlJywgc3RhcnRfbWFyaywgXCJleHBlY3RlZCBhIGRpZ2l0IGJ1dCBmb3VuZCBcIiArIGNoYXIsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSAwO1xuICAgICAgd2hpbGUgKCgnMCcgPD0gKF9yZWYxID0gdGhpcy5wZWVrKGxlbmd0aCkpICYmIF9yZWYxIDw9ICc5JykpIHtcbiAgICAgICAgbGVuZ3RoKys7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHBhcnNlSW50KHRoaXMucHJlZml4KGxlbmd0aCkpO1xuICAgICAgdGhpcy5mb3J3YXJkKGxlbmd0aCk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fdGFnX2RpcmVjdGl2ZV92YWx1ZSA9IGZ1bmN0aW9uKHN0YXJ0X21hcmspIHtcbiAgICAgIHZhciBoYW5kbGUsIHByZWZpeDtcbiAgICAgIHdoaWxlICh0aGlzLnBlZWsoKSA9PT0gJyAnKSB7XG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgfVxuICAgICAgaGFuZGxlID0gdGhpcy5zY2FuX3RhZ19kaXJlY3RpdmVfaGFuZGxlKHN0YXJ0X21hcmspO1xuICAgICAgd2hpbGUgKHRoaXMucGVlaygpID09PSAnICcpIHtcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICB9XG4gICAgICBwcmVmaXggPSB0aGlzLnNjYW5fdGFnX2RpcmVjdGl2ZV9wcmVmaXgoc3RhcnRfbWFyayk7XG4gICAgICByZXR1cm4gW2hhbmRsZSwgcHJlZml4XTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl90YWdfZGlyZWN0aXZlX2hhbmRsZSA9IGZ1bmN0aW9uKHN0YXJ0X21hcmspIHtcbiAgICAgIHZhciBjaGFyLCB2YWx1ZTtcbiAgICAgIHZhbHVlID0gdGhpcy5zY2FuX3RhZ19oYW5kbGUoJ2RpcmVjdGl2ZScsIHN0YXJ0X21hcmspO1xuICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgaWYgKGNoYXIgIT09ICcgJykge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgZGlyZWN0aXZlJywgc3RhcnRfbWFyaywgXCJleHBlY3RlZCAnICcgYnV0IGZvdW5kIFwiICsgY2hhciwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl90YWdfZGlyZWN0aXZlX3ByZWZpeCA9IGZ1bmN0aW9uKHN0YXJ0X21hcmspIHtcbiAgICAgIHZhciBjaGFyLCB2YWx1ZTtcbiAgICAgIHZhbHVlID0gdGhpcy5zY2FuX3RhZ191cmkoJ2RpcmVjdGl2ZScsIHN0YXJ0X21hcmspO1xuICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKENfTEIgKyAnXFx4MDAgJywgY2hhcikgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBkaXJlY3RpdmUnLCBzdGFydF9tYXJrLCBcImV4cGVjdGVkICcgJyBidXQgZm91bmQgXCIgKyBjaGFyLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX2RpcmVjdGl2ZV9pZ25vcmVkX2xpbmUgPSBmdW5jdGlvbihzdGFydF9tYXJrKSB7XG4gICAgICB2YXIgY2hhciwgX3JlZjE7XG4gICAgICB3aGlsZSAodGhpcy5wZWVrKCkgPT09ICcgJykge1xuICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gJyMnKSB7XG4gICAgICAgIHdoaWxlIChfcmVmMSA9IHRoaXMucGVlaygpLCBfX2luZGV4T2YuY2FsbChDX0xCICsgJ1xceDAwJywgX3JlZjEpIDwgMCkge1xuICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICBpZiAoX19pbmRleE9mLmNhbGwoQ19MQiArICdcXHgwMCcsIGNoYXIpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgZGlyZWN0aXZlJywgc3RhcnRfbWFyaywgXCJleHBlY3RlZCBhIGNvbW1lbnQgb3IgYSBsaW5lIGJyZWFrIGJ1dCBmb3VuZCBcIiArIGNoYXIsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zY2FuX2xpbmVfYnJlYWsoKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBUaGUgc3BlY2lmaWNhdGlvbiBkb2VzIG5vdCByZXN0cmljdCBjaGFyYWN0ZXJzIGZvciBhbmNob3JzIGFuZCBhbGlhc2VzLlxuICAgIFRoaXMgbWF5IGxlYWQgdG8gcHJvYmxlbXMsIGZvciBpbnN0YW5jZSwgdGhlIGRvY3VtZW50OlxuICAgICAgWyAqYWxpYXMsIHZhbHVlIF1cbiAgICBjYW4gYmUgaW50ZXJwdGV0ZWQgaW4gdHdvIHdheXMsIGFzXG4gICAgICBbIFwidmFsdWVcIiBdXG4gICAgYW5kXG4gICAgICBbICphbGlhcyAsIFwidmFsdWVcIiBdXG4gICAgVGhlcmVmb3JlIHdlIHJlc3RyaWN0IGFsaWFzZXMgdG8gbnVtYmVycyBhbmQgQVNDSUkgbGV0dGVycy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX2FuY2hvciA9IGZ1bmN0aW9uKFRva2VuQ2xhc3MpIHtcbiAgICAgIHZhciBjaGFyLCBpbmRpY2F0b3IsIGxlbmd0aCwgbmFtZSwgc3RhcnRfbWFyaywgdmFsdWU7XG4gICAgICBzdGFydF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgaW5kaWNhdG9yID0gdGhpcy5wZWVrKCk7XG4gICAgICBpZiAoaW5kaWNhdG9yID09PSAnKicpIHtcbiAgICAgICAgbmFtZSA9ICdhbGlhcyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lID0gJ2FuY2hvcic7XG4gICAgICB9XG4gICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgICBjaGFyID0gdGhpcy5wZWVrKGxlbmd0aCk7XG4gICAgICB3aGlsZSAoKCcwJyA8PSBjaGFyICYmIGNoYXIgPD0gJzknKSB8fCAoJ0EnIDw9IGNoYXIgJiYgY2hhciA8PSAnWicpIHx8ICgnYScgPD0gY2hhciAmJiBjaGFyIDw9ICd6JykgfHwgX19pbmRleE9mLmNhbGwoJy1fJywgY2hhcikgPj0gMCkge1xuICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgY2hhciA9IHRoaXMucGVlayhsZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoXCJ3aGlsZSBzY2FubmluZyBhbiBcIiArIG5hbWUsIHN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgYWxwaGFiZXRpYyBvciBudW1lcmljIGNoYXJhY3RlciBidXQgZm91bmQgJ1wiICsgY2hhciArIFwiJ1wiLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB0aGlzLnByZWZpeChsZW5ndGgpO1xuICAgICAgdGhpcy5mb3J3YXJkKGxlbmd0aCk7XG4gICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICBpZiAoX19pbmRleE9mLmNhbGwoQ19MQiArIENfV1MgKyAnXFx4MDAnICsgJz86LF19JUBgJywgY2hhcikgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcihcIndoaWxlIHNjYW5uaW5nIGFuIFwiICsgbmFtZSwgc3RhcnRfbWFyaywgXCJleHBlY3RlZCBhbHBoYWJldGljIG9yIG51bWVyaWMgY2hhcmFjdGVyIGJ1dCBmb3VuZCAnXCIgKyBjaGFyICsgXCInXCIsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFRva2VuQ2xhc3ModmFsdWUsIHN0YXJ0X21hcmssIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fdGFnID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2hhciwgaGFuZGxlLCBsZW5ndGgsIHN0YXJ0X21hcmssIHN1ZmZpeCwgdXNlX2hhbmRsZTtcbiAgICAgIHN0YXJ0X21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICBjaGFyID0gdGhpcy5wZWVrKDEpO1xuICAgICAgaWYgKGNoYXIgPT09ICc8Jykge1xuICAgICAgICBoYW5kbGUgPSBudWxsO1xuICAgICAgICB0aGlzLmZvcndhcmQoMik7XG4gICAgICAgIHN1ZmZpeCA9IHRoaXMuc2Nhbl90YWdfdXJpKCd0YWcnLCBzdGFydF9tYXJrKTtcbiAgICAgICAgaWYgKHRoaXMucGVlaygpICE9PSAnPicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHBhcnNpbmcgYSB0YWcnLCBzdGFydF9tYXJrLCBcImV4cGVjdGVkICc+JyBidXQgZm91bmQgXCIgKyAodGhpcy5wZWVrKCkpLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgfSBlbHNlIGlmIChfX2luZGV4T2YuY2FsbChDX0xCICsgQ19XUyArICdcXHgwMCcsIGNoYXIpID49IDApIHtcbiAgICAgICAgaGFuZGxlID0gbnVsbDtcbiAgICAgICAgc3VmZml4ID0gJyEnO1xuICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIHVzZV9oYW5kbGUgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKF9faW5kZXhPZi5jYWxsKENfTEIgKyAnXFx4MDAgJywgY2hhcikgPCAwKSB7XG4gICAgICAgICAgaWYgKGNoYXIgPT09ICchJykge1xuICAgICAgICAgICAgdXNlX2hhbmRsZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgICAgY2hhciA9IHRoaXMucGVlayhsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VfaGFuZGxlKSB7XG4gICAgICAgICAgaGFuZGxlID0gdGhpcy5zY2FuX3RhZ19oYW5kbGUoJ3RhZycsIHN0YXJ0X21hcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZSA9ICchJztcbiAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgfVxuICAgICAgICBzdWZmaXggPSB0aGlzLnNjYW5fdGFnX3VyaSgndGFnJywgc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICBpZiAoX19pbmRleE9mLmNhbGwoQ19MQiArICdcXHgwMCAnLCBjaGFyKSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIHRhZycsIHN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgJyAnIGJ1dCBmb3VuZCBcIiArIGNoYXIsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IHRva2Vucy5UYWdUb2tlbihbaGFuZGxlLCBzdWZmaXhdLCBzdGFydF9tYXJrLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX2Jsb2NrX3NjYWxhciA9IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICB2YXIgYnJlYWtzLCBjaG9tcGluZywgY2h1bmtzLCBlbmRfbWFyaywgZm9sZGVkLCBpbmNyZW1lbnQsIGluZGVudCwgbGVhZGluZ19ub25fc3BhY2UsIGxlbmd0aCwgbGluZV9icmVhaywgbWF4X2luZGVudCwgbWluX2luZGVudCwgc3RhcnRfbWFyaywgX3JlZjEsIF9yZWYyLCBfcmVmMywgX3JlZjQsIF9yZWY1LCBfcmVmNiwgX3JlZjc7XG4gICAgICBmb2xkZWQgPSBzdHlsZSA9PT0gJz4nO1xuICAgICAgY2h1bmtzID0gW107XG4gICAgICBzdGFydF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICBfcmVmMSA9IHRoaXMuc2Nhbl9ibG9ja19zY2FsYXJfaW5kaWNhdG9ycyhzdGFydF9tYXJrKSwgY2hvbXBpbmcgPSBfcmVmMVswXSwgaW5jcmVtZW50ID0gX3JlZjFbMV07XG4gICAgICB0aGlzLnNjYW5fYmxvY2tfc2NhbGFyX2lnbm9yZWRfbGluZShzdGFydF9tYXJrKTtcbiAgICAgIG1pbl9pbmRlbnQgPSB0aGlzLmluZGVudCArIDE7XG4gICAgICBpZiAobWluX2luZGVudCA8IDEpIHtcbiAgICAgICAgbWluX2luZGVudCA9IDE7XG4gICAgICB9XG4gICAgICBpZiAoaW5jcmVtZW50ID09IG51bGwpIHtcbiAgICAgICAgX3JlZjIgPSB0aGlzLnNjYW5fYmxvY2tfc2NhbGFyX2luZGVudGF0aW9uKCksIGJyZWFrcyA9IF9yZWYyWzBdLCBtYXhfaW5kZW50ID0gX3JlZjJbMV0sIGVuZF9tYXJrID0gX3JlZjJbMl07XG4gICAgICAgIGluZGVudCA9IE1hdGgubWF4KG1pbl9pbmRlbnQsIG1heF9pbmRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZW50ID0gbWluX2luZGVudCArIGluY3JlbWVudCAtIDE7XG4gICAgICAgIF9yZWYzID0gdGhpcy5zY2FuX2Jsb2NrX3NjYWxhcl9icmVha3MoaW5kZW50KSwgYnJlYWtzID0gX3JlZjNbMF0sIGVuZF9tYXJrID0gX3JlZjNbMV07XG4gICAgICB9XG4gICAgICBsaW5lX2JyZWFrID0gJyc7XG4gICAgICB3aGlsZSAodGhpcy5jb2x1bW4gPT09IGluZGVudCAmJiB0aGlzLnBlZWsoKSAhPT0gJ1xceDAwJykge1xuICAgICAgICBjaHVua3MgPSBjaHVua3MuY29uY2F0KGJyZWFrcyk7XG4gICAgICAgIGxlYWRpbmdfbm9uX3NwYWNlID0gKF9yZWY0ID0gdGhpcy5wZWVrKCksIF9faW5kZXhPZi5jYWxsKCcgXFx0JywgX3JlZjQpIDwgMCk7XG4gICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICAgIHdoaWxlIChfcmVmNSA9IHRoaXMucGVlayhsZW5ndGgpLCBfX2luZGV4T2YuY2FsbChDX0xCICsgJ1xceDAwJywgX3JlZjUpIDwgMCkge1xuICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICB9XG4gICAgICAgIGNodW5rcy5wdXNoKHRoaXMucHJlZml4KGxlbmd0aCkpO1xuICAgICAgICB0aGlzLmZvcndhcmQobGVuZ3RoKTtcbiAgICAgICAgbGluZV9icmVhayA9IHRoaXMuc2Nhbl9saW5lX2JyZWFrKCk7XG4gICAgICAgIF9yZWY2ID0gdGhpcy5zY2FuX2Jsb2NrX3NjYWxhcl9icmVha3MoaW5kZW50KSwgYnJlYWtzID0gX3JlZjZbMF0sIGVuZF9tYXJrID0gX3JlZjZbMV07XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbiA9PT0gaW5kZW50ICYmIHRoaXMucGVlaygpICE9PSAnXFx4MDAnKSB7XG4gICAgICAgICAgaWYgKGZvbGRlZCAmJiBsaW5lX2JyZWFrID09PSAnXFxuJyAmJiBsZWFkaW5nX25vbl9zcGFjZSAmJiAoX3JlZjcgPSB0aGlzLnBlZWsoKSwgX19pbmRleE9mLmNhbGwoJyBcXHQnLCBfcmVmNykgPCAwKSkge1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNfZW1wdHkoYnJlYWtzKSkge1xuICAgICAgICAgICAgICBjaHVua3MucHVzaCgnICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHVua3MucHVzaChsaW5lX2JyZWFrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjaG9tcGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgY2h1bmtzLnB1c2gobGluZV9icmVhayk7XG4gICAgICB9XG4gICAgICBpZiAoY2hvbXBpbmcgPT09IHRydWUpIHtcbiAgICAgICAgY2h1bmtzID0gY2h1bmtzLmNvbmNhdChicmVha3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyB0b2tlbnMuU2NhbGFyVG9rZW4oY2h1bmtzLmpvaW4oJycpLCBmYWxzZSwgc3RhcnRfbWFyaywgZW5kX21hcmssIHN0eWxlKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl9ibG9ja19zY2FsYXJfaW5kaWNhdG9ycyA9IGZ1bmN0aW9uKHN0YXJ0X21hcmspIHtcbiAgICAgIHZhciBjaGFyLCBjaG9tcGluZywgaW5jcmVtZW50O1xuICAgICAgY2hvbXBpbmcgPSBudWxsO1xuICAgICAgaW5jcmVtZW50ID0gbnVsbDtcbiAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbCgnKy0nLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgIGNob21waW5nID0gY2hhciA9PT0gJysnO1xuICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgICBpZiAoX19pbmRleE9mLmNhbGwoQ19OVU1CRVJTLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgICAgaW5jcmVtZW50ID0gcGFyc2VJbnQoY2hhcik7XG4gICAgICAgICAgaWYgKGluY3JlbWVudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIGJsb2NrIHNjYWxhcicsIHN0YXJ0X21hcmssICdleHBlY3RlZCBpbmRlbnRhdGlvbiBpbmRpY2F0b3IgaW4gdGhlIHJhbmdlIDEtOSBidXQgZm91bmQgMCcsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKF9faW5kZXhPZi5jYWxsKENfTlVNQkVSUywgY2hhcikgPj0gMCkge1xuICAgICAgICBpbmNyZW1lbnQgPSBwYXJzZUludChjaGFyKTtcbiAgICAgICAgaWYgKGluY3JlbWVudCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBibG9jayBzY2FsYXInLCBzdGFydF9tYXJrLCAnZXhwZWN0ZWQgaW5kZW50YXRpb24gaW5kaWNhdG9yIGluIHRoZSByYW5nZSAxLTkgYnV0IGZvdW5kIDAnLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmIChfX2luZGV4T2YuY2FsbCgnKy0nLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgICAgY2hvbXBpbmcgPSBjaGFyID09PSAnKyc7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbChDX0xCICsgJ1xceDAwICcsIGNoYXIpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgYmxvY2sgc2NhbGFyJywgc3RhcnRfbWFyaywgXCJleHBlY3RlZCBjaG9tcGluZyBvciBpbmRlbnRhdGlvbiBpbmRpY2F0b3JzLCBidXQgZm91bmQgXCIgKyBjaGFyLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtjaG9tcGluZywgaW5jcmVtZW50XTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl9ibG9ja19zY2FsYXJfaWdub3JlZF9saW5lID0gZnVuY3Rpb24oc3RhcnRfbWFyaykge1xuICAgICAgdmFyIGNoYXIsIF9yZWYxO1xuICAgICAgd2hpbGUgKHRoaXMucGVlaygpID09PSAnICcpIHtcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wZWVrKCkgPT09ICcjJykge1xuICAgICAgICB3aGlsZSAoX3JlZjEgPSB0aGlzLnBlZWsoKSwgX19pbmRleE9mLmNhbGwoQ19MQiArICdcXHgwMCcsIF9yZWYxKSA8IDApIHtcbiAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hhciA9IHRoaXMucGVlaygpO1xuICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKENfTEIgKyAnXFx4MDAnLCBjaGFyKSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIGJsb2NrIHNjYWxhcicsIHN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgYSBjb21tZW50IG9yIGEgbGluZSBicmVhayBidXQgZm91bmQgXCIgKyBjaGFyLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc2Nhbl9saW5lX2JyZWFrKCk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fYmxvY2tfc2NhbGFyX2luZGVudGF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2h1bmtzLCBlbmRfbWFyaywgbWF4X2luZGVudCwgX3JlZjE7XG4gICAgICBjaHVua3MgPSBbXTtcbiAgICAgIG1heF9pbmRlbnQgPSAwO1xuICAgICAgZW5kX21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICB3aGlsZSAoX3JlZjEgPSB0aGlzLnBlZWsoKSwgX19pbmRleE9mLmNhbGwoQ19MQiArICcgJywgX3JlZjEpID49IDApIHtcbiAgICAgICAgaWYgKHRoaXMucGVlaygpICE9PSAnICcpIHtcbiAgICAgICAgICBjaHVua3MucHVzaCh0aGlzLnNjYW5fbGluZV9icmVhaygpKTtcbiAgICAgICAgICBlbmRfbWFyayA9IHRoaXMuZ2V0X21hcmsoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICBpZiAodGhpcy5jb2x1bW4gPiBtYXhfaW5kZW50KSB7XG4gICAgICAgICAgICBtYXhfaW5kZW50ID0gdGhpcy5jb2x1bW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW2NodW5rcywgbWF4X2luZGVudCwgZW5kX21hcmtdO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX2Jsb2NrX3NjYWxhcl9icmVha3MgPSBmdW5jdGlvbihpbmRlbnQpIHtcbiAgICAgIHZhciBjaHVua3MsIGVuZF9tYXJrLCBfcmVmMTtcbiAgICAgIGNodW5rcyA9IFtdO1xuICAgICAgZW5kX21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICB3aGlsZSAodGhpcy5jb2x1bW4gPCBpbmRlbnQgJiYgdGhpcy5wZWVrKCkgPT09ICcgJykge1xuICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChfcmVmMSA9IHRoaXMucGVlaygpLCBfX2luZGV4T2YuY2FsbChDX0xCLCBfcmVmMSkgPj0gMCkge1xuICAgICAgICBjaHVua3MucHVzaCh0aGlzLnNjYW5fbGluZV9icmVhaygpKTtcbiAgICAgICAgZW5kX21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLmNvbHVtbiA8IGluZGVudCAmJiB0aGlzLnBlZWsoKSA9PT0gJyAnKSB7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBbY2h1bmtzLCBlbmRfbWFya107XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgIE5vdGUgdGhhdCB3ZSBsb29zZSBpbmRlbnRhdGlvbiBydWxlcyBmb3IgcXVvdGVkIHNjYWxhcnMuIFF1b3RlZCBzY2FsYXJzXG4gICAgZG9uJ3QgbmVlZCB0byBhZGhlcmUgaW5kZW50YXRpb24gYmVjYXVzZSBcIiBhbmQgJyBjbGVhcmx5IG1hcmsgdGhlIGJlZ2lubmluZ1xuICAgIGFuZCB0aGUgZW5kIG9mIHRoZW0uIFRoZXJlZm9yZSB3ZSBhcmUgbGVzcyByZXN0cmljdGl2ZSB0aGFuIHRoZVxuICAgIHNwZWNpZmljYXRpb24gcmVxdWlyZXMuIFdlIG9ubHkgbmVlZCB0byBjaGVjayB0aGF0IGRvY3VtZW50IHNlcGFyYXRvcnMgYXJlXG4gICAgbm90IGluY2x1ZGVkIGluIHNjYWxhcnMuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl9mbG93X3NjYWxhciA9IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICB2YXIgY2h1bmtzLCBkb3VibGUsIHF1b3RlLCBzdGFydF9tYXJrO1xuICAgICAgZG91YmxlID0gc3R5bGUgPT09ICdcIic7XG4gICAgICBjaHVua3MgPSBbXTtcbiAgICAgIHN0YXJ0X21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICBxdW90ZSA9IHRoaXMucGVlaygpO1xuICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICBjaHVua3MgPSBjaHVua3MuY29uY2F0KHRoaXMuc2Nhbl9mbG93X3NjYWxhcl9ub25fc3BhY2VzKGRvdWJsZSwgc3RhcnRfbWFyaykpO1xuICAgICAgd2hpbGUgKHRoaXMucGVlaygpICE9PSBxdW90ZSkge1xuICAgICAgICBjaHVua3MgPSBjaHVua3MuY29uY2F0KHRoaXMuc2Nhbl9mbG93X3NjYWxhcl9zcGFjZXMoZG91YmxlLCBzdGFydF9tYXJrKSk7XG4gICAgICAgIGNodW5rcyA9IGNodW5rcy5jb25jYXQodGhpcy5zY2FuX2Zsb3dfc2NhbGFyX25vbl9zcGFjZXMoZG91YmxlLCBzdGFydF9tYXJrKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgIHJldHVybiBuZXcgdG9rZW5zLlNjYWxhclRva2VuKGNodW5rcy5qb2luKCcnKSwgZmFsc2UsIHN0YXJ0X21hcmssIHRoaXMuZ2V0X21hcmsoKSwgc3R5bGUpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX2Zsb3dfc2NhbGFyX25vbl9zcGFjZXMgPSBmdW5jdGlvbihkb3VibGUsIHN0YXJ0X21hcmspIHtcbiAgICAgIHZhciBjaGFyLCBjaHVua3MsIGNvZGUsIGssIGxlbmd0aCwgX2ksIF9yZWYxLCBfcmVmMjtcbiAgICAgIGNodW5rcyA9IFtdO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgICAgd2hpbGUgKF9yZWYxID0gdGhpcy5wZWVrKGxlbmd0aCksIF9faW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xcJ1wiXFxcXFxceDAwJywgX3JlZjEpIDwgMCkge1xuICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggIT09IDApIHtcbiAgICAgICAgICBjaHVua3MucHVzaCh0aGlzLnByZWZpeChsZW5ndGgpKTtcbiAgICAgICAgICB0aGlzLmZvcndhcmQobGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICAgIGlmICghZG91YmxlICYmIGNoYXIgPT09ICdcXCcnICYmIHRoaXMucGVlaygxKSA9PT0gJ1xcJycpIHtcbiAgICAgICAgICBjaHVua3MucHVzaCgnXFwnJyk7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKDIpO1xuICAgICAgICB9IGVsc2UgaWYgKChkb3VibGUgJiYgY2hhciA9PT0gJ1xcJycpIHx8ICghZG91YmxlICYmIF9faW5kZXhPZi5jYWxsKCdcIlxcXFwnLCBjaGFyKSA+PSAwKSkge1xuICAgICAgICAgIGNodW5rcy5wdXNoKGNoYXIpO1xuICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGRvdWJsZSAmJiBjaGFyID09PSAnXFxcXCcpIHtcbiAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICAgICAgaWYgKGNoYXIgaW4gRVNDQVBFX1JFUExBQ0VNRU5UUykge1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goRVNDQVBFX1JFUExBQ0VNRU5UU1tjaGFyXSk7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoYXIgaW4gRVNDQVBFX0NPREVTKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBFU0NBUEVfQ09ERVNbY2hhcl07XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICAgIGZvciAoayA9IF9pID0gMDsgMCA8PSBsZW5ndGggPyBfaSA8IGxlbmd0aCA6IF9pID4gbGVuZ3RoOyBrID0gMCA8PSBsZW5ndGggPyArK19pIDogLS1faSkge1xuICAgICAgICAgICAgICBpZiAoX3JlZjIgPSB0aGlzLnBlZWsoayksIF9faW5kZXhPZi5jYWxsKENfTlVNQkVSUyArICdBQkNERUZhYmNkZWYnLCBfcmVmMikgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIGRvdWJsZS1xdW90ZWQgc2NhbGFyJywgc3RhcnRfbWFyaywgXCJleHBlY3RlZCBlc2NhcGUgc2VxdWVuY2Ugb2YgXCIgKyBsZW5ndGggKyBcIiBoZXhhZGVjaW1hbCBudW1iZXJzLCBidXQgZm91bmQgXCIgKyAodGhpcy5wZWVrKGspKSwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kZSA9IHBhcnNlSW50KHRoaXMucHJlZml4KGxlbmd0aCksIDE2KTtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKGxlbmd0aCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChfX2luZGV4T2YuY2FsbChDX0xCLCBjaGFyKSA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnNjYW5fbGluZV9icmVhaygpO1xuICAgICAgICAgICAgY2h1bmtzID0gY2h1bmtzLmNvbmNhdCh0aGlzLnNjYW5fZmxvd19zY2FsYXJfYnJlYWtzKGRvdWJsZSwgc3RhcnRfbWFyaykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoJ3doaWxlIHNjYW5uaW5nIGEgZG91YmxlLXF1b3RlZCBzY2FsYXInLCBzdGFydF9tYXJrLCBcImZvdW5kIHVua25vd24gZXNjYXBlIGNoYXJhY3RlciBcIiArIGNoYXIsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjaHVua3M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgKi9cblxuXG4gICAgU2Nhbm5lci5wcm90b3R5cGUuc2Nhbl9mbG93X3NjYWxhcl9zcGFjZXMgPSBmdW5jdGlvbihkb3VibGUsIHN0YXJ0X21hcmspIHtcbiAgICAgIHZhciBicmVha3MsIGNoYXIsIGNodW5rcywgbGVuZ3RoLCBsaW5lX2JyZWFrLCB3aGl0ZXNwYWNlcywgX3JlZjE7XG4gICAgICBjaHVua3MgPSBbXTtcbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgICB3aGlsZSAoX3JlZjEgPSB0aGlzLnBlZWsobGVuZ3RoKSwgX19pbmRleE9mLmNhbGwoQ19XUywgX3JlZjEpID49IDApIHtcbiAgICAgICAgbGVuZ3RoKys7XG4gICAgICB9XG4gICAgICB3aGl0ZXNwYWNlcyA9IHRoaXMucHJlZml4KGxlbmd0aCk7XG4gICAgICB0aGlzLmZvcndhcmQobGVuZ3RoKTtcbiAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgIGlmIChjaGFyID09PSAnXFx4MDAnKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBxdW90ZWQgc2NhbGFyJywgc3RhcnRfbWFyaywgJ2ZvdW5kIHVuZXhwZWN0ZWQgZW5kIG9mIHN0cmVhbScsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICB9XG4gICAgICBpZiAoX19pbmRleE9mLmNhbGwoQ19MQiwgY2hhcikgPj0gMCkge1xuICAgICAgICBsaW5lX2JyZWFrID0gdGhpcy5zY2FuX2xpbmVfYnJlYWsoKTtcbiAgICAgICAgYnJlYWtzID0gdGhpcy5zY2FuX2Zsb3dfc2NhbGFyX2JyZWFrcyhkb3VibGUsIHN0YXJ0X21hcmspO1xuICAgICAgICBpZiAobGluZV9icmVhayAhPT0gJ1xcbicpIHtcbiAgICAgICAgICBjaHVua3MucHVzaChsaW5lX2JyZWFrKTtcbiAgICAgICAgfSBlbHNlIGlmICghYnJlYWtzKSB7XG4gICAgICAgICAgY2h1bmtzLnB1c2goJyAnKTtcbiAgICAgICAgfVxuICAgICAgICBjaHVua3MgPSBjaHVua3MuY29uY2F0KGJyZWFrcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaHVua3MucHVzaCh3aGl0ZXNwYWNlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2h1bmtzO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX2Zsb3dfc2NhbGFyX2JyZWFrcyA9IGZ1bmN0aW9uKGRvdWJsZSwgc3RhcnRfbWFyaykge1xuICAgICAgdmFyIGNodW5rcywgcHJlZml4LCBfcmVmMSwgX3JlZjIsIF9yZWYzO1xuICAgICAgY2h1bmtzID0gW107XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBwcmVmaXggPSB0aGlzLnByZWZpeCgzKTtcbiAgICAgICAgaWYgKHByZWZpeCA9PT0gJy0tLScgfHwgcHJlZml4ID09PSAnLi4uJyAmJiAoX3JlZjEgPSB0aGlzLnBlZWsoMyksIF9faW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwJywgX3JlZjEpID49IDApKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKCd3aGlsZSBzY2FubmluZyBhIHF1b3RlZCBzY2FsYXInLCBzdGFydF9tYXJrLCAnZm91bmQgdW5leHBlY3RlZCBkb2N1bWVudCBzZXBhcmF0b3InLCB0aGlzLmdldF9tYXJrKCkpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChfcmVmMiA9IHRoaXMucGVlaygpLCBfX2luZGV4T2YuY2FsbChDX1dTLCBfcmVmMikgPj0gMCkge1xuICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfcmVmMyA9IHRoaXMucGVlaygpLCBfX2luZGV4T2YuY2FsbChDX0xCLCBfcmVmMykgPj0gMCkge1xuICAgICAgICAgIGNodW5rcy5wdXNoKHRoaXMuc2Nhbl9saW5lX2JyZWFrKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjaHVua3M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgV2UgYWRkIGFuIGFkZGl0aW9uYWwgcmVzdHJpY3Rpb24gZm9yIHRoZSBmbG93IGNvbnRleHQ6XG4gICAgICBwbGFpbiBzY2FsYXJzIGluIHRoZSBmbG93IGNvbnRleHQgY2Fubm90IGNvbnRhaW4gJywnLCAnOicgYW5kICc/Jy5cbiAgICBXZSBhbHNvIGtlZXAgdHJhY2sgb2YgdGhlIGBhbGxvd19zaW1wbGVfa2V5YCBmbGFnIGhlcmUuXG4gICAgSW5kZW50YXRpb24gcnVsZXMgYXJlIGxvb3NlZCBmb3IgdGhlIGZsb3cgY29udGV4dC5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX3BsYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2hhciwgY2h1bmtzLCBlbmRfbWFyaywgaW5kZW50LCBsZW5ndGgsIHNwYWNlcywgc3RhcnRfbWFyaywgX3JlZjEsIF9yZWYyO1xuICAgICAgY2h1bmtzID0gW107XG4gICAgICBzdGFydF9tYXJrID0gZW5kX21hcmsgPSB0aGlzLmdldF9tYXJrKCk7XG4gICAgICBpbmRlbnQgPSB0aGlzLmluZGVudCArIDE7XG4gICAgICBzcGFjZXMgPSBbXTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gJyMnKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjaGFyID0gdGhpcy5wZWVrKGxlbmd0aCk7XG4gICAgICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwJywgY2hhcikgPj0gMCB8fCAodGhpcy5mbG93X2xldmVsID09PSAwICYmIGNoYXIgPT09ICc6JyAmJiAoX3JlZjEgPSB0aGlzLnBlZWsobGVuZ3RoICsgMSksIF9faW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwJywgX3JlZjEpID49IDApKSB8fCAodGhpcy5mbG93X2xldmVsICE9PSAwICYmIF9faW5kZXhPZi5jYWxsKCcsOj9bXXt9JywgY2hhcikgPj0gMCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mbG93X2xldmVsICE9PSAwICYmIGNoYXIgPT09ICc6JyAmJiAoX3JlZjIgPSB0aGlzLnBlZWsobGVuZ3RoICsgMSksIF9faW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwLFtde30nLCBfcmVmMikgPCAwKSkge1xuICAgICAgICAgIHRoaXMuZm9yd2FyZChsZW5ndGgpO1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcignd2hpbGUgc2Nhbm5pbmcgYSBwbGFpbiBzY2FsYXInLCBzdGFydF9tYXJrLCAnZm91bmQgdW5leHBlY3RlZCBcXCc6XFwnJywgdGhpcy5nZXRfbWFyaygpLCAnUGxlYXNlIGNoZWNrIGh0dHA6Ly9weXlhbWwub3JnL3dpa2kvWUFNTENvbG9uSW5GbG93Q29udGV4dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFsbG93X3NpbXBsZV9rZXkgPSBmYWxzZTtcbiAgICAgICAgY2h1bmtzID0gY2h1bmtzLmNvbmNhdChzcGFjZXMpO1xuICAgICAgICBjaHVua3MucHVzaCh0aGlzLnByZWZpeChsZW5ndGgpKTtcbiAgICAgICAgdGhpcy5mb3J3YXJkKGxlbmd0aCk7XG4gICAgICAgIGVuZF9tYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgICBzcGFjZXMgPSB0aGlzLnNjYW5fcGxhaW5fc3BhY2VzKGluZGVudCwgc3RhcnRfbWFyayk7XG4gICAgICAgIGlmICgoc3BhY2VzID09IG51bGwpIHx8IHNwYWNlcy5sZW5ndGggPT09IDAgfHwgdGhpcy5wZWVrKCkgPT09ICcjJyB8fCAodGhpcy5mbG93X2xldmVsID09PSAwICYmIHRoaXMuY29sdW1uIDwgaW5kZW50KSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IHRva2Vucy5TY2FsYXJUb2tlbihjaHVua3Muam9pbignJyksIHRydWUsIHN0YXJ0X21hcmssIGVuZF9tYXJrKTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgVGhlIHNwZWNpZmljYXRpb24gaXMgcmVhbGx5IGNvbmZ1c2luZyBhYm91dCB0YWJzIGluIHBsYWluIHNjYWxhcnMuXG4gICAgV2UganVzdCBmb3JiaWQgdGhlbSBjb21wbGV0ZWx5LiBEbyBub3QgdXNlIHRhYnMgaW4gWUFNTCFcbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX3BsYWluX3NwYWNlcyA9IGZ1bmN0aW9uKGluZGVudCwgc3RhcnRfbWFyaykge1xuICAgICAgdmFyIGJyZWFrcywgY2hhciwgY2h1bmtzLCBsZW5ndGgsIGxpbmVfYnJlYWssIHByZWZpeCwgd2hpdGVzcGFjZXMsIF9yZWYxLCBfcmVmMjtcbiAgICAgIGNodW5rcyA9IFtdO1xuICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIHdoaWxlIChfcmVmMSA9IHRoaXMucGVlayhsZW5ndGgpLCBfX2luZGV4T2YuY2FsbCgnICcsIF9yZWYxKSA+PSAwKSB7XG4gICAgICAgIGxlbmd0aCsrO1xuICAgICAgfVxuICAgICAgd2hpdGVzcGFjZXMgPSB0aGlzLnByZWZpeChsZW5ndGgpO1xuICAgICAgdGhpcy5mb3J3YXJkKGxlbmd0aCk7XG4gICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICBpZiAoX19pbmRleE9mLmNhbGwoQ19MQiwgY2hhcikgPj0gMCkge1xuICAgICAgICBsaW5lX2JyZWFrID0gdGhpcy5zY2FuX2xpbmVfYnJlYWsoKTtcbiAgICAgICAgdGhpcy5hbGxvd19zaW1wbGVfa2V5ID0gdHJ1ZTtcbiAgICAgICAgcHJlZml4ID0gdGhpcy5wcmVmaXgoMyk7XG4gICAgICAgIGlmIChwcmVmaXggPT09ICctLS0nIHx8IHByZWZpeCA9PT0gJy4uLicgJiYgdGhpcy5wZWVrKF9faW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwJywgMykgPj0gMCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtzID0gW107XG4gICAgICAgIHdoaWxlIChfcmVmMiA9IHRoaXMucGVlaygpLCBfX2luZGV4T2YuY2FsbChDX0xCICsgJyAnLCBfcmVmMikgPj0gMCkge1xuICAgICAgICAgIGlmICh0aGlzLnBlZWsoKSA9PT0gJyAnKSB7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWtzLnB1c2godGhpcy5zY2FuX2xpbmVfYnJlYWsoKSk7XG4gICAgICAgICAgICBwcmVmaXggPSB0aGlzLnByZWZpeCgzKTtcbiAgICAgICAgICAgIGlmIChwcmVmaXggPT09ICctLS0nIHx8IHByZWZpeCA9PT0gJy4uLicgJiYgdGhpcy5wZWVrKF9faW5kZXhPZi5jYWxsKENfTEIgKyBDX1dTICsgJ1xceDAwJywgMykgPj0gMCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZV9icmVhayAhPT0gJ1xcbicpIHtcbiAgICAgICAgICBjaHVua3MucHVzaChsaW5lX2JyZWFrKTtcbiAgICAgICAgfSBlbHNlIGlmIChicmVha3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY2h1bmtzLnB1c2goJyAnKTtcbiAgICAgICAgfVxuICAgICAgICBjaHVua3MgPSBjaHVua3MuY29uY2F0KGJyZWFrcyk7XG4gICAgICB9IGVsc2UgaWYgKHdoaXRlc3BhY2VzKSB7XG4gICAgICAgIGNodW5rcy5wdXNoKHdoaXRlc3BhY2VzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaHVua3M7XG4gICAgfTtcblxuICAgIC8qXG4gICAgU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBkZXRhaWxzLlxuICAgIEZvciBzb21lIHN0cmFuZ2UgcmVhc29ucywgdGhlIHNwZWNpZmljYXRpb24gZG9lcyBub3QgYWxsb3cgJ18nIGluIHRhZ1xuICAgIGhhbmRsZXMuIEkgaGF2ZSBhbGxvd2VkIGl0IGFueXdheS5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX3RhZ19oYW5kbGUgPSBmdW5jdGlvbihuYW1lLCBzdGFydF9tYXJrKSB7XG4gICAgICB2YXIgY2hhciwgbGVuZ3RoLCB2YWx1ZTtcbiAgICAgIGNoYXIgPSB0aGlzLnBlZWsoKTtcbiAgICAgIGlmIChjaGFyICE9PSAnIScpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKFwid2hpbGUgc2Nhbm5pbmcgYSBcIiArIG5hbWUsIHN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgJyEnIGJ1dCBmb3VuZCBcIiArIGNoYXIsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSAxO1xuICAgICAgY2hhciA9IHRoaXMucGVlayhsZW5ndGgpO1xuICAgICAgaWYgKGNoYXIgIT09ICcgJykge1xuICAgICAgICB3aGlsZSAoKCcwJyA8PSBjaGFyICYmIGNoYXIgPD0gJzknKSB8fCAoJ0EnIDw9IGNoYXIgJiYgY2hhciA8PSAnWicpIHx8ICgnYScgPD0gY2hhciAmJiBjaGFyIDw9ICd6JykgfHwgX19pbmRleE9mLmNhbGwoJy1fJywgY2hhcikgPj0gMCkge1xuICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICAgIGNoYXIgPSB0aGlzLnBlZWsobGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciAhPT0gJyEnKSB7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKGxlbmd0aCk7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuU2Nhbm5lckVycm9yKFwid2hpbGUgc2Nhbm5pbmcgYSBcIiArIG5hbWUsIHN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgJyEnIGJ1dCBmb3VuZCBcIiArIGNoYXIsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoKys7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHRoaXMucHJlZml4KGxlbmd0aCk7XG4gICAgICB0aGlzLmZvcndhcmQobGVuZ3RoKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICBTZWUgdGhlIHNwZWNpZmljYXRpb24gZm9yIGRldGFpbHMuXG4gICAgTm90ZTogd2UgZG8gbm90IGNoZWNrIGlmIFVSSSBpcyB3ZWxsLWZvcm1lZC5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX3RhZ191cmkgPSBmdW5jdGlvbihuYW1lLCBzdGFydF9tYXJrKSB7XG4gICAgICB2YXIgY2hhciwgY2h1bmtzLCBsZW5ndGg7XG4gICAgICBjaHVua3MgPSBbXTtcbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgICBjaGFyID0gdGhpcy5wZWVrKGxlbmd0aCk7XG4gICAgICB3aGlsZSAoKCcwJyA8PSBjaGFyICYmIGNoYXIgPD0gJzknKSB8fCAoJ0EnIDw9IGNoYXIgJiYgY2hhciA8PSAnWicpIHx8ICgnYScgPD0gY2hhciAmJiBjaGFyIDw9ICd6JykgfHwgX19pbmRleE9mLmNhbGwoJy07Lz86QCY9KyQsXy4hfipcXCcoKVtdJScsIGNoYXIpID49IDApIHtcbiAgICAgICAgaWYgKGNoYXIgPT09ICclJykge1xuICAgICAgICAgIGNodW5rcy5wdXNoKHRoaXMucHJlZml4KGxlbmd0aCkpO1xuICAgICAgICAgIHRoaXMuZm9yd2FyZChsZW5ndGgpO1xuICAgICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICAgICAgY2h1bmtzLnB1c2godGhpcy5zY2FuX3VyaV9lc2NhcGVzKG5hbWUsIHN0YXJ0X21hcmspKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgfVxuICAgICAgICBjaGFyID0gdGhpcy5wZWVrKGxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGNodW5rcy5wdXNoKHRoaXMucHJlZml4KGxlbmd0aCkpO1xuICAgICAgICB0aGlzLmZvcndhcmQobGVuZ3RoKTtcbiAgICAgICAgbGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlNjYW5uZXJFcnJvcihcIndoaWxlIHBhcnNpbmcgYSBcIiArIG5hbWUsIHN0YXJ0X21hcmssIFwiZXhwZWN0ZWQgVVJJIGJ1dCBmb3VuZCBcIiArIGNoYXIsIHRoaXMuZ2V0X21hcmsoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2h1bmtzLmpvaW4oJycpO1xuICAgIH07XG5cbiAgICAvKlxuICAgIFNlZSB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAqL1xuXG5cbiAgICBTY2FubmVyLnByb3RvdHlwZS5zY2FuX3VyaV9lc2NhcGVzID0gZnVuY3Rpb24obmFtZSwgc3RhcnRfbWFyaykge1xuICAgICAgdmFyIGJ5dGVzLCBrLCBtYXJrLCBfaTtcbiAgICAgIGJ5dGVzID0gW107XG4gICAgICBtYXJrID0gdGhpcy5nZXRfbWFyaygpO1xuICAgICAgd2hpbGUgKHRoaXMucGVlaygpID09PSAnJScpIHtcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIGZvciAoayA9IF9pID0gMDsgX2kgPD0gMjsgayA9ICsrX2kpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5TY2FubmVyRXJyb3IoXCJ3aGlsZSBzY2FubmluZyBhIFwiICsgbmFtZSwgc3RhcnRfbWFyaywgXCJleHBlY3RlZCBVUkkgZXNjYXBlIHNlcXVlbmNlIG9mIDIgaGV4YWRlY2ltYWwgbnVtYmVycyBidXQgZm91bmQgICAgICAgICAgXCIgKyAodGhpcy5wZWVrKGspKSwgdGhpcy5nZXRfbWFyaygpKTtcbiAgICAgICAgfVxuICAgICAgICBieXRlcy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQodGhpcy5wcmVmaXgoMiksIDE2KSkpO1xuICAgICAgICB0aGlzLmZvcndhcmQoMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnl0ZXMuam9pbignJyk7XG4gICAgfTtcblxuICAgIC8qXG4gICAgVHJhbnNmb3JtczpcbiAgICAgICdcXHJcXG4nICAgICAgOiAgICdcXG4nXG4gICAgICAnXFxyJyAgICAgICAgOiAgICdcXG4nXG4gICAgICAnXFxuJyAgICAgICAgOiAgICdcXG4nXG4gICAgICAnXFx4ODUnICAgICAgOiAgICdcXG4nXG4gICAgICAnXFx1MjAyOCcgICAgOiAgICdcXHUyMDI4J1xuICAgICAgJ1xcdTIwMjkgICAgIDogICAnXFx1MjAyOSdcbiAgICAgIGRlZmF1bHQgICAgIDogICAnJ1xuICAgICovXG5cblxuICAgIFNjYW5uZXIucHJvdG90eXBlLnNjYW5fbGluZV9icmVhayA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNoYXI7XG4gICAgICBjaGFyID0gdGhpcy5wZWVrKCk7XG4gICAgICBpZiAoX19pbmRleE9mLmNhbGwoJ1xcclxcblxceDg1JywgY2hhcikgPj0gMCkge1xuICAgICAgICBpZiAodGhpcy5wcmVmaXgoMikgPT09ICdcXHJcXG4nKSB7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnXFxuJztcbiAgICAgIH0gZWxzZSBpZiAoX19pbmRleE9mLmNhbGwoJ1xcdTIwMjhcXHUyMDI5JywgY2hhcikgPj0gMCkge1xuICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgcmV0dXJuIGNoYXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfTtcblxuICAgIHJldHVybiBTY2FubmVyO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBNYXJrZWRZQU1MRXJyb3IsIG5vZGVzLCBfcmVmLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH07XG5cbiAgTWFya2VkWUFNTEVycm9yID0gcmVxdWlyZSgnLi9lcnJvcnMnKS5NYXJrZWRZQU1MRXJyb3I7XG5cbiAgbm9kZXMgPSByZXF1aXJlKCcuL25vZGVzJyk7XG5cbiAgLypcbiAgVGhlIFNjaGVtYXMgdGhyb3dzIHRoZXNlLlxuICAqL1xuXG5cbiAgdGhpcy5TY2hlbWFFcnJvciA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2NoZW1hRXJyb3IsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBTY2hlbWFFcnJvcigpIHtcbiAgICAgIF9yZWYgPSBTY2hlbWFFcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmO1xuICAgIH1cblxuICAgIHJldHVybiBTY2hlbWFFcnJvcjtcblxuICB9KShNYXJrZWRZQU1MRXJyb3IpO1xuXG4gIC8qXG4gICAgVGhlIFNjaGVtYXMgY2xhc3MgZGVhbHMgd2l0aCBhcHBseWluZyBzY2hlbWFzIHRvIHJlc291cmNlcyBhY2NvcmRpbmcgdG8gdGhlIHNwZWNcbiAgKi9cblxuXG4gIHRoaXMuU2NoZW1hcyA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTY2hlbWFzKCkge1xuICAgICAgdGhpcy5nZXRfc2NoZW1hc191c2VkID0gX19iaW5kKHRoaXMuZ2V0X3NjaGVtYXNfdXNlZCwgdGhpcyk7XG4gICAgICB0aGlzLmFwcGx5X3NjaGVtYXMgPSBfX2JpbmQodGhpcy5hcHBseV9zY2hlbWFzLCB0aGlzKTtcbiAgICAgIHRoaXMuZ2V0X2FsbF9zY2hlbWFzID0gX19iaW5kKHRoaXMuZ2V0X2FsbF9zY2hlbWFzLCB0aGlzKTtcbiAgICAgIHRoaXMuaGFzX3NjaGVtYXMgPSBfX2JpbmQodGhpcy5oYXNfc2NoZW1hcywgdGhpcyk7XG4gICAgICB0aGlzLmxvYWRfc2NoZW1hcyA9IF9fYmluZCh0aGlzLmxvYWRfc2NoZW1hcywgdGhpcyk7XG4gICAgICB0aGlzLmRlY2xhcmVkU2NoZW1hcyA9IHt9O1xuICAgIH1cblxuICAgIFNjaGVtYXMucHJvdG90eXBlLmxvYWRfc2NoZW1hcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBhbGxTY2hlbWFzLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5oYXNfcHJvcGVydHkobm9kZSwgXCJzY2hlbWFzXCIpKSB7XG4gICAgICAgIGFsbFNjaGVtYXMgPSB0aGlzLnByb3BlcnR5X3ZhbHVlKG5vZGUsICdzY2hlbWFzJyk7XG4gICAgICAgIGlmIChhbGxTY2hlbWFzICYmIHR5cGVvZiBhbGxTY2hlbWFzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGFsbFNjaGVtYXMuZm9yRWFjaChmdW5jdGlvbihzY2hlbWFfZW50cnkpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWFfZW50cnkgJiYgdHlwZW9mIHNjaGVtYV9lbnRyeSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygc2NoZW1hX2VudHJ5LnZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzY2hlbWFfZW50cnkudmFsdWUuZm9yRWFjaChmdW5jdGlvbihzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZGVjbGFyZWRTY2hlbWFzW3NjaGVtYVswXS52YWx1ZV0gPSBzY2hlbWE7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIFNjaGVtYXMucHJvdG90eXBlLmhhc19zY2hlbWFzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKHRoaXMuZGVjbGFyZWRTY2hlbWFzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmhhc19wcm9wZXJ0eShub2RlLCBcInNjaGVtYXNcIikpIHtcbiAgICAgICAgdGhpcy5sb2FkX3NjaGVtYXMobm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5kZWNsYXJlZFNjaGVtYXMpLmxlbmd0aCA+IDA7XG4gICAgfTtcblxuICAgIFNjaGVtYXMucHJvdG90eXBlLmdldF9hbGxfc2NoZW1hcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVjbGFyZWRTY2hlbWFzO1xuICAgIH07XG5cbiAgICBTY2hlbWFzLnByb3RvdHlwZS5hcHBseV9zY2hlbWFzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHJlc291cmNlcywgc2NoZW1hcyxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgcmVzb3VyY2VzID0gdGhpcy5jaGlsZF9yZXNvdXJjZXMobm9kZSk7XG4gICAgICBzY2hlbWFzID0gdGhpcy5nZXRfc2NoZW1hc191c2VkKHJlc291cmNlcyk7XG4gICAgICByZXR1cm4gc2NoZW1hcy5mb3JFYWNoKGZ1bmN0aW9uKHNjaGVtYSkge1xuICAgICAgICBpZiAoc2NoZW1hWzFdLnZhbHVlIGluIF90aGlzLmRlY2xhcmVkU2NoZW1hcykge1xuICAgICAgICAgIHJldHVybiBzY2hlbWFbMV0udmFsdWUgPSBfdGhpcy5kZWNsYXJlZFNjaGVtYXNbc2NoZW1hWzFdLnZhbHVlXVsxXS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFNjaGVtYXMucHJvdG90eXBlLmdldF9zY2hlbWFzX3VzZWQgPSBmdW5jdGlvbihyZXNvdXJjZXMpIHtcbiAgICAgIHZhciBzY2hlbWFzLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBzY2hlbWFzID0gW107XG4gICAgICByZXNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihyZXNvdXJjZSkge1xuICAgICAgICB2YXIgcHJvcGVydGllcztcbiAgICAgICAgcHJvcGVydGllcyA9IF90aGlzLmdldF9wcm9wZXJ0aWVzKHJlc291cmNlWzFdLCBcInNjaGVtYVwiKTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYXMgPSBzY2hlbWFzLmNvbmNhdChwcm9wZXJ0aWVzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNjaGVtYXM7XG4gICAgfTtcblxuICAgIHJldHVybiBTY2hlbWFzO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIoZnVuY3Rpb24oKSB7XG4gIHZhciBNYXJrZWRZQU1MRXJyb3IsIG5vZGVzLCBfcmVmLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH07XG5cbiAgTWFya2VkWUFNTEVycm9yID0gcmVxdWlyZSgnLi9lcnJvcnMnKS5NYXJrZWRZQU1MRXJyb3I7XG5cbiAgbm9kZXMgPSByZXF1aXJlKCcuL25vZGVzJyk7XG5cbiAgLypcbiAgVGhlIFNjaGVtYXMgdGhyb3dzIHRoZXNlLlxuICAqL1xuXG5cbiAgdGhpcy5TZWN1cml0eVNjaGVtZUVycm9yID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZWN1cml0eVNjaGVtZUVycm9yLCBfc3VwZXIpO1xuXG4gICAgLypcbiAgICAgIFRoZSBTY2hlbWFzIGNsYXNzIGRlYWxzIHdpdGggYXBwbHlpbmcgc2NoZW1hcyB0byByZXNvdXJjZXMgYWNjb3JkaW5nIHRvIHRoZSBzcGVjXG4gICAgKi9cblxuXG4gICAgZnVuY3Rpb24gU2VjdXJpdHlTY2hlbWVFcnJvcigpIHtcbiAgICAgIF9yZWYgPSBTZWN1cml0eVNjaGVtZUVycm9yLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNlY3VyaXR5U2NoZW1lRXJyb3I7XG5cbiAgfSkoTWFya2VkWUFNTEVycm9yKTtcblxuICB0aGlzLlNlY3VyaXR5U2NoZW1lcyA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTZWN1cml0eVNjaGVtZXMoKSB7XG4gICAgICB0aGlzLmdldF9zZWN1cml0eV9zY2hlbWUgPSBfX2JpbmQodGhpcy5nZXRfc2VjdXJpdHlfc2NoZW1lLCB0aGlzKTtcbiAgICAgIHRoaXMuZ2V0X2FsbF9zY2hlbWVzID0gX19iaW5kKHRoaXMuZ2V0X2FsbF9zY2hlbWVzLCB0aGlzKTtcbiAgICAgIHRoaXMubG9hZF9zZWN1cml0eV9zY2hlbWVzID0gX19iaW5kKHRoaXMubG9hZF9zZWN1cml0eV9zY2hlbWVzLCB0aGlzKTtcbiAgICAgIHRoaXMuZGVjbGFyZWRTY2hlbWVzID0ge307XG4gICAgfVxuXG4gICAgU2VjdXJpdHlTY2hlbWVzLnByb3RvdHlwZS5sb2FkX3NlY3VyaXR5X3NjaGVtZXMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgYWxsc2NoZW1lcyxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuaGFzX3Byb3BlcnR5KG5vZGUsIFwic2VjdXJpdHlTY2hlbWVzXCIpKSB7XG4gICAgICAgIGFsbHNjaGVtZXMgPSB0aGlzLnByb3BlcnR5X3ZhbHVlKG5vZGUsICdzZWN1cml0eVNjaGVtZXMnKTtcbiAgICAgICAgaWYgKGFsbHNjaGVtZXMgJiYgdHlwZW9mIGFsbHNjaGVtZXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICByZXR1cm4gYWxsc2NoZW1lcy5mb3JFYWNoKGZ1bmN0aW9uKHNjaGVtZV9lbnRyeSkge1xuICAgICAgICAgICAgaWYgKHNjaGVtZV9lbnRyeS50YWcgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjptYXAnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzY2hlbWVfZW50cnkudmFsdWUuZm9yRWFjaChmdW5jdGlvbihzY2hlbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZGVjbGFyZWRTY2hlbWVzW3NjaGVtZVswXS52YWx1ZV0gPSBzY2hlbWVbMV0udmFsdWU7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIFNlY3VyaXR5U2NoZW1lcy5wcm90b3R5cGUuZ2V0X2FsbF9zY2hlbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNsYXJlZFNjaGVtZXM7XG4gICAgfTtcblxuICAgIFNlY3VyaXR5U2NoZW1lcy5wcm90b3R5cGUuZ2V0X3NlY3VyaXR5X3NjaGVtZSA9IGZ1bmN0aW9uKHNjaGVtYU5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlY2xhcmVkU2NoZW1lc1tzY2hlbWFOYW1lXTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNlY3VyaXR5U2NoZW1lcztcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgX3JlZiwgX3JlZjEsIF9yZWYxMCwgX3JlZjExLCBfcmVmMTIsIF9yZWYxMywgX3JlZjIsIF9yZWYzLCBfcmVmNCwgX3JlZjUsIF9yZWY2LCBfcmVmNywgX3JlZjgsIF9yZWY5LFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoX19oYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9O1xuXG4gIHRoaXMuVG9rZW4gPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gVG9rZW4oc3RhcnRfbWFyaywgZW5kX21hcmspIHtcbiAgICAgIHRoaXMuc3RhcnRfbWFyayA9IHN0YXJ0X21hcms7XG4gICAgICB0aGlzLmVuZF9tYXJrID0gZW5kX21hcms7XG4gICAgfVxuXG4gICAgcmV0dXJuIFRva2VuO1xuXG4gIH0pKCk7XG5cbiAgdGhpcy5EaXJlY3RpdmVUb2tlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGlyZWN0aXZlVG9rZW4sIF9zdXBlcik7XG5cbiAgICBEaXJlY3RpdmVUb2tlbi5wcm90b3R5cGUuaWQgPSAnPGRpcmVjdGl2ZT4nO1xuXG4gICAgZnVuY3Rpb24gRGlyZWN0aXZlVG9rZW4obmFtZSwgdmFsdWUsIHN0YXJ0X21hcmssIGVuZF9tYXJrKSB7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5zdGFydF9tYXJrID0gc3RhcnRfbWFyaztcbiAgICAgIHRoaXMuZW5kX21hcmsgPSBlbmRfbWFyaztcbiAgICB9XG5cbiAgICByZXR1cm4gRGlyZWN0aXZlVG9rZW47XG5cbiAgfSkodGhpcy5Ub2tlbik7XG5cbiAgdGhpcy5Eb2N1bWVudFN0YXJ0VG9rZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERvY3VtZW50U3RhcnRUb2tlbiwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIERvY3VtZW50U3RhcnRUb2tlbigpIHtcbiAgICAgIF9yZWYgPSBEb2N1bWVudFN0YXJ0VG9rZW4uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjtcbiAgICB9XG5cbiAgICBEb2N1bWVudFN0YXJ0VG9rZW4ucHJvdG90eXBlLmlkID0gJzxkb2N1bWVudCBzdGFydD4nO1xuXG4gICAgcmV0dXJuIERvY3VtZW50U3RhcnRUb2tlbjtcblxuICB9KSh0aGlzLlRva2VuKTtcblxuICB0aGlzLkRvY3VtZW50RW5kVG9rZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERvY3VtZW50RW5kVG9rZW4sIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBEb2N1bWVudEVuZFRva2VuKCkge1xuICAgICAgX3JlZjEgPSBEb2N1bWVudEVuZFRva2VuLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWYxO1xuICAgIH1cblxuICAgIERvY3VtZW50RW5kVG9rZW4ucHJvdG90eXBlLmlkID0gJzxkb2N1bWVudCBlbmQ+JztcblxuICAgIHJldHVybiBEb2N1bWVudEVuZFRva2VuO1xuXG4gIH0pKHRoaXMuVG9rZW4pO1xuXG4gIHRoaXMuU3RyZWFtU3RhcnRUb2tlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3RyZWFtU3RhcnRUb2tlbiwgX3N1cGVyKTtcblxuICAgIFN0cmVhbVN0YXJ0VG9rZW4ucHJvdG90eXBlLmlkID0gJzxzdHJlYW0gc3RhcnQ+JztcblxuICAgIGZ1bmN0aW9uIFN0cmVhbVN0YXJ0VG9rZW4oc3RhcnRfbWFyaywgZW5kX21hcmssIGVuY29kaW5nKSB7XG4gICAgICB0aGlzLnN0YXJ0X21hcmsgPSBzdGFydF9tYXJrO1xuICAgICAgdGhpcy5lbmRfbWFyayA9IGVuZF9tYXJrO1xuICAgICAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBTdHJlYW1TdGFydFRva2VuO1xuXG4gIH0pKHRoaXMuVG9rZW4pO1xuXG4gIHRoaXMuU3RyZWFtRW5kVG9rZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0cmVhbUVuZFRva2VuLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gU3RyZWFtRW5kVG9rZW4oKSB7XG4gICAgICBfcmVmMiA9IFN0cmVhbUVuZFRva2VuLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWYyO1xuICAgIH1cblxuICAgIFN0cmVhbUVuZFRva2VuLnByb3RvdHlwZS5pZCA9ICc8c3RyZWFtIGVuZD4nO1xuXG4gICAgcmV0dXJuIFN0cmVhbUVuZFRva2VuO1xuXG4gIH0pKHRoaXMuVG9rZW4pO1xuXG4gIHRoaXMuQmxvY2tTZXF1ZW5jZVN0YXJ0VG9rZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJsb2NrU2VxdWVuY2VTdGFydFRva2VuLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gQmxvY2tTZXF1ZW5jZVN0YXJ0VG9rZW4oKSB7XG4gICAgICBfcmVmMyA9IEJsb2NrU2VxdWVuY2VTdGFydFRva2VuLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWYzO1xuICAgIH1cblxuICAgIEJsb2NrU2VxdWVuY2VTdGFydFRva2VuLnByb3RvdHlwZS5pZCA9ICc8YmxvY2sgc2VxdWVuY2Ugc3RhcnQ+JztcblxuICAgIHJldHVybiBCbG9ja1NlcXVlbmNlU3RhcnRUb2tlbjtcblxuICB9KSh0aGlzLlRva2VuKTtcblxuICB0aGlzLkJsb2NrTWFwcGluZ1N0YXJ0VG9rZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJsb2NrTWFwcGluZ1N0YXJ0VG9rZW4sIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBCbG9ja01hcHBpbmdTdGFydFRva2VuKCkge1xuICAgICAgX3JlZjQgPSBCbG9ja01hcHBpbmdTdGFydFRva2VuLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY0O1xuICAgIH1cblxuICAgIEJsb2NrTWFwcGluZ1N0YXJ0VG9rZW4ucHJvdG90eXBlLmlkID0gJzxibG9jayBtYXBwaW5nIGVuZD4nO1xuXG4gICAgcmV0dXJuIEJsb2NrTWFwcGluZ1N0YXJ0VG9rZW47XG5cbiAgfSkodGhpcy5Ub2tlbik7XG5cbiAgdGhpcy5CbG9ja0VuZFRva2VuID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCbG9ja0VuZFRva2VuLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gQmxvY2tFbmRUb2tlbigpIHtcbiAgICAgIF9yZWY1ID0gQmxvY2tFbmRUb2tlbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmNTtcbiAgICB9XG5cbiAgICBCbG9ja0VuZFRva2VuLnByb3RvdHlwZS5pZCA9ICc8YmxvY2sgZW5kPic7XG5cbiAgICByZXR1cm4gQmxvY2tFbmRUb2tlbjtcblxuICB9KSh0aGlzLlRva2VuKTtcblxuICB0aGlzLkZsb3dTZXF1ZW5jZVN0YXJ0VG9rZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZsb3dTZXF1ZW5jZVN0YXJ0VG9rZW4sIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBGbG93U2VxdWVuY2VTdGFydFRva2VuKCkge1xuICAgICAgX3JlZjYgPSBGbG93U2VxdWVuY2VTdGFydFRva2VuLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY2O1xuICAgIH1cblxuICAgIEZsb3dTZXF1ZW5jZVN0YXJ0VG9rZW4ucHJvdG90eXBlLmlkID0gJ1snO1xuXG4gICAgcmV0dXJuIEZsb3dTZXF1ZW5jZVN0YXJ0VG9rZW47XG5cbiAgfSkodGhpcy5Ub2tlbik7XG5cbiAgdGhpcy5GbG93TWFwcGluZ1N0YXJ0VG9rZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZsb3dNYXBwaW5nU3RhcnRUb2tlbiwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIEZsb3dNYXBwaW5nU3RhcnRUb2tlbigpIHtcbiAgICAgIF9yZWY3ID0gRmxvd01hcHBpbmdTdGFydFRva2VuLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY3O1xuICAgIH1cblxuICAgIEZsb3dNYXBwaW5nU3RhcnRUb2tlbi5wcm90b3R5cGUuaWQgPSAneyc7XG5cbiAgICByZXR1cm4gRmxvd01hcHBpbmdTdGFydFRva2VuO1xuXG4gIH0pKHRoaXMuVG9rZW4pO1xuXG4gIHRoaXMuRmxvd1NlcXVlbmNlRW5kVG9rZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZsb3dTZXF1ZW5jZUVuZFRva2VuLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gRmxvd1NlcXVlbmNlRW5kVG9rZW4oKSB7XG4gICAgICBfcmVmOCA9IEZsb3dTZXF1ZW5jZUVuZFRva2VuLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY4O1xuICAgIH1cblxuICAgIEZsb3dTZXF1ZW5jZUVuZFRva2VuLnByb3RvdHlwZS5pZCA9ICddJztcblxuICAgIHJldHVybiBGbG93U2VxdWVuY2VFbmRUb2tlbjtcblxuICB9KSh0aGlzLlRva2VuKTtcblxuICB0aGlzLkZsb3dNYXBwaW5nRW5kVG9rZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZsb3dNYXBwaW5nRW5kVG9rZW4sIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBGbG93TWFwcGluZ0VuZFRva2VuKCkge1xuICAgICAgX3JlZjkgPSBGbG93TWFwcGluZ0VuZFRva2VuLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWY5O1xuICAgIH1cblxuICAgIEZsb3dNYXBwaW5nRW5kVG9rZW4ucHJvdG90eXBlLmlkID0gJ30nO1xuXG4gICAgcmV0dXJuIEZsb3dNYXBwaW5nRW5kVG9rZW47XG5cbiAgfSkodGhpcy5Ub2tlbik7XG5cbiAgdGhpcy5LZXlUb2tlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoS2V5VG9rZW4sIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBLZXlUb2tlbigpIHtcbiAgICAgIF9yZWYxMCA9IEtleVRva2VuLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWYxMDtcbiAgICB9XG5cbiAgICBLZXlUb2tlbi5wcm90b3R5cGUuaWQgPSAnPyc7XG5cbiAgICByZXR1cm4gS2V5VG9rZW47XG5cbiAgfSkodGhpcy5Ub2tlbik7XG5cbiAgdGhpcy5WYWx1ZVRva2VuID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWYWx1ZVRva2VuLCBfc3VwZXIpO1xuXG4gICAgZnVuY3Rpb24gVmFsdWVUb2tlbigpIHtcbiAgICAgIF9yZWYxMSA9IFZhbHVlVG9rZW4uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjExO1xuICAgIH1cblxuICAgIFZhbHVlVG9rZW4ucHJvdG90eXBlLmlkID0gJzonO1xuXG4gICAgcmV0dXJuIFZhbHVlVG9rZW47XG5cbiAgfSkodGhpcy5Ub2tlbik7XG5cbiAgdGhpcy5CbG9ja0VudHJ5VG9rZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJsb2NrRW50cnlUb2tlbiwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIEJsb2NrRW50cnlUb2tlbigpIHtcbiAgICAgIF9yZWYxMiA9IEJsb2NrRW50cnlUb2tlbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmMTI7XG4gICAgfVxuXG4gICAgQmxvY2tFbnRyeVRva2VuLnByb3RvdHlwZS5pZCA9ICctJztcblxuICAgIHJldHVybiBCbG9ja0VudHJ5VG9rZW47XG5cbiAgfSkodGhpcy5Ub2tlbik7XG5cbiAgdGhpcy5GbG93RW50cnlUb2tlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmxvd0VudHJ5VG9rZW4sIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBGbG93RW50cnlUb2tlbigpIHtcbiAgICAgIF9yZWYxMyA9IEZsb3dFbnRyeVRva2VuLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIF9yZWYxMztcbiAgICB9XG5cbiAgICBGbG93RW50cnlUb2tlbi5wcm90b3R5cGUuaWQgPSAnLCc7XG5cbiAgICByZXR1cm4gRmxvd0VudHJ5VG9rZW47XG5cbiAgfSkodGhpcy5Ub2tlbik7XG5cbiAgdGhpcy5BbGlhc1Rva2VuID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbGlhc1Rva2VuLCBfc3VwZXIpO1xuXG4gICAgQWxpYXNUb2tlbi5wcm90b3R5cGUuaWQgPSAnPGFsaWFzPic7XG5cbiAgICBmdW5jdGlvbiBBbGlhc1Rva2VuKHZhbHVlLCBzdGFydF9tYXJrLCBlbmRfbWFyaykge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5zdGFydF9tYXJrID0gc3RhcnRfbWFyaztcbiAgICAgIHRoaXMuZW5kX21hcmsgPSBlbmRfbWFyaztcbiAgICB9XG5cbiAgICByZXR1cm4gQWxpYXNUb2tlbjtcblxuICB9KSh0aGlzLlRva2VuKTtcblxuICB0aGlzLkFuY2hvclRva2VuID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbmNob3JUb2tlbiwgX3N1cGVyKTtcblxuICAgIEFuY2hvclRva2VuLnByb3RvdHlwZS5pZCA9ICc8YW5jaG9yPic7XG5cbiAgICBmdW5jdGlvbiBBbmNob3JUb2tlbih2YWx1ZSwgc3RhcnRfbWFyaywgZW5kX21hcmspIHtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuc3RhcnRfbWFyayA9IHN0YXJ0X21hcms7XG4gICAgICB0aGlzLmVuZF9tYXJrID0gZW5kX21hcms7XG4gICAgfVxuXG4gICAgcmV0dXJuIEFuY2hvclRva2VuO1xuXG4gIH0pKHRoaXMuVG9rZW4pO1xuXG4gIHRoaXMuVGFnVG9rZW4gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhZ1Rva2VuLCBfc3VwZXIpO1xuXG4gICAgVGFnVG9rZW4ucHJvdG90eXBlLmlkID0gJzx0YWc+JztcblxuICAgIGZ1bmN0aW9uIFRhZ1Rva2VuKHZhbHVlLCBzdGFydF9tYXJrLCBlbmRfbWFyaykge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5zdGFydF9tYXJrID0gc3RhcnRfbWFyaztcbiAgICAgIHRoaXMuZW5kX21hcmsgPSBlbmRfbWFyaztcbiAgICB9XG5cbiAgICByZXR1cm4gVGFnVG9rZW47XG5cbiAgfSkodGhpcy5Ub2tlbik7XG5cbiAgdGhpcy5TY2FsYXJUb2tlbiA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2NhbGFyVG9rZW4sIF9zdXBlcik7XG5cbiAgICBTY2FsYXJUb2tlbi5wcm90b3R5cGUuaWQgPSAnPHNjYWxhcj4nO1xuXG4gICAgZnVuY3Rpb24gU2NhbGFyVG9rZW4odmFsdWUsIHBsYWluLCBzdGFydF9tYXJrLCBlbmRfbWFyaywgc3R5bGUpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMucGxhaW4gPSBwbGFpbjtcbiAgICAgIHRoaXMuc3RhcnRfbWFyayA9IHN0YXJ0X21hcms7XG4gICAgICB0aGlzLmVuZF9tYXJrID0gZW5kX21hcms7XG4gICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNjYWxhclRva2VuO1xuXG4gIH0pKHRoaXMuVG9rZW4pO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgTWFya2VkWUFNTEVycm9yLCBpbmZsZWN0aW9uLCBub2RlcywgdXRpbCwgX3JlZiwgX3JlZjEsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChfX2hhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH07XG5cbiAgTWFya2VkWUFNTEVycm9yID0gcmVxdWlyZSgnLi9lcnJvcnMnKS5NYXJrZWRZQU1MRXJyb3I7XG5cbiAgbm9kZXMgPSByZXF1aXJlKCcuL25vZGVzJyk7XG5cbiAgaW5mbGVjdGlvbiA9IHJlcXVpcmUoJ2luZmxlY3Rpb24nKTtcblxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLypcbiAgVGhlIFRyYWl0cyB0aHJvd3MgdGhlc2UuXG4gICovXG5cblxuICB0aGlzLlRyYWl0RXJyb3IgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRyYWl0RXJyb3IsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBUcmFpdEVycm9yKCkge1xuICAgICAgX3JlZiA9IFRyYWl0RXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjtcbiAgICB9XG5cbiAgICByZXR1cm4gVHJhaXRFcnJvcjtcblxuICB9KShNYXJrZWRZQU1MRXJyb3IpO1xuXG4gIC8qXG4gICovXG5cblxuICB0aGlzLlBhcmFtZXRlckVycm9yID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYXJhbWV0ZXJFcnJvciwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFBhcmFtZXRlckVycm9yKCkge1xuICAgICAgX3JlZjEgPSBQYXJhbWV0ZXJFcnJvci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBfcmVmMTtcbiAgICB9XG5cbiAgICByZXR1cm4gUGFyYW1ldGVyRXJyb3I7XG5cbiAgfSkoTWFya2VkWUFNTEVycm9yKTtcblxuICAvKlxuICBUaGUgVHJhaXRzIGNsYXNzIGRlYWxzIHdpdGggYXBwbHlpbmcgdHJhaXRzIHRvIHJlc291cmNlcyBhY2NvcmRpbmcgdG8gdGhlIHNwZWNcbiAgKi9cblxuXG4gIHRoaXMuVHJhaXRzID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFRyYWl0cygpIHtcbiAgICAgIHRoaXMuZGVjbGFyZWRUcmFpdHMgPSB7fTtcbiAgICB9XG5cbiAgICBUcmFpdHMucHJvdG90eXBlLmxvYWRfdHJhaXRzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGFsbFRyYWl0cyxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuaGFzX3Byb3BlcnR5KG5vZGUsICd0cmFpdHMnKSkge1xuICAgICAgICBhbGxUcmFpdHMgPSB0aGlzLnByb3BlcnR5X3ZhbHVlKG5vZGUsICd0cmFpdHMnKTtcbiAgICAgICAgaWYgKGFsbFRyYWl0cyAmJiB0eXBlb2YgYWxsVHJhaXRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGFsbFRyYWl0cy5mb3JFYWNoKGZ1bmN0aW9uKHRyYWl0X2l0ZW0pIHtcbiAgICAgICAgICAgIGlmICh0cmFpdF9pdGVtICYmIHR5cGVvZiB0cmFpdF9pdGVtID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB0cmFpdF9pdGVtLnZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cmFpdF9pdGVtLnZhbHVlLmZvckVhY2goZnVuY3Rpb24odHJhaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZGVjbGFyZWRUcmFpdHNbdHJhaXRbMF0udmFsdWVdID0gdHJhaXQ7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRyYWl0cy5wcm90b3R5cGUuaGFzX3RyYWl0cyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmICh0aGlzLmRlY2xhcmVkVHJhaXRzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmhhc19wcm9wZXJ0eShub2RlLCAndHJhaXRzJykpIHtcbiAgICAgICAgdGhpcy5sb2FkX3RyYWl0cyhub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmRlY2xhcmVkVHJhaXRzKS5sZW5ndGggPiAwO1xuICAgIH07XG5cbiAgICBUcmFpdHMucHJvdG90eXBlLmdldF90cmFpdCA9IGZ1bmN0aW9uKHRyYWl0TmFtZSkge1xuICAgICAgaWYgKHRyYWl0TmFtZSBpbiB0aGlzLmRlY2xhcmVkVHJhaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY2xhcmVkVHJhaXRzW3RyYWl0TmFtZV1bMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgVHJhaXRzLnByb3RvdHlwZS5hcHBseV90cmFpdHMgPSBmdW5jdGlvbihub2RlLCByZXNvdXJjZVVyaSwgcmVtb3ZlUXMpIHtcbiAgICAgIHZhciByZXNvdXJjZXMsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGlmIChyZXNvdXJjZVVyaSA9PSBudWxsKSB7XG4gICAgICAgIHJlc291cmNlVXJpID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIGlmIChyZW1vdmVRcyA9PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZVFzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdXRpbC5pc01hcHBpbmcobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFzX3RyYWl0cyhub2RlKSkge1xuICAgICAgICByZXNvdXJjZXMgPSB0aGlzLmNoaWxkX3Jlc291cmNlcyhub2RlKTtcbiAgICAgICAgcmV0dXJuIHJlc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHJlc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmFwcGx5X3RyYWl0c190b19yZXNvdXJjZShyZXNvdXJjZVVyaSArIHJlc291cmNlWzBdLnZhbHVlLCByZXNvdXJjZVsxXSwgcmVtb3ZlUXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVHJhaXRzLnByb3RvdHlwZS5hcHBseV90cmFpdHNfdG9fcmVzb3VyY2UgPSBmdW5jdGlvbihyZXNvdXJjZVVyaSwgcmVzb3VyY2UsIHJlbW92ZVFzKSB7XG4gICAgICB2YXIgbWV0aG9kcywgdXNlcyxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyhyZXNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbWV0aG9kcyA9IHRoaXMuY2hpbGRfbWV0aG9kcyhyZXNvdXJjZSk7XG4gICAgICBpZiAodGhpcy5oYXNfcHJvcGVydHkocmVzb3VyY2UsICdpcycpKSB7XG4gICAgICAgIHVzZXMgPSB0aGlzLnByb3BlcnR5X3ZhbHVlKHJlc291cmNlLCAnaXMnKTtcbiAgICAgICAgdXNlcy5mb3JFYWNoKGZ1bmN0aW9uKHVzZSkge1xuICAgICAgICAgIHJldHVybiBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYXBwbHlfdHJhaXQocmVzb3VyY2VVcmksIG1ldGhvZCwgdXNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgIGlmIChfdGhpcy5oYXNfcHJvcGVydHkobWV0aG9kWzFdLCAnaXMnKSkge1xuICAgICAgICAgIHVzZXMgPSBfdGhpcy5wcm9wZXJ0eV92YWx1ZShtZXRob2RbMV0sICdpcycpO1xuICAgICAgICAgIHJldHVybiB1c2VzLmZvckVhY2goZnVuY3Rpb24odXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYXBwbHlfdHJhaXQocmVzb3VyY2VVcmksIG1ldGhvZCwgdXNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAocmVtb3ZlUXMpIHtcbiAgICAgICAgcmVzb3VyY2UucmVtb3ZlX3F1ZXN0aW9uX21hcmtfcHJvcGVydGllcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYXBwbHlfdHJhaXRzKHJlc291cmNlLCByZXNvdXJjZVVyaSwgcmVtb3ZlUXMpO1xuICAgIH07XG5cbiAgICBUcmFpdHMucHJvdG90eXBlLmFwcGx5X3RyYWl0ID0gZnVuY3Rpb24ocmVzb3VyY2VVcmksIG1ldGhvZCwgdXNlS2V5KSB7XG4gICAgICB2YXIgcGxhaW5QYXJhbWV0ZXJzLCB0ZW1wLCB0cmFpdCwgdHJhaXROYW1lO1xuICAgICAgdHJhaXROYW1lID0gdGhpcy5rZXlfb3JfdmFsdWUodXNlS2V5KTtcbiAgICAgIGlmICghKHRyYWl0TmFtZSAhPSBudWxsID8gdHJhaXROYW1lLnRyaW0oKSA6IHZvaWQgMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVHJhaXRFcnJvcignd2hpbGUgYXBwbHlpbmcgdHJhaXQnLCBudWxsLCAndHJhaXQgbmFtZSBtdXN0IGJlIHByb3ZpZGVkJywgdXNlS2V5LnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgaWYgKCEodHJhaXQgPSB0aGlzLmdldF90cmFpdCh0cmFpdE5hbWUpKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5UcmFpdEVycm9yKCd3aGlsZSBhcHBseWluZyB0cmFpdCcsIG51bGwsIFwidGhlcmUgaXMgbm8gdHJhaXQgbmFtZWQgXCIgKyB0cmFpdE5hbWUsIHVzZUtleS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHBsYWluUGFyYW1ldGVycyA9IHRoaXMuZ2V0X3BhcmFtZXRlcnNfZnJvbV9pc19rZXkocmVzb3VyY2VVcmksIG1ldGhvZFswXS52YWx1ZSwgdXNlS2V5KTtcbiAgICAgIHRlbXAgPSB0cmFpdC5jbG9uZUZvclRyYWl0KCk7XG4gICAgICB0aGlzLmFwcGx5X3BhcmFtZXRlcnModGVtcCwgcGxhaW5QYXJhbWV0ZXJzLCB1c2VLZXkpO1xuICAgICAgdGhpcy5hcHBseV9kZWZhdWx0X21lZGlhX3R5cGVfdG9fbWV0aG9kKHRlbXApO1xuICAgICAgdGVtcC5jb21iaW5lKG1ldGhvZFsxXSk7XG4gICAgICByZXR1cm4gbWV0aG9kWzFdID0gdGVtcDtcbiAgICB9O1xuXG4gICAgVHJhaXRzLnByb3RvdHlwZS5hcHBseV9wYXJhbWV0ZXJzID0gZnVuY3Rpb24ocmVzb3VyY2UsIHBhcmFtZXRlcnMsIHVzZUtleSkge1xuICAgICAgdmFyIHBhcmFtZXRlck5hbWUsIHVzZWRQYXJhbWV0ZXJzLCBfcmVzdWx0cztcbiAgICAgIHRoaXMuX2FwcGx5X3BhcmFtZXRlcnMocmVzb3VyY2UsIHBhcmFtZXRlcnMsIHVzZUtleSwgdXNlZFBhcmFtZXRlcnMgPSB7XG4gICAgICAgIHJlc291cmNlUGF0aDogdHJ1ZSxcbiAgICAgICAgcmVzb3VyY2VQYXRoTmFtZTogdHJ1ZSxcbiAgICAgICAgbWV0aG9kTmFtZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChwYXJhbWV0ZXJOYW1lIGluIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgaWYgKCF1c2VkUGFyYW1ldGVyc1twYXJhbWV0ZXJOYW1lXSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlBhcmFtZXRlckVycm9yKCd3aGlsZSBhcHBseWluZyBwYXJhbWV0ZXJzJywgbnVsbCwgXCJ1bnVzZWQgcGFyYW1ldGVyOiBcIiArIHBhcmFtZXRlck5hbWUsIHVzZUtleS5zdGFydF9tYXJrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgVHJhaXRzLnByb3RvdHlwZS5fYXBwbHlfcGFyYW1ldGVycyA9IGZ1bmN0aW9uKHJlc291cmNlLCBwYXJhbWV0ZXJzLCB1c2VLZXksIHVzZWRQYXJhbWV0ZXJzKSB7XG4gICAgICB2YXIgcGFyYW1ldGVyVXNlLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAoIXJlc291cmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh1dGlsLmlzU3RyaW5nKHJlc291cmNlKSkge1xuICAgICAgICBpZiAocGFyYW1ldGVyVXNlID0gcmVzb3VyY2UudmFsdWUubWF0Y2goLzw8XFxzKihbXlxcfFxccz5dKylcXHMqKFxcfC4qKT9cXHMqPj4vZykpIHtcbiAgICAgICAgICBwYXJhbWV0ZXJVc2UuZm9yRWFjaChmdW5jdGlvbihwYXJhbWV0ZXIpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QsIHBhcmFtZXRlck5hbWUsIHZhbHVlLCBfcmVmMiwgX3JlZjM7XG4gICAgICAgICAgICBwYXJhbWV0ZXJOYW1lID0gcGFyYW1ldGVyICE9IG51bGwgPyAoX3JlZjIgPSBwYXJhbWV0ZXIudHJpbSgpKSAhPSBudWxsID8gX3JlZjIucmVwbGFjZSgvWzw+XSsvZywgJycpLnRyaW0oKSA6IHZvaWQgMCA6IHZvaWQgMDtcbiAgICAgICAgICAgIF9yZWYzID0gcGFyYW1ldGVyTmFtZS5zcGxpdCgvXFxzKlxcfFxccyovKSwgcGFyYW1ldGVyTmFtZSA9IF9yZWYzWzBdLCBtZXRob2QgPSBfcmVmM1sxXTtcbiAgICAgICAgICAgIGlmICghKHBhcmFtZXRlck5hbWUgaW4gcGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuUGFyYW1ldGVyRXJyb3IoJ3doaWxlIGFwcGx5aW5nIHBhcmFtZXRlcnMnLCBudWxsLCBcInZhbHVlIHdhcyBub3QgcHJvdmlkZWQgZm9yIHBhcmFtZXRlcjogXCIgKyBwYXJhbWV0ZXJOYW1lLCB1c2VLZXkuc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcmFtZXRlcnNbcGFyYW1ldGVyTmFtZV07XG4gICAgICAgICAgICB1c2VkUGFyYW1ldGVyc1twYXJhbWV0ZXJOYW1lXSA9IHRydWU7XG4gICAgICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgIGlmIChtZXRob2QubWF0Y2goLyFcXHMqc2luZ3VsYXJpemUvKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaW5mbGVjdGlvbi5zaW5ndWxhcml6ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobWV0aG9kLm1hdGNoKC8hXFxzKnBsdXJhbGl6ZS8pKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpbmZsZWN0aW9uLnBsdXJhbGl6ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuUGFyYW1ldGVyRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyJywgbnVsbCwgJ3Vua25vd24gZnVuY3Rpb24gYXBwbGllZCB0byBwYXJhbWV0ZXInLCByZXNvdXJjZS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc291cmNlLnZhbHVlID0gcmVzb3VyY2UudmFsdWUucmVwbGFjZShwYXJhbWV0ZXIsIHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodXRpbC5pc1NlcXVlbmNlKHJlc291cmNlKSkge1xuICAgICAgICByZXNvdXJjZS52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX2FwcGx5X3BhcmFtZXRlcnMobm9kZSwgcGFyYW1ldGVycywgdXNlS2V5LCB1c2VkUGFyYW1ldGVycyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodXRpbC5pc01hcHBpbmcocmVzb3VyY2UpKSB7XG4gICAgICAgIHJlc291cmNlLnZhbHVlLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgICBfdGhpcy5fYXBwbHlfcGFyYW1ldGVycyhwcm9wZXJ0eVswXSwgcGFyYW1ldGVycywgdXNlS2V5LCB1c2VkUGFyYW1ldGVycyk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9hcHBseV9wYXJhbWV0ZXJzKHByb3BlcnR5WzFdLCBwYXJhbWV0ZXJzLCB1c2VLZXksIHVzZWRQYXJhbWV0ZXJzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRyYWl0cy5wcm90b3R5cGUuZ2V0X3BhcmFtZXRlcnNfZnJvbV9pc19rZXkgPSBmdW5jdGlvbihyZXNvdXJjZVVyaSwgbWV0aG9kTmFtZSwgdHlwZUtleSkge1xuICAgICAgdmFyIHBhcmFtZXRlciwgcGFyYW1ldGVycywgcmVzZXJ2ZWQsIHJlc3VsdCwgX2ksIF9sZW4sIF9yZWYyO1xuICAgICAgcmVzdWx0ID0ge307XG4gICAgICByZXNlcnZlZCA9IHtcbiAgICAgICAgbWV0aG9kTmFtZTogbWV0aG9kTmFtZSxcbiAgICAgICAgcmVzb3VyY2VQYXRoOiByZXNvdXJjZVVyaS5yZXBsYWNlKC9cXC9cXC8qL2csICcvJyksXG4gICAgICAgIHJlc291cmNlUGF0aE5hbWU6IHRoaXMuZXh0cmFjdFJlc291cmNlUGF0aE5hbWUocmVzb3VyY2VVcmkpXG4gICAgICB9O1xuICAgICAgaWYgKHV0aWwuaXNNYXBwaW5nKHR5cGVLZXkpKSB7XG4gICAgICAgIHBhcmFtZXRlcnMgPSB0aGlzLnZhbHVlX29yX3VuZGVmaW5lZCh0eXBlS2V5KTtcbiAgICAgICAgaWYgKHV0aWwuaXNNYXBwaW5nKHBhcmFtZXRlcnNbMF1bMV0pKSB7XG4gICAgICAgICAgX3JlZjIgPSBwYXJhbWV0ZXJzWzBdWzFdLnZhbHVlO1xuICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjIubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgIHBhcmFtZXRlciA9IF9yZWYyW19pXTtcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJbMF0udmFsdWUgaW4gcmVzZXJ2ZWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVHJhaXRFcnJvcignd2hpbGUgYXBwbHlpbmcgcGFyYW1ldGVycycsIG51bGwsIFwiaW52YWxpZCBwYXJhbWV0ZXIgbmFtZTogXCIgKyBwYXJhbWV0ZXJbMF0udmFsdWUgKyBcIiBpcyByZXNlcnZlZFwiLCBwYXJhbWV0ZXJbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbcGFyYW1ldGVyWzBdLnZhbHVlXSA9IHBhcmFtZXRlclsxXS52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1dGlsLmV4dGVuZChyZXN1bHQsIHJlc2VydmVkKTtcbiAgICB9O1xuXG4gICAgVHJhaXRzLnByb3RvdHlwZS5leHRyYWN0UmVzb3VyY2VQYXRoTmFtZSA9IGZ1bmN0aW9uKHJlc291cmNlVXJpKSB7XG4gICAgICB2YXIgcGF0aFNlZ21lbnRzLCBzZWdtZW50O1xuICAgICAgcGF0aFNlZ21lbnRzID0gcmVzb3VyY2VVcmkuc3BsaXQoL1xcLy8pO1xuICAgICAgd2hpbGUgKHNlZ21lbnQgPSBwYXRoU2VnbWVudHMucG9wKCkpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIHNlZ21lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VnbWVudCAhPT0gbnVsbCA/IHNlZ21lbnQubWF0Y2goL1t7fV0vKSA6IHZvaWQgMCkpIHtcbiAgICAgICAgICByZXR1cm4gc2VnbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfTtcblxuICAgIHJldHVybiBUcmFpdHM7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGVzLCB1cml0ZW1wbGF0ZSwgdXRpbCxcbiAgICBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9O1xuXG4gIHVyaXRlbXBsYXRlID0gcmVxdWlyZSgndXJpdGVtcGxhdGUnKTtcblxuICBub2RlcyA9IHJlcXVpcmUoJy4vbm9kZXMnKTtcblxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbiAgLypcbiAgICAgQXBwbGllcyB0cmFuc2Zvcm1hdGlvbnMgdG8gdGhlIFJBTUxcbiAgKi9cblxuXG4gIHRoaXMuVHJhbnNmb3JtYXRpb25zID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybWF0aW9ucyhzZXR0aW5ncykge1xuICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgdGhpcy5pc0NvbnRlbnRUeXBlU3RyaW5nID0gX19iaW5kKHRoaXMuaXNDb250ZW50VHlwZVN0cmluZywgdGhpcyk7XG4gICAgICB0aGlzLmFkZF9rZXlfdmFsdWVfdG9fbm9kZSA9IF9fYmluZCh0aGlzLmFkZF9rZXlfdmFsdWVfdG9fbm9kZSwgdGhpcyk7XG4gICAgICB0aGlzLmFwcGx5X2RlZmF1bHRfbWVkaWFfdHlwZV90b19yZXNvdXJjZSA9IF9fYmluZCh0aGlzLmFwcGx5X2RlZmF1bHRfbWVkaWFfdHlwZV90b19yZXNvdXJjZSwgdGhpcyk7XG4gICAgICB0aGlzLmdldF9tZWRpYV90eXBlID0gX19iaW5kKHRoaXMuZ2V0X21lZGlhX3R5cGUsIHRoaXMpO1xuICAgICAgdGhpcy5sb2FkX2RlZmF1bHRfbWVkaWFfdHlwZSA9IF9fYmluZCh0aGlzLmxvYWRfZGVmYXVsdF9tZWRpYV90eXBlLCB0aGlzKTtcbiAgICAgIHRoaXMuYXBwbHlBc3RUcmFuc2Zvcm1hdGlvbnMgPSBfX2JpbmQodGhpcy5hcHBseUFzdFRyYW5zZm9ybWF0aW9ucywgdGhpcyk7XG4gICAgICB0aGlzLmFwcGx5VHJhbnNmb3JtYXRpb25zID0gX19iaW5kKHRoaXMuYXBwbHlUcmFuc2Zvcm1hdGlvbnMsIHRoaXMpO1xuICAgICAgdGhpcy5kZWNsYXJlZFNjaGVtYXMgPSB7fTtcbiAgICB9XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLmFwcGx5VHJhbnNmb3JtYXRpb25zID0gZnVuY3Rpb24ocm9vdE9iamVjdCkge1xuICAgICAgdmFyIHJlc291cmNlcztcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnRyYW5zZm9ybSkge1xuICAgICAgICB0aGlzLmFwcGx5VHJhbnNmb3JtYXRpb25zVG9Sb290KHJvb3RPYmplY3QpO1xuICAgICAgICByZXNvdXJjZXMgPSByb290T2JqZWN0LnJlc291cmNlcztcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUcmFuc2Zvcm1hdGlvbnNUb1Jlc291cmNlcyhyb290T2JqZWN0LCByZXNvdXJjZXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLmFwcGx5QXN0VHJhbnNmb3JtYXRpb25zID0gZnVuY3Rpb24oZG9jdW1lbnQpIHtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1fZG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLmxvYWRfZGVmYXVsdF9tZWRpYV90eXBlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyhub2RlIHx8IChub2RlICE9IG51bGwgPyBub2RlLnZhbHVlIDogdm9pZCAwKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubWVkaWFUeXBlID0gdGhpcy5wcm9wZXJ0eV92YWx1ZShub2RlLCAnbWVkaWFUeXBlJyk7XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUuZ2V0X21lZGlhX3R5cGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lZGlhVHlwZTtcbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS5hcHBseVRyYW5zZm9ybWF0aW9uc1RvUm9vdCA9IGZ1bmN0aW9uKHJvb3RPYmplY3QpIHtcbiAgICAgIHZhciBleHByZXNzaW9ucywgdGVtcGxhdGU7XG4gICAgICBpZiAocm9vdE9iamVjdC5iYXNlVXJpKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdXJpdGVtcGxhdGUucGFyc2Uocm9vdE9iamVjdC5iYXNlVXJpKTtcbiAgICAgICAgZXhwcmVzc2lvbnMgPSB0ZW1wbGF0ZS5leHByZXNzaW9ucy5maWx0ZXIoZnVuY3Rpb24oZXhwcikge1xuICAgICAgICAgIHJldHVybiAndGVtcGxhdGVUZXh0JyBpbiBleHByO1xuICAgICAgICB9KS5tYXAoZnVuY3Rpb24oZXhwcmVzc2lvbikge1xuICAgICAgICAgIHJldHVybiBleHByZXNzaW9uLnRlbXBsYXRlVGV4dDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIXJvb3RPYmplY3QuYmFzZVVyaVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIHJvb3RPYmplY3QuYmFzZVVyaVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zLmZvckVhY2goZnVuY3Rpb24ocGFyYW1ldGVyTmFtZSkge1xuICAgICAgICAgIGlmICghKHBhcmFtZXRlck5hbWUgaW4gcm9vdE9iamVjdC5iYXNlVXJpUGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgIHJvb3RPYmplY3QuYmFzZVVyaVBhcmFtZXRlcnNbcGFyYW1ldGVyTmFtZV0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogcGFyYW1ldGVyTmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJOYW1lID09PSBcInZlcnNpb25cIikge1xuICAgICAgICAgICAgICByZXR1cm4gcm9vdE9iamVjdC5iYXNlVXJpUGFyYW1ldGVyc1twYXJhbWV0ZXJOYW1lXVtcImVudW1cIl0gPSBbcm9vdE9iamVjdC52ZXJzaW9uXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLmFwcGx5VHJhbnNmb3JtYXRpb25zVG9SZXNvdXJjZXMgPSBmdW5jdGlvbihyb290T2JqZWN0LCByZXNvdXJjZXMpIHtcbiAgICAgIHZhciBleHByZXNzaW9ucywgaW5oZXJpdGVkU2VjU2NoZW1lLCBtZXRob2QsIHBhcmFtZXRlck5hbWUsIHBhdGhQYXJ0cywgcmVzb3VyY2UsIHRlbXBsYXRlLCBfaSwgX2osIF9rLCBfbGVuLCBfbGVuMSwgX2xlbjIsIF9yZWYsIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgIGlmIChyZXNvdXJjZXMgIT0gbnVsbCA/IHJlc291cmNlcy5sZW5ndGggOiB2b2lkIDApIHtcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSByZXNvdXJjZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICByZXNvdXJjZSA9IHJlc291cmNlc1tfaV07XG4gICAgICAgICAgaW5oZXJpdGVkU2VjU2NoZW1lID0gcmVzb3VyY2Uuc2VjdXJlZEJ5ID8gcmVzb3VyY2Uuc2VjdXJlZEJ5IDogcm9vdE9iamVjdCAhPSBudWxsID8gcm9vdE9iamVjdC5zZWN1cmVkQnkgOiB2b2lkIDA7XG4gICAgICAgICAgaWYgKChfcmVmID0gcmVzb3VyY2UubWV0aG9kcykgIT0gbnVsbCA/IF9yZWYubGVuZ3RoIDogdm9pZCAwKSB7XG4gICAgICAgICAgICBfcmVmMSA9IHJlc291cmNlLm1ldGhvZHM7XG4gICAgICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmMS5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICAgICAgbWV0aG9kID0gX3JlZjFbX2pdO1xuICAgICAgICAgICAgICBpZiAoIShcInNlY3VyZWRCeVwiIGluIG1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5oZXJpdGVkU2VjU2NoZW1lKSB7XG4gICAgICAgICAgICAgICAgICBtZXRob2Quc2VjdXJlZEJ5ID0gaW5oZXJpdGVkU2VjU2NoZW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwYXRoUGFydHMgPSByZXNvdXJjZS5yZWxhdGl2ZVVyaS5zcGxpdCgnXFwvJyk7XG4gICAgICAgICAgd2hpbGUgKCFwYXRoUGFydHNbMF0gJiYgcGF0aFBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcGF0aFBhcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc291cmNlLnJlbGF0aXZlVXJpUGF0aFNlZ21lbnRzID0gcGF0aFBhcnRzO1xuICAgICAgICAgIHRlbXBsYXRlID0gdXJpdGVtcGxhdGUucGFyc2UocmVzb3VyY2UucmVsYXRpdmVVcmkpO1xuICAgICAgICAgIGV4cHJlc3Npb25zID0gdGVtcGxhdGUuZXhwcmVzc2lvbnMuZmlsdGVyKGZ1bmN0aW9uKGV4cHIpIHtcbiAgICAgICAgICAgIHJldHVybiAndGVtcGxhdGVUZXh0JyBpbiBleHByO1xuICAgICAgICAgIH0pLm1hcChmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi50ZW1wbGF0ZVRleHQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCFyZXNvdXJjZS51cmlQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICAgIHJlc291cmNlLnVyaVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChfayA9IDAsIF9sZW4yID0gZXhwcmVzc2lvbnMubGVuZ3RoOyBfayA8IF9sZW4yOyBfaysrKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJOYW1lID0gZXhwcmVzc2lvbnNbX2tdO1xuICAgICAgICAgICAgaWYgKCEocGFyYW1ldGVyTmFtZSBpbiByZXNvdXJjZS51cmlQYXJhbWV0ZXJzKSkge1xuICAgICAgICAgICAgICByZXNvdXJjZS51cmlQYXJhbWV0ZXJzW3BhcmFtZXRlck5hbWVdID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IHBhcmFtZXRlck5hbWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLmFwcGx5VHJhbnNmb3JtYXRpb25zVG9SZXNvdXJjZXMocm9vdE9iamVjdCwgcmVzb3VyY2UucmVzb3VyY2VzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgIE1lZGlhIFR5cGUgcGl2b3Qgd2hlbiB1c2luZyBkZWZhdWx0IG1lZGlhVHlwZSBwcm9wZXJ0eVxuICAgICovXG5cblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUuYXBwbHlfZGVmYXVsdF9tZWRpYV90eXBlX3RvX3Jlc291cmNlID0gZnVuY3Rpb24ocmVzb3VyY2UpIHtcbiAgICAgIHZhciBjaGlsZFJlc291cmNlLCBtZXRob2QsIF9pLCBfaiwgX2xlbiwgX2xlbjEsIF9yZWYsIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgIGlmICghdGhpcy5tZWRpYVR5cGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyhyZXNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3JlZiA9IHRoaXMuY2hpbGRfcmVzb3VyY2VzKHJlc291cmNlKTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBjaGlsZFJlc291cmNlID0gX3JlZltfaV07XG4gICAgICAgIHRoaXMuYXBwbHlfZGVmYXVsdF9tZWRpYV90eXBlX3RvX3Jlc291cmNlKGNoaWxkUmVzb3VyY2VbMV0pO1xuICAgICAgfVxuICAgICAgX3JlZjEgPSB0aGlzLmNoaWxkX21ldGhvZHMocmVzb3VyY2UpO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYxLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICBtZXRob2QgPSBfcmVmMVtfal07XG4gICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy5hcHBseV9kZWZhdWx0X21lZGlhX3R5cGVfdG9fbWV0aG9kKG1ldGhvZFsxXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLmFwcGx5X2RlZmF1bHRfbWVkaWFfdHlwZV90b19tZXRob2QgPSBmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHZhciByZXNwb25zZXMsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGlmICghdGhpcy5tZWRpYVR5cGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyhtZXRob2QpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc19wcm9wZXJ0eShtZXRob2QsICdib2R5JykpIHtcbiAgICAgICAgdGhpcy5hcHBseV9kZWZhdWx0X21lZGlhX3R5cGVfdG9fYm9keSh0aGlzLmdldF9wcm9wZXJ0eShtZXRob2QsICdib2R5JykpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFzX3Byb3BlcnR5KG1ldGhvZCwgJ3Jlc3BvbnNlcycpKSB7XG4gICAgICAgIHJlc3BvbnNlcyA9IHRoaXMuZ2V0X3Byb3BlcnR5KG1ldGhvZCwgJ3Jlc3BvbnNlcycpO1xuICAgICAgICBpZiAoIShyZXNwb25zZXMgJiYgcmVzcG9uc2VzLnZhbHVlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2VzLnZhbHVlLmZvckVhY2goZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICBpZiAoX3RoaXMuaGFzX3Byb3BlcnR5KHJlc3BvbnNlWzFdLCAnYm9keScpKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYXBwbHlfZGVmYXVsdF9tZWRpYV90eXBlX3RvX2JvZHkoX3RoaXMuZ2V0X3Byb3BlcnR5KHJlc3BvbnNlWzFdLCAnYm9keScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLmFwcGx5X2RlZmF1bHRfbWVkaWFfdHlwZV90b19ib2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgdmFyIGtleSwgcmVzcG9uc2VUeXBlLCByZXNwb25zZVR5cGVLZXksIF9yZWYsIF9yZWYxLCBfcmVmMjtcbiAgICAgIGlmICghdXRpbC5pc01hcHBpbmcoYm9keSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGJvZHkgIT0gbnVsbCA/IChfcmVmID0gYm9keS52YWx1ZSkgIT0gbnVsbCA/IChfcmVmMSA9IF9yZWZbMF0pICE9IG51bGwgPyAoX3JlZjIgPSBfcmVmMVswXSkgIT0gbnVsbCA/IF9yZWYyLnZhbHVlIDogdm9pZCAwIDogdm9pZCAwIDogdm9pZCAwIDogdm9pZCAwKSB7XG4gICAgICAgIGtleSA9IGJvZHkudmFsdWVbMF1bMF0udmFsdWU7XG4gICAgICAgIGlmICgha2V5Lm1hdGNoKC9cXC8vKSkge1xuICAgICAgICAgIHJlc3BvbnNlVHlwZSA9IG5ldyBub2Rlcy5NYXBwaW5nTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6bWFwJywgW10sIGJvZHkuc3RhcnRfbWFyaywgYm9keS5lbmRfbWFyayk7XG4gICAgICAgICAgcmVzcG9uc2VUeXBlS2V5ID0gbmV3IG5vZGVzLlNjYWxhck5vZGUoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsIHRoaXMubWVkaWFUeXBlLCBib2R5LnN0YXJ0X21hcmssIGJvZHkuZW5kX21hcmspO1xuICAgICAgICAgIHJlc3BvbnNlVHlwZS52YWx1ZS5wdXNoKFtyZXNwb25zZVR5cGVLZXksIGJvZHkuY2xvbmUoKV0pO1xuICAgICAgICAgIHJldHVybiBib2R5LnZhbHVlID0gcmVzcG9uc2VUeXBlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUubm9vcCA9IGZ1bmN0aW9uKCkge307XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLnRyYW5zZm9ybV90eXBlcyA9IGZ1bmN0aW9uKHR5cGVQcm9wZXJ0eSkge1xuICAgICAgdmFyIHR5cGVzLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICB0eXBlcyA9IHR5cGVQcm9wZXJ0eS52YWx1ZTtcbiAgICAgIHJldHVybiB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uKHR5cGVfZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVfZW50cnkudmFsdWUuZm9yRWFjaChmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV9yZXNvdXJjZSh0eXBlLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS50cmFuc2Zvcm1fdHJhaXRzID0gZnVuY3Rpb24odHJhaXRQcm9wZXJ0eSkge1xuICAgICAgdmFyIHRyYWl0cyxcbiAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgdHJhaXRzID0gdHJhaXRQcm9wZXJ0eS52YWx1ZTtcbiAgICAgIHJldHVybiB0cmFpdHMuZm9yRWFjaChmdW5jdGlvbih0cmFpdF9lbnRyeSkge1xuICAgICAgICByZXR1cm4gdHJhaXRfZW50cnkudmFsdWUuZm9yRWFjaChmdW5jdGlvbih0cmFpdCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fbWV0aG9kKHRyYWl0WzFdLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS50cmFuc2Zvcm1fbmFtZWRfcGFyYW1zID0gZnVuY3Rpb24ocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cywgcmVxdWlyZWRCeURlZmF1bHQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAocmVxdWlyZWRCeURlZmF1bHQgPT0gbnVsbCkge1xuICAgICAgICByZXF1aXJlZEJ5RGVmYXVsdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodXRpbC5pc051bGwocHJvcGVydHlbMV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wZXJ0eVsxXS52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgIGlmICh1dGlsLmlzTnVsbChwYXJhbVsxXSkpIHtcbiAgICAgICAgICBwYXJhbVsxXSA9IG5ldyBub2Rlcy5NYXBwaW5nTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6bWFwJywgW10sIHBhcmFtWzFdLnN0YXJ0X21hcmssIHBhcmFtWzFdLmVuZF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX2NvbW1vbl9wYXJhbWV0ZXJfcHJvcGVydGllcyhwYXJhbVswXS52YWx1ZSwgcGFyYW1bMV0sIGFsbG93UGFyYW1ldGVyS2V5cywgcmVxdWlyZWRCeURlZmF1bHQpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUudHJhbnNmb3JtX2NvbW1vbl9wYXJhbWV0ZXJfcHJvcGVydGllcyA9IGZ1bmN0aW9uKHBhcmFtZXRlck5hbWUsIG5vZGUsIGFsbG93UGFyYW1ldGVyS2V5cywgcmVxdWlyZWRCeURlZmF1bHQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAodXRpbC5pc1NlcXVlbmNlKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBub2RlLnZhbHVlLmZvckVhY2goZnVuY3Rpb24ocGFyYW1ldGVyKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV9uYW1lZF9wYXJhbWV0ZXIocGFyYW1ldGVyTmFtZSwgcGFyYW1ldGVyLCBhbGxvd1BhcmFtZXRlcktleXMsIHJlcXVpcmVkQnlEZWZhdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1fbmFtZWRfcGFyYW1ldGVyKHBhcmFtZXRlck5hbWUsIG5vZGUsIGFsbG93UGFyYW1ldGVyS2V5cywgcmVxdWlyZWRCeURlZmF1bHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLnRyYW5zZm9ybV9uYW1lZF9wYXJhbWV0ZXIgPSBmdW5jdGlvbihwYXJhbWV0ZXJOYW1lLCBub2RlLCBhbGxvd1BhcmFtZXRlcktleXMsIHJlcXVpcmVkQnlEZWZhdWx0KSB7XG4gICAgICB2YXIgaGFzRGlzcGxheU5hbWUsIGhhc1JlcXVpcmVkLCBoYXNUeXBlLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICBoYXNEaXNwbGF5TmFtZSA9IGZhbHNlO1xuICAgICAgaGFzUmVxdWlyZWQgPSBmYWxzZTtcbiAgICAgIGhhc1R5cGUgPSBmYWxzZTtcbiAgICAgIG5vZGUudmFsdWUuZm9yRWFjaChmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAgICAgICAgdmFyIGNhbm9uaWNhbFByb3BlcnR5TmFtZTtcbiAgICAgICAgaWYgKGFsbG93UGFyYW1ldGVyS2V5cyAmJiBfdGhpcy5pc1BhcmFtZXRlcktleShjaGlsZE5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhbm9uaWNhbFByb3BlcnR5TmFtZSA9IF90aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShjaGlsZE5vZGVbMF0udmFsdWUsIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgIHN3aXRjaCAoY2Fub25pY2FsUHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgY2FzZSBcInBhdHRlcm5cIjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgY2FzZSBcImRlZmF1bHRcIjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgY2FzZSBcImRlc2NyaXB0aW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgIGNhc2UgXCJleGFtcGxlXCI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgIGNhc2UgXCJtaW5MZW5ndGhcIjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgY2FzZSBcIm1heExlbmd0aFwiOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICBjYXNlIFwibWluaW11bVwiOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICBjYXNlIFwibWF4aW11bVwiOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICBjYXNlIFwicmVwZWF0XCI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgIGNhc2UgXCJkaXNwbGF5TmFtZVwiOlxuICAgICAgICAgICAgcmV0dXJuIGhhc0Rpc3BsYXlOYW1lID0gdHJ1ZTtcbiAgICAgICAgICBjYXNlIFwidHlwZVwiOlxuICAgICAgICAgICAgcmV0dXJuIGhhc1R5cGUgPSB0cnVlO1xuICAgICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICAgICAgcmV0dXJuIGhhc1JlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIWhhc0Rpc3BsYXlOYW1lKSB7XG4gICAgICAgIHRoaXMuYWRkX2tleV92YWx1ZV90b19ub2RlKG5vZGUsICdkaXNwbGF5TmFtZScsICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLCB0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShwYXJhbWV0ZXJOYW1lLCBhbGxvd1BhcmFtZXRlcktleXMpKTtcbiAgICAgIH1cbiAgICAgIGlmICghaGFzUmVxdWlyZWQpIHtcbiAgICAgICAgaWYgKHJlcXVpcmVkQnlEZWZhdWx0KSB7XG4gICAgICAgICAgdGhpcy5hZGRfa2V5X3ZhbHVlX3RvX25vZGUobm9kZSwgJ3JlcXVpcmVkJywgJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLCAndHJ1ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWhhc1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkX2tleV92YWx1ZV90b19ub2RlKG5vZGUsICd0eXBlJywgJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsICdzdHJpbmcnKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS5hZGRfa2V5X3ZhbHVlX3RvX25vZGUgPSBmdW5jdGlvbihub2RlLCBrZXlOYW1lLCB2YWx1ZVRhZywgdmFsdWUpIHtcbiAgICAgIHZhciBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWU7XG4gICAgICBwcm9wZXJ0eU5hbWUgPSBuZXcgbm9kZXMuU2NhbGFyTm9kZSgndGFnOnlhbWwub3JnLDIwMDI6c3RyJywga2V5TmFtZSwgbm9kZS5zdGFydF9tYXJrLCBub2RlLmVuZF9tYXJrKTtcbiAgICAgIHByb3BlcnR5VmFsdWUgPSBuZXcgbm9kZXMuU2NhbGFyTm9kZSh2YWx1ZVRhZywgdmFsdWUsIG5vZGUuc3RhcnRfbWFyaywgbm9kZS5lbmRfbWFyayk7XG4gICAgICByZXR1cm4gbm9kZS52YWx1ZS5wdXNoKFtwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWVdKTtcbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS50cmFuc2Zvcm1fZG9jdW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKG5vZGUgIT0gbnVsbCA/IG5vZGUudmFsdWUgOiB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIG5vZGUudmFsdWUuZm9yRWFjaChmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICAgIHZhciBfcmVmO1xuICAgICAgICAgIHN3aXRjaCAocHJvcGVydHlbMF0udmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0aXRsZVwiOlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgICAgY2FzZSBcInNlY3VyaXR5U2NoZW1lc1wiOlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgICAgY2FzZSBcInNjaGVtYXNcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICAgIGNhc2UgXCJ2ZXJzaW9uXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgICBjYXNlIFwiZG9jdW1lbnRhdGlvblwiOlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgICAgY2FzZSBcIm1lZGlhVHlwZVwiOlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgICAgY2FzZSBcInNlY3VyZWRCeVwiOlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgICAgY2FzZSBcImJhc2VVcmlcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICAgIGNhc2UgXCJ0cmFpdHNcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV90cmFpdHMocHJvcGVydHlbMV0pO1xuICAgICAgICAgICAgY2FzZSBcImJhc2VVcmlQYXJhbWV0ZXJzXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fbmFtZWRfcGFyYW1zKHByb3BlcnR5LCBmYWxzZSk7XG4gICAgICAgICAgICBjYXNlIFwicmVzb3VyY2VUeXBlc1wiOlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX3R5cGVzKHByb3BlcnR5WzFdKTtcbiAgICAgICAgICAgIGNhc2UgXCJyZXNvdXJjZXNcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIChfcmVmID0gcHJvcGVydHlbMV0pICE9IG51bGwgPyBfcmVmLnZhbHVlLmZvckVhY2goZnVuY3Rpb24ocmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX3Jlc291cmNlKHJlc291cmNlKTtcbiAgICAgICAgICAgICAgfSkgOiB2b2lkIDA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFRyYW5zZm9ybWF0aW9ucy5wcm90b3R5cGUudHJhbnNmb3JtX3Jlc291cmNlID0gZnVuY3Rpb24ocmVzb3VyY2UsIGFsbG93UGFyYW1ldGVyS2V5cykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmIChhbGxvd1BhcmFtZXRlcktleXMgPT0gbnVsbCkge1xuICAgICAgICBhbGxvd1BhcmFtZXRlcktleXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNvdXJjZS52YWx1ZSkge1xuICAgICAgICByZXR1cm4gcmVzb3VyY2UudmFsdWUuZm9yRWFjaChmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICAgIHZhciBjYW5vbmljYWxLZXksIGlzS25vd25Db21tb25Qcm9wZXJ0eSwgX3JlZiwgX3JlZjE7XG4gICAgICAgICAgaXNLbm93bkNvbW1vblByb3BlcnR5ID0gX3RoaXMudHJhbnNmb3JtX2NvbW1vbl9wcm9wZXJ0aWVzKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgIGlmICghaXNLbm93bkNvbW1vblByb3BlcnR5KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNIdHRwTWV0aG9kKHByb3BlcnR5WzBdLnZhbHVlLCBhbGxvd1BhcmFtZXRlcktleXMpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fbWV0aG9kKHByb3BlcnR5WzFdLCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2Fub25pY2FsS2V5ID0gX3RoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKHByb3BlcnR5WzBdLnZhbHVlLCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgICAgICBzd2l0Y2ggKGNhbm9uaWNhbEtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0eXBlXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ1c2FnZVwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwic2VjdXJlZEJ5XCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ1cmlQYXJhbWV0ZXJzXCI6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX25hbWVkX3BhcmFtcyhwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYmFzZVVyaVBhcmFtZXRlcnNcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fbmFtZWRfcGFyYW1zKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNvdXJjZXNcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiAoX3JlZiA9IHByb3BlcnR5WzFdKSAhPSBudWxsID8gX3JlZi52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHJlc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fcmVzb3VyY2UocmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgfSkgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1ldGhvZHNcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiAoX3JlZjEgPSBwcm9wZXJ0eVsxXSkgIT0gbnVsbCA/IF9yZWYxLnZhbHVlLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fbWV0aG9kKG1ldGhvZCwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICAgICAgICAgIH0pIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS50cmFuc2Zvcm1fbWV0aG9kID0gZnVuY3Rpb24obWV0aG9kLCBhbGxvd1BhcmFtZXRlcktleXMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAodXRpbC5pc051bGwobWV0aG9kKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gbWV0aG9kLnZhbHVlLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgdmFyIGNhbm9uaWNhbEtleTtcbiAgICAgICAgaWYgKF90aGlzLnRyYW5zZm9ybV9jb21tb25fcHJvcGVydGllcyhwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYW5vbmljYWxLZXkgPSBfdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUocHJvcGVydHlbMF0udmFsdWUsIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgIHN3aXRjaCAoY2Fub25pY2FsS2V5KSB7XG4gICAgICAgICAgY2FzZSBcInNlY3VyZWRCeVwiOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICBjYXNlIFwidXNhZ2VcIjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgY2FzZSBcImhlYWRlcnNcIjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fbmFtZWRfcGFyYW1zKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMsIGZhbHNlKTtcbiAgICAgICAgICBjYXNlIFwicXVlcnlQYXJhbWV0ZXJzXCI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX25hbWVkX3BhcmFtcyhwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcImJhc2VVcmlQYXJhbWV0ZXJzXCI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMudHJhbnNmb3JtX25hbWVkX3BhcmFtcyhwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV9ib2R5KHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgIGNhc2UgXCJyZXNwb25zZXNcIjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fcmVzcG9uc2VzKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS50cmFuc2Zvcm1fcmVzcG9uc2VzID0gZnVuY3Rpb24ocmVzcG9uc2VzLCBhbGxvd1BhcmFtZXRlcktleXMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAodXRpbC5pc051bGwocmVzcG9uc2VzWzFdKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2VzWzFdLnZhbHVlLmZvckVhY2goZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV9yZXNwb25zZShyZXNwb25zZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLnRyYW5zZm9ybV9yZXNwb25zZSA9IGZ1bmN0aW9uKHJlc3BvbnNlLCBhbGxvd1BhcmFtZXRlcktleXMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAodXRpbC5pc01hcHBpbmcocmVzcG9uc2VbMV0pKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZVsxXS52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIGNhbm9uaWNhbEtleTtcbiAgICAgICAgICBjYW5vbmljYWxLZXkgPSBfdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUocHJvcGVydHlbMF0udmFsdWUsIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgc3dpdGNoIChjYW5vbmljYWxLZXkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkZXNjcmlwdGlvblwiOlxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV9ib2R5KHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgICAgY2FzZSBcImhlYWRlcnNcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV9uYW1lZF9wYXJhbXMocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cywgZmFsc2UpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm5vb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLmlzQ29udGVudFR5cGVTdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyB2YWx1ZS5tYXRjaCgvXlteXFwvXStcXC9bXlxcL10rJC8pIDogdm9pZCAwO1xuICAgIH07XG5cbiAgICBUcmFuc2Zvcm1hdGlvbnMucHJvdG90eXBlLnRyYW5zZm9ybV9ib2R5ID0gZnVuY3Rpb24ocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cykge1xuICAgICAgdmFyIF9yZWYsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh1dGlsLmlzTnVsbChwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChfcmVmID0gcHJvcGVydHlbMV0udmFsdWUpICE9IG51bGwgPyBfcmVmLmZvckVhY2goZnVuY3Rpb24oYm9keVByb3BlcnR5KSB7XG4gICAgICAgIHZhciBjYW5vbmljYWxQcm9wZXJ0eTtcbiAgICAgICAgaWYgKF90aGlzLmlzUGFyYW1ldGVyS2V5KGJvZHlQcm9wZXJ0eSkpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMubm9vcCgpO1xuICAgICAgICB9IGVsc2UgaWYgKF90aGlzLmlzQ29udGVudFR5cGVTdHJpbmcoYm9keVByb3BlcnR5WzBdLnZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2Zvcm1fYm9keShib2R5UHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2Fub25pY2FsUHJvcGVydHkgPSBfdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUoYm9keVByb3BlcnR5WzBdLnZhbHVlLCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgIHN3aXRjaCAoY2Fub25pY2FsUHJvcGVydHkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJleGFtcGxlXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgICBjYXNlIFwic2NoZW1hXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgICBjYXNlIFwiZm9ybVBhcmFtZXRlcnNcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRyYW5zZm9ybV9uYW1lZF9wYXJhbXMoYm9keVByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMsIGZhbHNlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5ub29wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSA6IHZvaWQgMDtcbiAgICB9O1xuXG4gICAgVHJhbnNmb3JtYXRpb25zLnByb3RvdHlwZS50cmFuc2Zvcm1fY29tbW9uX3Byb3BlcnRpZXMgPSBmdW5jdGlvbihwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSB7XG4gICAgICB2YXIgY2Fub25pY2FsUHJvcGVydHk7XG4gICAgICBpZiAodGhpcy5pc1BhcmFtZXRlcktleShwcm9wZXJ0eSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW5vbmljYWxQcm9wZXJ0eSA9IHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKHByb3BlcnR5WzBdLnZhbHVlLCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICBzd2l0Y2ggKGNhbm9uaWNhbFByb3BlcnR5KSB7XG4gICAgICAgICAgY2FzZSBcImRpc3BsYXlOYW1lXCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBjYXNlIFwiZGVzY3JpcHRpb25cIjpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIGNhc2UgXCJpc1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMubm9vcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHJldHVybiBUcmFuc2Zvcm1hdGlvbnM7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIF9fc2xpY2UgPSBbXS5zbGljZSxcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICB0aGlzLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZXN0aW5hdGlvbiwgaywgc291cmNlLCBzb3VyY2VzLCB2LCBfaSwgX2xlbjtcbiAgICBkZXN0aW5hdGlvbiA9IGFyZ3VtZW50c1swXSwgc291cmNlcyA9IDIgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpIDogW107XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBzb3VyY2VzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBzb3VyY2UgPSBzb3VyY2VzW19pXTtcbiAgICAgIGZvciAoayBpbiBzb3VyY2UpIHtcbiAgICAgICAgdiA9IHNvdXJjZVtrXTtcbiAgICAgICAgZGVzdGluYXRpb25ba10gPSB2O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdGluYXRpb247XG4gIH07XG5cbiAgdGhpcy5pc19lbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSB8fCB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgaWYgKCFfX2hhc1Byb3AuY2FsbChvYmosIGtleSkpIGNvbnRpbnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICB0aGlzLmlzTm9vcCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfTtcblxuICB0aGlzLmlzTWFwcGluZyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUgIT0gbnVsbCA/IG5vZGUudGFnIDogdm9pZCAwKSA9PT0gXCJ0YWc6eWFtbC5vcmcsMjAwMjptYXBcIjtcbiAgfTtcblxuICB0aGlzLmlzTnVsbCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUgIT0gbnVsbCA/IG5vZGUudGFnIDogdm9pZCAwKSA9PT0gXCJ0YWc6eWFtbC5vcmcsMjAwMjpudWxsXCI7XG4gIH07XG5cbiAgdGhpcy5pc1NlcXVlbmNlID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiAobm9kZSAhPSBudWxsID8gbm9kZS50YWcgOiB2b2lkIDApID09PSBcInRhZzp5YW1sLm9yZywyMDAyOnNlcVwiO1xuICB9O1xuXG4gIHRoaXMuaXNTdHJpbmcgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIChub2RlICE9IG51bGwgPyBub2RlLnRhZyA6IHZvaWQgMCkgPT09IFwidGFnOnlhbWwub3JnLDIwMDI6c3RyXCI7XG4gIH07XG5cbiAgdGhpcy5pc0ludGVnZXIgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIChub2RlICE9IG51bGwgPyBub2RlLnRhZyA6IHZvaWQgMCkgPT09IFwidGFnOnlhbWwub3JnLDIwMDI6aW50XCI7XG4gIH07XG5cbiAgdGhpcy5pc051bGxhYmxlTWFwcGluZyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5pc01hcHBpbmcobm9kZSkgfHwgdGhpcy5pc051bGwobm9kZSk7XG4gIH07XG5cbiAgdGhpcy5pc051bGxhYmxlU3RyaW5nID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiB0aGlzLmlzU3RyaW5nKG5vZGUpIHx8IHRoaXMuaXNOdWxsKG5vZGUpO1xuICB9O1xuXG4gIHRoaXMuaXNOdWxsYWJsZVNlcXVlbmNlID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiB0aGlzLmlzU2VxdWVuY2Uobm9kZSkgfHwgdGhpcy5pc051bGwobm9kZSk7XG4gIH07XG5cbiAgdGhpcy5pc051bWJlciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUgIT0gbnVsbCA/IG5vZGUudGFnIDogdm9pZCAwKSA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOmludCcgfHwgKG5vZGUgIT0gbnVsbCA/IG5vZGUudGFnIDogdm9pZCAwKSA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JztcbiAgfTtcblxuICB0aGlzLmlzU2NhbGFyID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiAobm9kZSAhPSBudWxsID8gbm9kZS50YWcgOiB2b2lkIDApID09PSAndGFnOnlhbWwub3JnLDIwMDI6bnVsbCcgfHwgKG5vZGUgIT0gbnVsbCA/IG5vZGUudGFnIDogdm9pZCAwKSA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnIHx8IChub2RlICE9IG51bGwgPyBub2RlLnRhZyA6IHZvaWQgMCkgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnIHx8IChub2RlICE9IG51bGwgPyBub2RlLnRhZyA6IHZvaWQgMCkgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcgfHwgKG5vZGUgIT0gbnVsbCA/IG5vZGUudGFnIDogdm9pZCAwKSA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScgfHwgKG5vZGUgIT0gbnVsbCA/IG5vZGUudGFnIDogdm9pZCAwKSA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCcgfHwgKG5vZGUgIT0gbnVsbCA/IG5vZGUudGFnIDogdm9pZCAwKSA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOnN0cic7XG4gIH07XG5cbiAgdGhpcy5pc0NvbGxlY3Rpb24gPSBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIChub2RlICE9IG51bGwgPyBub2RlLnRhZyA6IHZvaWQgMCkgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJyB8fCAobm9kZSAhPSBudWxsID8gbm9kZS50YWcgOiB2b2lkIDApID09PSAndGFnOnlhbWwub3JnLDIwMDI6cGFpcnMnIHx8IChub2RlICE9IG51bGwgPyBub2RlLnRhZyA6IHZvaWQgMCkgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnIHx8IChub2RlICE9IG51bGwgPyBub2RlLnRhZyA6IHZvaWQgMCkgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnIHx8IChub2RlICE9IG51bGwgPyBub2RlLnRhZyA6IHZvaWQgMCkgPT09ICd0YWc6eWFtbC5vcmcsMjAwMjptYXAnO1xuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgTWFya2VkWUFNTEVycm9yLCBqc29ubGludCwgbm9kZXMsIHRyYWl0cywgdXJpdGVtcGxhdGUsIHVybCwgdXRpbCwgX3JlZixcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKF9faGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LFxuICAgIF9faW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24oaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9O1xuXG4gIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG4gIHVyaXRlbXBsYXRlID0gcmVxdWlyZSgndXJpdGVtcGxhdGUnKTtcblxuICBNYXJrZWRZQU1MRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9ycycpLk1hcmtlZFlBTUxFcnJvcjtcblxuICBub2RlcyA9IHJlcXVpcmUoJy4vbm9kZXMnKTtcblxuICB0cmFpdHMgPSByZXF1aXJlKCcuL3RyYWl0cycpO1xuXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICBqc29ubGludCA9IHJlcXVpcmUoJ2pzb24tbGludCcpO1xuXG4gIC8qXG4gIFRoZSBWYWxpZGF0b3IgdGhyb3dzIHRoZXNlLlxuICAqL1xuXG5cbiAgdGhpcy5WYWxpZGF0aW9uRXJyb3IgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFZhbGlkYXRpb25FcnJvciwgX3N1cGVyKTtcblxuICAgIGZ1bmN0aW9uIFZhbGlkYXRpb25FcnJvcigpIHtcbiAgICAgIF9yZWYgPSBWYWxpZGF0aW9uRXJyb3IuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gX3JlZjtcbiAgICB9XG5cbiAgICByZXR1cm4gVmFsaWRhdGlvbkVycm9yO1xuXG4gIH0pKE1hcmtlZFlBTUxFcnJvcik7XG5cbiAgLypcbiAgQSBjb2xsZWN0aW9uIG9mIG11bHRpcGxlIHZhbGlkYXRpb24gZXJyb3JzXG4gICovXG5cblxuICB0aGlzLlZhbGlkYXRpb25FcnJvcnMgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFZhbGlkYXRpb25FcnJvcnMsIF9zdXBlcik7XG5cbiAgICBmdW5jdGlvbiBWYWxpZGF0aW9uRXJyb3JzKHZhbGlkYXRpb25fZXJyb3JzKSB7XG4gICAgICB0aGlzLnZhbGlkYXRpb25fZXJyb3JzID0gdmFsaWRhdGlvbl9lcnJvcnM7XG4gICAgfVxuXG4gICAgVmFsaWRhdGlvbkVycm9ycy5wcm90b3R5cGUuZ2V0X3ZhbGlkYXRpb25fZXJyb3JzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0aW9uX2Vycm9ycztcbiAgICB9O1xuXG4gICAgcmV0dXJuIFZhbGlkYXRpb25FcnJvcnM7XG5cbiAgfSkoTWFya2VkWUFNTEVycm9yKTtcblxuICAvKlxuICBUaGUgVmFsaWRhdG9yIGNsYXNzIGRlYWxzIHdpdGggdmFsaWRhdGluZyBhIFlBTUwgZmlsZSBhY2NvcmRpbmcgdG8gdGhlIHNwZWNcbiAgKi9cblxuXG4gIHRoaXMuVmFsaWRhdG9yID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFZhbGlkYXRvcigpIHtcbiAgICAgIHRoaXMuZ2V0X3Byb3BlcnRpZXMgPSBfX2JpbmQodGhpcy5nZXRfcHJvcGVydGllcywgdGhpcyk7XG4gICAgICB0aGlzLmdldF9saXN0X3ZhbHVlcyA9IF9fYmluZCh0aGlzLmdldF9saXN0X3ZhbHVlcywgdGhpcyk7XG4gICAgICB0aGlzLnZhbGlkYXRpb25zID0gW3RoaXMudmFsaWRhdGVfcm9vdCwgdGhpcy52YWxpZGF0ZV9yb290X3Byb3BlcnRpZXMsIHRoaXMudmFsaWRhdGVfYmFzZV91cmlfcGFyYW1ldGVycywgdGhpcy52YWxpZF9hYnNvbHV0ZV91cmlzXTtcbiAgICB9XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX2RvY3VtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHZhbGlkYXRpb24sIF9pLCBfbGVuLCBfcmVmMTtcbiAgICAgIF9yZWYxID0gdGhpcy52YWxpZGF0aW9ucztcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgdmFsaWRhdGlvbiA9IF9yZWYxW19pXTtcbiAgICAgICAgdmFsaWRhdGlvbi5jYWxsKHRoaXMsIG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfc2VjdXJpdHlfc2NoZW1lcyA9IGZ1bmN0aW9uKHNjaGVtZXNQcm9wZXJ0eSkge1xuICAgICAgdmFyIHNjaGVtZSwgc2NoZW1lX2VudHJ5LCBfaSwgX2xlbiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgaWYgKCF1dGlsLmlzU2VxdWVuY2Uoc2NoZW1lc1Byb3BlcnR5KSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHlTY2hlbWVzJywgbnVsbCwgJ2ludmFsaWQgc2VjdXJpdHkgc2NoZW1lcyBwcm9wZXJ0eSwgaXQgbXVzdCBiZSBhbiBhcnJheScsIHNjaGVtZXNQcm9wZXJ0eS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIF9yZWYxID0gc2NoZW1lc1Byb3BlcnR5LnZhbHVlO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgc2NoZW1lX2VudHJ5ID0gX3JlZjFbX2ldO1xuICAgICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKHNjaGVtZV9lbnRyeSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHlTY2hlbWVzJywgbnVsbCwgJ2ludmFsaWQgc2VjdXJpdHkgc2NoZW1lIHByb3BlcnR5LCBpdCBtdXN0IGJlIGEgbWFwJywgc2NoZW1lX2VudHJ5LnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIF9yZXN1bHRzLnB1c2goKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfaiwgX2xlbjEsIF9yZWYyLCBfcmVzdWx0czE7XG4gICAgICAgICAgX3JlZjIgPSBzY2hlbWVfZW50cnkudmFsdWU7XG4gICAgICAgICAgX3Jlc3VsdHMxID0gW107XG4gICAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjIubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgICBzY2hlbWUgPSBfcmVmMltfal07XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKHNjaGVtZVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5U2NoZW1lcycsIG51bGwsICdpbnZhbGlkIHNlY3VyaXR5IHNjaGVtZSBwcm9wZXJ0eSwgaXQgbXVzdCBiZSBhIG1hcCcsIHNjaGVtZVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9yZXN1bHRzMS5wdXNoKHRoaXMudmFsaWRhdGVfc2VjdXJpdHlfc2NoZW1lKHNjaGVtZVsxXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHMxO1xuICAgICAgICB9KS5jYWxsKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS50cmFja1JlcGVhdGVkUHJvcGVydGllcyA9IGZ1bmN0aW9uKHByb3BlcnRpZXMsIGtleSwgcHJvcGVydHksIHNlY3Rpb24sIGVycm9yTWVzc2FnZSkge1xuICAgICAgaWYgKHNlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICBzZWN0aW9uID0gXCJSQU1MXCI7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3JNZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gXCJhIHByb3BlcnR5IHdpdGggdGhlIHNhbWUgbmFtZSBhbHJlYWR5IGV4aXN0c1wiO1xuICAgICAgfVxuICAgICAgaWYgKGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcihcIndoaWxlIHZhbGlkYXRpbmcgXCIgKyBzZWN0aW9uLCBudWxsLCBcIlwiICsgZXJyb3JNZXNzYWdlICsgXCI6ICdcIiArIGtleSArIFwiJ1wiLCBwcm9wZXJ0eS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzW2tleV0gPSBwcm9wZXJ0eTtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9zZWN1cml0eV9zY2hlbWUgPSBmdW5jdGlvbihzY2hlbWUpIHtcbiAgICAgIHZhciBwcm9wZXJ0eSwgc2NoZW1lUHJvcGVydGllcywgc2V0dGluZ3MsIHR5cGUsIF9pLCBfbGVuLCBfcmVmMTtcbiAgICAgIHR5cGUgPSBudWxsO1xuICAgICAgc2V0dGluZ3MgPSBudWxsO1xuICAgICAgc2NoZW1lUHJvcGVydGllcyA9IHt9O1xuICAgICAgX3JlZjEgPSBzY2hlbWUudmFsdWU7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHByb3BlcnR5ID0gX3JlZjFbX2ldO1xuICAgICAgICB0aGlzLnRyYWNrUmVwZWF0ZWRQcm9wZXJ0aWVzKHNjaGVtZVByb3BlcnRpZXMsIHByb3BlcnR5WzBdLnZhbHVlLCBwcm9wZXJ0eVswXSwgJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHkgc2NoZW1lJywgXCJwcm9wZXJ0eSBhbHJlYWR5IHVzZWQgaW4gc2VjdXJpdHkgc2NoZW1lXCIpO1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5WzBdLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSBcImRlc2NyaXB0aW9uXCI6XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNTY2FsYXIocHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eSBzY2hlbWUnLCBudWxsLCAnc2NoZW1lcyBkZXNjcmlwdGlvbiBtdXN0IGJlIGEgc3RyaW5nJywgcHJvcGVydHlbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidHlwZVwiOlxuICAgICAgICAgICAgdHlwZSA9IHByb3BlcnR5WzFdLnZhbHVlO1xuICAgICAgICAgICAgaWYgKCEodXRpbC5pc1N0cmluZyhwcm9wZXJ0eVsxXSkgJiYgdHlwZS5tYXRjaCgvXihPQXV0aCAxLjB8T0F1dGggMi4wfEJhc2ljIEF1dGhlbnRpY2F0aW9ufERpZ2VzdCBBdXRoZW50aWNhdGlvbnx4LS4rKSQvKSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5IHNjaGVtZScsIG51bGwsICdzY2hlbWVzIHR5cGUgbXVzdCBiZSBhbnkgb2Y6IFwiT0F1dGggMS4wXCIsIFwiT0F1dGggMi4wXCIsIFwiQmFzaWMgQXV0aGVudGljYXRpb25cIiwgXCJEaWdlc3QgQXV0aGVudGljYXRpb25cIiwgXCJ4LVxcey4rXFx9XCInLCBwcm9wZXJ0eVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJkZXNjcmliZWRCeVwiOlxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZV9tZXRob2QocHJvcGVydHksIHRydWUsIFwic2VjdXJpdHkgc2NoZW1lXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInNldHRpbmdzXCI6XG4gICAgICAgICAgICBzZXR0aW5ncyA9IHByb3BlcnR5O1xuICAgICAgICAgICAgaWYgKCF1dGlsLmlzTnVsbGFibGVNYXBwaW5nKHByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHkgc2NoZW1lJywgbnVsbCwgJ3NjaGVtZXMgc2V0dGluZ3MgbXVzdCBiZSBhIG1hcCcsIHByb3BlcnR5WzFdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eSBzY2hlbWUnLCBudWxsLCBcInByb3BlcnR5OiAnXCIgKyBwcm9wZXJ0eVswXS52YWx1ZSArIFwiJyBpcyBpbnZhbGlkIGluIGEgc2VjdXJpdHkgc2NoZW1lXCIsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5IHNjaGVtZScsIG51bGwsICdzY2hlbWVzIHR5cGUgbXVzdCBiZSBhbnkgb2Y6IFwiT0F1dGggMS4wXCIsIFwiT0F1dGggMi4wXCIsIFwiQmFzaWMgQXV0aGVudGljYXRpb25cIiwgXCJEaWdlc3QgQXV0aGVudGljYXRpb25cIiwgXCJ4LVxcey4rXFx9XCInLCBzY2hlbWUuc3RhcnRfbWFyayk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiT0F1dGggMi4wXCIpIHtcbiAgICAgICAgaWYgKCFzZXR0aW5ncykge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eSBzY2hlbWUnLCBudWxsLCAnZm9yIE9BdXRoIDIuMCBzZXR0aW5ncyBtdXN0IGJlIGEgbWFwJywgc2NoZW1lLnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlX29hdXRoMl9zZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiT0F1dGggMS4wXCIpIHtcbiAgICAgICAgaWYgKCFzZXR0aW5ncykge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eSBzY2hlbWUnLCBudWxsLCAnZm9yIE9BdXRoIDEuMCBzZXR0aW5ncyBtdXN0IGJlIGEgbWFwJywgc2NoZW1lLnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlX29hdXRoMV9zZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfb2F1dGgyX3NldHRpbmdzID0gZnVuY3Rpb24oc2V0dGluZ3MpIHtcbiAgICAgIHZhciBwcm9wZXJ0eSwgcHJvcGVydHlOYW1lLCBzZXR0aW5nUHJvcGVydGllcywgX2ksIF9qLCBfbGVuLCBfbGVuMSwgX3JlZjEsIF9yZWYyLCBfcmVzdWx0cztcbiAgICAgIHNldHRpbmdQcm9wZXJ0aWVzID0ge307XG4gICAgICBfcmVmMSA9IHNldHRpbmdzWzFdLnZhbHVlO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwcm9wZXJ0eSA9IF9yZWYxW19pXTtcbiAgICAgICAgdGhpcy50cmFja1JlcGVhdGVkUHJvcGVydGllcyhzZXR0aW5nUHJvcGVydGllcywgcHJvcGVydHlbMF0udmFsdWUsIHByb3BlcnR5WzBdLCAnd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eSBzY2hlbWUnLCBcInNldHRpbmcgd2l0aCB0aGUgc2FtZSBuYW1lIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5WzBdLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSBcImF1dGhvcml6YXRpb25VcmlcIjpcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1N0cmluZyhwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5IHNjaGVtZScsIG51bGwsICdhdXRob3JpemF0aW9uVXJpIG11c3QgYmUgYSBVUkwnLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJhY2Nlc3NUb2tlblVyaVwiOlxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzU3RyaW5nKHByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHkgc2NoZW1lJywgbnVsbCwgJ2FjY2Vzc1Rva2VuVXJpIG11c3QgYmUgYSBVUkwnLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX3JlZjIgPSBbJ2FjY2Vzc1Rva2VuVXJpJywgJ2F1dGhvcml6YXRpb25VcmknXTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmMi5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgcHJvcGVydHlOYW1lID0gX3JlZjJbX2pdO1xuICAgICAgICBpZiAoIShwcm9wZXJ0eU5hbWUgaW4gc2V0dGluZ1Byb3BlcnRpZXMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5IHNjaGVtZScsIG51bGwsIFwiT0F1dGggMi4wIHNldHRpbmdzIG11c3QgaGF2ZSBcIiArIHByb3BlcnR5TmFtZSArIFwiIHByb3BlcnR5XCIsIHNldHRpbmdzWzBdLnN0YXJ0X21hcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX29hdXRoMV9zZXR0aW5ncyA9IGZ1bmN0aW9uKHNldHRpbmdzKSB7XG4gICAgICB2YXIgcHJvcGVydHksIHByb3BlcnR5TmFtZSwgc2V0dGluZ1Byb3BlcnRpZXMsIF9pLCBfaiwgX2xlbiwgX2xlbjEsIF9yZWYxLCBfcmVmMiwgX3Jlc3VsdHM7XG4gICAgICBzZXR0aW5nUHJvcGVydGllcyA9IHt9O1xuICAgICAgX3JlZjEgPSBzZXR0aW5nc1sxXS52YWx1ZTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcHJvcGVydHkgPSBfcmVmMVtfaV07XG4gICAgICAgIHRoaXMudHJhY2tSZXBlYXRlZFByb3BlcnRpZXMoc2V0dGluZ1Byb3BlcnRpZXMsIHByb3BlcnR5WzBdLnZhbHVlLCBwcm9wZXJ0eVswXSwgJ3doaWxlIHZhbGlkYXRpbmcgc2VjdXJpdHkgc2NoZW1lJywgXCJzZXR0aW5nIHdpdGggdGhlIHNhbWUgbmFtZSBhbHJlYWR5IGV4aXN0c1wiKTtcbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0eVswXS52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgXCJyZXF1ZXN0VG9rZW5VcmlcIjpcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1N0cmluZyhwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5IHNjaGVtZScsIG51bGwsICdyZXF1ZXN0VG9rZW5VcmkgbXVzdCBiZSBhIFVSTCcsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImF1dGhvcml6YXRpb25VcmlcIjpcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1N0cmluZyhwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5IHNjaGVtZScsIG51bGwsICdhdXRob3JpemF0aW9uVXJpIG11c3QgYmUgYSBVUkwnLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ0b2tlbkNyZWRlbnRpYWxzVXJpXCI6XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNTdHJpbmcocHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eSBzY2hlbWUnLCBudWxsLCAndG9rZW5DcmVkZW50aWFsc1VyaSBtdXN0IGJlIGEgVVJMJywgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9yZWYyID0gWydyZXF1ZXN0VG9rZW5VcmknLCAnYXV0aG9yaXphdGlvblVyaScsICd0b2tlbkNyZWRlbnRpYWxzVXJpJ107XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjIubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgIHByb3BlcnR5TmFtZSA9IF9yZWYyW19qXTtcbiAgICAgICAgaWYgKCEocHJvcGVydHlOYW1lIGluIHNldHRpbmdQcm9wZXJ0aWVzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eSBzY2hlbWUnLCBudWxsLCBcIk9BdXRoIDEuMCBzZXR0aW5ncyBtdXN0IGhhdmUgXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIiBwcm9wZXJ0eVwiLCBzZXR0aW5nc1swXS5zdGFydF9tYXJrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9yb290X3NjaGVtYXMgPSBmdW5jdGlvbihzY2hlbWFzKSB7XG4gICAgICB2YXIgc2NoZW1hLCBzY2hlbWFMaXN0LCBzY2hlbWFOYW1lLCBfcmVzdWx0cztcbiAgICAgIGlmICghdXRpbC5pc1NlcXVlbmNlKHNjaGVtYXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzY2hlbWFzJywgbnVsbCwgJ3NjaGVtYXMgcHJvcGVydHkgbXVzdCBiZSBhbiBhcnJheScsIHNjaGVtYXMuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBzY2hlbWFMaXN0ID0gdGhpcy5nZXRfYWxsX3NjaGVtYXMoKTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKHNjaGVtYU5hbWUgaW4gc2NoZW1hTGlzdCkge1xuICAgICAgICBzY2hlbWEgPSBzY2hlbWFMaXN0W3NjaGVtYU5hbWVdO1xuICAgICAgICBpZiAoIShzY2hlbWFbMV0udGFnICYmIHV0aWwuaXNTdHJpbmcoc2NoZW1hWzFdKSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgc2NoZW1hcycsIG51bGwsICdzY2hlbWEgJyArIHNjaGVtYU5hbWUgKyAnIG11c3QgYmUgYSBzdHJpbmcnLCBzY2hlbWFbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLnZhbGlkYXRlU2NoZW1hKHNjaGVtYVsxXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX3Jvb3QgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAoIShub2RlIHx8IHV0aWwuaXNOdWxsKG5vZGUpKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcm9vdCcsIG51bGwsICdlbXB0eSBkb2N1bWVudCcsIG5vZGUgIT0gbnVsbCA/IG5vZGUuc3RhcnRfbWFyayA6IHZvaWQgMCk7XG4gICAgICB9XG4gICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKG5vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByb290JywgbnVsbCwgJ2RvY3VtZW50IG11c3QgYmUgYSBtYXAnLCBub2RlLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX2Jhc2VfdXJpX3BhcmFtZXRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5iYXNlVXJpUGFyYW1ldGVycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuYmFzZVVyaSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgdXJpIHBhcmFtZXRlcnMnLCBudWxsLCAndXJpIHBhcmFtZXRlcnMgZGVmaW5lZCB3aGVuIHRoZXJlIGlzIG5vIGJhc2VVcmknLCB0aGlzLmJhc2VVcmlQYXJhbWV0ZXJzLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgaWYgKCF1dGlsLmlzTnVsbGFibGVNYXBwaW5nKHRoaXMuYmFzZVVyaVBhcmFtZXRlcnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyB1cmkgcGFyYW1ldGVycycsIG51bGwsICdiYXNlIHVyaSBwYXJhbWV0ZXJzIG11c3QgYmUgYSBtYXAnLCB0aGlzLmJhc2VVcmlQYXJhbWV0ZXJzLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVfdXJpX3BhcmFtZXRlcnModGhpcy5iYXNlVXJpLCB0aGlzLmJhc2VVcmlQYXJhbWV0ZXJzLCBmYWxzZSwgZmFsc2UsIFtcInZlcnNpb25cIl0pO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX3VyaV9wYXJhbWV0ZXJzID0gZnVuY3Rpb24odXJpLCB1cmlQcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzLCBza2lwUGFyYW1ldGVyVXNlQ2hlY2ssIHJlc2VydmVkTmFtZXMpIHtcbiAgICAgIHZhciBlcnIsIGV4cHJlc3Npb25zLCBwYXJhbWV0ZXJOYW1lLCB0ZW1wbGF0ZSwgdXJpUGFyYW1ldGVyLCB1cmlQYXJhbWV0ZXJzLCBfaSwgX2xlbiwgX3JlZjEsIF9yZWYyLCBfcmVzdWx0cztcbiAgICAgIGlmIChyZXNlcnZlZE5hbWVzID09IG51bGwpIHtcbiAgICAgICAgcmVzZXJ2ZWROYW1lcyA9IFtdO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGVtcGxhdGUgPSB1cml0ZW1wbGF0ZS5wYXJzZSh1cmkpO1xuICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIGVyciA9IF9lcnJvcjtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHVyaSBwYXJhbWV0ZXJzJywgbnVsbCwgZXJyICE9IG51bGwgPyAoX3JlZjEgPSBlcnIub3B0aW9ucykgIT0gbnVsbCA/IF9yZWYxLm1lc3NhZ2UgOiB2b2lkIDAgOiB2b2lkIDAsIHVyaVByb3BlcnR5LnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgZXhwcmVzc2lvbnMgPSB0ZW1wbGF0ZS5leHByZXNzaW9ucy5maWx0ZXIoZnVuY3Rpb24oZXhwcikge1xuICAgICAgICByZXR1cm4gXCJ0ZW1wbGF0ZVRleHRcIiBpbiBleHByO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24udGVtcGxhdGVUZXh0O1xuICAgICAgfSk7XG4gICAgICB1cmlQYXJhbWV0ZXJzID0ge307XG4gICAgICBpZiAodHlwZW9mIHVyaVByb3BlcnR5LnZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIF9yZWYyID0gdXJpUHJvcGVydHkudmFsdWU7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjIubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICB1cmlQYXJhbWV0ZXIgPSBfcmVmMltfaV07XG4gICAgICAgICAgcGFyYW1ldGVyTmFtZSA9IHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKHVyaVBhcmFtZXRlclswXS52YWx1ZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICB0aGlzLnRyYWNrUmVwZWF0ZWRQcm9wZXJ0aWVzKHVyaVBhcmFtZXRlcnMsIHBhcmFtZXRlck5hbWUsIHVyaVByb3BlcnR5LCAnd2hpbGUgdmFsaWRhdGluZyBVUkkgcGFyYW1ldGVycycsIFwiVVJJIHBhcmFtZXRlciB3aXRoIHRoZSBzYW1lIG5hbWUgYWxyZWFkeSBleGlzdHNcIik7XG4gICAgICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKHJlc2VydmVkTmFtZXMsIHBhcmFtZXRlck5hbWUpID49IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBiYXNlVXJpJywgbnVsbCwgdXJpUGFyYW1ldGVyWzBdLnZhbHVlICsgJyBwYXJhbWV0ZXIgbm90IGFsbG93ZWQgaGVyZScsIHVyaVBhcmFtZXRlclswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEodXRpbC5pc051bGxhYmxlTWFwcGluZyh1cmlQYXJhbWV0ZXJbMV0sIGFsbG93UGFyYW1ldGVyS2V5cykgfHwgdXRpbC5pc051bGxhYmxlU2VxdWVuY2UodXJpUGFyYW1ldGVyWzFdLCBhbGxvd1BhcmFtZXRlcktleXMpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGJhc2VVcmknLCBudWxsLCAnVVJJIHBhcmFtZXRlciBtdXN0IGJlIGEgbWFwJywgdXJpUGFyYW1ldGVyWzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXV0aWwuaXNOdWxsKHVyaVBhcmFtZXRlclsxXSkpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRfY29tbW9uX3BhcmFtZXRlcl9wcm9wZXJ0aWVzKHVyaVBhcmFtZXRlclsxXSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEoc2tpcFBhcmFtZXRlclVzZUNoZWNrIHx8IHRoaXMuaXNQYXJhbWV0ZXJLZXkodXJpUGFyYW1ldGVyKSB8fCBfX2luZGV4T2YuY2FsbChleHByZXNzaW9ucywgcGFyYW1ldGVyTmFtZSkgPj0gMCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBiYXNlVXJpJywgbnVsbCwgdXJpUGFyYW1ldGVyWzBdLnZhbHVlICsgJyB1cmkgcGFyYW1ldGVyIHVudXNlZCcsIHVyaVBhcmFtZXRlclswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfdHlwZXMgPSBmdW5jdGlvbih0eXBlUHJvcGVydHkpIHtcbiAgICAgIHZhciB0eXBlLCB0eXBlX2VudHJ5LCB0eXBlcywgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgdHlwZXMgPSB0eXBlUHJvcGVydHkudmFsdWU7XG4gICAgICBpZiAoIXV0aWwuaXNTZXF1ZW5jZSh0eXBlUHJvcGVydHkpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZSB0eXBlcycsIG51bGwsICdpbnZhbGlkIHJlc291cmNlVHlwZXMgZGVmaW5pdGlvbiwgaXQgbXVzdCBiZSBhbiBhcnJheScsIHR5cGVQcm9wZXJ0eS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHR5cGVzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHR5cGVfZW50cnkgPSB0eXBlc1tfaV07XG4gICAgICAgIGlmICghdXRpbC5pc01hcHBpbmcodHlwZV9lbnRyeSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2UgdHlwZXMnLCBudWxsLCAnaW52YWxpZCByZXNvdXJjZVR5cGUgZGVmaW5pdGlvbiwgaXQgbXVzdCBiZSBhIG1hcCcsIHR5cGVfZW50cnkuc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgX3Jlc3VsdHMucHVzaCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9qLCBfbGVuMSwgX3JlZjEsIF9yZXN1bHRzMTtcbiAgICAgICAgICBfcmVmMSA9IHR5cGVfZW50cnkudmFsdWU7XG4gICAgICAgICAgX3Jlc3VsdHMxID0gW107XG4gICAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjEubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgICB0eXBlID0gX3JlZjFbX2pdO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNQYXJhbWV0ZXJLZXkodHlwZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlIHR5cGVzJywgbnVsbCwgJ3BhcmFtZXRlciBrZXkgY2Fubm90IGJlIHVzZWQgYXMgYSByZXNvdXJjZSB0eXBlIG5hbWUnLCB0eXBlWzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyh0eXBlWzFdKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2UgdHlwZXMnLCBudWxsLCAnaW52YWxpZCByZXNvdXJjZVR5cGUgZGVmaW5pdGlvbiwgaXQgbXVzdCBiZSBhIG1hcCcsIHR5cGVbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfcmVzdWx0czEucHVzaCh0aGlzLnZhbGlkYXRlX3Jlc291cmNlKHR5cGUsIHRydWUsICdyZXNvdXJjZSB0eXBlJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHMxO1xuICAgICAgICB9KS5jYWxsKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV90cmFpdHMgPSBmdW5jdGlvbih0cmFpdFByb3BlcnR5KSB7XG4gICAgICB2YXIgdHJhaXQsIHRyYWl0X2VudHJ5LCBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICB0cmFpdHMgPSB0cmFpdFByb3BlcnR5LnZhbHVlO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRyYWl0cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHRyYWl0cycsIG51bGwsICdpbnZhbGlkIHRyYWl0cyBkZWZpbml0aW9uLCBpdCBtdXN0IGJlIGFuIGFycmF5JywgdHJhaXRQcm9wZXJ0eS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHRyYWl0cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICB0cmFpdF9lbnRyeSA9IHRyYWl0c1tfaV07XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0cmFpdF9lbnRyeS52YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgdHJhaXRzJywgbnVsbCwgJ2ludmFsaWQgdHJhaXRzIGRlZmluaXRpb24sIGl0IG11c3QgYmUgYW4gYXJyYXknLCB0cmFpdFByb3BlcnR5LnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIF9yZXN1bHRzLnB1c2goKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfaiwgX2xlbjEsIF9yZWYxLCBfcmVzdWx0czE7XG4gICAgICAgICAgX3JlZjEgPSB0cmFpdF9lbnRyeS52YWx1ZTtcbiAgICAgICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmMS5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICAgIHRyYWl0ID0gX3JlZjFbX2pdO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNQYXJhbWV0ZXJLZXkodHJhaXQpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyB0cmFpdHMnLCBudWxsLCAncGFyYW1ldGVyIGtleSBjYW5ub3QgYmUgdXNlZCBhcyBhIHRyYWl0IG5hbWUnLCB0cmFpdFswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdXRpbC5pc01hcHBpbmcodHJhaXRbMV0pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyB0cmFpdHMnLCBudWxsLCAnaW52YWxpZCB0cmFpdCBkZWZpbml0aW9uLCBpdCBtdXN0IGJlIGEgbWFwJywgdHJhaXRbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfcmVzdWx0czEucHVzaCh0aGlzLnZhbGlkX3RyYWl0c19wcm9wZXJ0aWVzKHRyYWl0KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgICAgIH0pLmNhbGwodGhpcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkX3RyYWl0c19wcm9wZXJ0aWVzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGludmFsaWQ7XG4gICAgICBpZiAoIW5vZGVbMV0udmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyhub2RlWzFdKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpbnZhbGlkID0gbm9kZVsxXS52YWx1ZS5maWx0ZXIoZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gICAgICAgIHJldHVybiBjaGlsZE5vZGVbMF0udmFsdWUgPT09IFwiaXNcIiB8fCBjaGlsZE5vZGVbMF0udmFsdWUgPT09IFwidHlwZVwiO1xuICAgICAgfSk7XG4gICAgICBpZiAoaW52YWxpZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyB0cmFpdCBwcm9wZXJ0aWVzJywgbnVsbCwgXCJwcm9wZXJ0eTogJ1wiICsgaW52YWxpZFswXVswXS52YWx1ZSArIFwiJyBpcyBpbnZhbGlkIGluIGEgdHJhaXRcIiwgaW52YWxpZFswXVswXS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlX21ldGhvZChub2RlLCB0cnVlLCAndHJhaXQnKTtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihwcm9wZXJ0eU5hbWUsIG11c3RSZW1vdmVRdWVzdGlvbk1hcmspIHtcbiAgICAgIGlmIChtdXN0UmVtb3ZlUXVlc3Rpb25NYXJrICYmIHByb3BlcnR5TmFtZS5zbGljZSgtMSkgPT09ICc/Jykge1xuICAgICAgICByZXR1cm4gcHJvcGVydHlOYW1lLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wZXJ0eU5hbWU7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRfY29tbW9uX3BhcmFtZXRlcl9wcm9wZXJ0aWVzID0gZnVuY3Rpb24obm9kZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSB7XG4gICAgICB2YXIgcGFyYW1ldGVyLCBfaSwgX2xlbiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgaWYgKCFub2RlLnZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh1dGlsLmlzU2VxdWVuY2Uobm9kZSkpIHtcbiAgICAgICAgaWYgKG5vZGUudmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlciBwcm9wZXJ0aWVzJywgbnVsbCwgJ25hbWVkIHBhcmFtZXRlciBuZWVkcyBhdCBsZWFzdCBvbmUgdHlwZScsIG5vZGUuc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEobm9kZS52YWx1ZS5sZW5ndGggPiAxKSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXIgcHJvcGVydGllcycsIG51bGwsICdzaW5nbGUgdHlwZSBmb3IgdmFyaWFibHkgdHlwZWQgcGFyYW1ldGVyJywgbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBfcmVmMSA9IG5vZGUudmFsdWU7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBwYXJhbWV0ZXIgPSBfcmVmMVtfaV07XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLnZhbGlkYXRlX25hbWVkX3BhcmFtZXRlcihwYXJhbWV0ZXIsIGFsbG93UGFyYW1ldGVyS2V5cykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlX25hbWVkX3BhcmFtZXRlcihub2RlLCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX25hbWVkX3BhcmFtZXRlciA9IGZ1bmN0aW9uKG5vZGUsIGFsbG93UGFyYW1ldGVyS2V5cykge1xuICAgICAgdmFyIGJvb2xlYW5WYWx1ZXMsIGNhbm9uaWNhbFByb3BlcnR5TmFtZSwgY2hpbGROb2RlLCBlbnVtVmFsdWVzLCBwYXJhbWV0ZXJQcm9wZXJ0aWVzLCBwYXJhbWV0ZXJUeXBlLCBwcm9wZXJ0eU5hbWUsIHByb3BlcnR5VmFsdWUsIHVudXNhYmxlUHJvcGVydHksIHZhbGlkLCB2YWxpZFR5cGVzLCBfaSwgX2osIF9rLCBfbGVuLCBfbGVuMSwgX2xlbjIsIF9yZWYxLCBfcmVmMiwgX3JlZjMsIF9yZXN1bHRzO1xuICAgICAgcGFyYW1ldGVyUHJvcGVydGllcyA9IHt9O1xuICAgICAgcGFyYW1ldGVyVHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICBfcmVmMSA9IG5vZGUudmFsdWU7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGNoaWxkTm9kZSA9IF9yZWYxW19pXTtcbiAgICAgICAgcHJvcGVydHlOYW1lID0gY2hpbGROb2RlWzBdLnZhbHVlO1xuICAgICAgICBwcm9wZXJ0eVZhbHVlID0gY2hpbGROb2RlWzFdLnZhbHVlO1xuICAgICAgICB0aGlzLnRyYWNrUmVwZWF0ZWRQcm9wZXJ0aWVzKHBhcmFtZXRlclByb3BlcnRpZXMsIHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKGNoaWxkTm9kZVswXS52YWx1ZSwgdHJ1ZSksIGNoaWxkTm9kZVswXSwgJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHByb3BlcnRpZXMnLCBcInBhcmFtZXRlciBwcm9wZXJ0eSBhbHJlYWR5IHVzZWRcIik7XG4gICAgICAgIGJvb2xlYW5WYWx1ZXMgPSBbXCJ0cnVlXCIsIFwiZmFsc2VcIl07XG4gICAgICAgIGlmIChhbGxvd1BhcmFtZXRlcktleXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc1BhcmFtZXRlcktleShjaGlsZE5vZGUpIHx8IHRoaXMuaXNQYXJhbWV0ZXJWYWx1ZShjaGlsZE5vZGUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2Fub25pY2FsUHJvcGVydHlOYW1lID0gdGhpcy5jYW5vbmljYWxpemVQcm9wZXJ0eU5hbWUocHJvcGVydHlOYW1lLCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICB2YWxpZCA9IHRydWU7XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgY2FzZSBcImRpc3BsYXlOYW1lXCI6XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNTY2FsYXIoY2hpbGROb2RlWzFdKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHByb3BlcnRpZXMnLCBudWxsLCAndGhlIHZhbHVlIG9mIGRpc3BsYXlOYW1lIG11c3QgYmUgYSBzY2FsYXInLCBjaGlsZE5vZGVbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicGF0dGVyblwiOlxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzU2NhbGFyKGNoaWxkTm9kZVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlciBwcm9wZXJ0aWVzJywgbnVsbCwgJ3RoZSB2YWx1ZSBvZiBwYXR0ZXJuIG11c3QgYmUgYSBzY2FsYXInLCBjaGlsZE5vZGVbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZGVmYXVsdFwiOlxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzU2NhbGFyKGNoaWxkTm9kZVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlciBwcm9wZXJ0aWVzJywgbnVsbCwgJ3RoZSB2YWx1ZSBvZiBkZWZhdWx0IG11c3QgYmUgYSBzY2FsYXInLCBjaGlsZE5vZGVbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZGVzY3JpcHRpb25cIjpcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1NjYWxhcihjaGlsZE5vZGVbMV0pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXIgcHJvcGVydGllcycsIG51bGwsICd0aGUgdmFsdWUgb2YgZGVzY3JpcHRpb24gbXVzdCBiZSBhIHNjYWxhcicsIGNoaWxkTm9kZVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJleGFtcGxlXCI6XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNTY2FsYXIoY2hpbGROb2RlWzFdKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHByb3BlcnRpZXMnLCBudWxsLCAndGhlIHZhbHVlIG9mIGV4YW1wbGUgbXVzdCBiZSBhIHNjYWxhcicsIGNoaWxkTm9kZVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtaW5MZW5ndGhcIjpcbiAgICAgICAgICAgIGlmIChpc05hTihwcm9wZXJ0eVZhbHVlKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHByb3BlcnRpZXMnLCBudWxsLCAndGhlIHZhbHVlIG9mIG1pbkxlbmd0aCBtdXN0IGJlIGEgbnVtYmVyJywgY2hpbGROb2RlWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1heExlbmd0aFwiOlxuICAgICAgICAgICAgaWYgKGlzTmFOKHByb3BlcnR5VmFsdWUpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXIgcHJvcGVydGllcycsIG51bGwsICd0aGUgdmFsdWUgb2YgbWF4TGVuZ3RoIG11c3QgYmUgYSBudW1iZXInLCBjaGlsZE5vZGVbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibWluaW11bVwiOlxuICAgICAgICAgICAgaWYgKGlzTmFOKHByb3BlcnR5VmFsdWUpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXIgcHJvcGVydGllcycsIG51bGwsICd0aGUgdmFsdWUgb2YgbWluaW11bSBtdXN0IGJlIGEgbnVtYmVyJywgY2hpbGROb2RlWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1heGltdW1cIjpcbiAgICAgICAgICAgIGlmIChpc05hTihwcm9wZXJ0eVZhbHVlKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHByb3BlcnRpZXMnLCBudWxsLCAndGhlIHZhbHVlIG9mIG1heGltdW0gbXVzdCBiZSBhIG51bWJlcicsIGNoaWxkTm9kZVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ0eXBlXCI6XG4gICAgICAgICAgICBwYXJhbWV0ZXJUeXBlID0gcHJvcGVydHlWYWx1ZTtcbiAgICAgICAgICAgIHZhbGlkVHlwZXMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnaW50ZWdlcicsICdkYXRlJywgJ2Jvb2xlYW4nLCAnZmlsZSddO1xuICAgICAgICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKHZhbGlkVHlwZXMsIHByb3BlcnR5VmFsdWUpIDwgMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHByb3BlcnRpZXMnLCBudWxsLCAndHlwZSBjYW4gYmUgZWl0aGVyIG9mOiBzdHJpbmcsIG51bWJlciwgaW50ZWdlciwgZmlsZSwgZGF0ZSBvciBib29sZWFuICcsIGNoaWxkTm9kZVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKGJvb2xlYW5WYWx1ZXMsIHByb3BlcnR5VmFsdWUpIDwgMCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHByb3BlcnRpZXMnLCBudWxsLCAncmVxdWlyZWQgY2FuIGJlIGFueSBlaXRoZXIgdHJ1ZSBvciBmYWxzZScsIGNoaWxkTm9kZVsxXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJyZXBlYXRcIjpcbiAgICAgICAgICAgIGlmIChfX2luZGV4T2YuY2FsbChib29sZWFuVmFsdWVzLCBwcm9wZXJ0eVZhbHVlKSA8IDApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlciBwcm9wZXJ0aWVzJywgbnVsbCwgJ3JlcGVhdCBjYW4gYmUgYW55IGVpdGhlciB0cnVlIG9yIGZhbHNlJywgY2hpbGROb2RlWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjYW5vbmljYWxQcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzTnVsbGFibGVTZXF1ZW5jZShjaGlsZE5vZGVbMV0pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXIgcHJvcGVydGllcycsIG51bGwsICd0aGUgdmFsdWUgb2YgZW51bSBtdXN0IGJlIGFuIGFycmF5JywgY2hpbGROb2RlWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGVbMV0udmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXIgcHJvcGVydGllcycsIG51bGwsICdlbnVtIGlzIGVtcHR5JywgY2hpbGROb2RlWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW51bVZhbHVlcyA9IHRoaXMuZ2V0X2xpc3RfdmFsdWVzKGNoaWxkTm9kZVsxXS52YWx1ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNEdXBsaWNhdGVzKGVudW1WYWx1ZXMpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXIgcHJvcGVydGllcycsIG51bGwsICdlbnVtIGNvbnRhaW5zIGR1cGxpY2F0ZWQgdmFsdWVzJywgY2hpbGROb2RlWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlciBwcm9wZXJ0aWVzJywgbnVsbCwgXCJ1bmtub3duIHByb3BlcnR5IFwiICsgcHJvcGVydHlOYW1lLCBjaGlsZE5vZGVbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbWV0ZXJUeXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIF9yZWYyID0gWydlbnVtJywgJ3BhdHRlcm4nLCAnbWluTGVuZ3RoJywgJ21heExlbmd0aCddO1xuICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmMi5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICB1bnVzYWJsZVByb3BlcnR5ID0gX3JlZjJbX2pdO1xuICAgICAgICAgIGlmICh1bnVzYWJsZVByb3BlcnR5IGluIHBhcmFtZXRlclByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwYXJhbWV0ZXIgcHJvcGVydGllcycsIG51bGwsIFwicHJvcGVydHkgXCIgKyB1bnVzYWJsZVByb3BlcnR5ICsgXCIgY2FuIG9ubHkgYmUgdXNlZCBpZiB0eXBlIGlzICdzdHJpbmcnXCIsIHBhcmFtZXRlclByb3BlcnRpZXNbdW51c2FibGVQcm9wZXJ0eV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIShwYXJhbWV0ZXJUeXBlID09PSBcIm51bWJlclwiIHx8IHBhcmFtZXRlclR5cGUgPT09IFwiaW50ZWdlclwiKSkge1xuICAgICAgICBfcmVmMyA9IFsnbWluaW11bScsICdtYXhpbXVtJ107XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2sgPSAwLCBfbGVuMiA9IF9yZWYzLmxlbmd0aDsgX2sgPCBfbGVuMjsgX2srKykge1xuICAgICAgICAgIHVudXNhYmxlUHJvcGVydHkgPSBfcmVmM1tfa107XG4gICAgICAgICAgaWYgKHVudXNhYmxlUHJvcGVydHkgaW4gcGFyYW1ldGVyUHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlciBwcm9wZXJ0aWVzJywgbnVsbCwgXCJwcm9wZXJ0eSBcIiArIHVudXNhYmxlUHJvcGVydHkgKyBcIiBjYW4gb25seSBiZSB1c2VkIGlmIHR5cGUgaXMgJ251bWJlcicgb3IgJ2ludGVnZXInXCIsIHBhcmFtZXRlclByb3BlcnRpZXNbdW51c2FibGVQcm9wZXJ0eV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLmdldF9saXN0X3ZhbHVlcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICByZXR1cm4gbm9kZS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX3Jvb3RfcHJvcGVydGllcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBjaGVja1ZlcnNpb24sIHByb3BlcnR5LCByb290UHJvcGVydGllcywgX2ksIF9sZW4sIF9yZWYxO1xuICAgICAgY2hlY2tWZXJzaW9uID0gZmFsc2U7XG4gICAgICByb290UHJvcGVydGllcyA9IHt9O1xuICAgICAgaWYgKG5vZGUgIT0gbnVsbCA/IG5vZGUudmFsdWUgOiB2b2lkIDApIHtcbiAgICAgICAgX3JlZjEgPSBub2RlLnZhbHVlO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgcHJvcGVydHkgPSBfcmVmMVtfaV07XG4gICAgICAgICAgaWYgKHByb3BlcnR5WzBdLnZhbHVlLm1hdGNoKC9eXFwvLykpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2tSZXBlYXRlZFByb3BlcnRpZXMocm9vdFByb3BlcnRpZXMsIHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKHByb3BlcnR5WzBdLnZhbHVlLCB0cnVlKSwgcHJvcGVydHlbMF0sICd3aGlsZSB2YWxpZGF0aW5nIHJvb3QgcHJvcGVydGllcycsIFwicmVzb3VyY2UgYWxyZWFkeSBkZWNsYXJlZFwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFja1JlcGVhdGVkUHJvcGVydGllcyhyb290UHJvcGVydGllcywgcHJvcGVydHlbMF0udmFsdWUsIHByb3BlcnR5WzBdLCAnd2hpbGUgdmFsaWRhdGluZyByb290IHByb3BlcnRpZXMnLCAncm9vdCBwcm9wZXJ0eSBhbHJlYWR5IHVzZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChwcm9wZXJ0eVswXS52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAndGl0bGUnOlxuICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNTY2FsYXIocHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJvb3QgcHJvcGVydGllcycsIG51bGwsICd0aXRsZSBtdXN0IGJlIGEgc3RyaW5nJywgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiYXNlVXJpJzpcbiAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzU2NhbGFyKHByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByb290IHByb3BlcnRpZXMnLCBudWxsLCAnYmFzZVVyaSBtdXN0IGJlIGEgc3RyaW5nJywgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5iYXNlVXJpID0gcHJvcGVydHlbMV0udmFsdWU7XG4gICAgICAgICAgICAgIGNoZWNrVmVyc2lvbiA9IHRoaXMudmFsaWRhdGVfYmFzZV91cmkocHJvcGVydHlbMV0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY3VyaXR5U2NoZW1lcyc6XG4gICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVfc2VjdXJpdHlfc2NoZW1lcyhwcm9wZXJ0eVsxXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2NoZW1hcyc6XG4gICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVfcm9vdF9zY2hlbWFzKHByb3BlcnR5WzFdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd2ZXJzaW9uJzpcbiAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzU2NhbGFyKHByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByb290IHByb3BlcnRpZXMnLCBudWxsLCAndmVyc2lvbiBtdXN0IGJlIGEgc3RyaW5nJywgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzTnVsbChwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eVsxXS50YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6c3RyJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RyYWl0cyc6XG4gICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVfdHJhaXRzKHByb3BlcnR5WzFdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkb2N1bWVudGF0aW9uJzpcbiAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzU2VxdWVuY2UocHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJvb3QgcHJvcGVydGllcycsIG51bGwsICdkb2N1bWVudGF0aW9uIG11c3QgYmUgYW4gYXJyYXknLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlX2RvY3VtZW50YXRpb24ocHJvcGVydHlbMV0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21lZGlhVHlwZSc6XG4gICAgICAgICAgICAgIGlmICghdXRpbC5pc1N0cmluZyhwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcm9vdCBwcm9wZXJ0aWVzJywgbnVsbCwgJ21lZGlhVHlwZSBtdXN0IGJlIGEgc2NhbGFyJywgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiYXNlVXJpUGFyYW1ldGVycyc6XG4gICAgICAgICAgICAgIHRoaXMuYmFzZVVyaVBhcmFtZXRlcnMgPSBwcm9wZXJ0eVsxXTtcbiAgICAgICAgICAgICAgdXRpbC5pc05vb3AocHJvcGVydHlbMV0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Jlc291cmNlVHlwZXMnOlxuICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlX3R5cGVzKHByb3BlcnR5WzFdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWN1cmVkQnknOlxuICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlX3NlY3VyZWRfYnkocHJvcGVydHkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Byb3RvY29scyc6XG4gICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVfcHJvdG9jb2xzX3Byb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAocHJvcGVydHlbMF0udmFsdWUubWF0Y2goL15cXC8vKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVfcmVzb3VyY2UocHJvcGVydHkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByb290IHByb3BlcnRpZXMnLCBudWxsLCBcInVua25vd24gcHJvcGVydHkgXCIgKyBwcm9wZXJ0eVswXS52YWx1ZSwgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghKCd0aXRsZScgaW4gcm9vdFByb3BlcnRpZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByb290IHByb3BlcnRpZXMnLCBudWxsLCAnbWlzc2luZyB0aXRsZScsIG5vZGUuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tWZXJzaW9uICYmICEoJ3ZlcnNpb24nIGluIHJvb3RQcm9wZXJ0aWVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgdmVyc2lvbicsIG51bGwsICdtaXNzaW5nIHZlcnNpb24nLCBub2RlLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX2RvY3VtZW50YXRpb24gPSBmdW5jdGlvbihkb2N1bWVudGF0aW9uX3Byb3BlcnR5KSB7XG4gICAgICB2YXIgZG9jU2VjdGlvbiwgX2ksIF9sZW4sIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgIGlmICghZG9jdW1lbnRhdGlvbl9wcm9wZXJ0eS52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGRvY3VtZW50YXRpb24gc2VjdGlvbicsIG51bGwsICd0aGVyZSBtdXN0IGJlIGF0IGxlYXN0IG9uZSBkb2N1bWVudCBpbiB0aGUgZG9jdW1lbnRhdGlvbiBzZWN0aW9uJywgZG9jdW1lbnRhdGlvbl9wcm9wZXJ0eS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIF9yZWYxID0gZG9jdW1lbnRhdGlvbl9wcm9wZXJ0eS52YWx1ZTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGRvY1NlY3Rpb24gPSBfcmVmMVtfaV07XG4gICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy52YWxpZGF0ZV9kb2Nfc2VjdGlvbihkb2NTZWN0aW9uKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfZG9jX3NlY3Rpb24gPSBmdW5jdGlvbihkb2NTZWN0aW9uKSB7XG4gICAgICB2YXIgZG9jUHJvcGVydGllcywgcHJvcGVydHksIF9pLCBfbGVuLCBfcmVmMTtcbiAgICAgIGlmICghdXRpbC5pc01hcHBpbmcoZG9jU2VjdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGRvY3VtZW50YXRpb24gc2VjdGlvbicsIG51bGwsICdlYWNoIGRvY3VtZW50YXRpb24gc2VjdGlvbiBtdXN0IGJlIGEgbWFwJywgZG9jU2VjdGlvbi5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGRvY1Byb3BlcnRpZXMgPSB7fTtcbiAgICAgIF9yZWYxID0gZG9jU2VjdGlvbi52YWx1ZTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcHJvcGVydHkgPSBfcmVmMVtfaV07XG4gICAgICAgIHRoaXMudHJhY2tSZXBlYXRlZFByb3BlcnRpZXMoZG9jUHJvcGVydGllcywgcHJvcGVydHlbMF0udmFsdWUsIHByb3BlcnR5WzBdLCAnd2hpbGUgdmFsaWRhdGluZyBkb2N1bWVudGF0aW9uIHNlY3Rpb24nLCBcInByb3BlcnR5IGFscmVhZHkgdXNlZFwiKTtcbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0eVswXS52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgXCJ0aXRsZVwiOlxuICAgICAgICAgICAgaWYgKCEodXRpbC5pc1NjYWxhcihwcm9wZXJ0eVsxXSkgJiYgIXV0aWwuaXNOdWxsKHByb3BlcnR5WzFdKSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGRvY3VtZW50YXRpb24gc2VjdGlvbicsIG51bGwsICd0aXRsZSBtdXN0IGJlIGEgc3RyaW5nJywgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiY29udGVudFwiOlxuICAgICAgICAgICAgaWYgKCEodXRpbC5pc1NjYWxhcihwcm9wZXJ0eVsxXSkgJiYgIXV0aWwuaXNOdWxsKHByb3BlcnR5WzFdKSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGRvY3VtZW50YXRpb24gc2VjdGlvbicsIG51bGwsICdjb250ZW50IG11c3QgYmUgYSBzdHJpbmcnLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcm9vdCBwcm9wZXJ0aWVzJywgbnVsbCwgJ3Vua25vd24gcHJvcGVydHkgJyArIHByb3BlcnR5WzBdLnZhbHVlLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCEoXCJjb250ZW50XCIgaW4gZG9jUHJvcGVydGllcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGRvY3VtZW50YXRpb24gc2VjdGlvbicsIG51bGwsICdhIGRvY3VtZW50YXRpb24gZW50cnkgbXVzdCBoYXZlIGNvbnRlbnQgcHJvcGVydHknLCBkb2NTZWN0aW9uLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgaWYgKCEoXCJ0aXRsZVwiIGluIGRvY1Byb3BlcnRpZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBkb2N1bWVudGF0aW9uIHNlY3Rpb24nLCBudWxsLCAnYSBkb2N1bWVudGF0aW9uIGVudHJ5IG11c3QgaGF2ZSB0aXRsZSBwcm9wZXJ0eScsIGRvY1NlY3Rpb24uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUuY2hpbGRfcmVzb3VyY2VzID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUgJiYgdXRpbC5pc01hcHBpbmcobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUudmFsdWUuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuICAgICAgICAgIHJldHVybiBjaGlsZE5vZGVbMF0udmFsdWUubWF0Y2goL15cXC8vKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfcmVzb3VyY2UgPSBmdW5jdGlvbihyZXNvdXJjZSwgYWxsb3dQYXJhbWV0ZXJLZXlzLCBjb250ZXh0KSB7XG4gICAgICB2YXIgY2Fub25pY2FsS2V5LCBlcnIsIGtleSwgcHJvcGVydHksIHJlc291cmNlUHJvcGVydGllcywgdGVtcGxhdGUsIHZhbGlkLCBfaSwgX2xlbiwgX3JlZjEsIF9yZWYyLCBfcmVzdWx0cztcbiAgICAgIGlmIChhbGxvd1BhcmFtZXRlcktleXMgPT0gbnVsbCkge1xuICAgICAgICBhbGxvd1BhcmFtZXRlcktleXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0ID09IG51bGwpIHtcbiAgICAgICAgY29udGV4dCA9IFwicmVzb3VyY2VcIjtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc291cmNlWzFdICYmIHV0aWwuaXNOdWxsYWJsZU1hcHBpbmcocmVzb3VyY2VbMV0pKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2VzJywgbnVsbCwgJ3Jlc291cmNlIGlzIG5vdCBhIG1hcCcsIHJlc291cmNlWzFdLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgaWYgKHJlc291cmNlWzBdLnZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSB1cml0ZW1wbGF0ZS5wYXJzZShyZXNvdXJjZVswXS52YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGVyciA9IF9lcnJvcjtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2UnLCBudWxsLCBcIlJlc291cmNlIG5hbWUgaXMgaW52YWxpZDogXCIgKyAoZXJyICE9IG51bGwgPyAoX3JlZjEgPSBlcnIub3B0aW9ucykgIT0gbnVsbCA/IF9yZWYxLm1lc3NhZ2UgOiB2b2lkIDAgOiB2b2lkIDApLCByZXNvdXJjZVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHV0aWwuaXNOdWxsKHJlc291cmNlWzFdKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmVzb3VyY2VbMV0udmFsdWUpIHtcbiAgICAgICAgcmVzb3VyY2VQcm9wZXJ0aWVzID0ge307XG4gICAgICAgIF9yZWYyID0gcmVzb3VyY2VbMV0udmFsdWU7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjIubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBwcm9wZXJ0eSA9IF9yZWYyW19pXTtcbiAgICAgICAgICBpZiAocHJvcGVydHlbMF0udmFsdWUubWF0Y2goL15cXC8vKSkge1xuICAgICAgICAgICAgdGhpcy50cmFja1JlcGVhdGVkUHJvcGVydGllcyhyZXNvdXJjZVByb3BlcnRpZXMsIHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKHByb3BlcnR5WzBdLnZhbHVlLCB0cnVlKSwgcHJvcGVydHlbMF0sICd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlJywgXCJyZXNvdXJjZSBhbHJlYWR5IGRlY2xhcmVkXCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0h0dHBNZXRob2QocHJvcGVydHlbMF0udmFsdWUsIGFsbG93UGFyYW1ldGVyS2V5cykpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2tSZXBlYXRlZFByb3BlcnRpZXMocmVzb3VyY2VQcm9wZXJ0aWVzLCB0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShwcm9wZXJ0eVswXS52YWx1ZSwgdHJ1ZSksIHByb3BlcnR5WzBdLCAnd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZScsIFwibWV0aG9kIGFscmVhZHkgZGVjbGFyZWRcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2tSZXBlYXRlZFByb3BlcnRpZXMocmVzb3VyY2VQcm9wZXJ0aWVzLCB0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShwcm9wZXJ0eVswXS52YWx1ZSwgdHJ1ZSksIHByb3BlcnR5WzBdLCAnd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZScsIFwicHJvcGVydHkgYWxyZWFkeSB1c2VkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGVfY29tbW9uX3Byb3BlcnRpZXMocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cykpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eVswXS52YWx1ZS5tYXRjaCgvXlxcLy8pKSB7XG4gICAgICAgICAgICAgIGlmIChhbGxvd1BhcmFtZXRlcktleXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgdHJhaXQgcHJvcGVydGllcycsIG51bGwsICdyZXNvdXJjZSB0eXBlIGNhbm5vdCBkZWZpbmUgY2hpbGQgcmVzb3VyY2VzJywgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLnZhbGlkYXRlX3Jlc291cmNlKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0h0dHBNZXRob2QocHJvcGVydHlbMF0udmFsdWUsIGFsbG93UGFyYW1ldGVyS2V5cykpIHtcbiAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLnZhbGlkYXRlX21ldGhvZChwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzLCAnbWV0aG9kJykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAga2V5ID0gcHJvcGVydHlbMF0udmFsdWU7XG4gICAgICAgICAgICAgIGNhbm9uaWNhbEtleSA9IHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKGtleSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICBzd2l0Y2ggKGNhbm9uaWNhbEtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ1cmlQYXJhbWV0ZXJzXCI6XG4gICAgICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNOdWxsYWJsZU1hcHBpbmcocHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyB1cmkgcGFyYW1ldGVycycsIG51bGwsICd1cmkgcGFyYW1ldGVycyBtdXN0IGJlIGEgbWFwJywgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlX3VyaV9wYXJhbWV0ZXJzKHJlc291cmNlWzBdLnZhbHVlLCBwcm9wZXJ0eVsxXSwgYWxsb3dQYXJhbWV0ZXJLZXlzLCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJhc2VVcmlQYXJhbWV0ZXJzXCI6XG4gICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYmFzZVVyaSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgdXJpIHBhcmFtZXRlcnMnLCBudWxsLCAnYmFzZSB1cmkgcGFyYW1ldGVycyBkZWZpbmVkIHdoZW4gdGhlcmUgaXMgbm8gYmFzZVVyaScsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzTnVsbGFibGVNYXBwaW5nKHByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgdXJpIHBhcmFtZXRlcnMnLCBudWxsLCAnYmFzZSB1cmkgcGFyYW1ldGVycyBtdXN0IGJlIGEgbWFwJywgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlX3VyaV9wYXJhbWV0ZXJzKHRoaXMuYmFzZVVyaSwgcHJvcGVydHlbMV0sIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0eXBlXCI6XG4gICAgICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMudmFsaWRhdGVfdHlwZV9wcm9wZXJ0eShwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwidXNhZ2VcIjpcbiAgICAgICAgICAgICAgICAgIGlmICghYWxsb3dQYXJhbWV0ZXJLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZXMnLCBudWxsLCBcInByb3BlcnR5OiAnXCIgKyBwcm9wZXJ0eVswXS52YWx1ZSArIFwiJyBpcyBpbnZhbGlkIGluIGEgcmVzb3VyY2VcIiwgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwic2VjdXJlZEJ5XCI6XG4gICAgICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMudmFsaWRhdGVfc2VjdXJlZF9ieShwcm9wZXJ0eSkpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlcycsIG51bGwsIFwicHJvcGVydHk6ICdcIiArIHByb3BlcnR5WzBdLnZhbHVlICsgKFwiJyBpcyBpbnZhbGlkIGluIGEgXCIgKyBjb250ZXh0KSwgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfc2VjdXJlZF9ieSA9IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICB2YXIgc2VjU2NoZW1lLCBzZWNTY2hlbWVzLCBzZWN1cml0eVNjaGVtZU5hbWUsIF9pLCBfbGVuLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICBpZiAoIXV0aWwuaXNTZXF1ZW5jZShwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5U2NoZW1lJywgbnVsbCwgXCJwcm9wZXJ0eSAnc2VjdXJlZEJ5JyBtdXN0IGJlIGFuIGFycmF5XCIsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgc2VjU2NoZW1lcyA9IHRoaXMuZ2V0X2xpc3RfdmFsdWVzKHByb3BlcnR5WzFdLnZhbHVlKTtcbiAgICAgIGlmICh0aGlzLmhhc0R1cGxpY2F0ZXMoc2VjU2NoZW1lcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5U2NoZW1lIGNvbnN1bXB0aW9uJywgbnVsbCwgJ3NlY3VyaXR5U2NoZW1lcyBjYW4gb25seSBiZSByZWZlcmVuY2VkIG9uY2UgaW4gYSBzZWN1cmVkQnkgcHJvcGVydHknLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIF9yZWYxID0gcHJvcGVydHlbMV0udmFsdWU7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBzZWNTY2hlbWUgPSBfcmVmMVtfaV07XG4gICAgICAgIGlmICh1dGlsLmlzU2VxdWVuY2Uoc2VjU2NoZW1lKSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBzZWN1cml0eVNjaGVtZSBjb25zdW1wdGlvbicsIG51bGwsICdzZWN1cml0eVNjaGVtZSByZWZlcmVuY2UgY2Fubm90IGJlIGFuIGFycmF5Jywgc2VjU2NoZW1lLnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXRpbC5pc051bGwoc2VjU2NoZW1lKSkge1xuICAgICAgICAgIHNlY3VyaXR5U2NoZW1lTmFtZSA9IHRoaXMua2V5X29yX3ZhbHVlKHNlY1NjaGVtZSk7XG4gICAgICAgICAgaWYgKCF0aGlzLmdldF9zZWN1cml0eV9zY2hlbWUoc2VjdXJpdHlTY2hlbWVOYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHNlY3VyaXR5U2NoZW1lIGNvbnN1bXB0aW9uJywgbnVsbCwgJ3RoZXJlIGlzIG5vIHNlY3VyaXR5U2NoZW1lIG5hbWVkICcgKyBzZWN1cml0eVNjaGVtZU5hbWUsIHNlY1NjaGVtZS5zdGFydF9tYXJrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9wcm90b2NvbHNfcHJvcGVydHkgPSBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgdmFyIHByb3RvY29sLCBfaSwgX2xlbiwgX3JlZjEsIF9yZWYyLCBfcmVzdWx0cztcbiAgICAgIGlmICghdXRpbC5pc1NlcXVlbmNlKHByb3BlcnR5WzFdKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcHJvdG9jb2xzJywgbnVsbCwgJ3Byb3BlcnR5IG11c3QgYmUgYW4gYXJyYXknLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIF9yZWYxID0gcHJvcGVydHlbMV0udmFsdWU7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwcm90b2NvbCA9IF9yZWYxW19pXTtcbiAgICAgICAgaWYgKCF1dGlsLmlzU3RyaW5nKHByb3RvY29sKSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwcm90b2NvbHMnLCBudWxsLCAndmFsdWUgbXVzdCBiZSBhIHN0cmluZycsIHByb3RvY29sLnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoX3JlZjIgPSBwcm90b2NvbC52YWx1ZSkgIT09ICdIVFRQJyAmJiBfcmVmMiAhPT0gJ0hUVFBTJykge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBwcm90b2NvbHMnLCBudWxsLCAnb25seSBIVFRQIGFuZCBIVFRQUyB2YWx1ZXMgYXJlIGFsbG93ZWQnLCBwcm90b2NvbC5zdGFydF9tYXJrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV90eXBlX3Byb3BlcnR5ID0gZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgIHZhciBwYXJhbWV0ZXIsIHR5cGVOYW1lLCBfaSwgX2xlbiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgaWYgKCEodXRpbC5pc01hcHBpbmcocHJvcGVydHlbMV0pIHx8IHV0aWwuaXNTdHJpbmcocHJvcGVydHlbMV0pKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2UgdHlwZXMnLCBudWxsLCBcInByb3BlcnR5ICd0eXBlJyBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgbWFwXCIsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWwuaXNNYXBwaW5nKHByb3BlcnR5WzFdKSkge1xuICAgICAgICBpZiAocHJvcGVydHlbMV0udmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZSB0eXBlcycsIG51bGwsICdhIHJlc291cmNlIG9yIHJlc291cmNlVHlwZSBjYW4gaW5oZXJpdCBmcm9tIGEgc2luZ2xlIHJlc291cmNlVHlwZScsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0eXBlTmFtZSA9IHRoaXMua2V5X29yX3ZhbHVlKHByb3BlcnR5WzFdKTtcbiAgICAgIGlmICghKHR5cGVOYW1lICE9IG51bGwgPyB0eXBlTmFtZS50cmltKCkgOiB2b2lkIDApKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZSB0eXBlIGNvbnN1bXB0aW9uJywgbnVsbCwgJ3Jlc291cmNlIHR5cGUgbmFtZSBtdXN0IGJlIHByb3ZpZGVkJywgcHJvcGVydHlbMV0uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBpZiAoISh0aGlzLmlzUGFyYW1ldGVyS2V5VmFsdWUodHlwZU5hbWUpIHx8IHRoaXMuZ2V0X3R5cGUodHlwZU5hbWUpKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2UgdHlwZSBjb25zdW1wdGlvbicsIG51bGwsIFwidGhlcmUgaXMgbm8gcmVzb3VyY2UgdHlwZSBuYW1lZCBcIiArIHR5cGVOYW1lLCBwcm9wZXJ0eVsxXS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGlmICh1dGlsLmlzTWFwcGluZyhwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgX3JlZjEgPSBwcm9wZXJ0eVsxXS52YWx1ZTtcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHBhcmFtZXRlciA9IF9yZWYxW19pXTtcbiAgICAgICAgICBpZiAoISh1dGlsLmlzTnVsbChwYXJhbWV0ZXJbMV0pIHx8IHV0aWwuaXNNYXBwaW5nKHBhcmFtZXRlclsxXSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2UgY29uc3VtcHRpb24nLCBudWxsLCAncmVzb3VyY2UgdHlwZSBwYXJhbWV0ZXJzIG11c3QgYmUgaW4gYSBtYXAnLCBwYXJhbWV0ZXJbMV0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX21ldGhvZCA9IGZ1bmN0aW9uKG1ldGhvZCwgYWxsb3dQYXJhbWV0ZXJLZXlzLCBjb250ZXh0KSB7XG4gICAgICB2YXIgY2Fub25pY2FsS2V5LCBrZXksIG1ldGhvZFByb3BlcnRpZXMsIHByb3BlcnR5LCB2YWxpZCwgX2ksIF9sZW4sIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgIGlmIChjb250ZXh0ID09IG51bGwpIHtcbiAgICAgICAgY29udGV4dCA9ICdtZXRob2QnO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWwuaXNOdWxsKG1ldGhvZFsxXSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF1dGlsLmlzTWFwcGluZyhtZXRob2RbMV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBtZXRob2RzJywgbnVsbCwgXCJtZXRob2QgbXVzdCBiZSBhIG1hcFwiLCBtZXRob2RbMF0uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBtZXRob2RQcm9wZXJ0aWVzID0ge307XG4gICAgICBfcmVmMSA9IG1ldGhvZFsxXS52YWx1ZTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHByb3BlcnR5ID0gX3JlZjFbX2ldO1xuICAgICAgICB0aGlzLnRyYWNrUmVwZWF0ZWRQcm9wZXJ0aWVzKG1ldGhvZFByb3BlcnRpZXMsIHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKHByb3BlcnR5WzBdLnZhbHVlLCB0cnVlKSwgcHJvcGVydHlbMF0sICd3aGlsZSB2YWxpZGF0aW5nIG1ldGhvZCcsIFwicHJvcGVydHkgYWxyZWFkeSB1c2VkXCIpO1xuICAgICAgICBpZiAodGhpcy52YWxpZGF0ZV9jb21tb25fcHJvcGVydGllcyhwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzLCBjb250ZXh0KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGtleSA9IHByb3BlcnR5WzBdLnZhbHVlO1xuICAgICAgICBjYW5vbmljYWxLZXkgPSB0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShrZXksIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgc3dpdGNoIChjYW5vbmljYWxLZXkpIHtcbiAgICAgICAgICBjYXNlICdoZWFkZXJzJzpcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVfaGVhZGVycyhwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3F1ZXJ5UGFyYW1ldGVycyc6XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlX3F1ZXJ5X3BhcmFtcyhwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZV9ib2R5KHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Jlc3BvbnNlcyc6XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlX3Jlc3BvbnNlcyhwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Jhc2VVcmlQYXJhbWV0ZXJzJzpcbiAgICAgICAgICAgIGlmICghdGhpcy5iYXNlVXJpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyB1cmkgcGFyYW1ldGVycycsIG51bGwsICdiYXNlIHVyaSBwYXJhbWV0ZXJzIGRlZmluZWQgd2hlbiB0aGVyZSBpcyBubyBiYXNlVXJpJywgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNOdWxsYWJsZU1hcHBpbmcocHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyB1cmkgcGFyYW1ldGVycycsIG51bGwsICdiYXNlIHVyaSBwYXJhbWV0ZXJzIG11c3QgYmUgYSBtYXAnLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVfdXJpX3BhcmFtZXRlcnModGhpcy5iYXNlVXJpLCBwcm9wZXJ0eVsxXSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3Byb3RvY29scyc6XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlX3Byb3RvY29sc19wcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgIGNhc2UgJ3NlY3VyZWRCeSc6XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMudmFsaWRhdGVfc2VjdXJlZF9ieShwcm9wZXJ0eSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndXNhZ2UnOlxuICAgICAgICAgICAgaWYgKCEoYWxsb3dQYXJhbWV0ZXJLZXlzICYmIGNvbnRleHQgPT09ICd0cmFpdCcpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZXMnLCBudWxsLCBcInByb3BlcnR5OiAndXNhZ2UnIGlzIGludmFsaWQgaW4gYSBcIiArIGNvbnRleHQsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlcycsIG51bGwsIFwicHJvcGVydHk6ICdcIiArIHByb3BlcnR5WzBdLnZhbHVlICsgXCInIGlzIGludmFsaWQgaW4gYSBcIiArIGNvbnRleHQsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh2b2lkIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfcmVzcG9uc2VzID0gZnVuY3Rpb24ocmVzcG9uc2VzLCBhbGxvd1BhcmFtZXRlcktleXMpIHtcbiAgICAgIHZhciByZXNwb25zZSwgcmVzcG9uc2VWYWx1ZXMsIF9pLCBfbGVuLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICBpZiAodXRpbC5pc051bGwocmVzcG9uc2VzWzFdKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKHJlc3BvbnNlc1sxXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc3BvbnNlcycsIG51bGwsIFwicHJvcGVydHk6ICdyZXNwb25zZXMnIG11c3QgYmUgYSBtYXBcIiwgcmVzcG9uc2VzWzBdLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgcmVzcG9uc2VWYWx1ZXMgPSB7fTtcbiAgICAgIF9yZWYxID0gcmVzcG9uc2VzWzFdLnZhbHVlO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcmVzcG9uc2UgPSBfcmVmMVtfaV07XG4gICAgICAgIGlmICghdXRpbC5pc051bGxhYmxlTWFwcGluZyhyZXNwb25zZVsxXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzcG9uc2VzJywgbnVsbCwgJ2VhY2ggcmVzcG9uc2UgbXVzdCBiZSBhIG1hcCcsIHJlc3BvbnNlWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tSZXBlYXRlZFByb3BlcnRpZXMocmVzcG9uc2VWYWx1ZXMsIHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKHJlc3BvbnNlWzBdLnZhbHVlLCB0cnVlKSwgcmVzcG9uc2VbMF0sICd3aGlsZSB2YWxpZGF0aW5nIHJlc3BvbnNlcycsIFwicmVzcG9uc2UgY29kZSBhbHJlYWR5IHVzZWRcIik7XG4gICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy52YWxpZGF0ZV9yZXNwb25zZShyZXNwb25zZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfcXVlcnlfcGFyYW1zID0gZnVuY3Rpb24ocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cykge1xuICAgICAgdmFyIHBhcmFtLCBxdWVyeVBhcmFtZXRlcnMsIF9pLCBfbGVuLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICBpZiAodXRpbC5pc051bGwocHJvcGVydHlbMV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdXRpbC5pc01hcHBpbmcocHJvcGVydHlbMV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBxdWVyeSBwYXJhbWV0ZXJzJywgbnVsbCwgXCJwcm9wZXJ0eTogJ3F1ZXJ5UGFyYW1ldGVycycgbXVzdCBiZSBhIG1hcFwiLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5UGFyYW1ldGVycyA9IHt9O1xuICAgICAgX3JlZjEgPSBwcm9wZXJ0eVsxXS52YWx1ZTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHBhcmFtID0gX3JlZjFbX2ldO1xuICAgICAgICBpZiAoISh1dGlsLmlzTnVsbGFibGVNYXBwaW5nKHBhcmFtWzFdKSB8fCB1dGlsLmlzTnVsbGFibGVTZXF1ZW5jZShwYXJhbVsxXSkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHF1ZXJ5IHBhcmFtZXRlcnMnLCBudWxsLCBcImVhY2ggcXVlcnkgcGFyYW1ldGVyIG11c3QgYmUgYSBtYXBcIiwgcGFyYW1bMV0uc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFja1JlcGVhdGVkUHJvcGVydGllcyhxdWVyeVBhcmFtZXRlcnMsIHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKHBhcmFtWzBdLnZhbHVlLCB0cnVlKSwgcGFyYW1bMF0sICd3aGlsZSB2YWxpZGF0aW5nIHF1ZXJ5IHBhcmFtZXRlcicsIFwicGFyYW1ldGVyIG5hbWUgYWxyZWFkeSB1c2VkXCIpO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMudmFsaWRfY29tbW9uX3BhcmFtZXRlcl9wcm9wZXJ0aWVzKHBhcmFtWzFdLCBhbGxvd1BhcmFtZXRlcktleXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9mb3JtX3BhcmFtcyA9IGZ1bmN0aW9uKHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMpIHtcbiAgICAgIHZhciBmb3JtUGFyYW1ldGVycywgcGFyYW0sIF9pLCBfbGVuLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICBpZiAodXRpbC5pc051bGwocHJvcGVydHlbMV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdXRpbC5pc01hcHBpbmcocHJvcGVydHlbMV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBxdWVyeSBwYXJhbWV0ZXJzJywgbnVsbCwgXCJwcm9wZXJ0eTogJ2Zvcm1QYXJhbWV0ZXJzJyBtdXN0IGJlIGEgbWFwXCIsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgZm9ybVBhcmFtZXRlcnMgPSB7fTtcbiAgICAgIF9yZWYxID0gcHJvcGVydHlbMV0udmFsdWU7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwYXJhbSA9IF9yZWYxW19pXTtcbiAgICAgICAgaWYgKCEodXRpbC5pc051bGxhYmxlTWFwcGluZyhwYXJhbVsxXSkgfHwgdXRpbC5pc051bGxhYmxlU2VxdWVuY2UocGFyYW1bMV0pKSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBxdWVyeSBwYXJhbWV0ZXJzJywgbnVsbCwgJ2VhY2ggZm9ybSBwYXJhbWV0ZXIgbXVzdCBiZSBhIG1hcCcsIHBhcmFtWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tSZXBlYXRlZFByb3BlcnRpZXMoZm9ybVBhcmFtZXRlcnMsIHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKHBhcmFtWzBdLnZhbHVlLCB0cnVlKSwgcGFyYW1bMF0sICd3aGlsZSB2YWxpZGF0aW5nIGZvcm0gcGFyYW1ldGVyJywgXCJwYXJhbWV0ZXIgbmFtZSBhbHJlYWR5IHVzZWRcIik7XG4gICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy52YWxpZF9jb21tb25fcGFyYW1ldGVyX3Byb3BlcnRpZXMocGFyYW1bMV0sIGFsbG93UGFyYW1ldGVyS2V5cykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX2hlYWRlcnMgPSBmdW5jdGlvbihwcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSB7XG4gICAgICB2YXIgaGVhZGVyTmFtZXMsIHBhcmFtLCBfaSwgX2xlbiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgaWYgKHV0aWwuaXNOdWxsKHByb3BlcnR5WzFdKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKHByb3BlcnR5WzFdKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgaGVhZGVycycsIG51bGwsIFwicHJvcGVydHk6ICdoZWFkZXJzJyBtdXN0IGJlIGEgbWFwXCIsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgaGVhZGVyTmFtZXMgPSB7fTtcbiAgICAgIF9yZWYxID0gcHJvcGVydHlbMV0udmFsdWU7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwYXJhbSA9IF9yZWYxW19pXTtcbiAgICAgICAgaWYgKCEodXRpbC5pc051bGxhYmxlTWFwcGluZyhwYXJhbVsxXSkgfHwgdXRpbC5pc051bGxhYmxlU2VxdWVuY2UocGFyYW1bMV0pKSkge1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBxdWVyeSBwYXJhbWV0ZXJzJywgbnVsbCwgXCJlYWNoIGhlYWRlciBtdXN0IGJlIGEgbWFwXCIsIHBhcmFtWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tSZXBlYXRlZFByb3BlcnRpZXMoaGVhZGVyTmFtZXMsIHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKHBhcmFtWzBdLnZhbHVlLCB0cnVlKSwgcGFyYW1bMF0sICd3aGlsZSB2YWxpZGF0aW5nIGhlYWRlcnMnLCBcImhlYWRlciBuYW1lIGFscmVhZHkgdXNlZFwiKTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLnZhbGlkX2NvbW1vbl9wYXJhbWV0ZXJfcHJvcGVydGllcyhwYXJhbVsxXSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfcmVzcG9uc2UgPSBmdW5jdGlvbihyZXNwb25zZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKSB7XG4gICAgICB2YXIgY2Fub25pY2FsS2V5LCBwcm9wZXJ0eSwgcmVzcG9uc2VDb2RlLCByZXNwb25zZVByb3BlcnRpZXMsIHZhbGlkLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmMSwgX3JlZjIsIF9yZXN1bHRzO1xuICAgICAgaWYgKHV0aWwuaXNTZXF1ZW5jZShyZXNwb25zZVswXSkpIHtcbiAgICAgICAgaWYgKCFyZXNwb25zZVswXS52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzcG9uc2VzJywgbnVsbCwgJ3RoZXJlIG11c3QgYmUgYXQgbGVhc3Qgb25lIHJlc3BvbnNlIGNvZGUnLCByZXNwb25zZVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBfcmVmMSA9IHJlc3BvbnNlWzBdLnZhbHVlO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgcmVzcG9uc2VDb2RlID0gX3JlZjFbX2ldO1xuICAgICAgICAgIGlmICghKHRoaXMuaXNQYXJhbWV0ZXJLZXkocmVzcG9uc2VDb2RlKSB8fCB1dGlsLmlzSW50ZWdlcihyZXNwb25zZUNvZGUpIHx8ICFpc05hTih0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShyZXNwb25zZUNvZGUsIGFsbG93UGFyYW1ldGVyS2V5cykpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc3BvbnNlcycsIG51bGwsIFwiZWFjaCByZXNwb25zZSBrZXkgbXVzdCBiZSBhbiBpbnRlZ2VyXCIsIHJlc3BvbnNlQ29kZS5zdGFydF9tYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoISh0aGlzLmlzUGFyYW1ldGVyS2V5KHJlc3BvbnNlKSB8fCB1dGlsLmlzSW50ZWdlcihyZXNwb25zZVswXSkgfHwgIWlzTmFOKHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKHJlc3BvbnNlWzBdLnZhbHVlLCBhbGxvd1BhcmFtZXRlcktleXMpKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc3BvbnNlcycsIG51bGwsIFwiZWFjaCByZXNwb25zZSBrZXkgbXVzdCBiZSBhbiBpbnRlZ2VyXCIsIHJlc3BvbnNlWzBdLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgaWYgKCF1dGlsLmlzTnVsbGFibGVNYXBwaW5nKHJlc3BvbnNlWzFdKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzcG9uc2VzJywgbnVsbCwgXCJlYWNoIHJlc3BvbnNlIHByb3BlcnR5IG11c3QgYmUgYSBtYXBcIiwgcmVzcG9uc2VbMF0uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBpZiAodXRpbC5pc01hcHBpbmcocmVzcG9uc2VbMV0pKSB7XG4gICAgICAgIHJlc3BvbnNlUHJvcGVydGllcyA9IHt9O1xuICAgICAgICBfcmVmMiA9IHJlc3BvbnNlWzFdLnZhbHVlO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmMi5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICBwcm9wZXJ0eSA9IF9yZWYyW19qXTtcbiAgICAgICAgICBjYW5vbmljYWxLZXkgPSB0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShwcm9wZXJ0eVswXS52YWx1ZSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICB0aGlzLnRyYWNrUmVwZWF0ZWRQcm9wZXJ0aWVzKHJlc3BvbnNlUHJvcGVydGllcywgY2Fub25pY2FsS2V5LCBwcm9wZXJ0eVswXSwgJ3doaWxlIHZhbGlkYXRpbmcgcmVzcG9uc2VzJywgXCJwcm9wZXJ0eSBhbHJlYWR5IHVzZWRcIik7XG4gICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgIGlmICghdGhpcy5pc1BhcmFtZXRlcktleShwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocHJvcGVydHlbMF0udmFsdWUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImRlc2NyaXB0aW9uXCI6XG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzU2NhbGFyKHByb3BlcnR5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc3BvbnNlcycsIG51bGwsICdwcm9wZXJ0eSBkZXNjcmlwdGlvbiBtdXN0IGJlIGEgc3RyaW5nJywgcmVzcG9uc2VbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGNhbm9uaWNhbEtleSkge1xuICAgICAgICAgICAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy52YWxpZGF0ZV9ib2R5KHByb3BlcnR5LCBhbGxvd1BhcmFtZXRlcktleXMsIG51bGwsIHRydWUpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImhlYWRlcnNcIjpcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNOdWxsYWJsZU1hcHBpbmcocHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2VzJywgbnVsbCwgXCJwcm9wZXJ0eSAnaGVhZGVycycgbXVzdCBiZSBhIG1hcFwiLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLnZhbGlkYXRlX2hlYWRlcnMocHJvcGVydHkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzcG9uc2UnLCBudWxsLCBcInByb3BlcnR5OiAnXCIgKyBwcm9wZXJ0eVswXS52YWx1ZSArIFwiJyBpcyBpbnZhbGlkIGluIGEgcmVzcG9uc2VcIiwgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLmlzSHR0cE1ldGhvZCA9IGZ1bmN0aW9uKHZhbHVlLCBhbGxvd1BhcmFtZXRlcktleXMpIHtcbiAgICAgIHZhciBfcmVmMTtcbiAgICAgIGlmIChhbGxvd1BhcmFtZXRlcktleXMgPT0gbnVsbCkge1xuICAgICAgICBhbGxvd1BhcmFtZXRlcktleXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKHZhbHVlLCBhbGxvd1BhcmFtZXRlcktleXMpO1xuICAgICAgICByZXR1cm4gKF9yZWYxID0gdmFsdWUudG9Mb3dlckNhc2UoKSkgPT09ICdvcHRpb25zJyB8fCBfcmVmMSA9PT0gJ2dldCcgfHwgX3JlZjEgPT09ICdoZWFkJyB8fCBfcmVmMSA9PT0gJ3Bvc3QnIHx8IF9yZWYxID09PSAncHV0JyB8fCBfcmVmMSA9PT0gJ2RlbGV0ZScgfHwgX3JlZjEgPT09ICd0cmFjZScgfHwgX3JlZjEgPT09ICdjb25uZWN0JyB8fCBfcmVmMSA9PT0gJ3BhdGNoJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS5pc1BhcmFtZXRlclZhbHVlID0gZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzUGFyYW1ldGVyS2V5KHByb3BlcnR5LCBmYWxzZSk7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUuaXNQYXJhbWV0ZXJLZXkgPSBmdW5jdGlvbihwcm9wZXJ0eSwgY2hlY2tLZXkpIHtcbiAgICAgIHZhciBvZmZzZXQ7XG4gICAgICBpZiAoY2hlY2tLZXkgPT0gbnVsbCkge1xuICAgICAgICBjaGVja0tleSA9IHRydWU7XG4gICAgICB9XG4gICAgICBvZmZzZXQgPSBjaGVja0tleSA/IDAgOiAxO1xuICAgICAgaWYgKCEoY2hlY2tLZXkgfHwgdXRpbC5pc1NjYWxhcihwcm9wZXJ0eVsxXSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzUGFyYW1ldGVyS2V5VmFsdWUocHJvcGVydHlbb2Zmc2V0XS52YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5W29mZnNldF0udmFsdWUubWF0Y2goLzw8XFxzKihbXlxcfFxccz5dKylcXHMqXFx8LipcXHMqPj4vZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHBhcmFtZXRlcicsIG51bGwsIFwidW5rbm93biBmdW5jdGlvbiBhcHBsaWVkIHRvIHByb3BlcnR5IG5hbWVcIiwgcHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUuaXNQYXJhbWV0ZXJLZXlWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUubWF0Y2goLzw8XFxzKihbXlxcfFxccz5dKylcXHMqPj4vZykgfHwgdmFsdWUubWF0Y2goLzw8XFxzKihbXlxcfFxccz5dKylcXHMqKFxcfFxccypcXCFcXHMqKHNpbmd1bGFyaXplfHBsdXJhbGl6ZSkpP1xccyo+Pi9nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZV9ib2R5ID0gZnVuY3Rpb24ocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cywgYm9keU1vZGUsIGlzUmVzcG9uc2VCb2R5KSB7XG4gICAgICB2YXIgYm9keVByb3BlcnRpZXMsIGJvZHlQcm9wZXJ0eSwgY2Fub25pY2FsUHJvcGVydHksIGltcGxpY2l0TW9kZSwga2V5LCBzdGFydF9tYXJrLCB2YWxpZCwgX2ksIF9sZW4sIF9yZWYxO1xuICAgICAgaWYgKGJvZHlNb2RlID09IG51bGwpIHtcbiAgICAgICAgYm9keU1vZGUgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWwuaXNOdWxsKHByb3BlcnR5WzFdKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXV0aWwuaXNNYXBwaW5nKHByb3BlcnR5WzFdKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgYm9keScsIG51bGwsIFwicHJvcGVydHk6IGJvZHkgc3BlY2lmaWNhdGlvbiBtdXN0IGJlIGEgbWFwXCIsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgaW1wbGljaXRNb2RlID0gW1wiaW1wbGljaXRcIiwgXCJmb3JjZWRJbXBsaWNpdFwiXTtcbiAgICAgIGJvZHlQcm9wZXJ0aWVzID0ge307XG4gICAgICBfcmVmMSA9IHByb3BlcnR5WzFdLnZhbHVlO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBib2R5UHJvcGVydHkgPSBfcmVmMVtfaV07XG4gICAgICAgIHRoaXMudHJhY2tSZXBlYXRlZFByb3BlcnRpZXMoYm9keVByb3BlcnRpZXMsIHRoaXMuY2Fub25pY2FsaXplUHJvcGVydHlOYW1lKGJvZHlQcm9wZXJ0eVswXS52YWx1ZSwgdHJ1ZSksIGJvZHlQcm9wZXJ0eVswXSwgJ3doaWxlIHZhbGlkYXRpbmcgYm9keScsIFwicHJvcGVydHkgYWxyZWFkeSB1c2VkXCIpO1xuICAgICAgICBpZiAodGhpcy5pc1BhcmFtZXRlcktleShib2R5UHJvcGVydHkpKSB7XG4gICAgICAgICAgaWYgKCFhbGxvd1BhcmFtZXRlcktleXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBib2R5JywgbnVsbCwgXCJwcm9wZXJ0eSAnXCIgKyBib2R5UHJvcGVydHlbMF0udmFsdWUgKyBcIicgaXMgaW52YWxpZCBpbiBhIHJlc291cmNlXCIsIGJvZHlQcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYm9keVByb3BlcnR5WzBdLnZhbHVlLm1hdGNoKC9eW15cXC9dK1xcL1teXFwvXSskLykpIHtcbiAgICAgICAgICBpZiAoYm9keU1vZGUgJiYgYm9keU1vZGUgIT09IFwiZXhwbGljaXRcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGJvZHknLCBudWxsLCBcIm5vdCBjb21wYXRpYmxlIHdpdGggaW1wbGljaXQgZGVmYXVsdCBNZWRpYSBUeXBlXCIsIGJvZHlQcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYm9keU1vZGUgPSBcImV4cGxpY2l0XCI7XG4gICAgICAgICAgdGhpcy52YWxpZGF0ZV9ib2R5KGJvZHlQcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzLCBcImZvcmNlZEltcGxpY2l0XCIsIGlzUmVzcG9uc2VCb2R5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXkgPSBib2R5UHJvcGVydHlbMF0udmFsdWU7XG4gICAgICAgICAgY2Fub25pY2FsUHJvcGVydHkgPSB0aGlzLmNhbm9uaWNhbGl6ZVByb3BlcnR5TmFtZShrZXksIGFsbG93UGFyYW1ldGVyS2V5cyk7XG4gICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgIHN3aXRjaCAoY2Fub25pY2FsUHJvcGVydHkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmb3JtUGFyYW1ldGVyc1wiOlxuICAgICAgICAgICAgICBpZiAoYm9keU1vZGUgJiYgX19pbmRleE9mLmNhbGwoaW1wbGljaXRNb2RlLCBib2R5TW9kZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGJvZHknLCBudWxsLCBcIm5vdCBjb21wYXRpYmxlIHdpdGggZXhwbGljaXQgTWVkaWEgVHlwZVwiLCBib2R5UHJvcGVydHlbMF0uc3RhcnRfbWFyayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGJvZHlNb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBib2R5TW9kZSA9IFwiaW1wbGljaXRcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlX2Zvcm1fcGFyYW1zKGJvZHlQcm9wZXJ0eSwgYWxsb3dQYXJhbWV0ZXJLZXlzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSBcImV4YW1wbGVcIjpcbiAgICAgICAgICAgICAgaWYgKGJvZHlNb2RlICYmIF9faW5kZXhPZi5jYWxsKGltcGxpY2l0TW9kZSwgYm9keU1vZGUpIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBib2R5JywgbnVsbCwgXCJub3QgY29tcGF0aWJsZSB3aXRoIGV4cGxpY2l0IE1lZGlhIFR5cGVcIiwgYm9keVByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChib2R5TW9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYm9keU1vZGUgPSBcImltcGxpY2l0XCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzU2NhbGFyKGJvZHlQcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgYm9keScsIG51bGwsIFwiZXhhbXBsZSBtdXN0IGJlIGEgc3RyaW5nXCIsIGJvZHlQcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzY2hlbWFcIjpcbiAgICAgICAgICAgICAgaWYgKGJvZHlNb2RlICYmIF9faW5kZXhPZi5jYWxsKGltcGxpY2l0TW9kZSwgYm9keU1vZGUpIDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBib2R5JywgbnVsbCwgXCJub3QgY29tcGF0aWJsZSB3aXRoIGV4cGxpY2l0IE1lZGlhIFR5cGVcIiwgYm9keVByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChib2R5TW9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYm9keU1vZGUgPSBcImltcGxpY2l0XCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzU2NhbGFyKGJvZHlQcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgYm9keScsIG51bGwsIFwic2NoZW1hIG11c3QgYmUgYSBzdHJpbmdcIiwgYm9keVByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVTY2hlbWEoYm9keVByb3BlcnR5WzFdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGJvZHknLCBudWxsLCBcInByb3BlcnR5OiAnXCIgKyBib2R5UHJvcGVydHlbMF0udmFsdWUgKyBcIicgaXMgaW52YWxpZCBpbiBhIGJvZHlcIiwgYm9keVByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoXCJmb3JtUGFyYW1ldGVyc1wiIGluIGJvZHlQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHN0YXJ0X21hcmsgPSBib2R5UHJvcGVydGllcy5mb3JtUGFyYW1ldGVycy5zdGFydF9tYXJrO1xuICAgICAgICBpZiAoaXNSZXNwb25zZUJvZHkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgYm9keScsIG51bGwsIFwiZm9ybVBhcmFtZXRlcnMgY2Fubm90IGJlIHVzZWQgdG8gZGVzY3JpYmUgcmVzcG9uc2UgYm9kaWVzXCIsIHN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcInNjaGVtYVwiIGluIGJvZHlQcm9wZXJ0aWVzIHx8IFwiZXhhbXBsZVwiIGluIGJvZHlQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGJvZHknLCBudWxsLCBcImZvcm1QYXJhbWV0ZXJzIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyIHdpdGggdGhlIGV4YW1wbGUgb3Igc2NoZW1hIHByb3BlcnRpZXNcIiwgc3RhcnRfbWFyayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChib2R5TW9kZSA9PT0gXCJpbXBsaWNpdFwiKSB7XG4gICAgICAgIGlmICghdGhpcy5nZXRfbWVkaWFfdHlwZSgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIGJvZHknLCBudWxsLCBcImJvZHkgdHJpZXMgdG8gdXNlIGRlZmF1bHQgTWVkaWEgVHlwZSwgYnV0IG1lZGlhVHlwZSBpcyBudWxsXCIsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVTY2hlbWEgPSBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgdmFyIGVycm9yLCBsaW50LCBtYXJrLCBzY2hlbWE7XG4gICAgICBpZiAodGhpcy5pc1htbFNjaGVtYShwcm9wZXJ0eS52YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0pzb25TY2hlbWEocHJvcGVydHkudmFsdWUpKSB7XG4gICAgICAgIGxpbnQgPSBqc29ubGludChwcm9wZXJ0eS52YWx1ZSk7XG4gICAgICAgIGlmIChsaW50LmVycm9yKSB7XG4gICAgICAgICAgbWFyayA9IHRoaXMuY3JlYXRlX21hcmsocHJvcGVydHkuc3RhcnRfbWFyay5saW5lICsgbGludC5saW5lLCAwKTtcbiAgICAgICAgICBpZiAocHJvcGVydHkuZW5kX21hcmsubGluZSA9PT0gbWFyay5saW5lICYmIHByb3BlcnR5LmVuZF9tYXJrLmNvbHVtbiA9PT0gMCkge1xuICAgICAgICAgICAgbWFyay5saW5lLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBib2R5JywgbnVsbCwgXCJzY2hlbWEgaXMgbm90IHZhbGlkIEpTT04gZXJyb3I6ICdcIiArIGxpbnQuZXJyb3IgKyBcIidcIiwgbWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gc2NoZW1hID0gSlNPTi5wYXJzZShwcm9wZXJ0eS52YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGVycm9yID0gX2Vycm9yO1xuICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBib2R5JywgbnVsbCwgXCJzY2hlbWEgaXMgbm90IHZhbGlkIEpTT04gZXJyb3I6ICdcIiArIGVycm9yICsgXCInXCIsIHByb3BlcnR5LnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUuaXNKc29uU2NoZW1hID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nICE9IG51bGwgPyBzdHJpbmcubWF0Y2goL15cXHMqXFx7LykgOiB2b2lkIDA7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUuaXNYbWxTY2hlbWEgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcgIT0gbnVsbCA/IHN0cmluZy5tYXRjaCgvXlxccyooPFxcP3htbFtePl0rPik/W1xcc1xcbl0qPHhzOnNjaGVtYS8pIDogdm9pZCAwO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX2NvbW1vbl9wcm9wZXJ0aWVzID0gZnVuY3Rpb24ocHJvcGVydHksIGFsbG93UGFyYW1ldGVyS2V5cywgY29udGV4dCkge1xuICAgICAgdmFyIHVzZSwgX2ksIF9sZW4sIF9yZWYxO1xuICAgICAgaWYgKHRoaXMuaXNQYXJhbWV0ZXJLZXkocHJvcGVydHkpKSB7XG4gICAgICAgIGlmICghYWxsb3dQYXJhbWV0ZXJLZXlzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlcycsIG51bGwsIFwicHJvcGVydHkgJ1wiICsgcHJvcGVydHlbMF0udmFsdWUgKyBcIicgaXMgaW52YWxpZCBpbiBhIHJlc291cmNlXCIsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0eVswXS52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgXCJkaXNwbGF5TmFtZVwiOlxuICAgICAgICAgICAgaWYgKGNvbnRleHQgPT09ICdtZXRob2QnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdXRpbC5pc1NjYWxhcihwcm9wZXJ0eVsxXSkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHJlc291cmNlcycsIG51bGwsIFwicHJvcGVydHkgJ2Rpc3BsYXlOYW1lJyBtdXN0IGJlIGEgc3RyaW5nXCIsIHByb3BlcnR5WzBdLnN0YXJ0X21hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgY2FzZSBcImRlc2NyaXB0aW9uXCI6XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNTY2FsYXIocHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZXMnLCBudWxsLCBcInByb3BlcnR5ICdkZXNjcmlwdGlvbicgbXVzdCBiZSBhIHN0cmluZ1wiLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIGNhc2UgXCJpc1wiOlxuICAgICAgICAgICAgaWYgKCF1dGlsLmlzU2VxdWVuY2UocHJvcGVydHlbMV0pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyByZXNvdXJjZXMnLCBudWxsLCBcInByb3BlcnR5ICdpcycgbXVzdCBiZSBhbiBhcnJheVwiLCBwcm9wZXJ0eVswXS5zdGFydF9tYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9yZWYxID0gcHJvcGVydHlbMV0udmFsdWU7XG4gICAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICAgIHVzZSA9IF9yZWYxW19pXTtcbiAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZV90cmFpdF91c2UodXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGVfdHJhaXRfdXNlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHBhcmFtZXRlciwgdHJhaXROYW1lLCB0cmFpdFZhbHVlLCBfaSwgX2xlbiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgaWYgKCEodXRpbC5pc1NjYWxhcihub2RlKSB8fCB1dGlsLmlzTWFwcGluZyhub2RlKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHRyYWl0IGNvbnN1bXB0aW9uJywgbnVsbCwgJ3RyYWl0IG11c3QgYmUgYSBzdHJpbmcgb3IgYSBtYXAnLCBub2RlLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgdHJhaXROYW1lID0gdGhpcy5rZXlfb3JfdmFsdWUobm9kZSk7XG4gICAgICBpZiAoISh0cmFpdE5hbWUgIT0gbnVsbCA/IHRyYWl0TmFtZS50cmltKCkgOiB2b2lkIDApKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyB0cmFpdCBjb25zdW1wdGlvbicsIG51bGwsICd0cmFpdCBuYW1lIG11c3QgYmUgcHJvdmlkZWQnLCBub2RlLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgaWYgKCEodGhpcy5pc1BhcmFtZXRlcktleVZhbHVlKHRyYWl0TmFtZSkgfHwgdGhpcy5nZXRfdHJhaXQodHJhaXROYW1lKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHRyYWl0IGNvbnN1bXB0aW9uJywgbnVsbCwgXCJ0aGVyZSBpcyBubyB0cmFpdCBuYW1lZCBcIiArIHRyYWl0TmFtZSwgbm9kZS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGlmICh1dGlsLmlzU2NhbGFyKG5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyYWl0VmFsdWUgPSBub2RlLnZhbHVlWzBdWzFdO1xuICAgICAgaWYgKCEodXRpbC5pc051bGwodHJhaXRWYWx1ZSkgfHwgdXRpbC5pc01hcHBpbmcodHJhaXRWYWx1ZSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyB0cmFpdCBjb25zdW1wdGlvbicsIG51bGwsICd0cmFpdCBtdXN0IGJlIGEgbWFwJywgdHJhaXRWYWx1ZS5zdGFydF9tYXJrKTtcbiAgICAgIH1cbiAgICAgIGlmICh1dGlsLmlzTnVsbCh0cmFpdFZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfcmVmMSA9IHRyYWl0VmFsdWUudmFsdWU7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwYXJhbWV0ZXIgPSBfcmVmMVtfaV07XG4gICAgICAgIGlmICghdXRpbC5pc1NjYWxhcihwYXJhbWV0ZXJbMV0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHRyYWl0IGNvbnN1bXB0aW9uJywgbnVsbCwgJ3BhcmFtZXRlciB2YWx1ZSBtdXN0IGJlIGEgc2NhbGFyJywgcGFyYW1ldGVyWzFdLnN0YXJ0X21hcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2godm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLmNoaWxkX21ldGhvZHMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKCEobm9kZSAmJiB1dGlsLmlzTWFwcGluZyhub2RlKSkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGUudmFsdWUuZmlsdGVyKGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuICAgICAgICByZXR1cm4gX3RoaXMuaXNIdHRwTWV0aG9kKGNoaWxkTm9kZVswXS52YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS5oYXNfcHJvcGVydHkgPSBmdW5jdGlvbihub2RlLCBwcm9wZXJ0eSkge1xuICAgICAgaWYgKG5vZGUgJiYgdXRpbC5pc01hcHBpbmcobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUudmFsdWUuc29tZShmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGROb2RlWzBdLnZhbHVlICYmIHR5cGVvZiBjaGlsZE5vZGVbMF0udmFsdWUgIT09IFwib2JqZWN0XCIgJiYgY2hpbGROb2RlWzBdLnZhbHVlID09PSBwcm9wZXJ0eTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUucHJvcGVydHlfdmFsdWUgPSBmdW5jdGlvbihub2RlLCBwcm9wZXJ0eSkge1xuICAgICAgdmFyIGZpbHRlcmVkTm9kZXM7XG4gICAgICBmaWx0ZXJlZE5vZGVzID0gbm9kZS52YWx1ZS5maWx0ZXIoZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgY2hpbGROb2RlWzBdLnZhbHVlICE9PSBcIm9iamVjdFwiICYmIGNoaWxkTm9kZVswXS52YWx1ZSA9PT0gcHJvcGVydHk7XG4gICAgICB9KTtcbiAgICAgIGlmIChmaWx0ZXJlZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmlsdGVyZWROb2Rlc1swXVsxXS52YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS5nZXRfcHJvcGVydHkgPSBmdW5jdGlvbihub2RlLCBwcm9wZXJ0eSkge1xuICAgICAgdmFyIGZpbHRlcmVkTm9kZXMsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGlmIChub2RlICYmIHV0aWwuaXNNYXBwaW5nKG5vZGUpKSB7XG4gICAgICAgIGZpbHRlcmVkTm9kZXMgPSBub2RlLnZhbHVlLmZpbHRlcihmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbC5pc1N0cmluZyhjaGlsZE5vZGVbMF0pICYmIGNoaWxkTm9kZVswXS52YWx1ZSA9PT0gcHJvcGVydHk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZmlsdGVyZWROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgaWYgKGZpbHRlcmVkTm9kZXNbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkTm9kZXNbMF1bMV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUuZ2V0X3Byb3BlcnRpZXMgPSBmdW5jdGlvbihub2RlLCBwcm9wZXJ0eSkge1xuICAgICAgdmFyIHByb3AsIHByb3BlcnRpZXMsIF9pLCBfbGVuLCBfcmVmMTtcbiAgICAgIHByb3BlcnRpZXMgPSBbXTtcbiAgICAgIGlmIChub2RlICYmIHV0aWwuaXNNYXBwaW5nKG5vZGUpKSB7XG4gICAgICAgIF9yZWYxID0gbm9kZS52YWx1ZTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHByb3AgPSBfcmVmMVtfaV07XG4gICAgICAgICAgaWYgKHV0aWwuaXNTdHJpbmcocHJvcFswXSkgJiYgcHJvcFswXS52YWx1ZSA9PT0gcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMuY29uY2F0KHRoaXMuZ2V0X3Byb3BlcnRpZXMocHJvcFsxXSwgcHJvcGVydHkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkX2Fic29sdXRlX3VyaXMgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgcmVwZWF0ZWRVcmksIHVyaXM7XG4gICAgICB1cmlzID0gdGhpcy5nZXRfYWJzb2x1dGVfdXJpcyhub2RlKTtcbiAgICAgIGlmIChyZXBlYXRlZFVyaSA9IHRoaXMuaGFzRHVwbGljYXRlc1VyaXModXJpcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKCd3aGlsZSB2YWxpZGF0aW5nIHRyYWl0IGNvbnN1bXB0aW9uJywgbnVsbCwgXCJ0d28gcmVzb3VyY2VzIHNoYXJlIHNhbWUgVVJJIFwiICsgcmVwZWF0ZWRVcmkudXJpLCByZXBlYXRlZFVyaS5tYXJrKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS5nZXRfYWJzb2x1dGVfdXJpcyA9IGZ1bmN0aW9uKG5vZGUsIHBhcmVudFBhdGgpIHtcbiAgICAgIHZhciBjaGlsZFJlc291cmNlLCBjaGlsZF9yZXNvdXJjZXMsIHJlc3BvbnNlLCB1cmksIF9pLCBfbGVuO1xuICAgICAgcmVzcG9uc2UgPSBbXTtcbiAgICAgIGlmICghdXRpbC5pc051bGxhYmxlTWFwcGluZyhub2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgcmVzb3VyY2VzJywgbnVsbCwgJ3Jlc291cmNlIGlzIG5vdCBhIG1hcCcsIG5vZGUuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBjaGlsZF9yZXNvdXJjZXMgPSB0aGlzLmNoaWxkX3Jlc291cmNlcyhub2RlKTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gY2hpbGRfcmVzb3VyY2VzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGNoaWxkUmVzb3VyY2UgPSBjaGlsZF9yZXNvdXJjZXNbX2ldO1xuICAgICAgICBpZiAocGFyZW50UGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgdXJpID0gcGFyZW50UGF0aCArIGNoaWxkUmVzb3VyY2VbMF0udmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJpID0gY2hpbGRSZXNvdXJjZVswXS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXNwb25zZS5wdXNoKHtcbiAgICAgICAgICB1cmk6IHVyaSxcbiAgICAgICAgICBtYXJrOiBjaGlsZFJlc291cmNlWzBdLnN0YXJ0X21hcmtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2UuY29uY2F0KHRoaXMuZ2V0X2Fic29sdXRlX3VyaXMoY2hpbGRSZXNvdXJjZVsxXSwgdXJpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUua2V5X29yX3ZhbHVlID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHBvc3NpYmxlS2V5TmFtZSwgX3JlZjEsIF9yZWYyLCBfcmVmMztcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuU2NhbGFyTm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuTWFwcGluZ05vZGUpIHtcbiAgICAgICAgcG9zc2libGVLZXlOYW1lID0gbm9kZSAhPSBudWxsID8gKF9yZWYxID0gbm9kZS52YWx1ZSkgIT0gbnVsbCA/IChfcmVmMiA9IF9yZWYxWzBdKSAhPSBudWxsID8gKF9yZWYzID0gX3JlZjJbMF0pICE9IG51bGwgPyBfcmVmMy52YWx1ZSA6IHZvaWQgMCA6IHZvaWQgMCA6IHZvaWQgMCA6IHZvaWQgMDtcbiAgICAgICAgaWYgKHBvc3NpYmxlS2V5TmFtZSkge1xuICAgICAgICAgIHJldHVybiBwb3NzaWJsZUtleU5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbHVlX29yX3VuZGVmaW5lZCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuTWFwcGluZ05vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlX2Jhc2VfdXJpID0gZnVuY3Rpb24oYmFzZVVyaU5vZGUpIHtcbiAgICAgIHZhciBiYXNlVXJpLCBlcnIsIGV4cHJlc3Npb25zLCBwcm90b2NvbCwgdGVtcGxhdGUsIF9yZWYxLCBfcmVmMjtcbiAgICAgIGJhc2VVcmkgPSAoX3JlZjEgPSBiYXNlVXJpTm9kZS52YWx1ZSkgIT0gbnVsbCA/IF9yZWYxLnRyaW0oKSA6IHZvaWQgMDtcbiAgICAgIGlmICghYmFzZVVyaSkge1xuICAgICAgICB0aHJvdyBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IoJ3doaWxlIHZhbGlkYXRpbmcgYmFzZVVyaScsIG51bGwsICdiYXNlVXJpIG11c3QgaGF2ZSBhIHZhbHVlJywgYmFzZVVyaU5vZGUuc3RhcnRfbWFyayk7XG4gICAgICB9XG4gICAgICBwcm90b2NvbCA9ICgodXJsLnBhcnNlKGJhc2VVcmkpKS5wcm90b2NvbCB8fCAnaHR0cDonKS5zbGljZSgwLCAtMSkudG9VcHBlckNhc2UoKTtcbiAgICAgIGlmIChwcm90b2NvbCAhPT0gJ0hUVFAnICYmIHByb3RvY29sICE9PSAnSFRUUFMnKSB7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBiYXNlVXJpJywgbnVsbCwgJ2Jhc2VVcmkgcHJvdG9jb2wgbXVzdCBiZSBlaXRoZXIgSFRUUCBvciBIVFRQUycsIGJhc2VVcmlOb2RlLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGVtcGxhdGUgPSB1cml0ZW1wbGF0ZS5wYXJzZShiYXNlVXJpKTtcbiAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICBlcnIgPSBfZXJyb3I7XG4gICAgICAgIHRocm93IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcignd2hpbGUgdmFsaWRhdGluZyBiYXNlVXJpJywgbnVsbCwgZXJyICE9IG51bGwgPyAoX3JlZjIgPSBlcnIub3B0aW9ucykgIT0gbnVsbCA/IF9yZWYyLm1lc3NhZ2UgOiB2b2lkIDAgOiB2b2lkIDAsIGJhc2VVcmlOb2RlLnN0YXJ0X21hcmspO1xuICAgICAgfVxuICAgICAgZXhwcmVzc2lvbnMgPSB0ZW1wbGF0ZS5leHByZXNzaW9ucy5maWx0ZXIoZnVuY3Rpb24oZXhwcikge1xuICAgICAgICByZXR1cm4gJ3RlbXBsYXRlVGV4dCcgaW4gZXhwcjtcbiAgICAgIH0pLm1hcChmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uLnRlbXBsYXRlVGV4dDtcbiAgICAgIH0pO1xuICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKGV4cHJlc3Npb25zLCAndmVyc2lvbicpID49IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUuZ2V0X3ZhbGlkYXRpb25fZXJyb3JzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0aW9uX2Vycm9ycztcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS5pc192YWxpZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGlvbl9lcnJvcnMubGVuZ3RoID09PSAwO1xuICAgIH07XG5cbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLmhhc0R1cGxpY2F0ZXNVcmlzID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgIHZhciBpdGVtLCBvdXRwdXQsIF9pLCBfbGVuO1xuICAgICAgb3V0cHV0ID0ge307XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGFycmF5Lmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBhcnJheVtfaV07XG4gICAgICAgIGlmIChpdGVtLnVyaSBpbiBvdXRwdXQpIHtcbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRbaXRlbS51cmldID0gaXRlbTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgVmFsaWRhdG9yLnByb3RvdHlwZS5oYXNEdXBsaWNhdGVzID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgIHZhciBpdGVtLCBvdXRwdXQsIF9pLCBfbGVuO1xuICAgICAgb3V0cHV0ID0ge307XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGFycmF5Lmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBhcnJheVtfaV07XG4gICAgICAgIGlmIChpdGVtIGluIG91dHB1dCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFtpdGVtXSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHJldHVybiBWYWxpZGF0b3I7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8qIVxuICogaW5mbGVjdGlvblxuICogQ29weXJpZ2h0KGMpIDIwMTEgQmVuIExpbiA8YmVuQGRyZWFtZXJzbGFiLmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICpcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqIEEgcG9ydCBvZiBpbmZsZWN0aW9uLWpzIHRvIG5vZGUuanMgbW9kdWxlLlxuICovXG5cbiggZnVuY3Rpb24gKCByb290ICl7XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGEgbGlzdCBvZiBub3VucyB0aGF0IHVzZSB0aGUgc2FtZSBmb3JtIGZvciBib3RoIHNpbmd1bGFyIGFuZCBwbHVyYWwuXG4gICAqICAgICAgICAgICAgICBUaGlzIGxpc3Qgc2hvdWxkIHJlbWFpbiBlbnRpcmVseSBpbiBsb3dlciBjYXNlIHRvIGNvcnJlY3RseSBtYXRjaCBTdHJpbmdzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdmFyIHVuY291bnRhYmxlX3dvcmRzID0gW1xuICAgICdlcXVpcG1lbnQnLCAnaW5mb3JtYXRpb24nLCAncmljZScsICdtb25leScsICdzcGVjaWVzJyxcbiAgICAnc2VyaWVzJywgJ2Zpc2gnLCAnc2hlZXAnLCAnbW9vc2UnLCAnZGVlcicsICduZXdzJ1xuICBdO1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gVGhlc2UgcnVsZXMgdHJhbnNsYXRlIGZyb20gdGhlIHNpbmd1bGFyIGZvcm0gb2YgYSBub3VuIHRvIGl0cyBwbHVyYWwgZm9ybS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHZhciBwbHVyYWxfcnVsZXMgPSBbXG5cbiAgICAvLyBkbyBub3QgcmVwbGFjZSBpZiBpdHMgYWxyZWFkeSBhIHBsdXJhbCB3b3JkXG4gICAgWyBuZXcgUmVnRXhwKCAnKG0pZW4kJywgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhwZSlvcGxlJCcsICAgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoY2hpbGQpcmVuJCcsICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKFt0aV0pYSQnLCAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJygoYSluYWx5fChiKWF8KGQpaWFnbm98KHApYXJlbnRoZXwocClyb2dub3wocyl5bm9wfCh0KWhlKXNlcyQnLCdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGhpdmUpcyQnLCAgICAgICAgICAgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcodGl2ZSlzJCcsICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhjdXJ2ZSlzJCcsICAgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKFtscl0pdmVzJCcsICAgICAgICAgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoW15mb10pdmVzJCcsICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhbXmFlaW91eV18cXUpaWVzJCcsICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHMpZXJpZXMkJywgICAgICAgICAgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcobSlvdmllcyQnLCAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyh4fGNofHNzfHNoKWVzJCcsICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKFttfGxdKWljZSQnLCAgICAgICAgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoYnVzKWVzJCcsICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhvKWVzJCcsICAgICAgICAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHNob2UpcyQnLCAgICAgICAgICAgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoY3Jpc3xheHx0ZXN0KWVzJCcsICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhvY3RvcHx2aXIpaSQnLCAgICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGFsaWFzfHN0YXR1cyllcyQnLCAgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICdeKG94KWVuJywgICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyh2ZXJ0fGluZClpY2VzJCcsICAgICdnaScgKV0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKG1hdHIpaWNlcyQnLCAgICAgICAgJ2dpJyApXSxcbiAgICBbIG5ldyBSZWdFeHAoICcocXVpeil6ZXMkJywgICAgICAgICAnZ2knICldLFxuXG4gICAgLy8gb3JpZ2luYWwgcnVsZVxuICAgIFsgbmV3IFJlZ0V4cCggJyhtKWFuJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICckMWVuJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhwZSlyc29uJCcsICdnaScgKSwgICAgICAgICAgICAgICckMW9wbGUnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGNoaWxkKSQnLCAnZ2knICksICAgICAgICAgICAgICAgJyQxcmVuJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJ14ob3gpJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICckMWVuJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhheHx0ZXN0KWlzJCcsICdnaScgKSwgICAgICAgICAgICckMWVzJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhvY3RvcHx2aXIpdXMkJywgJ2dpJyApLCAgICAgICAgICckMWknIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGFsaWFzfHN0YXR1cykkJywgJ2dpJyApLCAgICAgICAgJyQxZXMnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGJ1KXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgJyQxc2VzJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhidWZmYWx8dG9tYXR8cG90YXQpbyQnLCAnZ2knICksICckMW9lcycgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoW3RpXSl1bSQnLCAnZ2knICksICAgICAgICAgICAgICAnJDFhJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJ3NpcyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICdzZXMnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKD86KFteZl0pZmV8KFtscl0pZikkJywgJ2dpJyApLCAgJyQxJDJ2ZXMnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKGhpdmUpJCcsICdnaScgKSwgICAgICAgICAgICAgICAgJyQxcycgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoW15hZWlvdXldfHF1KXkkJywgJ2dpJyApLCAgICAgICAnJDFpZXMnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHh8Y2h8c3N8c2gpJCcsICdnaScgKSwgICAgICAgICAgJyQxZXMnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKG1hdHJ8dmVydHxpbmQpaXh8ZXgkJywgJ2dpJyApLCAgJyQxaWNlcycgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoW218bF0pb3VzZSQnLCAnZ2knICksICAgICAgICAgICAnJDFpY2UnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHF1aXopJCcsICdnaScgKSwgICAgICAgICAgICAgICAgJyQxemVzJyBdLFxuXG4gICAgWyBuZXcgUmVnRXhwKCAncyQnLCAnZ2knICksICdzJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyQnLCAnZ2knICksICAncycgXVxuICBdO1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb24gVGhlc2UgcnVsZXMgdHJhbnNsYXRlIGZyb20gdGhlIHBsdXJhbCBmb3JtIG9mIGEgbm91biB0byBpdHMgc2luZ3VsYXIgZm9ybS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHZhciBzaW5ndWxhcl9ydWxlcyA9IFtcblxuICAgIC8vIGRvIG5vdCByZXBsYWNlIGlmIGl0cyBhbHJlYWR5IGEgc2luZ3VsYXIgd29yZFxuICAgIFsgbmV3IFJlZ0V4cCggJyhtKWFuJCcsICAgICAgICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhwZSlyc29uJCcsICAgICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhjaGlsZCkkJywgICAgICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJ14ob3gpJCcsICAgICAgICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhheHx0ZXN0KWlzJCcsICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhvY3RvcHx2aXIpdXMkJywgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhhbGlhc3xzdGF0dXMpJCcsICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhidSlzJCcsICAgICAgICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhidWZmYWx8dG9tYXR8cG90YXQpbyQnLCAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhbdGldKXVtJCcsICAgICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJ3NpcyQnLCAgICAgICAgICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyg/OihbXmZdKWZlfChbbHJdKWYpJCcsICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhoaXZlKSQnLCAgICAgICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhbXmFlaW91eV18cXUpeSQnLCAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyh4fGNofHNzfHNoKSQnLCAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhtYXRyfHZlcnR8aW5kKWl4fGV4JCcsICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhbbXxsXSlvdXNlJCcsICAgICAgICAgICAnZ2knICldLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhxdWl6KSQnLCAgICAgICAgICAgICAgICAnZ2knICldLFxuXG4gICAgLy8gb3JpZ2luYWwgcnVsZVxuICAgIFsgbmV3IFJlZ0V4cCggJyhtKWVuJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxYW4nIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHBlKW9wbGUkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDFyc29uJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhjaGlsZClyZW4kJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhbdGldKWEkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxdW0nIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKChhKW5hbHl8KGIpYXwoZClpYWdub3wocClhcmVudGhlfChwKXJvZ25vfChzKXlub3B8KHQpaGUpc2VzJCcsJ2dpJyApLCAnJDEkMnNpcycgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoaGl2ZSlzJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMScgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcodGl2ZSlzJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMScgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoY3VydmUpcyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMScgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoW2xyXSl2ZXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMWYnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKFteZm9dKXZlcyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDFmZScgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoW15hZWlvdXldfHF1KWllcyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMXknIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHMpZXJpZXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDFlcmllcycgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcobSlvdmllcyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMW92aWUnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHh8Y2h8c3N8c2gpZXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDEnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKFttfGxdKWljZSQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDFvdXNlJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhidXMpZXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhvKWVzJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhzaG9lKXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxJyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhjcmlzfGF4fHRlc3QpZXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxaXMnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKG9jdG9wfHZpcilpJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDF1cycgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcoYWxpYXN8c3RhdHVzKWVzJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMScgXSxcbiAgICBbIG5ldyBSZWdFeHAoICdeKG94KWVuJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMScgXSxcbiAgICBbIG5ldyBSZWdFeHAoICcodmVydHxpbmQpaWNlcyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckMWV4JyBdLFxuICAgIFsgbmV3IFJlZ0V4cCggJyhtYXRyKWljZXMkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQxaXgnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnKHF1aXopemVzJCcsICdnaScgKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDEnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAnc3MkJywgJ2dpJyApLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3MnIF0sXG4gICAgWyBuZXcgUmVnRXhwKCAncyQnLCAnZ2knICksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJyBdXG4gIF07XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGEgbGlzdCBvZiB3b3JkcyB0aGF0IHNob3VsZCBub3QgYmUgY2FwaXRhbGl6ZWQgZm9yIHRpdGxlIGNhc2UuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YXIgbm9uX3RpdGxlY2FzZWRfd29yZHMgPSBbXG4gICAgJ2FuZCcsICdvcicsICdub3InLCAnYScsICdhbicsICd0aGUnLCAnc28nLCAnYnV0JywgJ3RvJywgJ29mJywgJ2F0JywnYnknLFxuICAgICdmcm9tJywgJ2ludG8nLCAnb24nLCAnb250bycsICdvZmYnLCAnb3V0JywgJ2luJywgJ292ZXInLCAnd2l0aCcsICdmb3InXG4gIF07XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvbiBUaGVzZSBhcmUgcmVndWxhciBleHByZXNzaW9ucyB1c2VkIGZvciBjb252ZXJ0aW5nIGJldHdlZW4gU3RyaW5nIGZvcm1hdHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB2YXIgaWRfc3VmZml4ICAgICAgICAgPSBuZXcgUmVnRXhwKCAnKF9pZHN8X2lkKSQnLCAnZycgKTtcbiAgdmFyIHVuZGVyYmFyICAgICAgICAgID0gbmV3IFJlZ0V4cCggJ18nLCAnZycgKTtcbiAgdmFyIHNwYWNlX29yX3VuZGVyYmFyID0gbmV3IFJlZ0V4cCggJ1tcXCBfXScsICdnJyApO1xuICB2YXIgdXBwZXJjYXNlICAgICAgICAgPSBuZXcgUmVnRXhwKCAnKFtBLVpdKScsICdnJyApO1xuICB2YXIgdW5kZXJiYXJfcHJlZml4ICAgPSBuZXcgUmVnRXhwKCAnXl8nICk7XG5cbiAgdmFyIGluZmxlY3RvciA9IHtcblxuICAvKipcbiAgICogQSBoZWxwZXIgbWV0aG9kIHRoYXQgYXBwbGllcyBydWxlcyBiYXNlZCByZXBsYWNlbWVudCB0byBhIFN0cmluZy5cbiAgICogQHByaXZhdGVcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIG1vZGlmeSBhbmQgcmV0dXJuIGJhc2VkIG9uIHRoZSBwYXNzZWQgcnVsZXMuXG4gICAqIEBwYXJhbSB7QXJyYXk6IFtSZWdFeHAsIFN0cmluZ119IHJ1bGVzIFJlZ2V4cCB0byBtYXRjaCBwYWlyZWQgd2l0aCBTdHJpbmcgdG8gdXNlIGZvciByZXBsYWNlbWVudFxuICAgKiBAcGFyYW0ge0FycmF5OiBbU3RyaW5nXX0gc2tpcCBTdHJpbmdzIHRvIHNraXAgaWYgdGhleSBtYXRjaFxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3ZlcnJpZGUgU3RyaW5nIHRvIHJldHVybiBhcyB0aG91Z2ggdGhpcyBtZXRob2Qgc3VjY2VlZGVkICh1c2VkIHRvIGNvbmZvcm0gdG8gQVBJcylcbiAgICogQHJldHVybnMge1N0cmluZ30gUmV0dXJuIHBhc3NlZCBTdHJpbmcgbW9kaWZpZWQgYnkgcGFzc2VkIHJ1bGVzLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdGhpcy5fYXBwbHlfcnVsZXMoICdjb3dzJywgc2luZ3VsYXJfcnVsZXMgKTsgLy8gPT09ICdjb3cnXG4gICAqL1xuICAgIF9hcHBseV9ydWxlcyA6IGZ1bmN0aW9uKCBzdHIsIHJ1bGVzLCBza2lwLCBvdmVycmlkZSApe1xuICAgICAgaWYoIG92ZXJyaWRlICl7XG4gICAgICAgIHN0ciA9IG92ZXJyaWRlO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHZhciBpZ25vcmUgPSAoIGluZmxlY3Rvci5pbmRleE9mKCBza2lwLCBzdHIudG9Mb3dlckNhc2UoKSkgPiAtMSApO1xuXG4gICAgICAgIGlmKCAhaWdub3JlICl7XG4gICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgIHZhciBqID0gcnVsZXMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yKCA7IGkgPCBqOyBpKysgKXtcbiAgICAgICAgICAgIGlmKCBzdHIubWF0Y2goIHJ1bGVzWyBpIF1bIDAgXSkpe1xuICAgICAgICAgICAgICBpZiggcnVsZXNbIGkgXVsgMSBdICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSggcnVsZXNbIGkgXVsgMCBdLCBydWxlc1sgaSBdWyAxIF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGxldHMgdXMgZGV0ZWN0IGlmIGFuIEFycmF5IGNvbnRhaW5zIGEgZ2l2ZW4gZWxlbWVudC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheX0gYXJyIFRoZSBzdWJqZWN0IGFycmF5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBPYmplY3QgdG8gbG9jYXRlIGluIHRoZSBBcnJheS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleCBTdGFydHMgY2hlY2tpbmcgZnJvbSB0aGlzIHBvc2l0aW9uIGluIHRoZSBBcnJheS4ob3B0aW9uYWwpXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVGdW5jIEZ1bmN0aW9uIHVzZWQgdG8gY29tcGFyZSBBcnJheSBpdGVtIHZzIHBhc3NlZCBpdGVtLihvcHRpb25hbClcbiAgICogQHJldHVybnMge051bWJlcn0gUmV0dXJuIGluZGV4IHBvc2l0aW9uIGluIHRoZSBBcnJheSBvZiB0aGUgcGFzc2VkIGl0ZW0uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5pbmRleE9mKFsgJ2hpJywndGhlcmUnIF0sICdndXlzJyApOyAvLyA9PT0gLTFcbiAgICogICAgIGluZmxlY3Rpb24uaW5kZXhPZihbICdoaScsJ3RoZXJlJyBdLCAnaGknICk7IC8vID09PSAwXG4gICAqL1xuICAgIGluZGV4T2YgOiBmdW5jdGlvbiggYXJyLCBpdGVtLCBmcm9tSW5kZXgsIGNvbXBhcmVGdW5jICl7XG4gICAgICBpZiggIWZyb21JbmRleCApe1xuICAgICAgICBmcm9tSW5kZXggPSAtMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICB2YXIgaSAgICAgPSBmcm9tSW5kZXg7XG4gICAgICB2YXIgaiAgICAgPSBhcnIubGVuZ3RoO1xuXG4gICAgICBmb3IoIDsgaSA8IGo7IGkrKyApe1xuICAgICAgICBpZiggYXJyWyBpIF0gID09PSBpdGVtIHx8IGNvbXBhcmVGdW5jICYmIGNvbXBhcmVGdW5jKCBhcnJbIGkgXSwgaXRlbSApKXtcbiAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgcGx1cmFsaXphdGlvbiBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGx1cmFsIE92ZXJyaWRlcyBub3JtYWwgb3V0cHV0IHdpdGggc2FpZCBTdHJpbmcuKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBTaW5ndWxhciBFbmdsaXNoIGxhbmd1YWdlIG5vdW5zIGFyZSByZXR1cm5lZCBpbiBwbHVyYWwgZm9ybS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLnBsdXJhbGl6ZSggJ3BlcnNvbicgKTsgLy8gPT09ICdwZW9wbGUnXG4gICAqICAgICBpbmZsZWN0aW9uLnBsdXJhbGl6ZSggJ29jdG9wdXMnICk7IC8vID09PSAnb2N0b3BpJ1xuICAgKiAgICAgaW5mbGVjdGlvbi5wbHVyYWxpemUoICdIYXQnICk7IC8vID09PSAnSGF0cydcbiAgICogICAgIGluZmxlY3Rpb24ucGx1cmFsaXplKCAncGVyc29uJywgJ2d1eXMnICk7IC8vID09PSAnZ3V5cydcbiAgICovXG4gICAgcGx1cmFsaXplIDogZnVuY3Rpb24gKCBzdHIsIHBsdXJhbCApe1xuICAgICAgcmV0dXJuIGluZmxlY3Rvci5fYXBwbHlfcnVsZXMoIHN0ciwgcGx1cmFsX3J1bGVzLCB1bmNvdW50YWJsZV93b3JkcywgcGx1cmFsICk7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBzaW5ndWxhcml6YXRpb24gc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHNpbmd1bGFyIE92ZXJyaWRlcyBub3JtYWwgb3V0cHV0IHdpdGggc2FpZCBTdHJpbmcuKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBQbHVyYWwgRW5nbGlzaCBsYW5ndWFnZSBub3VucyBhcmUgcmV0dXJuZWQgaW4gc2luZ3VsYXIgZm9ybS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBpbmZsZWN0aW9uID0gcmVxdWlyZSggJ2luZmxlY3Rpb24nICk7XG4gICAqXG4gICAqICAgICBpbmZsZWN0aW9uLnNpbmd1bGFyaXplKCAncGVvcGxlJyApOyAvLyA9PT0gJ3BlcnNvbidcbiAgICogICAgIGluZmxlY3Rpb24uc2luZ3VsYXJpemUoICdvY3RvcGknICk7IC8vID09PSAnb2N0b3B1cydcbiAgICogICAgIGluZmxlY3Rpb24uc2luZ3VsYXJpemUoICdIYXRzJyApOyAvLyA9PT0gJ0hhdCdcbiAgICogICAgIGluZmxlY3Rpb24uc2luZ3VsYXJpemUoICdndXlzJywgJ3BlcnNvbicgKTsgLy8gPT09ICdwZXJzb24nXG4gICAqL1xuICAgIHNpbmd1bGFyaXplIDogZnVuY3Rpb24gKCBzdHIsIHNpbmd1bGFyICl7XG4gICAgICByZXR1cm4gaW5mbGVjdG9yLl9hcHBseV9ydWxlcyggc3RyLCBzaW5ndWxhcl9ydWxlcywgdW5jb3VudGFibGVfd29yZHMsIHNpbmd1bGFyICk7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBjYW1lbGl6YXRpb24gc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBsb3dGaXJzdExldHRlciBEZWZhdWx0IGlzIHRvIGNhcGl0YWxpemUgdGhlIGZpcnN0IGxldHRlciBvZiB0aGUgcmVzdWx0cy4ob3B0aW9uYWwpXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUGFzc2luZyB0cnVlIHdpbGwgbG93ZXJjYXNlIGl0LlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBMb3dlciBjYXNlIHVuZGVyc2NvcmVkIHdvcmRzIHdpbGwgYmUgcmV0dXJuZWQgaW4gY2FtZWwgY2FzZS5cbiAgICogICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsbHkgJy8nIGlzIHRyYW5zbGF0ZWQgdG8gJzo6J1xuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24uY2FtZWxpemUoICdtZXNzYWdlX3Byb3BlcnRpZXMnICk7IC8vID09PSAnTWVzc2FnZVByb3BlcnRpZXMnXG4gICAqICAgICBpbmZsZWN0aW9uLmNhbWVsaXplKCAnbWVzc2FnZV9wcm9wZXJ0aWVzJywgdHJ1ZSApOyAvLyA9PT0gJ21lc3NhZ2VQcm9wZXJ0aWVzJ1xuICAgKi9cbiAgICBjYW1lbGl6ZSA6IGZ1bmN0aW9uICggc3RyLCBsb3dGaXJzdExldHRlciApe1xuICAgICAgdmFyIHN0cl9wYXRoID0gc3RyLnNwbGl0KCAnLycgKTtcbiAgICAgIHZhciBpICAgICAgICA9IDA7XG4gICAgICB2YXIgaiAgICAgICAgPSBzdHJfcGF0aC5sZW5ndGg7XG4gICAgICB2YXIgc3RyX2FyciwgaW5pdF94LCBrLCBsLCBmaXJzdDtcblxuICAgICAgZm9yKCA7IGkgPCBqOyBpKysgKXtcbiAgICAgICAgc3RyX2FyciA9IHN0cl9wYXRoWyBpIF0uc3BsaXQoICdfJyApO1xuICAgICAgICBrICAgICAgID0gMDtcbiAgICAgICAgbCAgICAgICA9IHN0cl9hcnIubGVuZ3RoO1xuXG4gICAgICAgIGZvciggOyBrIDwgbDsgaysrICl7XG4gICAgICAgICAgaWYoIGsgIT09IDAgKXtcbiAgICAgICAgICAgIHN0cl9hcnJbIGsgXSA9IHN0cl9hcnJbIGsgXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpcnN0ID0gc3RyX2FyclsgayBdLmNoYXJBdCggMCApO1xuICAgICAgICAgIGZpcnN0ID0gbG93Rmlyc3RMZXR0ZXIgJiYgaSA9PT0gMCAmJiBrID09PSAwXG4gICAgICAgICAgICA/IGZpcnN0LnRvTG93ZXJDYXNlKCkgOiBmaXJzdC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIHN0cl9hcnJbIGsgXSA9IGZpcnN0ICsgc3RyX2FyclsgayBdLnN1YnN0cmluZyggMSApO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyX3BhdGhbIGkgXSA9IHN0cl9hcnIuam9pbiggJycgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cl9wYXRoLmpvaW4oICc6OicgKTtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIHVuZGVyc2NvcmUgc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbGxVcHBlckNhc2UgRGVmYXVsdCBpcyB0byBsb3dlcmNhc2UgYW5kIGFkZCB1bmRlcnNjb3JlIHByZWZpeC4ob3B0aW9uYWwpXG4gICAqICAgICAgICAgICAgICAgICAgUGFzc2luZyB0cnVlIHdpbGwgcmV0dXJuIGFzIGVudGVyZWQuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IENhbWVsIGNhc2VkIHdvcmRzIGFyZSByZXR1cm5lZCBhcyBsb3dlciBjYXNlZCBhbmQgdW5kZXJzY29yZWQuXG4gICAqICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbGx5ICc6OicgaXMgdHJhbnNsYXRlZCB0byAnLycuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi51bmRlcnNjb3JlKCAnTWVzc2FnZVByb3BlcnRpZXMnICk7IC8vID09PSAnbWVzc2FnZV9wcm9wZXJ0aWVzJ1xuICAgKiAgICAgaW5mbGVjdGlvbi51bmRlcnNjb3JlKCAnbWVzc2FnZVByb3BlcnRpZXMnICk7IC8vID09PSAnbWVzc2FnZV9wcm9wZXJ0aWVzJ1xuICAgKiAgICAgaW5mbGVjdGlvbi51bmRlcnNjb3JlKCAnTVAnLCB0cnVlICk7IC8vID09PSAnTVAnXG4gICAqL1xuICAgIHVuZGVyc2NvcmUgOiBmdW5jdGlvbiAoIHN0ciwgYWxsVXBwZXJDYXNlICl7XG4gICAgICBpZiggYWxsVXBwZXJDYXNlICYmIHN0ciA9PT0gc3RyLnRvVXBwZXJDYXNlKCkpIHJldHVybiBzdHI7XG5cbiAgICAgIHZhciBzdHJfcGF0aCA9IHN0ci5zcGxpdCggJzo6JyApO1xuICAgICAgdmFyIGkgICAgICAgID0gMDtcbiAgICAgIHZhciBqICAgICAgICA9IHN0cl9wYXRoLmxlbmd0aDtcblxuICAgICAgZm9yKCA7IGkgPCBqOyBpKysgKXtcbiAgICAgICAgc3RyX3BhdGhbIGkgXSA9IHN0cl9wYXRoWyBpIF0ucmVwbGFjZSggdXBwZXJjYXNlLCAnXyQxJyApO1xuICAgICAgICBzdHJfcGF0aFsgaSBdID0gc3RyX3BhdGhbIGkgXS5yZXBsYWNlKCB1bmRlcmJhcl9wcmVmaXgsICcnICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHJfcGF0aC5qb2luKCAnLycgKS50b0xvd2VyQ2FzZSgpO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgaHVtYW5pemUgc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBsb3dGaXJzdExldHRlciBEZWZhdWx0IGlzIHRvIGNhcGl0YWxpemUgdGhlIGZpcnN0IGxldHRlciBvZiB0aGUgcmVzdWx0cy4ob3B0aW9uYWwpXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUGFzc2luZyB0cnVlIHdpbGwgbG93ZXJjYXNlIGl0LlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBMb3dlciBjYXNlIHVuZGVyc2NvcmVkIHdvcmRzIHdpbGwgYmUgcmV0dXJuZWQgaW4gaHVtYW5pemVkIGZvcm0uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5odW1hbml6ZSggJ21lc3NhZ2VfcHJvcGVydGllcycgKTsgLy8gPT09ICdNZXNzYWdlIHByb3BlcnRpZXMnXG4gICAqICAgICBpbmZsZWN0aW9uLmh1bWFuaXplKCAnbWVzc2FnZV9wcm9wZXJ0aWVzJywgdHJ1ZSApOyAvLyA9PT0gJ21lc3NhZ2UgcHJvcGVydGllcydcbiAgICovXG4gICAgaHVtYW5pemUgOiBmdW5jdGlvbiggc3RyLCBsb3dGaXJzdExldHRlciApe1xuICAgICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSggaWRfc3VmZml4LCAnJyApO1xuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoIHVuZGVyYmFyLCAnICcgKTtcblxuICAgICAgaWYoICFsb3dGaXJzdExldHRlciApe1xuICAgICAgICBzdHIgPSBpbmZsZWN0b3IuY2FwaXRhbGl6ZSggc3RyICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBjYXBpdGFsaXphdGlvbiBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBBbGwgY2hhcmFjdGVycyB3aWxsIGJlIGxvd2VyIGNhc2UgYW5kIHRoZSBmaXJzdCB3aWxsIGJlIHVwcGVyLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24uY2FwaXRhbGl6ZSggJ21lc3NhZ2VfcHJvcGVydGllcycgKTsgLy8gPT09ICdNZXNzYWdlX3Byb3BlcnRpZXMnXG4gICAqICAgICBpbmZsZWN0aW9uLmNhcGl0YWxpemUoICdtZXNzYWdlIHByb3BlcnRpZXMnLCB0cnVlICk7IC8vID09PSAnTWVzc2FnZSBwcm9wZXJ0aWVzJ1xuICAgKi9cbiAgICBjYXBpdGFsaXplIDogZnVuY3Rpb24gKCBzdHIgKXtcbiAgICAgIHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICByZXR1cm4gc3RyLnN1YnN0cmluZyggMCwgMSApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKCAxICk7XG4gICAgfSxcblxuXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gYWRkcyBkYXNoZXJpemF0aW9uIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFJlcGxhY2VzIGFsbCBzcGFjZXMgb3IgdW5kZXJiYXJzIHdpdGggZGFzaGVzLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24uZGFzaGVyaXplKCAnbWVzc2FnZV9wcm9wZXJ0aWVzJyApOyAvLyA9PT0gJ21lc3NhZ2UtcHJvcGVydGllcydcbiAgICogICAgIGluZmxlY3Rpb24uZGFzaGVyaXplKCAnTWVzc2FnZSBQcm9wZXJ0aWVzJyApOyAvLyA9PT0gJ01lc3NhZ2UtUHJvcGVydGllcydcbiAgICovXG4gICAgZGFzaGVyaXplIDogZnVuY3Rpb24gKCBzdHIgKXtcbiAgICAgIHJldHVybiBzdHIucmVwbGFjZSggc3BhY2Vfb3JfdW5kZXJiYXIsICctJyApO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgdGl0bGVpemUgc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHJldHVybnMge1N0cmluZ30gQ2FwaXRhbGl6ZXMgd29yZHMgYXMgeW91IHdvdWxkIGZvciBhIGJvb2sgdGl0bGUuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi50aXRsZWl6ZSggJ21lc3NhZ2VfcHJvcGVydGllcycgKTsgLy8gPT09ICdNZXNzYWdlIFByb3BlcnRpZXMnXG4gICAqICAgICBpbmZsZWN0aW9uLnRpdGxlaXplKCAnbWVzc2FnZSBwcm9wZXJ0aWVzIHRvIGtlZXAnICk7IC8vID09PSAnTWVzc2FnZSBQcm9wZXJ0aWVzIHRvIEtlZXAnXG4gICAqL1xuICAgIHRpdGxlaXplIDogZnVuY3Rpb24gKCBzdHIgKXtcbiAgICAgIHN0ciAgICAgICAgID0gc3RyLnRvTG93ZXJDYXNlKCkucmVwbGFjZSggdW5kZXJiYXIsICcgJyk7XG4gICAgICB2YXIgc3RyX2FyciA9IHN0ci5zcGxpdCgnICcpO1xuICAgICAgdmFyIGkgICAgICAgPSAwO1xuICAgICAgdmFyIGogICAgICAgPSBzdHJfYXJyLmxlbmd0aDtcbiAgICAgIHZhciBkLCBrLCBsO1xuXG4gICAgICBmb3IoIDsgaSA8IGo7IGkrKyApe1xuICAgICAgICBkID0gc3RyX2FyclsgaSBdLnNwbGl0KCAnLScgKTtcbiAgICAgICAgayA9IDA7XG4gICAgICAgIGwgPSBkLmxlbmd0aDtcblxuICAgICAgICBmb3IoIDsgayA8IGw7IGsrKyl7XG4gICAgICAgICAgaWYoIGluZmxlY3Rvci5pbmRleE9mKCBub25fdGl0bGVjYXNlZF93b3JkcywgZFsgayBdLnRvTG93ZXJDYXNlKCkpIDwgMCApe1xuICAgICAgICAgICAgZFsgayBdID0gaW5mbGVjdG9yLmNhcGl0YWxpemUoIGRbIGsgXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RyX2FyclsgaSBdID0gZC5qb2luKCAnLScgKTtcbiAgICAgIH1cblxuICAgICAgc3RyID0gc3RyX2Fyci5qb2luKCAnICcgKTtcbiAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoIDAsIDEgKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZyggMSApO1xuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgZGVtb2R1bGl6ZSBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBSZW1vdmVzIG1vZHVsZSBuYW1lcyBsZWF2aW5nIG9ubHkgY2xhc3MgbmFtZXMuKFJ1Ynkgc3R5bGUpXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5kZW1vZHVsaXplKCAnTWVzc2FnZTo6QnVzOjpQcm9wZXJ0aWVzJyApOyAvLyA9PT0gJ1Byb3BlcnRpZXMnXG4gICAqL1xuICAgIGRlbW9kdWxpemUgOiBmdW5jdGlvbiAoIHN0ciApe1xuICAgICAgdmFyIHN0cl9hcnIgPSBzdHIuc3BsaXQoICc6OicgKTtcblxuICAgICAgcmV0dXJuIHN0cl9hcnJbIHN0cl9hcnIubGVuZ3RoIC0gMSBdO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgdGFibGVpemUgc3VwcG9ydCB0byBldmVyeSBTdHJpbmcgb2JqZWN0LlxuICAgKiBAcHVibGljXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdWJqZWN0IHN0cmluZy5cbiAgICogQHJldHVybnMge1N0cmluZ30gUmV0dXJuIGNhbWVsIGNhc2VkIHdvcmRzIGludG8gdGhlaXIgdW5kZXJzY29yZWQgcGx1cmFsIGZvcm0uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi50YWJsZWl6ZSggJ01lc3NhZ2VCdXNQcm9wZXJ0eScgKTsgLy8gPT09ICdtZXNzYWdlX2J1c19wcm9wZXJ0aWVzJ1xuICAgKi9cbiAgICB0YWJsZWl6ZSA6IGZ1bmN0aW9uICggc3RyICl7XG4gICAgICBzdHIgPSBpbmZsZWN0b3IudW5kZXJzY29yZSggc3RyICk7XG4gICAgICBzdHIgPSBpbmZsZWN0b3IucGx1cmFsaXplKCBzdHIgKTtcblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIGNsYXNzaWZpY2F0aW9uIHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFVuZGVyc2NvcmVkIHBsdXJhbCBub3VucyBiZWNvbWUgdGhlIGNhbWVsIGNhc2VkIHNpbmd1bGFyIGZvcm0uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5jbGFzc2lmeSggJ21lc3NhZ2VfYnVzX3Byb3BlcnRpZXMnICk7IC8vID09PSAnTWVzc2FnZUJ1c1Byb3BlcnR5J1xuICAgKi9cbiAgICBjbGFzc2lmeSA6IGZ1bmN0aW9uICggc3RyICl7XG4gICAgICBzdHIgPSBpbmZsZWN0b3IuY2FtZWxpemUoIHN0ciApO1xuICAgICAgc3RyID0gaW5mbGVjdG9yLnNpbmd1bGFyaXplKCBzdHIgKTtcblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9LFxuXG5cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhZGRzIGZvcmVpZ24ga2V5IHN1cHBvcnQgdG8gZXZlcnkgU3RyaW5nIG9iamVjdC5cbiAgICogQHB1YmxpY1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3ViamVjdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZHJvcElkVWJhciBEZWZhdWx0IGlzIHRvIHNlcGVyYXRlIGlkIHdpdGggYW4gdW5kZXJiYXIgYXQgdGhlIGVuZCBvZiB0aGUgY2xhc3MgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlvdSBjYW4gcGFzcyB0cnVlIHRvIHNraXAgaXQuKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBVbmRlcnNjb3JlZCBwbHVyYWwgbm91bnMgYmVjb21lIHRoZSBjYW1lbCBjYXNlZCBzaW5ndWxhciBmb3JtLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24uZm9yZWlnbl9rZXkoICdNZXNzYWdlQnVzUHJvcGVydHknICk7IC8vID09PSAnbWVzc2FnZV9idXNfcHJvcGVydHlfaWQnXG4gICAqICAgICBpbmZsZWN0aW9uLmZvcmVpZ25fa2V5KCAnTWVzc2FnZUJ1c1Byb3BlcnR5JywgdHJ1ZSApOyAvLyA9PT0gJ21lc3NhZ2VfYnVzX3Byb3BlcnR5aWQnXG4gICAqL1xuICAgIGZvcmVpZ25fa2V5IDogZnVuY3Rpb24oIHN0ciwgZHJvcElkVWJhciApe1xuICAgICAgc3RyID0gaW5mbGVjdG9yLmRlbW9kdWxpemUoIHN0ciApO1xuICAgICAgc3RyID0gaW5mbGVjdG9yLnVuZGVyc2NvcmUoIHN0ciApICsgKCggZHJvcElkVWJhciApID8gKCAnJyApIDogKCAnXycgKSkgKyAnaWQnO1xuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH0sXG5cblxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGFkZHMgb3JkaW5hbGl6ZSBzdXBwb3J0IHRvIGV2ZXJ5IFN0cmluZyBvYmplY3QuXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBSZXR1cm4gYWxsIGZvdW5kIG51bWJlcnMgdGhlaXIgc2VxdWVuY2UgbGlrZSAnMjJuZCcuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5mbGVjdGlvbiA9IHJlcXVpcmUoICdpbmZsZWN0aW9uJyApO1xuICAgKlxuICAgKiAgICAgaW5mbGVjdGlvbi5vcmRpbmFsaXplKCAndGhlIDEgcGl0Y2gnICk7IC8vID09PSAndGhlIDFzdCBwaXRjaCdcbiAgICovXG4gICAgb3JkaW5hbGl6ZSA6IGZ1bmN0aW9uICggc3RyICl7XG4gICAgICB2YXIgc3RyX2FyciA9IHN0ci5zcGxpdCgnICcpO1xuICAgICAgdmFyIGkgICAgICAgPSAwO1xuICAgICAgdmFyIGogICAgICAgPSBzdHJfYXJyLmxlbmd0aDtcblxuICAgICAgZm9yKCA7IGkgPCBqOyBpKysgKXtcbiAgICAgICAgdmFyIGsgPSBwYXJzZUludCggc3RyX2FyclsgaSBdLCAxMCApO1xuXG4gICAgICAgIGlmKCAhaXNOYU4oIGsgKSl7XG4gICAgICAgICAgdmFyIGx0ZCA9IHN0cl9hcnJbIGkgXS5zdWJzdHJpbmcoIHN0cl9hcnJbIGkgXS5sZW5ndGggLSAyICk7XG4gICAgICAgICAgdmFyIGxkICA9IHN0cl9hcnJbIGkgXS5zdWJzdHJpbmcoIHN0cl9hcnJbIGkgXS5sZW5ndGggLSAxICk7XG4gICAgICAgICAgdmFyIHN1ZiA9ICd0aCc7XG5cbiAgICAgICAgICBpZiggbHRkICE9ICcxMScgJiYgbHRkICE9ICcxMicgJiYgbHRkICE9ICcxMycgKXtcbiAgICAgICAgICAgIGlmKCBsZCA9PT0gJzEnICl7XG4gICAgICAgICAgICAgIHN1ZiA9ICdzdCc7XG4gICAgICAgICAgICB9ZWxzZSBpZiggbGQgPT09ICcyJyApe1xuICAgICAgICAgICAgICBzdWYgPSAnbmQnO1xuICAgICAgICAgICAgfWVsc2UgaWYoIGxkID09PSAnMycgKXtcbiAgICAgICAgICAgICAgc3VmID0gJ3JkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdHJfYXJyWyBpIF0gKz0gc3VmO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHJfYXJyLmpvaW4oICcgJyApO1xuICAgIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gcGVyZm9ybXMgbXVsdGlwbGUgaW5mbGVjdGlvbiBtZXRob2RzIG9uIGEgc3RyaW5nXG4gICAqIEBwdWJsaWNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN1YmplY3Qgc3RyaW5nLlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgQW4gYXJyYXkgb2YgaW5mbGVjdGlvbiBtZXRob2RzLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGluZmxlY3Rpb24gPSByZXF1aXJlKCAnaW5mbGVjdGlvbicgKTtcbiAgICpcbiAgICogICAgIGluZmxlY3Rpb24udHJhbnNmb3JtKCAnYWxsIGpvYicsIFsgJ3BsdXJhbGl6ZScsICdjYXBpdGFsaXplJywgJ2Rhc2hlcml6ZScgXSk7IC8vID09PSAnQWxsLWpvYnMnXG4gICAqL1xuICAgIHRyYW5zZm9ybSA6IGZ1bmN0aW9uICggc3RyLCBhcnIgKXtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBqID0gYXJyLmxlbmd0aDtcblxuICAgICAgZm9yKCA7aSA8IGo7IGkrKyApe1xuICAgICAgICB2YXIgbWV0aG9kID0gYXJyWyBpIF07XG5cbiAgICAgICAgaWYoIHRoaXMuaGFzT3duUHJvcGVydHkoIG1ldGhvZCApKXtcbiAgICAgICAgICBzdHIgPSB0aGlzWyBtZXRob2QgXSggc3RyICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG4gIGluZmxlY3Rvci52ZXJzaW9uID0gJzEuMy41JztcblxuICAvLyBicm93c2VyIHN1cHBvcnRcbiAgLy8gcmVxdWlyZWpzXG4gIGlmKCB0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJyApe1xuICAgIHJldHVybiBkZWZpbmUoIGZ1bmN0aW9uICggcmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlICl7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGluZmxlY3RvcjtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGJyb3dzZXIgc3VwcG9ydFxuICAvLyBub3JtYWwgdXNhZ2VcbiAgaWYoIHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyApe1xuICAgIHJvb3QuaW5mbGVjdGlvbiA9IGluZmxlY3RvcjtcbiAgICByZXR1cm47XG4gIH1cblxuLyoqXG4gKiBFeHBvcnRzIG1vZHVsZS5cbiAqL1xuICBtb2R1bGUuZXhwb3J0cyA9IGluZmxlY3Rvcjtcbn0pKCB0aGlzICk7XG4iLCIoZnVuY3Rpb24oIGdsb2IsIHVuZGVmaW5lZCApIHtcblxudmFyIHJudW1iZXIgPSAvWzAtOV0vLFxuXHRybmV3bGluZSA9IC8oXFxyXFxufFxccnxcXG4pLyxcblx0cmV2aWRlbmNlID0gL1xcclxcbnxcXHJ8XFxuLyxcblx0cndoaXRlc3BhY2UgPSAvKFxcc3xcXHQpLyxcblx0cnZhbGlkc29saWR1cyA9IC9cXFxcKFwifFxcXFx8XFwvfGJ8ZnxufHJ8dHx1WzAtOV17NH0pLyxcblx0ckUgPSAvXihcXC18XFwrKT9bMC05XS87XG5cblxuLy8gTGVlZWVlZWVycnJycm9vb3l5IEplbm5ra2tpaWlubm5zc1xuZnVuY3Rpb24gSlNPTkxpbnQoIGpzb24sIG9wdGlvbnMgKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblxuXHRpZiAoICEgKCBzZWxmIGluc3RhbmNlb2YgSlNPTkxpbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IEpTT05MaW50KCBqc29uLCBvcHRpb25zICk7XG5cdH1cblxuXHQvLyBBcmd1bWVudCBoYW5kbGluZ1xuXHRzZWxmLmpzb24gPSBqc29uIHx8ICcnO1xuXHRzZWxmLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRzZWxmLmxvd2VyID0gc2VsZi5qc29uLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gQWxsb3cgY29tbWVudHMgYnkgZGVmYXVsdFxuXHRpZiAoICEgc2VsZi5vcHRpb25zLmhhc093blByb3BlcnR5KCAnY29tbWVudHMnICkgKSB7XG5cdFx0c2VsZi5vcHRpb25zLmNvbW1lbnRzID0gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmFsc1xuXHRzZWxmLmMgPSAnJztcblx0c2VsZi5pID0gLTE7XG5cdHNlbGYubGVuZ3RoID0gc2VsZi5qc29uLmxlbmd0aDtcblx0c2VsZi5saW5lID0gMTtcblx0c2VsZi5jaGFyYWN0ZXIgPSAwO1xuXHRzZWxmLl9ldmlkZW5jZSA9IHNlbGYuanNvbi5zcGxpdCggcmV2aWRlbmNlICk7XG5cdHNlbGYuZW5kYmxvY2sgPSAnJztcblx0c2VsZi5jb21tYWJyZWFrID0gZmFsc2U7XG5cblx0dHJ5IHtcblx0XHRzZWxmLnJlbmRlcigpO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHRpZiAoIHR5cGVvZiBlICE9ICdzdHJpbmcnICkge1xuXHRcdFx0dGhyb3cgZTtcblx0XHR9XG5cdFx0c2VsZi5lcnJvciA9IGU7XG5cdFx0c2VsZi5zZXRFdmlkZW5jZSgpO1xuXHR9XG59XG5cblxuLy8gTWV0YSAoUGxlYXNlIGNoYW5nZSBjb250YWN0IGluZm8gZm9yIHJlcHVibGlzaGluZyB3aXRoIGNoYW5nZXMpXG5KU09OTGludC5jb250YWN0ID0gXCJDb3JleSBIYXJ0IChjb3JleUBjb2Rlbm90aGluZy5jb20pXCI7XG5KU09OTGludC52ZXJzaW9uID0gJ1tWRVJTSU9OXSc7XG5KU09OTGludC5kYXRlID0gJ1tEQVRFXSc7XG5cblxuLy8gTWV0aG9kc1xuSlNPTkxpbnQucHJvdG90eXBlID0ge1xuXG5cdC8vIFJlbmRlcmluZyBTdGFydFxuXHRyZW5kZXI6IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBwZWVrID0gJycsIGNvbnRlbnQgPSBmYWxzZTtcblxuXHRcdGZvciAoIDsgKytzZWxmLmkgPCBzZWxmLmxlbmd0aDsgKSB7XG5cdFx0XHRzZWxmLmMgPSBzZWxmLmpzb25bIHNlbGYuaSBdO1xuXHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblxuXHRcdFx0aWYgKCBzZWxmLm9wdGlvbnMuY29tbWVudHMgJiYgc2VsZi5jID09ICcvJyApIHtcblx0XHRcdFx0cGVlayA9IHNlbGYuanNvblsgc2VsZi5pICsgMSBdO1xuXHRcdFx0XHRpZiAoIHBlZWsgPT0gJyonICkge1xuXHRcdFx0XHRcdHNlbGYubXVsdGljb21tZW50KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHBlZWsgPT0gJy8nICkge1xuXHRcdFx0XHRcdHNlbGYuY29tbWVudCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IFwiVW5rbm93biBjaGFyYWN0ZXIgJy8nLCBtYXliZSBhIGNvbW1lbnQ/XCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBybmV3bGluZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0c2VsZi5saW5lKys7XG5cdFx0XHRcdHNlbGYuY2hhcmFjdGVyID0gMDtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCByd2hpdGVzcGFjZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggY29udGVudCApIHtcblx0XHRcdFx0dGhyb3cgXCJVbmtub3duIGNoYXJhY3RlciAnXCIgKyBzZWxmLmMgKyBcIicsIGV4cGVjdGluZyBlbmQgb2YgZmlsZS5cIjtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBzZWxmLmMgPT0gJ1snICkge1xuXHRcdFx0XHRjb250ZW50ID0gdHJ1ZTtcblx0XHRcdFx0c2VsZi5hcnJheSgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNlbGYuYyA9PSAneycgKSB7XG5cdFx0XHRcdGNvbnRlbnQgPSB0cnVlO1xuXHRcdFx0XHRzZWxmLm9iamVjdCgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRocm93IFwiVW5rbm93biBjaGFyYWN0ZXIgJ1wiICsgc2VsZi5jICsgXCInLCBleHBlY3Rpbmcgb3BlbmluZyBibG9jayAneycgb3IgJ1snLCBvciBtYXliZSBhIGNvbW1lbnRcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDaGVjayBmb3IgcHVyZSB3aGl0ZXNwYWNlXG5cdFx0aWYgKCAhIGNvbnRlbnQgKSB7XG5cdFx0XHR0aHJvdyBcIkludmFsaWQgSlNPTiwgbm8gY29udGVudC5cIjtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTXVsdGkgbGluZSBjb21tZW50XG5cdG11bHRpY29tbWVudDogZnVuY3Rpb24oKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRmb3IgKCA7ICsrc2VsZi5pIDwgc2VsZi5sZW5ndGg7ICkge1xuXHRcdFx0c2VsZi5jID0gc2VsZi5qc29uWyBzZWxmLmkgXTtcblx0XHRcdHNlbGYuY2hhcmFjdGVyKys7XG5cblx0XHRcdGlmICggc2VsZi5jID09IFwiKlwiICYmIHNlbGYuanNvblsgc2VsZi5pICsgMSBdID09IFwiL1wiICkge1xuXHRcdFx0XHRzZWxmLmkrKztcblx0XHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggcm5ld2xpbmUuZXhlYyggc2VsZi5jICkgKSB7XG5cdFx0XHRcdHNlbGYubGluZSsrO1xuXHRcdFx0XHRzZWxmLmNoYXJhY3RlciA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFNpbmdsZSBsaW5lIGNvbW1lbnRcblx0Y29tbWVudDogZnVuY3Rpb24oKXtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRmb3IgKCA7ICsrc2VsZi5pIDwgc2VsZi5sZW5ndGg7ICkge1xuXHRcdFx0c2VsZi5jID0gc2VsZi5qc29uWyBzZWxmLmkgXTtcblx0XHRcdHNlbGYuY2hhcmFjdGVyKys7XG5cblx0XHRcdGlmICggcm5ld2xpbmUuZXhlYyggc2VsZi5jICkgKSB7XG5cdFx0XHRcdHNlbGYubGluZSsrO1xuXHRcdFx0XHRzZWxmLmNoYXJhY3RlciA9IDA7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBBcnJheSBCbG9ja1xuXHRhcnJheTogZnVuY3Rpb24oKXtcblx0XHQvLyBLZWVwIHJlZmVyZW5jZSBvZiBjdXJyZW50IGVuZGJsb2NrXG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0X2VuZGJsb2NrID0gc2VsZi5lbmRibG9jayxcblx0XHRcdF9jb21tYWJyZWFrID0gc2VsZi5jb21tYWJyZWFrLFxuXHRcdFx0ZW5kZWQgPSBmYWxzZTtcblxuXHRcdHNlbGYuZW5kYmxvY2sgPSAnXSc7XG5cdFx0c2VsZi5jb21tYWJyZWFrID0gZmFsc2U7XG5cdFx0d2hpbGUgKCAoIGVuZGVkID0gc2VsZi52YWx1ZSgpICkgIT09IHRydWUgJiYgc2VsZi5pIDwgc2VsZi5sZW5ndGggKSB7XG5cdFx0XHQvLyBEbyBub3RoaW5nLCBqdXN0IHdhaXQgZm9yIGFycmF5IHZhbHVlcyB0byBmaW5pc2hcblx0XHR9XG5cblx0XHRpZiAoICEgZW5kZWQgKSB7XG5cdFx0XHR0aHJvdyBcIkVPRiBFcnJvci4gRXhwZWN0aW5nIGNsb3NpbmcgJ10nXCI7XG5cdFx0fVxuXG5cdFx0Ly8gUmVzZXQgcHJldmlvdXMgZW5kYmxvY2tcblx0XHRzZWxmLmVuZGJsb2NrID0gX2VuZGJsb2NrO1xuXHRcdHNlbGYuY29tbWFicmVhayA9IF9jb21tYWJyZWFrO1xuXHR9LFxuXG5cdC8vIE9iamVjdCBCbG9ja1xuXHRvYmplY3Q6IGZ1bmN0aW9uKCl7XG5cdFx0Ly8gS2VlcCByZWZlcmVuY2Ugb2YgY3VycmVudCBlbmRibG9ja1xuXHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdF9lbmRibG9jayA9IHNlbGYuZW5kYmxvY2ssXG5cdFx0XHRfY29tbWFicmVhayA9IHNlbGYuY29tbWFicmVhayxcblx0XHRcdGZvdW5kID0gZmFsc2UsIHBlZWsgPSAnJywgZW1wdHkgPSB0cnVlO1xuXG5cdFx0c2VsZi5lbmRibG9jayA9ICd9Jztcblx0XHRzZWxmLmNvbW1hYnJlYWsgPSBmYWxzZTtcblx0XHRmb3IgKCA7ICsrc2VsZi5pIDwgc2VsZi5sZW5ndGg7ICkge1xuXHRcdFx0c2VsZi5jID0gc2VsZi5qc29uWyBzZWxmLmkgXTtcblx0XHRcdHNlbGYuY2hhcmFjdGVyKys7XG5cblx0XHRcdGlmICggc2VsZi5vcHRpb25zLmNvbW1lbnRzICYmIHNlbGYuYyA9PSAnLycgKSB7XG5cdFx0XHRcdHBlZWsgPSBzZWxmLmpzb25bIHNlbGYuaSArIDEgXTtcblx0XHRcdFx0aWYgKCBwZWVrID09ICcqJyApIHtcblx0XHRcdFx0XHRzZWxmLm11bHRpY29tbWVudCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCBwZWVrID09ICcvJyApIHtcblx0XHRcdFx0XHRzZWxmLmNvbW1lbnQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBcIlVua25vd24gY2hhcmFjdGVyICcvJywgbWF5YmUgYSBjb21tZW50P1wiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggcm5ld2xpbmUuZXhlYyggc2VsZi5jICkgKSB7XG5cdFx0XHRcdHNlbGYubGluZSsrO1xuXHRcdFx0XHRzZWxmLmNoYXJhY3RlciA9IDA7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggcndoaXRlc3BhY2UuZXhlYyggc2VsZi5jICkgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNlbGYuYyA9PSAnXCInICkge1xuXHRcdFx0XHRlbXB0eSA9IGZhbHNlO1xuXHRcdFx0XHRpZiAoIHNlbGYua2V5KCkgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0Ly8gUmVzZXQgb2xkIGVuZGJsb2NrXG5cdFx0XHRcdFx0c2VsZi5lbmRibG9jayA9IF9lbmRibG9jaztcblx0XHRcdFx0XHRzZWxmLmNvbW1hYnJlYWsgPSBfY29tbWFicmVhaztcblx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBlbXB0eSAmJiBzZWxmLmMgPT0gJ30nICkge1xuXHRcdFx0XHRzZWxmLmVuZGJsb2NrID0gX2VuZGJsb2NrO1xuXHRcdFx0XHRzZWxmLmNvbW1hYnJlYWsgPSBfY29tbWFicmVhaztcblx0XHRcdFx0Zm91bmQgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBcIlVua25vd24gQ2hhcmFjdGVyICdcIiArIHNlbGYuYyArIFwiJywgZXhwZWN0aW5nIGEgc3RyaW5nIGZvciBrZXkgc3RhdGVtZW50LlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggISBmb3VuZCApIHtcblx0XHRcdHRocm93IFwiRU9GIEVycm9yLCBleHBlY3RpbmcgY2xvc2luZyAnfScuXCI7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEtleSBTdGF0ZW1lbnRcblx0a2V5OiBmdW5jdGlvbigpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRzZWxmLnN0cmluZygpO1xuXG5cdFx0Zm9yICggdmFyIHBlZWsgPSAnJzsgKytzZWxmLmkgPCBzZWxmLmxlbmd0aDsgKSB7XG5cdFx0XHRzZWxmLmMgPSBzZWxmLmpzb25bIHNlbGYuaSBdO1xuXHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblxuXHRcdFx0aWYgKCBzZWxmLm9wdGlvbnMuY29tbWVudHMgJiYgc2VsZi5jID09ICcvJyApIHtcblx0XHRcdFx0cGVlayA9IHNlbGYuanNvblsgc2VsZi5pICsgMSBdO1xuXHRcdFx0XHRpZiAoIHBlZWsgPT0gJyonICkge1xuXHRcdFx0XHRcdHNlbGYubXVsdGljb21tZW50KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHBlZWsgPT0gJy8nICkge1xuXHRcdFx0XHRcdHNlbGYuY29tbWVudCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IFwiVW5rbm93biBjaGFyYWN0ZXIgJy8nLCBtYXliZSBhIGNvbW1lbnQ/XCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBybmV3bGluZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0c2VsZi5saW5lKys7XG5cdFx0XHRcdHNlbGYuY2hhcmFjdGVyID0gMDtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCByd2hpdGVzcGFjZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5jID09IFwiOlwiICkge1xuXHRcdFx0XHRyZXR1cm4gc2VsZi52YWx1ZSgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRocm93IFwiVW5rbm93biBDaGFyYWN0ZXIgJ1wiICsgc2VsZi5jICsgXCInLCBleHBlY3RpbmcgYSBzZW1pY29sb24uXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFZhbHVlIHN0YXRlbWVudFxuXHR2YWx1ZTogZnVuY3Rpb24oKXtcblx0XHR2YXIgc2VsZiA9IHRoaXMsIHBlZWsgPSAnJztcblxuXHRcdGZvciAoIDsgKytzZWxmLmkgPCBzZWxmLmxlbmd0aDsgKSB7XG5cdFx0XHRzZWxmLmMgPSBzZWxmLmpzb25bIHNlbGYuaSBdO1xuXHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblxuXHRcdFx0aWYgKCBzZWxmLm9wdGlvbnMuY29tbWVudHMgJiYgc2VsZi5jID09ICcvJyApIHtcblx0XHRcdFx0cGVlayA9IHNlbGYuanNvblsgc2VsZi5pICsgMSBdO1xuXHRcdFx0XHRpZiAoIHBlZWsgPT0gJyonICkge1xuXHRcdFx0XHRcdHNlbGYubXVsdGljb21tZW50KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHBlZWsgPT0gJy8nICkge1xuXHRcdFx0XHRcdHNlbGYuY29tbWVudCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IFwiVW5rbm93biBjaGFyYWN0ZXIgJy8nLCBtYXliZSBhIGNvbW1lbnQ/XCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBybmV3bGluZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0c2VsZi5saW5lKys7XG5cdFx0XHRcdHNlbGYuY2hhcmFjdGVyID0gMDtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCByd2hpdGVzcGFjZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5jID09ICd7JyApIHtcblx0XHRcdFx0c2VsZi5vYmplY3QoKTtcblx0XHRcdFx0cmV0dXJuIHNlbGYuZW5kdmFsKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5jID09ICdbJyApIHtcblx0XHRcdFx0c2VsZi5hcnJheSgpO1xuXHRcdFx0XHRyZXR1cm4gc2VsZi5lbmR2YWwoKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBzZWxmLmMgPT0gJ1wiJyApIHtcblx0XHRcdFx0c2VsZi5zdHJpbmcoKTtcblx0XHRcdFx0cmV0dXJuIHNlbGYuZW5kdmFsKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5qc29uLmluZGV4T2YoICd0cnVlJywgc2VsZi5pICkgPT09IHNlbGYuaSApIHtcblx0XHRcdFx0c2VsZi5pICs9IDM7XG5cdFx0XHRcdHNlbGYuY2hhcmFjdGVyICs9IDM7XG5cdFx0XHRcdHJldHVybiBzZWxmLmVuZHZhbCgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNlbGYuanNvbi5pbmRleE9mKCAnZmFsc2UnLCBzZWxmLmkgKSA9PT0gc2VsZi5pICkge1xuXHRcdFx0XHRzZWxmLmkgKz0gNDtcblx0XHRcdFx0c2VsZi5jaGFyYWN0ZXIgKz0gNDtcblx0XHRcdFx0cmV0dXJuIHNlbGYuZW5kdmFsKCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5qc29uLmluZGV4T2YoICdudWxsJywgc2VsZi5pICkgPT09IHNlbGYuaSApIHtcblx0XHRcdFx0c2VsZi5pICs9IDM7XG5cdFx0XHRcdHNlbGYuY2hhcmFjdGVyICs9IDM7XG5cdFx0XHRcdHJldHVybiBzZWxmLmVuZHZhbCgpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNlbGYuYyA9PSAnLScgfHwgcm51bWJlci5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0cmV0dXJuIHNlbGYubnVtZXJpYygpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHNlbGYuYyA9PSAnXScgJiYgc2VsZi5lbmRibG9jayA9PSAnXScgKSB7XG5cdFx0XHRcdGlmICggc2VsZi5jb21tYWJyZWFrICkge1xuXHRcdFx0XHRcdHRocm93IFwiVW5leHBlY3RlZCBFbmQgT2YgQXJyYXkgRXJyb3IuIEV4cGVjdGluZyBhIHZhbHVlIHN0YXRlbWVudC5cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBcIlVua25vd24gQ2hhcmFjdGVyICdcIiArIHNlbGYuYyArIFwiJywgZXhwZWN0aW5nIGEgdmFsdWUuXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFN0cmluZyBzdGF0ZW1lbnRcblx0c3RyaW5nOiBmdW5jdGlvbigpe1xuXHRcdHZhciBzZWxmID0gdGhpcywgZm91bmQgPSBmYWxzZSwgbTtcblxuXHRcdGZvciAoIDsgKytzZWxmLmkgPCBzZWxmLmxlbmd0aDsgKSB7XG5cdFx0XHRzZWxmLmMgPSBzZWxmLmpzb25bIHNlbGYuaSBdO1xuXHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblxuXHRcdFx0aWYgKCBzZWxmLmMgPT0gXCJcXFxcXCIgKSB7XG5cdFx0XHRcdGlmICggKCBtID0gcnZhbGlkc29saWR1cy5leGVjKCBzZWxmLmpzb24uc3Vic3RyKCBzZWxmLmkgKSApICkgJiYgbS5pbmRleCA9PT0gMCApIHtcblx0XHRcdFx0XHRzZWxmLmkgKz0gbVsgMSBdLmxlbmd0aDtcblx0XHRcdFx0XHRzZWxmLmNoYXJhY3RlciArPSBtWyAxIF0ubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IFwiSW52YWxpZCBSZXZlcnNlIFNvbGlkdXMgJ1xcXFwnIGRlY2xhcmF0aW9uLlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggcm5ld2xpbmUuZXhlYyggc2VsZi5jICkgKSB7XG5cdFx0XHRcdHNlbGYubGluZSsrO1xuXHRcdFx0XHRzZWxmLmNoYXJhY3RlciA9IDA7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5jID09ICdcIicgKSB7XG5cdFx0XHRcdGZvdW5kID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIGNsb3NlIHN0cmluZyBpcyBmb3VuZFxuXHRcdGlmICggISBmb3VuZCApIHtcblx0XHRcdHRocm93IFwiRU9GOiBObyBjbG9zZSBzdHJpbmcgJ1xcXCInIGZvdW5kLlwiO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOdW1lcmljIFZhbHVlXG5cdG51bWVyaWM6IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0bmVnYXRpdmUgPSB0cnVlLFxuXHRcdFx0ZGVjaW1hbCA9IG51bGwsXG5cdFx0XHRlID0gbnVsbCxcblx0XHRcdHBlZWsgPSAnJztcblxuXHRcdC8vIFdlIG5lZWQgdG8ganVtcCBiYWNrIGEgY2hhcmFjdGVyIHRvIGNhdGNoIHRoZSB3aG9sZSBudW1iZXJcblx0XHRzZWxmLmktLTtcblx0XHRzZWxmLmNoYXJhY3Rlci0tO1xuXHRcdGZvciAoIDsgKytzZWxmLmkgPCBzZWxmLmxlbmd0aDsgKSB7XG5cdFx0XHRzZWxmLmMgPSBzZWxmLmpzb25bIHNlbGYuaSBdO1xuXHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblxuXHRcdFx0Ly8gSGFuZGxlIGluaXRpYWwgbmVnYXRpdmUgc2lnblxuXHRcdFx0aWYgKCBuZWdhdGl2ZSApIHtcblx0XHRcdFx0bmVnYXRpdmUgPSBmYWxzZTtcblx0XHRcdFx0aWYgKCBzZWxmLmMgPT0gJy0nICkge1xuXHRcdFx0XHRcdGlmICggISBybnVtYmVyLmV4ZWMoIHNlbGYuanNvblsgc2VsZi5pICsgMSBdICkgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBcIlVua25vd24gQ2hhcmFjdGVyICdcIiArIHNlbGYuYyArIFwiJyBmb2xsb3dpbmcgYSBuZWdhdGl2ZSwgZXhwZWN0aW5nIGEgbnVtZXJpYyB2YWx1ZS5cIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhIHNpbmdsZSBkZWNpbWFsIGlzIGFsbG93ZWQgaW4gYSBudW1lcmljIHZhbHVlXG5cdFx0XHRpZiAoIGRlY2ltYWwgJiYgc2VsZi5jID09ICcuJyApIHtcblx0XHRcdFx0ZGVjaW1hbCA9IGZhbHNlO1xuXHRcdFx0XHRlID0gdHJ1ZTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBPbmx5IGEgc2luZ2xlIGUgbm90YXRpb24gaXMgYWxsb3dlZCBpbiBhIG51bWVyaWMgdmFsdWVcblx0XHRcdGVsc2UgaWYgKCBlICYmIHNlbGYuYy50b0xvd2VyQ2FzZSgpID09ICdlJyApIHtcblx0XHRcdFx0ZSA9IGZhbHNlO1xuXHRcdFx0XHRuZWdhdGl2ZSA9IHRydWU7XG5cdFx0XHRcdGlmICggckUuZXhlYyggc2VsZi5qc29uLnN1YnN0ciggc2VsZi5pICsgMSwgMiApICkgKSB7XG5cdFx0XHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblx0XHRcdFx0XHRzZWxmLmkrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRzZWxmLmNoYXJhY3RlcisrO1xuXHRcdFx0XHRcdHRocm93IFwiVW5rbm93biBDaGFyYWN0ZXIgJ1wiICsgc2VsZi5qc29uWyBzZWxmLmkgKyAxIF0gKyBcIicgZm9sbG93aW5nIGUgbm90YXRpb24sIGV4cGVjdGluZyBhIG51bWVyaWMgdmFsdWUuXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIE5vcm1hbCBEaWdpdFxuXHRcdFx0ZWxzZSBpZiAoIHJudW1iZXIuZXhlYyggc2VsZi5jICkgKSB7XG5cdFx0XHRcdGlmICggZGVjaW1hbCA9PT0gbnVsbCApIHtcblx0XHRcdFx0XHRkZWNpbWFsID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gQXNzdW1lIGVuZCBvZiBudW1iZXIsIGFuZCBhbGxvdyBlbmR2YWwgdG8gaGFuZGxlIGl0XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gSnVtcCBiYWNrIGEgY2hhcmFjdGVyIHRvIGluY2x1ZGUgdGhlIGN1cnJlbnQgb25lXG5cdFx0XHRcdHNlbGYuaS0tO1xuXHRcdFx0XHRzZWxmLmNoYXJhY3Rlci0tO1xuXHRcdFx0XHRyZXR1cm4gc2VsZi5lbmR2YWwoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRW5kaW5nIGEgdmFsdWUgc3RhdGVtZW50XG5cdGVuZHZhbDogZnVuY3Rpb24oKXtcblx0XHR2YXIgc2VsZiA9IHRoaXMsIHBlZWsgPSAnJztcblx0XHRzZWxmLmNvbW1hYnJlYWsgPSBmYWxzZTtcblxuXHRcdGZvciAoIDsgKytzZWxmLmkgPCBzZWxmLmxlbmd0aDsgKSB7XG5cdFx0XHRzZWxmLmMgPSBzZWxmLmpzb25bIHNlbGYuaSBdO1xuXHRcdFx0c2VsZi5jaGFyYWN0ZXIrKztcblxuXHRcdFx0aWYgKCBzZWxmLm9wdGlvbnMuY29tbWVudHMgJiYgc2VsZi5jID09ICcvJyApIHtcblx0XHRcdFx0cGVlayA9IHNlbGYuanNvblsgc2VsZi5pICsgMSBdO1xuXHRcdFx0XHRpZiAoIHBlZWsgPT0gJyonICkge1xuXHRcdFx0XHRcdHNlbGYubXVsdGljb21tZW50KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIHBlZWsgPT0gJy8nICkge1xuXHRcdFx0XHRcdHNlbGYuY29tbWVudCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IFwiVW5rbm93biBjaGFyYWN0ZXIgJy8nLCBtYXliZSBhIGNvbW1lbnQ/XCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBybmV3bGluZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0c2VsZi5saW5lKys7XG5cdFx0XHRcdHNlbGYuY2hhcmFjdGVyID0gMDtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCByd2hpdGVzcGFjZS5leGVjKCBzZWxmLmMgKSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5jID09ICcsJyApIHtcblx0XHRcdFx0c2VsZi5jb21tYWJyZWFrID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZi5jID09IHNlbGYuZW5kYmxvY2sgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHRocm93IFwiVW5rbm93biBDaGFyYWN0ZXIgJ1wiICsgc2VsZi5jICsgXCInLCBleHBlY3RpbmcgYSBjb21tYSBvciBhIGNsb3NpbmcgJ1wiICsgc2VsZi5lbmRibG9jayArIFwiJ1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBFeHBvc2UgbGluZSBvZiB0aGUgZXJyb3Jcblx0c2V0RXZpZGVuY2U6IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBzdGFydCA9IHNlbGYubGluZSAtIDUsIGVuZCA9IHN0YXJ0ICsgOCwgZXZpZGVuY2UgPSAnJztcblxuXHRcdC8vIE1pbiBzdGFydFxuXHRcdGlmICggc3RhcnQgPCAwICkge1xuXHRcdFx0c3RhcnQgPSAwO1xuXHRcdFx0ZW5kID0gODtcblx0XHR9XG5cblx0XHQvLyBNYXggZW5kXG5cdFx0aWYgKCBlbmQgPj0gc2VsZi5fZXZpZGVuY2UubGVuZ3RoICkge1xuXHRcdFx0ZW5kID0gc2VsZi5fZXZpZGVuY2UubGVuZ3RoO1xuXHRcdH1cblxuXHRcdC8vIEV2aWRlbmNlIGRpc3BsYXlcblx0XHRmb3IgKCA7IHN0YXJ0IDwgZW5kOyBzdGFydCsrICkge1xuXHRcdFx0ZXZpZGVuY2UgKz0gKCBzdGFydCA9PT0gKCBzZWxmLmxpbmUgLSAxICkgPyBcIi0+IFwiIDogXCIgICBcIiApICtcblx0XHRcdFx0KCBzdGFydCArIDEgKSArICd8ICcgK1xuXHRcdFx0XHRzZWxmLl9ldmlkZW5jZVsgc3RhcnQgXSArIFwiXFxuXCI7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBldmlkZW5jZSBkaXNwbGF5XG5cdFx0c2VsZi5ldmlkZW5jZSA9IGV2aWRlbmNlO1xuXHR9XG59O1xuXG5cbi8vIENoZWNrIGZvciBub2RlanMgbW9kdWxlIHN5c3RlbVxuaWYgKCB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICkge1xuXHRtb2R1bGUuZXhwb3J0cyA9IEpTT05MaW50O1xufVxuLy8gSW4gYSBicm93c2VyXG5lbHNlIHtcblx0Z2xvYi5KU09OTGludCA9IEpTT05MaW50O1xufVxuXG59KSggdGhpcyApO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8vIHZpbTp0cz00OnN0cz00OnN3PTQ6XG4vKiFcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDEyIEtyaXMgS293YWwgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNSVRcbiAqIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3EvcmF3L21hc3Rlci9MSUNFTlNFXG4gKlxuICogV2l0aCBwYXJ0cyBieSBUeWxlciBDbG9zZVxuICogQ29weXJpZ2h0IDIwMDctMjAwOSBUeWxlciBDbG9zZSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1JVCBYIGxpY2Vuc2UgZm91bmRcbiAqIGF0IGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UuaHRtbFxuICogRm9ya2VkIGF0IHJlZl9zZW5kLmpzIHZlcnNpb246IDIwMDktMDUtMTFcbiAqXG4gKiBXaXRoIHBhcnRzIGJ5IE1hcmsgTWlsbGVyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTEgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgLy8gVHVybiBvZmYgc3RyaWN0IG1vZGUgZm9yIHRoaXMgZnVuY3Rpb24gc28gd2UgY2FuIGFzc2lnbiB0byBnbG9iYWwuUVxuICAgIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovXG5cbiAgICAvLyBUaGlzIGZpbGUgd2lsbCBmdW5jdGlvbiBwcm9wZXJseSBhcyBhIDxzY3JpcHQ+IHRhZywgb3IgYSBtb2R1bGVcbiAgICAvLyB1c2luZyBDb21tb25KUyBhbmQgTm9kZUpTIG9yIFJlcXVpcmVKUyBtb2R1bGUgZm9ybWF0cy4gIEluXG4gICAgLy8gQ29tbW9uL05vZGUvUmVxdWlyZUpTLCB0aGUgbW9kdWxlIGV4cG9ydHMgdGhlIFEgQVBJIGFuZCB3aGVuXG4gICAgLy8gZXhlY3V0ZWQgYXMgYSBzaW1wbGUgPHNjcmlwdD4sIGl0IGNyZWF0ZXMgYSBRIGdsb2JhbCBpbnN0ZWFkLlxuXG4gICAgLy8gTW9udGFnZSBSZXF1aXJlXG4gICAgaWYgKHR5cGVvZiBib290c3RyYXAgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBib290c3RyYXAoXCJwcm9taXNlXCIsIGRlZmluaXRpb24pO1xuXG4gICAgLy8gQ29tbW9uSlNcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuXG4gICAgLy8gUmVxdWlyZUpTXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG5cbiAgICAvLyBTRVMgKFNlY3VyZSBFY21hU2NyaXB0KVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoIXNlcy5vaygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXMubWFrZVEgPSBkZWZpbml0aW9uO1xuICAgICAgICB9XG5cbiAgICAvLyA8c2NyaXB0PlxuICAgIH0gZWxzZSB7XG4gICAgICAgIFEgPSBkZWZpbml0aW9uKCk7XG4gICAgfVxuXG59KShmdW5jdGlvbiAoKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGhhc1N0YWNrcyA9IGZhbHNlO1xudHJ5IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbn0gY2F0Y2ggKGUpIHtcbiAgICBoYXNTdGFja3MgPSAhIWUuc3RhY2s7XG59XG5cbi8vIEFsbCBjb2RlIGFmdGVyIHRoaXMgcG9pbnQgd2lsbCBiZSBmaWx0ZXJlZCBmcm9tIHN0YWNrIHRyYWNlcyByZXBvcnRlZFxuLy8gYnkgUS5cbnZhciBxU3RhcnRpbmdMaW5lID0gY2FwdHVyZUxpbmUoKTtcbnZhciBxRmlsZU5hbWU7XG5cbi8vIHNoaW1zXG5cbi8vIHVzZWQgZm9yIGZhbGxiYWNrIGluIFwiYWxsUmVzb2x2ZWRcIlxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcblxuLy8gVXNlIHRoZSBmYXN0ZXN0IHBvc3NpYmxlIG1lYW5zIHRvIGV4ZWN1dGUgYSB0YXNrIGluIGEgZnV0dXJlIHR1cm5cbi8vIG9mIHRoZSBldmVudCBsb29wLlxudmFyIG5leHRUaWNrID0oZnVuY3Rpb24gKCkge1xuICAgIC8vIGxpbmtlZCBsaXN0IG9mIHRhc2tzIChzaW5nbGUsIHdpdGggaGVhZCBub2RlKVxuICAgIHZhciBoZWFkID0ge3Rhc2s6IHZvaWQgMCwgbmV4dDogbnVsbH07XG4gICAgdmFyIHRhaWwgPSBoZWFkO1xuICAgIHZhciBmbHVzaGluZyA9IGZhbHNlO1xuICAgIHZhciByZXF1ZXN0VGljayA9IHZvaWQgMDtcbiAgICB2YXIgaXNOb2RlSlMgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICAvKiBqc2hpbnQgbG9vcGZ1bmM6IHRydWUgKi9cblxuICAgICAgICB3aGlsZSAoaGVhZC5uZXh0KSB7XG4gICAgICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgICAgICAgdmFyIHRhc2sgPSBoZWFkLnRhc2s7XG4gICAgICAgICAgICBoZWFkLnRhc2sgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgZG9tYWluID0gaGVhZC5kb21haW47XG5cbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICBoZWFkLmRvbWFpbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0YXNrKCk7XG5cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOb2RlSlMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gbm9kZSwgdW5jYXVnaHQgZXhjZXB0aW9ucyBhcmUgY29uc2lkZXJlZCBmYXRhbCBlcnJvcnMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlLXRocm93IHRoZW0gc3luY2hyb25vdXNseSB0byBpbnRlcnJ1cHQgZmx1c2hpbmchXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIGNvbnRpbnVhdGlvbiBpZiB0aGUgdW5jYXVnaHQgZXhjZXB0aW9uIGlzIHN1cHByZXNzZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGlzdGVuaW5nIFwidW5jYXVnaHRFeGNlcHRpb25cIiBldmVudHMgKGFzIGRvbWFpbnMgZG9lcykuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIGluIG5leHQgZXZlbnQgdG8gYXZvaWQgdGljayByZWN1cnNpb24uXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIGJyb3dzZXJzLCB1bmNhdWdodCBleGNlcHRpb25zIGFyZSBub3QgZmF0YWwuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlLXRocm93IHRoZW0gYXN5bmNocm9ub3VzbHkgdG8gYXZvaWQgc2xvdy1kb3ducy5cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZsdXNoaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgbmV4dFRpY2sgPSBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICB0YWlsID0gdGFpbC5uZXh0ID0ge1xuICAgICAgICAgICAgdGFzazogdGFzayxcbiAgICAgICAgICAgIGRvbWFpbjogaXNOb2RlSlMgJiYgcHJvY2Vzcy5kb21haW4sXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmVxdWVzdFRpY2soKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5uZXh0VGljaykge1xuICAgICAgICAvLyBOb2RlLmpzIGJlZm9yZSAwLjkuIE5vdGUgdGhhdCBzb21lIGZha2UtTm9kZSBlbnZpcm9ubWVudHMsIGxpa2UgdGhlXG4gICAgICAgIC8vIE1vY2hhIHRlc3QgcnVubmVyLCBpbnRyb2R1Y2UgYSBgcHJvY2Vzc2AgZ2xvYmFsIHdpdGhvdXQgYSBgbmV4dFRpY2tgLlxuICAgICAgICBpc05vZGVKUyA9IHRydWU7XG5cbiAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICAgICAgfTtcblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIEluIElFMTAsIE5vZGUuanMgMC45Kywgb3IgaHR0cHM6Ly9naXRodWIuY29tL05vYmxlSlMvc2V0SW1tZWRpYXRlXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXF1ZXN0VGljayA9IHNldEltbWVkaWF0ZS5iaW5kKHdpbmRvdywgZmx1c2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZsdXNoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIG1vZGVybiBicm93c2Vyc1xuICAgICAgICAvLyBodHRwOi8vd3d3Lm5vbmJsb2NraW5nLmlvLzIwMTEvMDYvd2luZG93bmV4dHRpY2suaHRtbFxuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICAvLyBBdCBsZWFzdCBTYWZhcmkgVmVyc2lvbiA2LjAuNSAoODUzNi4zMC4xKSBpbnRlcm1pdHRlbnRseSBjYW5ub3QgY3JlYXRlXG4gICAgICAgIC8vIHdvcmtpbmcgbWVzc2FnZSBwb3J0cyB0aGUgZmlyc3QgdGltZSBhIHBhZ2UgbG9hZHMuXG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVxdWVzdFRpY2sgPSByZXF1ZXN0UG9ydFRpY2s7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlcXVlc3RQb3J0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE9wZXJhIHJlcXVpcmVzIHVzIHRvIHByb3ZpZGUgYSBtZXNzYWdlIHBheWxvYWQsIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgICAgICAgIC8vIHdoZXRoZXIgd2UgdXNlIGl0LlxuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgICAgIHJlcXVlc3RQb3J0VGljaygpO1xuICAgICAgICB9O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb2xkIGJyb3dzZXJzXG4gICAgICAgIHJlcXVlc3RUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRUaWNrO1xufSkoKTtcblxuLy8gQXR0ZW1wdCB0byBtYWtlIGdlbmVyaWNzIHNhZmUgaW4gdGhlIGZhY2Ugb2YgZG93bnN0cmVhbVxuLy8gbW9kaWZpY2F0aW9ucy5cbi8vIFRoZXJlIGlzIG5vIHNpdHVhdGlvbiB3aGVyZSB0aGlzIGlzIG5lY2Vzc2FyeS5cbi8vIElmIHlvdSBuZWVkIGEgc2VjdXJpdHkgZ3VhcmFudGVlLCB0aGVzZSBwcmltb3JkaWFscyBuZWVkIHRvIGJlXG4vLyBkZWVwbHkgZnJvemVuIGFueXdheSwgYW5kIGlmIHlvdSBkb27igJl0IG5lZWQgYSBzZWN1cml0eSBndWFyYW50ZWUsXG4vLyB0aGlzIGlzIGp1c3QgcGxhaW4gcGFyYW5vaWQuXG4vLyBIb3dldmVyLCB0aGlzIGRvZXMgaGF2ZSB0aGUgbmljZSBzaWRlLWVmZmVjdCBvZiByZWR1Y2luZyB0aGUgc2l6ZVxuLy8gb2YgdGhlIGNvZGUgYnkgcmVkdWNpbmcgeC5jYWxsKCkgdG8gbWVyZWx5IHgoKSwgZWxpbWluYXRpbmcgbWFueVxuLy8gaGFyZC10by1taW5pZnkgY2hhcmFjdGVycy5cbi8vIFNlZSBNYXJrIE1pbGxlcuKAmXMgZXhwbGFuYXRpb24gb2Ygd2hhdCB0aGlzIGRvZXMuXG4vLyBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1jb252ZW50aW9uczpzYWZlX21ldGFfcHJvZ3JhbW1pbmdcbnZhciBjYWxsID0gRnVuY3Rpb24uY2FsbDtcbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2FsbC5hcHBseShmLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG4vLyBUaGlzIGlzIGVxdWl2YWxlbnQsIGJ1dCBzbG93ZXI6XG4vLyB1bmN1cnJ5VGhpcyA9IEZ1bmN0aW9uX2JpbmQuYmluZChGdW5jdGlvbl9iaW5kLmNhbGwpO1xuLy8gaHR0cDovL2pzcGVyZi5jb20vdW5jdXJyeXRoaXNcblxudmFyIGFycmF5X3NsaWNlID0gdW5jdXJyeVRoaXMoQXJyYXkucHJvdG90eXBlLnNsaWNlKTtcblxudmFyIGFycmF5X3JlZHVjZSA9IHVuY3VycnlUaGlzKFxuICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgfHwgZnVuY3Rpb24gKGNhbGxiYWNrLCBiYXNpcykge1xuICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIC8vIGNvbmNlcm5pbmcgdGhlIGluaXRpYWwgdmFsdWUsIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIHNlZWsgdG8gdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBhcnJheSwgYWNjb3VudGluZ1xuICAgICAgICAgICAgLy8gZm9yIHRoZSBwb3NzaWJpbGl0eSB0aGF0IGlzIGlzIGEgc3BhcnNlIGFycmF5XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzaXMgPSB0aGlzW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCsraW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICgxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWR1Y2VcbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBhY2NvdW50IGZvciB0aGUgcG9zc2liaWxpdHkgdGhhdCB0aGUgYXJyYXkgaXMgc3BhcnNlXG4gICAgICAgICAgICBpZiAoaW5kZXggaW4gdGhpcykge1xuICAgICAgICAgICAgICAgIGJhc2lzID0gY2FsbGJhY2soYmFzaXMsIHRoaXNbaW5kZXhdLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2lzO1xuICAgIH1cbik7XG5cbnZhciBhcnJheV9pbmRleE9mID0gdW5jdXJyeVRoaXMoXG4gICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5vdCBhIHZlcnkgZ29vZCBzaGltLCBidXQgZ29vZCBlbm91Z2ggZm9yIG91ciBvbmUgdXNlIG9mIGl0XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbik7XG5cbnZhciBhcnJheV9tYXAgPSB1bmN1cnJ5VGhpcyhcbiAgICBBcnJheS5wcm90b3R5cGUubWFwIHx8IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc3ApIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29sbGVjdCA9IFtdO1xuICAgICAgICBhcnJheV9yZWR1Y2Uoc2VsZiwgZnVuY3Rpb24gKHVuZGVmaW5lZCwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICBjb2xsZWN0LnB1c2goY2FsbGJhY2suY2FsbCh0aGlzcCwgdmFsdWUsIGluZGV4LCBzZWxmKSk7XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgICAgIHJldHVybiBjb2xsZWN0O1xuICAgIH1cbik7XG5cbnZhciBvYmplY3RfY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiAocHJvdG90eXBlKSB7XG4gICAgZnVuY3Rpb24gVHlwZSgpIHsgfVxuICAgIFR5cGUucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHJldHVybiBuZXcgVHlwZSgpO1xufTtcblxudmFyIG9iamVjdF9oYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG52YXIgb2JqZWN0X2tleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3RfaGFzT3duUHJvcGVydHkob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn07XG5cbnZhciBvYmplY3RfdG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IE9iamVjdCh2YWx1ZSk7XG59XG5cbi8vIGdlbmVyYXRvciByZWxhdGVkIHNoaW1zXG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBmdW5jdGlvbiBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpbiBTcGlkZXJNb25rZXkuXG5mdW5jdGlvbiBpc1N0b3BJdGVyYXRpb24oZXhjZXB0aW9uKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgb2JqZWN0X3RvU3RyaW5nKGV4Y2VwdGlvbikgPT09IFwiW29iamVjdCBTdG9wSXRlcmF0aW9uXVwiIHx8XG4gICAgICAgIGV4Y2VwdGlvbiBpbnN0YW5jZW9mIFFSZXR1cm5WYWx1ZVxuICAgICk7XG59XG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBoZWxwZXIgYW5kIFEucmV0dXJuIG9uY2UgRVM2IGdlbmVyYXRvcnMgYXJlIGluXG4vLyBTcGlkZXJNb25rZXkuXG52YXIgUVJldHVyblZhbHVlO1xuaWYgKHR5cGVvZiBSZXR1cm5WYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFFSZXR1cm5WYWx1ZSA9IFJldHVyblZhbHVlO1xufSBlbHNlIHtcbiAgICBRUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG59XG5cbi8vIFVudGlsIFY4IDMuMTkgLyBDaHJvbWl1bSAyOSBpcyByZWxlYXNlZCwgU3BpZGVyTW9ua2V5IGlzIHRoZSBvbmx5XG4vLyBlbmdpbmUgdGhhdCBoYXMgYSBkZXBsb3llZCBiYXNlIG9mIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBnZW5lcmF0b3JzLlxuLy8gSG93ZXZlciwgU00ncyBnZW5lcmF0b3JzIHVzZSB0aGUgUHl0aG9uLWluc3BpcmVkIHNlbWFudGljcyBvZlxuLy8gb3V0ZGF0ZWQgRVM2IGRyYWZ0cy4gIFdlIHdvdWxkIGxpa2UgdG8gc3VwcG9ydCBFUzYsIGJ1dCB3ZSdkIGFsc29cbi8vIGxpa2UgdG8gbWFrZSBpdCBwb3NzaWJsZSB0byB1c2UgZ2VuZXJhdG9ycyBpbiBkZXBsb3llZCBicm93c2Vycywgc29cbi8vIHdlIGFsc28gc3VwcG9ydCBQeXRob24tc3R5bGUgZ2VuZXJhdG9ycy4gIEF0IHNvbWUgcG9pbnQgd2UgY2FuIHJlbW92ZVxuLy8gdGhpcyBibG9jay5cbnZhciBoYXNFUzZHZW5lcmF0b3JzO1xudHJ5IHtcbiAgICAvKiBqc2hpbnQgZXZpbDogdHJ1ZSwgbm9uZXc6IGZhbHNlICovXG4gICAgbmV3IEZ1bmN0aW9uKFwiKGZ1bmN0aW9uKiAoKXsgeWllbGQgMTsgfSlcIik7XG4gICAgaGFzRVM2R2VuZXJhdG9ycyA9IHRydWU7XG59IGNhdGNoIChlKSB7XG4gICAgaGFzRVM2R2VuZXJhdG9ycyA9IGZhbHNlO1xufVxuXG4vLyBsb25nIHN0YWNrIHRyYWNlc1xuXG52YXIgU1RBQ0tfSlVNUF9TRVBBUkFUT1IgPSBcIkZyb20gcHJldmlvdXMgZXZlbnQ6XCI7XG5cbmZ1bmN0aW9uIG1ha2VTdGFja1RyYWNlTG9uZyhlcnJvciwgcHJvbWlzZSkge1xuICAgIC8vIElmIHBvc3NpYmxlLCB0cmFuc2Zvcm0gdGhlIGVycm9yIHN0YWNrIHRyYWNlIGJ5IHJlbW92aW5nIE5vZGUgYW5kIFFcbiAgICAvLyBjcnVmdCwgdGhlbiBjb25jYXRlbmF0aW5nIHdpdGggdGhlIHN0YWNrIHRyYWNlIG9mIGBwcm9taXNlYC4gU2VlICM1Ny5cbiAgICBpZiAoaGFzU3RhY2tzICYmXG4gICAgICAgIHByb21pc2Uuc3RhY2sgJiZcbiAgICAgICAgdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIGVycm9yICE9PSBudWxsICYmXG4gICAgICAgIGVycm9yLnN0YWNrICYmXG4gICAgICAgIGVycm9yLnN0YWNrLmluZGV4T2YoU1RBQ0tfSlVNUF9TRVBBUkFUT1IpID09PSAtMVxuICAgICkge1xuICAgICAgICB2YXIgc3RhY2tzID0gW107XG4gICAgICAgIGZvciAodmFyIHAgPSBwcm9taXNlOyAhIXA7IHAgPSBwLnNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHAuc3RhY2spIHtcbiAgICAgICAgICAgICAgICBzdGFja3MudW5zaGlmdChwLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFja3MudW5zaGlmdChlcnJvci5zdGFjayk7XG5cbiAgICAgICAgdmFyIGNvbmNhdGVkU3RhY2tzID0gc3RhY2tzLmpvaW4oXCJcXG5cIiArIFNUQUNLX0pVTVBfU0VQQVJBVE9SICsgXCJcXG5cIik7XG4gICAgICAgIGVycm9yLnN0YWNrID0gZmlsdGVyU3RhY2tTdHJpbmcoY29uY2F0ZWRTdGFja3MpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZmlsdGVyU3RhY2tTdHJpbmcoc3RhY2tTdHJpbmcpIHtcbiAgICB2YXIgbGluZXMgPSBzdGFja1N0cmluZy5zcGxpdChcIlxcblwiKTtcbiAgICB2YXIgZGVzaXJlZExpbmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuXG4gICAgICAgIGlmICghaXNJbnRlcm5hbEZyYW1lKGxpbmUpICYmICFpc05vZGVGcmFtZShsaW5lKSAmJiBsaW5lKSB7XG4gICAgICAgICAgICBkZXNpcmVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzaXJlZExpbmVzLmpvaW4oXCJcXG5cIik7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZUZyYW1lKHN0YWNrTGluZSkge1xuICAgIHJldHVybiBzdGFja0xpbmUuaW5kZXhPZihcIihtb2R1bGUuanM6XCIpICE9PSAtMSB8fFxuICAgICAgICAgICBzdGFja0xpbmUuaW5kZXhPZihcIihub2RlLmpzOlwiKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIGdldEZpbGVOYW1lQW5kTGluZU51bWJlcihzdGFja0xpbmUpIHtcbiAgICAvLyBOYW1lZCBmdW5jdGlvbnM6IFwiYXQgZnVuY3Rpb25OYW1lIChmaWxlbmFtZTpsaW5lTnVtYmVyOmNvbHVtbk51bWJlcilcIlxuICAgIC8vIEluIElFMTAgZnVuY3Rpb24gbmFtZSBjYW4gaGF2ZSBzcGFjZXMgKFwiQW5vbnltb3VzIGZ1bmN0aW9uXCIpIE9fb1xuICAgIHZhciBhdHRlbXB0MSA9IC9hdCAuKyBcXCgoLispOihcXGQrKTooPzpcXGQrKVxcKSQvLmV4ZWMoc3RhY2tMaW5lKTtcbiAgICBpZiAoYXR0ZW1wdDEpIHtcbiAgICAgICAgcmV0dXJuIFthdHRlbXB0MVsxXSwgTnVtYmVyKGF0dGVtcHQxWzJdKV07XG4gICAgfVxuXG4gICAgLy8gQW5vbnltb3VzIGZ1bmN0aW9uczogXCJhdCBmaWxlbmFtZTpsaW5lTnVtYmVyOmNvbHVtbk51bWJlclwiXG4gICAgdmFyIGF0dGVtcHQyID0gL2F0IChbXiBdKyk6KFxcZCspOig/OlxcZCspJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0Mikge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQyWzFdLCBOdW1iZXIoYXR0ZW1wdDJbMl0pXTtcbiAgICB9XG5cbiAgICAvLyBGaXJlZm94IHN0eWxlOiBcImZ1bmN0aW9uQGZpbGVuYW1lOmxpbmVOdW1iZXIgb3IgQGZpbGVuYW1lOmxpbmVOdW1iZXJcIlxuICAgIHZhciBhdHRlbXB0MyA9IC8uKkAoLispOihcXGQrKSQvLmV4ZWMoc3RhY2tMaW5lKTtcbiAgICBpZiAoYXR0ZW1wdDMpIHtcbiAgICAgICAgcmV0dXJuIFthdHRlbXB0M1sxXSwgTnVtYmVyKGF0dGVtcHQzWzJdKV07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0ludGVybmFsRnJhbWUoc3RhY2tMaW5lKSB7XG4gICAgdmFyIGZpbGVOYW1lQW5kTGluZU51bWJlciA9IGdldEZpbGVOYW1lQW5kTGluZU51bWJlcihzdGFja0xpbmUpO1xuXG4gICAgaWYgKCFmaWxlTmFtZUFuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBmaWxlTmFtZSA9IGZpbGVOYW1lQW5kTGluZU51bWJlclswXTtcbiAgICB2YXIgbGluZU51bWJlciA9IGZpbGVOYW1lQW5kTGluZU51bWJlclsxXTtcblxuICAgIHJldHVybiBmaWxlTmFtZSA9PT0gcUZpbGVOYW1lICYmXG4gICAgICAgIGxpbmVOdW1iZXIgPj0gcVN0YXJ0aW5nTGluZSAmJlxuICAgICAgICBsaW5lTnVtYmVyIDw9IHFFbmRpbmdMaW5lO1xufVxuXG4vLyBkaXNjb3ZlciBvd24gZmlsZSBuYW1lIGFuZCBsaW5lIG51bWJlciByYW5nZSBmb3IgZmlsdGVyaW5nIHN0YWNrXG4vLyB0cmFjZXNcbmZ1bmN0aW9uIGNhcHR1cmVMaW5lKCkge1xuICAgIGlmICghaGFzU3RhY2tzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IGUuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIHZhciBmaXJzdExpbmUgPSBsaW5lc1swXS5pbmRleE9mKFwiQFwiKSA+IDAgPyBsaW5lc1sxXSA6IGxpbmVzWzJdO1xuICAgICAgICB2YXIgZmlsZU5hbWVBbmRMaW5lTnVtYmVyID0gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKGZpcnN0TGluZSk7XG4gICAgICAgIGlmICghZmlsZU5hbWVBbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBxRmlsZU5hbWUgPSBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMF07XG4gICAgICAgIHJldHVybiBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMV07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZXByZWNhdGUoY2FsbGJhY2ssIG5hbWUsIGFsdGVybmF0aXZlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZS53YXJuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihuYW1lICsgXCIgaXMgZGVwcmVjYXRlZCwgdXNlIFwiICsgYWx0ZXJuYXRpdmUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGluc3RlYWQuXCIsIG5ldyBFcnJvcihcIlwiKS5zdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KGNhbGxiYWNrLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8vIGVuZCBvZiBzaGltc1xuLy8gYmVnaW5uaW5nIG9mIHJlYWwgd29ya1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBwcm9taXNlIGZvciBhbiBpbW1lZGlhdGUgcmVmZXJlbmNlLCBwYXNzZXMgcHJvbWlzZXMgdGhyb3VnaCwgb3JcbiAqIGNvZXJjZXMgcHJvbWlzZXMgZnJvbSBkaWZmZXJlbnQgc3lzdGVtcy5cbiAqIEBwYXJhbSB2YWx1ZSBpbW1lZGlhdGUgcmVmZXJlbmNlIG9yIHByb21pc2VcbiAqL1xuZnVuY3Rpb24gUSh2YWx1ZSkge1xuICAgIC8vIElmIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBhIFByb21pc2UsIHJldHVybiBpdCBkaXJlY3RseS4gIFRoaXMgZW5hYmxlc1xuICAgIC8vIHRoZSByZXNvbHZlIGZ1bmN0aW9uIHRvIGJvdGggYmUgdXNlZCB0byBjcmVhdGVkIHJlZmVyZW5jZXMgZnJvbSBvYmplY3RzLFxuICAgIC8vIGJ1dCB0byB0b2xlcmFibHkgY29lcmNlIG5vbi1wcm9taXNlcyB0byBwcm9taXNlcy5cbiAgICBpZiAoaXNQcm9taXNlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gYXNzaW1pbGF0ZSB0aGVuYWJsZXNcbiAgICBpZiAoaXNQcm9taXNlQWxpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBjb2VyY2UodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdWxmaWxsKHZhbHVlKTtcbiAgICB9XG59XG5RLnJlc29sdmUgPSBRO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgdGFzayBpbiBhIGZ1dHVyZSB0dXJuIG9mIHRoZSBldmVudCBsb29wLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdGFza1xuICovXG5RLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbi8qKlxuICogQ29udHJvbHMgd2hldGhlciBvciBub3QgbG9uZyBzdGFjayB0cmFjZXMgd2lsbCBiZSBvblxuICovXG5RLmxvbmdTdGFja1N1cHBvcnQgPSBmYWxzZTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEge3Byb21pc2UsIHJlc29sdmUsIHJlamVjdH0gb2JqZWN0LlxuICpcbiAqIGByZXNvbHZlYCBpcyBhIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIGEgbW9yZSByZXNvbHZlZCB2YWx1ZSBmb3IgdGhlXG4gKiBwcm9taXNlLiBUbyBmdWxmaWxsIHRoZSBwcm9taXNlLCBpbnZva2UgYHJlc29sdmVgIHdpdGggYW55IHZhbHVlIHRoYXQgaXNcbiAqIG5vdCBhIHRoZW5hYmxlLiBUbyByZWplY3QgdGhlIHByb21pc2UsIGludm9rZSBgcmVzb2x2ZWAgd2l0aCBhIHJlamVjdGVkXG4gKiB0aGVuYWJsZSwgb3IgaW52b2tlIGByZWplY3RgIHdpdGggdGhlIHJlYXNvbiBkaXJlY3RseS4gVG8gcmVzb2x2ZSB0aGVcbiAqIHByb21pc2UgdG8gYW5vdGhlciB0aGVuYWJsZSwgdGh1cyBwdXR0aW5nIGl0IGluIHRoZSBzYW1lIHN0YXRlLCBpbnZva2VcbiAqIGByZXNvbHZlYCB3aXRoIHRoYXQgb3RoZXIgdGhlbmFibGUuXG4gKi9cblEuZGVmZXIgPSBkZWZlcjtcbmZ1bmN0aW9uIGRlZmVyKCkge1xuICAgIC8vIGlmIFwibWVzc2FnZXNcIiBpcyBhbiBcIkFycmF5XCIsIHRoYXQgaW5kaWNhdGVzIHRoYXQgdGhlIHByb21pc2UgaGFzIG5vdCB5ZXRcbiAgICAvLyBiZWVuIHJlc29sdmVkLiAgSWYgaXQgaXMgXCJ1bmRlZmluZWRcIiwgaXQgaGFzIGJlZW4gcmVzb2x2ZWQuICBFYWNoXG4gICAgLy8gZWxlbWVudCBvZiB0aGUgbWVzc2FnZXMgYXJyYXkgaXMgaXRzZWxmIGFuIGFycmF5IG9mIGNvbXBsZXRlIGFyZ3VtZW50cyB0b1xuICAgIC8vIGZvcndhcmQgdG8gdGhlIHJlc29sdmVkIHByb21pc2UuICBXZSBjb2VyY2UgdGhlIHJlc29sdXRpb24gdmFsdWUgdG8gYVxuICAgIC8vIHByb21pc2UgdXNpbmcgdGhlIGByZXNvbHZlYCBmdW5jdGlvbiBiZWNhdXNlIGl0IGhhbmRsZXMgYm90aCBmdWxseVxuICAgIC8vIG5vbi10aGVuYWJsZSB2YWx1ZXMgYW5kIG90aGVyIHRoZW5hYmxlcyBncmFjZWZ1bGx5LlxuICAgIHZhciBtZXNzYWdlcyA9IFtdLCBwcm9ncmVzc0xpc3RlbmVycyA9IFtdLCByZXNvbHZlZFByb21pc2U7XG5cbiAgICB2YXIgZGVmZXJyZWQgPSBvYmplY3RfY3JlYXRlKGRlZmVyLnByb3RvdHlwZSk7XG4gICAgdmFyIHByb21pc2UgPSBvYmplY3RfY3JlYXRlKFByb21pc2UucHJvdG90eXBlKTtcblxuICAgIHByb21pc2UucHJvbWlzZURpc3BhdGNoID0gZnVuY3Rpb24gKHJlc29sdmUsIG9wLCBvcGVyYW5kcykge1xuICAgICAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChtZXNzYWdlcykge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaChhcmdzKTtcbiAgICAgICAgICAgIGlmIChvcCA9PT0gXCJ3aGVuXCIgJiYgb3BlcmFuZHNbMV0pIHsgLy8gcHJvZ3Jlc3Mgb3BlcmFuZFxuICAgICAgICAgICAgICAgIHByb2dyZXNzTGlzdGVuZXJzLnB1c2gob3BlcmFuZHNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS5wcm9taXNlRGlzcGF0Y2guYXBwbHkocmVzb2x2ZWRQcm9taXNlLCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFhYWCBkZXByZWNhdGVkXG4gICAgcHJvbWlzZS52YWx1ZU9mID0gZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmVhcmVyVmFsdWUgPSBuZWFyZXIocmVzb2x2ZWRQcm9taXNlKTtcbiAgICAgICAgaWYgKGlzUHJvbWlzZShuZWFyZXJWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZSA9IG5lYXJlclZhbHVlOyAvLyBzaG9ydGVuIGNoYWluXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5lYXJlclZhbHVlO1xuICAgIH0sIFwidmFsdWVPZlwiLCBcImluc3BlY3RcIik7XG5cbiAgICBwcm9taXNlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJwZW5kaW5nXCIgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZWRQcm9taXNlLmluc3BlY3QoKTtcbiAgICB9O1xuXG4gICAgaWYgKFEubG9uZ1N0YWNrU3VwcG9ydCAmJiBoYXNTdGFja3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBkb24ndCB0cnkgdG8gdXNlIGBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZWAgb3IgdHJhbnNmZXIgdGhlXG4gICAgICAgICAgICAvLyBhY2Nlc3NvciBhcm91bmQ7IHRoYXQgY2F1c2VzIG1lbW9yeSBsZWFrcyBhcyBwZXIgR0gtMTExLiBKdXN0XG4gICAgICAgICAgICAvLyByZWlmeSB0aGUgc3RhY2sgdHJhY2UgYXMgYSBzdHJpbmcgQVNBUC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBdCB0aGUgc2FtZSB0aW1lLCBjdXQgb2ZmIHRoZSBmaXJzdCBsaW5lOyBpdCdzIGFsd2F5cyBqdXN0XG4gICAgICAgICAgICAvLyBcIltvYmplY3QgUHJvbWlzZV1cXG5cIiwgYXMgcGVyIHRoZSBgdG9TdHJpbmdgLlxuICAgICAgICAgICAgcHJvbWlzZS5zdGFjayA9IGUuc3RhY2suc3Vic3RyaW5nKGUuc3RhY2suaW5kZXhPZihcIlxcblwiKSArIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTk9URTogd2UgZG8gdGhlIGNoZWNrcyBmb3IgYHJlc29sdmVkUHJvbWlzZWAgaW4gZWFjaCBtZXRob2QsIGluc3RlYWQgb2ZcbiAgICAvLyBjb25zb2xpZGF0aW5nIHRoZW0gaW50byBgYmVjb21lYCwgc2luY2Ugb3RoZXJ3aXNlIHdlJ2QgY3JlYXRlIG5ld1xuICAgIC8vIHByb21pc2VzIHdpdGggdGhlIGxpbmVzIGBiZWNvbWUod2hhdGV2ZXIodmFsdWUpKWAuIFNlZSBlLmcuIEdILTI1Mi5cblxuICAgIGZ1bmN0aW9uIGJlY29tZShuZXdQcm9taXNlKSB7XG4gICAgICAgIHJlc29sdmVkUHJvbWlzZSA9IG5ld1Byb21pc2U7XG4gICAgICAgIHByb21pc2Uuc291cmNlID0gbmV3UHJvbWlzZTtcblxuICAgICAgICBhcnJheV9yZWR1Y2UobWVzc2FnZXMsIGZ1bmN0aW9uICh1bmRlZmluZWQsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBuZXdQcm9taXNlLnByb21pc2VEaXNwYXRjaC5hcHBseShuZXdQcm9taXNlLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB2b2lkIDApO1xuXG4gICAgICAgIG1lc3NhZ2VzID0gdm9pZCAwO1xuICAgICAgICBwcm9ncmVzc0xpc3RlbmVycyA9IHZvaWQgMDtcbiAgICB9XG5cbiAgICBkZWZlcnJlZC5wcm9taXNlID0gcHJvbWlzZTtcbiAgICBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShRKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIGRlZmVycmVkLmZ1bGZpbGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVjb21lKGZ1bGZpbGwodmFsdWUpKTtcbiAgICB9O1xuICAgIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYmVjb21lKHJlamVjdChyZWFzb24pKTtcbiAgICB9O1xuICAgIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uIChwcm9ncmVzcykge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheV9yZWR1Y2UocHJvZ3Jlc3NMaXN0ZW5lcnMsIGZ1bmN0aW9uICh1bmRlZmluZWQsIHByb2dyZXNzTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0xpc3RlbmVyKHByb2dyZXNzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB2b2lkIDApO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIE5vZGUtc3R5bGUgY2FsbGJhY2sgdGhhdCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBkZWZlcnJlZFxuICogcHJvbWlzZS5cbiAqIEByZXR1cm5zIGEgbm9kZWJhY2tcbiAqL1xuZGVmZXIucHJvdG90eXBlLm1ha2VOb2RlUmVzb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXJyb3IsIHZhbHVlKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBzZWxmLnJlc29sdmUoYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHJlc29sdmVyIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgbm90aGluZyBhbmQgYWNjZXB0c1xuICogdGhlIHJlc29sdmUsIHJlamVjdCwgYW5kIG5vdGlmeSBmdW5jdGlvbnMgZm9yIGEgZGVmZXJyZWQuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCBtYXkgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgZ2l2ZW4gcmVzb2x2ZSBhbmQgcmVqZWN0XG4gKiBmdW5jdGlvbnMsIG9yIHJlamVjdGVkIGJ5IGEgdGhyb3duIGV4Y2VwdGlvbiBpbiByZXNvbHZlclxuICovXG5RLnByb21pc2UgPSBwcm9taXNlO1xuZnVuY3Rpb24gcHJvbWlzZShyZXNvbHZlcikge1xuICAgIGlmICh0eXBlb2YgcmVzb2x2ZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVzb2x2ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB0cnkge1xuICAgICAgICByZXNvbHZlcihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QsIGRlZmVycmVkLm5vdGlmeSk7XG4gICAgfSBjYXRjaCAocmVhc29uKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChyZWFzb24pO1xuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cblxuLy8gWFhYIGV4cGVyaW1lbnRhbC4gIFRoaXMgbWV0aG9kIGlzIGEgd2F5IHRvIGRlbm90ZSB0aGF0IGEgbG9jYWwgdmFsdWUgaXNcbi8vIHNlcmlhbGl6YWJsZSBhbmQgc2hvdWxkIGJlIGltbWVkaWF0ZWx5IGRpc3BhdGNoZWQgdG8gYSByZW1vdGUgdXBvbiByZXF1ZXN0LFxuLy8gaW5zdGVhZCBvZiBwYXNzaW5nIGEgcmVmZXJlbmNlLlxuUS5wYXNzQnlDb3B5ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIC8vZnJlZXplKG9iamVjdCk7XG4gICAgLy9wYXNzQnlDb3BpZXMuc2V0KG9iamVjdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnBhc3NCeUNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy9mcmVlemUob2JqZWN0KTtcbiAgICAvL3Bhc3NCeUNvcGllcy5zZXQob2JqZWN0LCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSWYgdHdvIHByb21pc2VzIGV2ZW50dWFsbHkgZnVsZmlsbCB0byB0aGUgc2FtZSB2YWx1ZSwgcHJvbWlzZXMgdGhhdCB2YWx1ZSxcbiAqIGJ1dCBvdGhlcndpc2UgcmVqZWN0cy5cbiAqIEBwYXJhbSB4IHtBbnkqfVxuICogQHBhcmFtIHkge0FueSp9XG4gKiBAcmV0dXJucyB7QW55Kn0gYSBwcm9taXNlIGZvciB4IGFuZCB5IGlmIHRoZXkgYXJlIHRoZSBzYW1lLCBidXQgYSByZWplY3Rpb25cbiAqIG90aGVyd2lzZS5cbiAqXG4gKi9cblEuam9pbiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgcmV0dXJuIFEoeCkuam9pbih5KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAodGhhdCkge1xuICAgIHJldHVybiBRKFt0aGlzLCB0aGF0XSkuc3ByZWFkKGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBcIj09PVwiIHNob3VsZCBiZSBPYmplY3QuaXMgb3IgZXF1aXZcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgam9pbjogbm90IHRoZSBzYW1lOiBcIiArIHggKyBcIiBcIiArIHkpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZmlyc3Qgb2YgYW4gYXJyYXkgb2YgcHJvbWlzZXMgdG8gYmVjb21lIGZ1bGZpbGxlZC5cbiAqIEBwYXJhbSBhbnN3ZXJzIHtBcnJheVtBbnkqXX0gcHJvbWlzZXMgdG8gcmFjZVxuICogQHJldHVybnMge0FueSp9IHRoZSBmaXJzdCBwcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5RLnJhY2UgPSByYWNlO1xuZnVuY3Rpb24gcmFjZShhbnN3ZXJQcykge1xuICAgIHJldHVybiBwcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdGhpcyBvbmNlIHdlIGNhbiBhc3N1bWUgYXQgbGVhc3QgRVM1XG4gICAgICAgIC8vIGFuc3dlclBzLmZvckVhY2goZnVuY3Rpb24oYW5zd2VyUCkge1xuICAgICAgICAvLyAgICAgUShhbnN3ZXJQKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvLyBVc2UgdGhpcyBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFuc3dlclBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBRKGFuc3dlclBzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUucmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKFEucmFjZSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBQcm9taXNlIHdpdGggYSBwcm9taXNlIGRlc2NyaXB0b3Igb2JqZWN0IGFuZCBvcHRpb25hbCBmYWxsYmFja1xuICogZnVuY3Rpb24uICBUaGUgZGVzY3JpcHRvciBjb250YWlucyBtZXRob2RzIGxpa2Ugd2hlbihyZWplY3RlZCksIGdldChuYW1lKSxcbiAqIHNldChuYW1lLCB2YWx1ZSksIHBvc3QobmFtZSwgYXJncyksIGFuZCBkZWxldGUobmFtZSksIHdoaWNoIGFsbFxuICogcmV0dXJuIGVpdGhlciBhIHZhbHVlLCBhIHByb21pc2UgZm9yIGEgdmFsdWUsIG9yIGEgcmVqZWN0aW9uLiAgVGhlIGZhbGxiYWNrXG4gKiBhY2NlcHRzIHRoZSBvcGVyYXRpb24gbmFtZSwgYSByZXNvbHZlciwgYW5kIGFueSBmdXJ0aGVyIGFyZ3VtZW50cyB0aGF0IHdvdWxkXG4gKiBoYXZlIGJlZW4gZm9yd2FyZGVkIHRvIHRoZSBhcHByb3ByaWF0ZSBtZXRob2QgYWJvdmUgaGFkIGEgbWV0aG9kIGJlZW5cbiAqIHByb3ZpZGVkIHdpdGggdGhlIHByb3BlciBuYW1lLiAgVGhlIEFQSSBtYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IHRoZSBuYXR1cmVcbiAqIG9mIHRoZSByZXR1cm5lZCBvYmplY3QsIGFwYXJ0IGZyb20gdGhhdCBpdCBpcyB1c2FibGUgd2hlcmVldmVyIHByb21pc2VzIGFyZVxuICogYm91Z2h0IGFuZCBzb2xkLlxuICovXG5RLm1ha2VQcm9taXNlID0gUHJvbWlzZTtcbmZ1bmN0aW9uIFByb21pc2UoZGVzY3JpcHRvciwgZmFsbGJhY2ssIGluc3BlY3QpIHtcbiAgICBpZiAoZmFsbGJhY2sgPT09IHZvaWQgMCkge1xuICAgICAgICBmYWxsYmFjayA9IGZ1bmN0aW9uIChvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJQcm9taXNlIGRvZXMgbm90IHN1cHBvcnQgb3BlcmF0aW9uOiBcIiArIG9wXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGluc3BlY3QgPT09IHZvaWQgMCkge1xuICAgICAgICBpbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtzdGF0ZTogXCJ1bmtub3duXCJ9O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBwcm9taXNlID0gb2JqZWN0X2NyZWF0ZShQcm9taXNlLnByb3RvdHlwZSk7XG5cbiAgICBwcm9taXNlLnByb21pc2VEaXNwYXRjaCA9IGZ1bmN0aW9uIChyZXNvbHZlLCBvcCwgYXJncykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3Jbb3BdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVzY3JpcHRvcltvcF0uYXBwbHkocHJvbWlzZSwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbGxiYWNrLmNhbGwocHJvbWlzZSwgb3AsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJvbWlzZS5pbnNwZWN0ID0gaW5zcGVjdDtcblxuICAgIC8vIFhYWCBkZXByZWNhdGVkIGB2YWx1ZU9mYCBhbmQgYGV4Y2VwdGlvbmAgc3VwcG9ydFxuICAgIGlmIChpbnNwZWN0KSB7XG4gICAgICAgIHZhciBpbnNwZWN0ZWQgPSBpbnNwZWN0KCk7XG4gICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgICAgICAgcHJvbWlzZS5leGNlcHRpb24gPSBpbnNwZWN0ZWQucmVhc29uO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvbWlzZS52YWx1ZU9mID0gZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnNwZWN0ZWQgPSBpbnNwZWN0KCk7XG4gICAgICAgICAgICBpZiAoaW5zcGVjdGVkLnN0YXRlID09PSBcInBlbmRpbmdcIiB8fFxuICAgICAgICAgICAgICAgIGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zcGVjdGVkLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBQcm9taXNlXVwiO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzc2VkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdmFyIGRvbmUgPSBmYWxzZTsgICAvLyBlbnN1cmUgdGhlIHVudHJ1c3RlZCBwcm9taXNlIG1ha2VzIGF0IG1vc3QgYVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIGNhbGwgdG8gb25lIG9mIHRoZSBjYWxsYmFja3NcblxuICAgIGZ1bmN0aW9uIF9mdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZnVsZmlsbGVkID09PSBcImZ1bmN0aW9uXCIgPyBmdWxmaWxsZWQodmFsdWUpIDogdmFsdWU7XG4gICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3JlamVjdGVkKGV4Y2VwdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIHJlamVjdGVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG1ha2VTdGFja1RyYWNlTG9uZyhleGNlcHRpb24sIHNlbGYpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0ZWQoZXhjZXB0aW9uKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKG5ld0V4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3RXhjZXB0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3Byb2dyZXNzZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwcm9ncmVzc2VkID09PSBcImZ1bmN0aW9uXCIgPyBwcm9ncmVzc2VkKHZhbHVlKSA6IHZhbHVlO1xuICAgIH1cblxuICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wcm9taXNlRGlzcGF0Y2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKF9mdWxmaWxsZWQodmFsdWUpKTtcbiAgICAgICAgfSwgXCJ3aGVuXCIsIFtmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKF9yZWplY3RlZChleGNlcHRpb24pKTtcbiAgICAgICAgfV0pO1xuICAgIH0pO1xuXG4gICAgLy8gUHJvZ3Jlc3MgcHJvcGFnYXRvciBuZWVkIHRvIGJlIGF0dGFjaGVkIGluIHRoZSBjdXJyZW50IHRpY2suXG4gICAgc2VsZi5wcm9taXNlRGlzcGF0Y2godm9pZCAwLCBcIndoZW5cIiwgW3ZvaWQgMCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBuZXdWYWx1ZTtcbiAgICAgICAgdmFyIHRocmV3ID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IF9wcm9ncmVzc2VkKHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyZXcgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKFEub25lcnJvcikge1xuICAgICAgICAgICAgICAgIFEub25lcnJvcihlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhyZXcpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeShuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGFuIG9ic2VydmVyIG9uIGEgcHJvbWlzZS5cbiAqXG4gKiBHdWFyYW50ZWVzOlxuICpcbiAqIDEuIHRoYXQgZnVsZmlsbGVkIGFuZCByZWplY3RlZCB3aWxsIGJlIGNhbGxlZCBvbmx5IG9uY2UuXG4gKiAyLiB0aGF0IGVpdGhlciB0aGUgZnVsZmlsbGVkIGNhbGxiYWNrIG9yIHRoZSByZWplY3RlZCBjYWxsYmFjayB3aWxsIGJlXG4gKiAgICBjYWxsZWQsIGJ1dCBub3QgYm90aC5cbiAqIDMuIHRoYXQgZnVsZmlsbGVkIGFuZCByZWplY3RlZCB3aWxsIG5vdCBiZSBjYWxsZWQgaW4gdGhpcyB0dXJuLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAgICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSB0byBvYnNlcnZlXG4gKiBAcGFyYW0gZnVsZmlsbGVkICBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCB0aGUgZnVsZmlsbGVkIHZhbHVlXG4gKiBAcGFyYW0gcmVqZWN0ZWQgICBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCB0aGUgcmVqZWN0aW9uIGV4Y2VwdGlvblxuICogQHBhcmFtIHByb2dyZXNzZWQgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGFueSBwcm9ncmVzcyBub3RpZmljYXRpb25zXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgaW52b2tlZCBjYWxsYmFja1xuICovXG5RLndoZW4gPSB3aGVuO1xuZnVuY3Rpb24gd2hlbih2YWx1ZSwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3NlZCkge1xuICAgIHJldHVybiBRKHZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0pO1xufTtcblxuUS50aGVuUmVzb2x2ZSA9IGZ1bmN0aW9uIChwcm9taXNlLCB2YWx1ZSkge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRoZW5SZXNvbHZlKHZhbHVlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW5SZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAoKSB7IHRocm93IHJlYXNvbjsgfSk7XG59O1xuXG5RLnRoZW5SZWplY3QgPSBmdW5jdGlvbiAocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZSkudGhlblJlamVjdChyZWFzb24pO1xufTtcblxuLyoqXG4gKiBJZiBhbiBvYmplY3QgaXMgbm90IGEgcHJvbWlzZSwgaXQgaXMgYXMgXCJuZWFyXCIgYXMgcG9zc2libGUuXG4gKiBJZiBhIHByb21pc2UgaXMgcmVqZWN0ZWQsIGl0IGlzIGFzIFwibmVhclwiIGFzIHBvc3NpYmxlIHRvby5cbiAqIElmIGl04oCZcyBhIGZ1bGZpbGxlZCBwcm9taXNlLCB0aGUgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmVhcmVyLlxuICogSWYgaXTigJlzIGEgZGVmZXJyZWQgcHJvbWlzZSBhbmQgdGhlIGRlZmVycmVkIGhhcyBiZWVuIHJlc29sdmVkLCB0aGVcbiAqIHJlc29sdXRpb24gaXMgXCJuZWFyZXJcIi5cbiAqIEBwYXJhbSBvYmplY3RcbiAqIEByZXR1cm5zIG1vc3QgcmVzb2x2ZWQgKG5lYXJlc3QpIGZvcm0gb2YgdGhlIG9iamVjdFxuICovXG5cbi8vIFhYWCBzaG91bGQgd2UgcmUtZG8gdGhpcz9cblEubmVhcmVyID0gbmVhcmVyO1xuZnVuY3Rpb24gbmVhcmVyKHZhbHVlKSB7XG4gICAgaWYgKGlzUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGluc3BlY3RlZCA9IHZhbHVlLmluc3BlY3QoKTtcbiAgICAgICAgaWYgKGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3RlZC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgcHJvbWlzZS5cbiAqIE90aGVyd2lzZSBpdCBpcyBhIGZ1bGZpbGxlZCB2YWx1ZS5cbiAqL1xuUS5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KG9iamVjdCkgJiZcbiAgICAgICAgdHlwZW9mIG9iamVjdC5wcm9taXNlRGlzcGF0Y2ggPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICB0eXBlb2Ygb2JqZWN0Lmluc3BlY3QgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuUS5pc1Byb21pc2VBbGlrZSA9IGlzUHJvbWlzZUFsaWtlO1xuZnVuY3Rpb24gaXNQcm9taXNlQWxpa2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KG9iamVjdCkgJiYgdHlwZW9mIG9iamVjdC50aGVuID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgcGVuZGluZyBwcm9taXNlLCBtZWFuaW5nIG5vdFxuICogZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuICovXG5RLmlzUGVuZGluZyA9IGlzUGVuZGluZztcbmZ1bmN0aW9uIGlzUGVuZGluZyhvYmplY3QpIHtcbiAgICByZXR1cm4gaXNQcm9taXNlKG9iamVjdCkgJiYgb2JqZWN0Lmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJwZW5kaW5nXCI7XG59XG5cblByb21pc2UucHJvdG90eXBlLmlzUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCkuc3RhdGUgPT09IFwicGVuZGluZ1wiO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSB2YWx1ZSBvciBmdWxmaWxsZWRcbiAqIHByb21pc2UuXG4gKi9cblEuaXNGdWxmaWxsZWQgPSBpc0Z1bGZpbGxlZDtcbmZ1bmN0aW9uIGlzRnVsZmlsbGVkKG9iamVjdCkge1xuICAgIHJldHVybiAhaXNQcm9taXNlKG9iamVjdCkgfHwgb2JqZWN0Lmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpLnN0YXRlID09PSBcImZ1bGZpbGxlZFwiO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSByZWplY3RlZCBwcm9taXNlLlxuICovXG5RLmlzUmVqZWN0ZWQgPSBpc1JlamVjdGVkO1xuZnVuY3Rpb24gaXNSZWplY3RlZChvYmplY3QpIHtcbiAgICByZXR1cm4gaXNQcm9taXNlKG9iamVjdCkgJiYgb2JqZWN0Lmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1JlamVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiO1xufTtcblxuLy8vLyBCRUdJTiBVTkhBTkRMRUQgUkVKRUNUSU9OIFRSQUNLSU5HXG5cbi8vIFRoaXMgcHJvbWlzZSBsaWJyYXJ5IGNvbnN1bWVzIGV4Y2VwdGlvbnMgdGhyb3duIGluIGhhbmRsZXJzIHNvIHRoZXkgY2FuIGJlXG4vLyBoYW5kbGVkIGJ5IGEgc3Vic2VxdWVudCBwcm9taXNlLiAgVGhlIGV4Y2VwdGlvbnMgZ2V0IGFkZGVkIHRvIHRoaXMgYXJyYXkgd2hlblxuLy8gdGhleSBhcmUgY3JlYXRlZCwgYW5kIHJlbW92ZWQgd2hlbiB0aGV5IGFyZSBoYW5kbGVkLiAgTm90ZSB0aGF0IGluIEVTNiBvclxuLy8gc2hpbW1lZCBlbnZpcm9ubWVudHMsIHRoaXMgd291bGQgbmF0dXJhbGx5IGJlIGEgYFNldGAuXG52YXIgdW5oYW5kbGVkUmVhc29ucyA9IFtdO1xudmFyIHVuaGFuZGxlZFJlamVjdGlvbnMgPSBbXTtcbnZhciB1bmhhbmRsZWRSZWFzb25zRGlzcGxheWVkID0gZmFsc2U7XG52YXIgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc3BsYXlVbmhhbmRsZWRSZWFzb25zKCkge1xuICAgIGlmIChcbiAgICAgICAgIXVuaGFuZGxlZFJlYXNvbnNEaXNwbGF5ZWQgJiZcbiAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAhd2luZG93LlRvdWNoICYmXG4gICAgICAgIHdpbmRvdy5jb25zb2xlXG4gICAgKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltRXSBVbmhhbmRsZWQgcmVqZWN0aW9uIHJlYXNvbnMgKHNob3VsZCBiZSBlbXB0eSk6XCIsXG4gICAgICAgICAgICAgICAgICAgICB1bmhhbmRsZWRSZWFzb25zKTtcbiAgICB9XG5cbiAgICB1bmhhbmRsZWRSZWFzb25zRGlzcGxheWVkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbG9nVW5oYW5kbGVkUmVhc29ucygpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuaGFuZGxlZFJlYXNvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJlYXNvbiA9IHVuaGFuZGxlZFJlYXNvbnNbaV07XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVuaGFuZGxlZCByZWplY3Rpb24gcmVhc29uOlwiLCByZWFzb24pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zKCkge1xuICAgIHVuaGFuZGxlZFJlYXNvbnMubGVuZ3RoID0gMDtcbiAgICB1bmhhbmRsZWRSZWplY3Rpb25zLmxlbmd0aCA9IDA7XG4gICAgdW5oYW5kbGVkUmVhc29uc0Rpc3BsYXllZCA9IGZhbHNlO1xuXG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gdHJ1ZTtcblxuICAgICAgICAvLyBTaG93IHVuaGFuZGxlZCByZWplY3Rpb24gcmVhc29ucyBpZiBOb2RlIGV4aXRzIHdpdGhvdXQgaGFuZGxpbmcgYW5cbiAgICAgICAgLy8gb3V0c3RhbmRpbmcgcmVqZWN0aW9uLiAgKE5vdGUgdGhhdCBCcm93c2VyaWZ5IHByZXNlbnRseSBwcm9kdWNlcyBhXG4gICAgICAgIC8vIGBwcm9jZXNzYCBnbG9iYWwgd2l0aG91dCB0aGUgYEV2ZW50RW1pdHRlcmAgYG9uYCBtZXRob2QuKVxuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5vbikge1xuICAgICAgICAgICAgcHJvY2Vzcy5vbihcImV4aXRcIiwgbG9nVW5oYW5kbGVkUmVhc29ucyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyYWNrUmVqZWN0aW9uKHByb21pc2UsIHJlYXNvbikge1xuICAgIGlmICghdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB1bmhhbmRsZWRSZWplY3Rpb25zLnB1c2gocHJvbWlzZSk7XG4gICAgaWYgKHJlYXNvbiAmJiB0eXBlb2YgcmVhc29uLnN0YWNrICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMucHVzaChyZWFzb24uc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaGFuZGxlZFJlYXNvbnMucHVzaChcIihubyBzdGFjaykgXCIgKyByZWFzb24pO1xuICAgIH1cbiAgICBkaXNwbGF5VW5oYW5kbGVkUmVhc29ucygpO1xufVxuXG5mdW5jdGlvbiB1bnRyYWNrUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgICBpZiAoIXRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF0ID0gYXJyYXlfaW5kZXhPZih1bmhhbmRsZWRSZWplY3Rpb25zLCBwcm9taXNlKTtcbiAgICBpZiAoYXQgIT09IC0xKSB7XG4gICAgICAgIHVuaGFuZGxlZFJlamVjdGlvbnMuc3BsaWNlKGF0LCAxKTtcbiAgICAgICAgdW5oYW5kbGVkUmVhc29ucy5zcGxpY2UoYXQsIDEpO1xuICAgIH1cbn1cblxuUS5yZXNldFVuaGFuZGxlZFJlamVjdGlvbnMgPSByZXNldFVuaGFuZGxlZFJlamVjdGlvbnM7XG5cblEuZ2V0VW5oYW5kbGVkUmVhc29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBNYWtlIGEgY29weSBzbyB0aGF0IGNvbnN1bWVycyBjYW4ndCBpbnRlcmZlcmUgd2l0aCBvdXIgaW50ZXJuYWwgc3RhdGUuXG4gICAgcmV0dXJuIHVuaGFuZGxlZFJlYXNvbnMuc2xpY2UoKTtcbn07XG5cblEuc3RvcFVuaGFuZGxlZFJlamVjdGlvblRyYWNraW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLm9uKSB7XG4gICAgICAgIHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoXCJleGl0XCIsIGxvZ1VuaGFuZGxlZFJlYXNvbnMpO1xuICAgIH1cbiAgICB0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMgPSBmYWxzZTtcbn07XG5cbnJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuXG4vLy8vIEVORCBVTkhBTkRMRUQgUkVKRUNUSU9OIFRSQUNLSU5HXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHJlamVjdGVkIHByb21pc2UuXG4gKiBAcGFyYW0gcmVhc29uIHZhbHVlIGRlc2NyaWJpbmcgdGhlIGZhaWx1cmVcbiAqL1xuUS5yZWplY3QgPSByZWplY3Q7XG5mdW5jdGlvbiByZWplY3QocmVhc29uKSB7XG4gICAgdmFyIHJlamVjdGlvbiA9IFByb21pc2Uoe1xuICAgICAgICBcIndoZW5cIjogZnVuY3Rpb24gKHJlamVjdGVkKSB7XG4gICAgICAgICAgICAvLyBub3RlIHRoYXQgdGhlIGVycm9yIGhhcyBiZWVuIGhhbmRsZWRcbiAgICAgICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgICAgICAgIHVudHJhY2tSZWplY3Rpb24odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0ZWQgPyByZWplY3RlZChyZWFzb24pIDogdGhpcztcbiAgICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIGZhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJyZWplY3RlZFwiLCByZWFzb246IHJlYXNvbiB9O1xuICAgIH0pO1xuXG4gICAgLy8gTm90ZSB0aGF0IHRoZSByZWFzb24gaGFzIG5vdCBiZWVuIGhhbmRsZWQuXG4gICAgdHJhY2tSZWplY3Rpb24ocmVqZWN0aW9uLCByZWFzb24pO1xuXG4gICAgcmV0dXJuIHJlamVjdGlvbjtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgZnVsZmlsbGVkIHByb21pc2UgZm9yIGFuIGltbWVkaWF0ZSByZWZlcmVuY2UuXG4gKiBAcGFyYW0gdmFsdWUgaW1tZWRpYXRlIHJlZmVyZW5jZVxuICovXG5RLmZ1bGZpbGwgPSBmdWxmaWxsO1xuZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkge1xuICAgIHJldHVybiBQcm9taXNlKHtcbiAgICAgICAgXCJ3aGVuXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJnZXRcIjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVtuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJzZXRcIjogZnVuY3Rpb24gKG5hbWUsIHJocykge1xuICAgICAgICAgICAgdmFsdWVbbmFtZV0gPSByaHM7XG4gICAgICAgIH0sXG4gICAgICAgIFwiZGVsZXRlXCI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBkZWxldGUgdmFsdWVbbmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIFwicG9zdFwiOiBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgICAgICAgICAgLy8gTWFyayBNaWxsZXIgcHJvcG9zZXMgdGhhdCBwb3N0IHdpdGggbm8gbmFtZSBzaG91bGQgYXBwbHkgYVxuICAgICAgICAgICAgLy8gcHJvbWlzZWQgZnVuY3Rpb24uXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gbnVsbCB8fCBuYW1lID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW25hbWVdLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJhcHBseVwiOiBmdW5jdGlvbiAodGhpc3AsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh0aGlzcCwgYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgIFwia2V5c1wiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0X2tleXModmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgdm9pZCAwLCBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJmdWxmaWxsZWRcIiwgdmFsdWU6IHZhbHVlIH07XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlbmFibGVzIHRvIFEgcHJvbWlzZXMuXG4gKiBAcGFyYW0gcHJvbWlzZSB0aGVuYWJsZSBwcm9taXNlXG4gKiBAcmV0dXJucyBhIFEgcHJvbWlzZVxuICovXG5mdW5jdGlvbiBjb2VyY2UocHJvbWlzZSkge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCwgZGVmZXJyZWQubm90aWZ5KTtcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuXG4vKipcbiAqIEFubm90YXRlcyBhbiBvYmplY3Qgc3VjaCB0aGF0IGl0IHdpbGwgbmV2ZXIgYmVcbiAqIHRyYW5zZmVycmVkIGF3YXkgZnJvbSB0aGlzIHByb2Nlc3Mgb3ZlciBhbnkgcHJvbWlzZVxuICogY29tbXVuaWNhdGlvbiBjaGFubmVsLlxuICogQHBhcmFtIG9iamVjdFxuICogQHJldHVybnMgcHJvbWlzZSBhIHdyYXBwaW5nIG9mIHRoYXQgb2JqZWN0IHRoYXRcbiAqIGFkZGl0aW9uYWxseSByZXNwb25kcyB0byB0aGUgXCJpc0RlZlwiIG1lc3NhZ2VcbiAqIHdpdGhvdXQgYSByZWplY3Rpb24uXG4gKi9cblEubWFzdGVyID0gbWFzdGVyO1xuZnVuY3Rpb24gbWFzdGVyKG9iamVjdCkge1xuICAgIHJldHVybiBQcm9taXNlKHtcbiAgICAgICAgXCJpc0RlZlwiOiBmdW5jdGlvbiAoKSB7fVxuICAgIH0sIGZ1bmN0aW9uIGZhbGxiYWNrKG9wLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaChvYmplY3QsIG9wLCBhcmdzKTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBRKG9iamVjdCkuaW5zcGVjdCgpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFNwcmVhZHMgdGhlIHZhbHVlcyBvZiBhIHByb21pc2VkIGFycmF5IG9mIGFyZ3VtZW50cyBpbnRvIHRoZVxuICogZnVsZmlsbG1lbnQgY2FsbGJhY2suXG4gKiBAcGFyYW0gZnVsZmlsbGVkIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdmFyaWFkaWMgYXJndW1lbnRzIGZyb20gdGhlXG4gKiBwcm9taXNlZCBhcnJheVxuICogQHBhcmFtIHJlamVjdGVkIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGV4Y2VwdGlvbiBpZiB0aGUgcHJvbWlzZVxuICogaXMgcmVqZWN0ZWQuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgb3IgdGhyb3duIGV4Y2VwdGlvbiBvZlxuICogZWl0aGVyIGNhbGxiYWNrLlxuICovXG5RLnNwcmVhZCA9IHNwcmVhZDtcbmZ1bmN0aW9uIHNwcmVhZCh2YWx1ZSwgZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICAgIHJldHVybiBRKHZhbHVlKS5zcHJlYWQoZnVsZmlsbGVkLCByZWplY3RlZCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnNwcmVhZCA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsKCkudGhlbihmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZC5hcHBseSh2b2lkIDAsIGFycmF5KTtcbiAgICB9LCByZWplY3RlZCk7XG59O1xuXG4vKipcbiAqIFRoZSBhc3luYyBmdW5jdGlvbiBpcyBhIGRlY29yYXRvciBmb3IgZ2VuZXJhdG9yIGZ1bmN0aW9ucywgdHVybmluZ1xuICogdGhlbSBpbnRvIGFzeW5jaHJvbm91cyBnZW5lcmF0b3JzLiAgQWx0aG91Z2ggZ2VuZXJhdG9ycyBhcmUgb25seSBwYXJ0XG4gKiBvZiB0aGUgbmV3ZXN0IEVDTUFTY3JpcHQgNiBkcmFmdHMsIHRoaXMgY29kZSBkb2VzIG5vdCBjYXVzZSBzeW50YXhcbiAqIGVycm9ycyBpbiBvbGRlciBlbmdpbmVzLiAgVGhpcyBjb2RlIHNob3VsZCBjb250aW51ZSB0byB3b3JrIGFuZCB3aWxsXG4gKiBpbiBmYWN0IGltcHJvdmUgb3ZlciB0aW1lIGFzIHRoZSBsYW5ndWFnZSBpbXByb3Zlcy5cbiAqXG4gKiBFUzYgZ2VuZXJhdG9ycyBhcmUgY3VycmVudGx5IHBhcnQgb2YgVjggdmVyc2lvbiAzLjE5IHdpdGggdGhlXG4gKiAtLWhhcm1vbnktZ2VuZXJhdG9ycyBydW50aW1lIGZsYWcgZW5hYmxlZC4gIFNwaWRlck1vbmtleSBoYXMgaGFkIHRoZW1cbiAqIGZvciBsb25nZXIsIGJ1dCB1bmRlciBhbiBvbGRlciBQeXRob24taW5zcGlyZWQgZm9ybS4gIFRoaXMgZnVuY3Rpb25cbiAqIHdvcmtzIG9uIGJvdGgga2luZHMgb2YgZ2VuZXJhdG9ycy5cbiAqXG4gKiBEZWNvcmF0ZXMgYSBnZW5lcmF0b3IgZnVuY3Rpb24gc3VjaCB0aGF0OlxuICogIC0gaXQgbWF5IHlpZWxkIHByb21pc2VzXG4gKiAgLSBleGVjdXRpb24gd2lsbCBjb250aW51ZSB3aGVuIHRoYXQgcHJvbWlzZSBpcyBmdWxmaWxsZWRcbiAqICAtIHRoZSB2YWx1ZSBvZiB0aGUgeWllbGQgZXhwcmVzc2lvbiB3aWxsIGJlIHRoZSBmdWxmaWxsZWQgdmFsdWVcbiAqICAtIGl0IHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlICh3aGVuIHRoZSBnZW5lcmF0b3JcbiAqICAgIHN0b3BzIGl0ZXJhdGluZylcbiAqICAtIHRoZSBkZWNvcmF0ZWQgZnVuY3Rpb24gcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqICAgIG9mIHRoZSBnZW5lcmF0b3Igb3IgdGhlIGZpcnN0IHJlamVjdGVkIHByb21pc2UgYW1vbmcgdGhvc2VcbiAqICAgIHlpZWxkZWQuXG4gKiAgLSBpZiBhbiBlcnJvciBpcyB0aHJvd24gaW4gdGhlIGdlbmVyYXRvciwgaXQgcHJvcGFnYXRlcyB0aHJvdWdoXG4gKiAgICBldmVyeSBmb2xsb3dpbmcgeWllbGQgdW50aWwgaXQgaXMgY2F1Z2h0LCBvciB1bnRpbCBpdCBlc2NhcGVzXG4gKiAgICB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGFsdG9nZXRoZXIsIGFuZCBpcyB0cmFuc2xhdGVkIGludG8gYVxuICogICAgcmVqZWN0aW9uIGZvciB0aGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGUgZGVjb3JhdGVkIGdlbmVyYXRvci5cbiAqL1xuUS5hc3luYyA9IGFzeW5jO1xuZnVuY3Rpb24gYXN5bmMobWFrZUdlbmVyYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHdoZW4gdmVyYiBpcyBcInNlbmRcIiwgYXJnIGlzIGEgdmFsdWVcbiAgICAgICAgLy8gd2hlbiB2ZXJiIGlzIFwidGhyb3dcIiwgYXJnIGlzIGFuIGV4Y2VwdGlvblxuICAgICAgICBmdW5jdGlvbiBjb250aW51ZXIodmVyYiwgYXJnKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKGhhc0VTNkdlbmVyYXRvcnMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0b3JbdmVyYl0oYXJnKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2hlbihyZXN1bHQudmFsdWUsIGNhbGxiYWNrLCBlcnJiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBSZW1vdmUgdGhpcyBjYXNlIHdoZW4gU00gZG9lcyBFUzYgZ2VuZXJhdG9ycy5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0b3JbdmVyYl0oYXJnKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RvcEl0ZXJhdGlvbihleGNlcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhjZXB0aW9uLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB3aGVuKHJlc3VsdCwgY2FsbGJhY2ssIGVycmJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBnZW5lcmF0b3IgPSBtYWtlR2VuZXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGNvbnRpbnVlci5iaW5kKGNvbnRpbnVlciwgXCJuZXh0XCIpO1xuICAgICAgICB2YXIgZXJyYmFjayA9IGNvbnRpbnVlci5iaW5kKGNvbnRpbnVlciwgXCJ0aHJvd1wiKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBUaGUgc3Bhd24gZnVuY3Rpb24gaXMgYSBzbWFsbCB3cmFwcGVyIGFyb3VuZCBhc3luYyB0aGF0IGltbWVkaWF0ZWx5XG4gKiBjYWxscyB0aGUgZ2VuZXJhdG9yIGFuZCBhbHNvIGVuZHMgdGhlIHByb21pc2UgY2hhaW4sIHNvIHRoYXQgYW55XG4gKiB1bmhhbmRsZWQgZXJyb3JzIGFyZSB0aHJvd24gaW5zdGVhZCBvZiBmb3J3YXJkZWQgdG8gdGhlIGVycm9yXG4gKiBoYW5kbGVyLiBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIGl0J3MgZXh0cmVtZWx5IGNvbW1vbiB0byBydW5cbiAqIGdlbmVyYXRvcnMgYXQgdGhlIHRvcC1sZXZlbCB0byB3b3JrIHdpdGggbGlicmFyaWVzLlxuICovXG5RLnNwYXduID0gc3Bhd247XG5mdW5jdGlvbiBzcGF3bihtYWtlR2VuZXJhdG9yKSB7XG4gICAgUS5kb25lKFEuYXN5bmMobWFrZUdlbmVyYXRvcikoKSk7XG59XG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBpbnRlcmZhY2Ugb25jZSBFUzYgZ2VuZXJhdG9ycyBhcmUgaW4gU3BpZGVyTW9ua2V5LlxuLyoqXG4gKiBUaHJvd3MgYSBSZXR1cm5WYWx1ZSBleGNlcHRpb24gdG8gc3RvcCBhbiBhc3luY2hyb25vdXMgZ2VuZXJhdG9yLlxuICpcbiAqIFRoaXMgaW50ZXJmYWNlIGlzIGEgc3RvcC1nYXAgbWVhc3VyZSB0byBzdXBwb3J0IGdlbmVyYXRvciByZXR1cm5cbiAqIHZhbHVlcyBpbiBvbGRlciBGaXJlZm94L1NwaWRlck1vbmtleS4gIEluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBFUzZcbiAqIGdlbmVyYXRvcnMgbGlrZSBDaHJvbWl1bSAyOSwganVzdCB1c2UgXCJyZXR1cm5cIiBpbiB5b3VyIGdlbmVyYXRvclxuICogZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgcmV0dXJuIHZhbHVlIGZvciB0aGUgc3Vycm91bmRpbmcgZ2VuZXJhdG9yXG4gKiBAdGhyb3dzIFJldHVyblZhbHVlIGV4Y2VwdGlvbiB3aXRoIHRoZSB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKiAvLyBFUzYgc3R5bGVcbiAqIFEuYXN5bmMoZnVuY3Rpb24qICgpIHtcbiAqICAgICAgdmFyIGZvbyA9IHlpZWxkIGdldEZvb1Byb21pc2UoKTtcbiAqICAgICAgdmFyIGJhciA9IHlpZWxkIGdldEJhclByb21pc2UoKTtcbiAqICAgICAgcmV0dXJuIGZvbyArIGJhcjtcbiAqIH0pXG4gKiAvLyBPbGRlciBTcGlkZXJNb25rZXkgc3R5bGVcbiAqIFEuYXN5bmMoZnVuY3Rpb24gKCkge1xuICogICAgICB2YXIgZm9vID0geWllbGQgZ2V0Rm9vUHJvbWlzZSgpO1xuICogICAgICB2YXIgYmFyID0geWllbGQgZ2V0QmFyUHJvbWlzZSgpO1xuICogICAgICBRLnJldHVybihmb28gKyBiYXIpO1xuICogfSlcbiAqL1xuUVtcInJldHVyblwiXSA9IF9yZXR1cm47XG5mdW5jdGlvbiBfcmV0dXJuKHZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IFFSZXR1cm5WYWx1ZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIHByb21pc2VkIGZ1bmN0aW9uIGRlY29yYXRvciBlbnN1cmVzIHRoYXQgYW55IHByb21pc2UgYXJndW1lbnRzXG4gKiBhcmUgc2V0dGxlZCBhbmQgcGFzc2VkIGFzIHZhbHVlcyAoYHRoaXNgIGlzIGFsc28gc2V0dGxlZCBhbmQgcGFzc2VkXG4gKiBhcyBhIHZhbHVlKS4gIEl0IHdpbGwgYWxzbyBlbnN1cmUgdGhhdCB0aGUgcmVzdWx0IG9mIGEgZnVuY3Rpb24gaXNcbiAqIGFsd2F5cyBhIHByb21pc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIHZhciBhZGQgPSBRLnByb21pc2VkKGZ1bmN0aW9uIChhLCBiKSB7XG4gKiAgICAgcmV0dXJuIGEgKyBiO1xuICogfSk7XG4gKiBhZGQoUShhKSwgUShCKSk7XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGRlY29yYXRlXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBoYXMgYmVlbiBkZWNvcmF0ZWQuXG4gKi9cblEucHJvbWlzZWQgPSBwcm9taXNlZDtcbmZ1bmN0aW9uIHByb21pc2VkKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNwcmVhZChbdGhpcywgYWxsKGFyZ3VtZW50cyldLCBmdW5jdGlvbiAoc2VsZiwgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG4vKipcbiAqIHNlbmRzIGEgbWVzc2FnZSB0byBhIHZhbHVlIGluIGEgZnV0dXJlIHR1cm5cbiAqIEBwYXJhbSBvYmplY3QqIHRoZSByZWNpcGllbnRcbiAqIEBwYXJhbSBvcCB0aGUgbmFtZSBvZiB0aGUgbWVzc2FnZSBvcGVyYXRpb24sIGUuZy4sIFwid2hlblwiLFxuICogQHBhcmFtIGFyZ3MgZnVydGhlciBhcmd1bWVudHMgdG8gYmUgZm9yd2FyZGVkIHRvIHRoZSBvcGVyYXRpb25cbiAqIEByZXR1cm5zIHJlc3VsdCB7UHJvbWlzZX0gYSBwcm9taXNlIGZvciB0aGUgcmVzdWx0IG9mIHRoZSBvcGVyYXRpb25cbiAqL1xuUS5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuZnVuY3Rpb24gZGlzcGF0Y2gob2JqZWN0LCBvcCwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2gob3AsIGFyZ3MpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChvcCwgYXJncykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wcm9taXNlRGlzcGF0Y2goZGVmZXJyZWQucmVzb2x2ZSwgb3AsIGFyZ3MpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIHByb3BlcnR5IHRvIGdldFxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcHJvcGVydHkgdmFsdWVcbiAqL1xuUS5nZXQgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiZ2V0XCIsIFtrZXldKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImdldFwiLCBba2V5XSk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciBvYmplY3Qgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgcHJvcGVydHkgdG8gc2V0XG4gKiBAcGFyYW0gdmFsdWUgICAgIG5ldyB2YWx1ZSBvZiBwcm9wZXJ0eVxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cblEuc2V0ID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJzZXRcIiwgW2tleSwgdmFsdWVdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJzZXRcIiwgW2tleSwgdmFsdWVdKTtcbn07XG5cbi8qKlxuICogRGVsZXRlcyBhIHByb3BlcnR5IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIHByb3BlcnR5IHRvIGRlbGV0ZVxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cblEuZGVsID0gLy8gWFhYIGxlZ2FjeVxuUVtcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJkZWxldGVcIiwgW2tleV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZGVsID0gLy8gWFhYIGxlZ2FjeVxuUHJvbWlzZS5wcm90b3R5cGVbXCJkZWxldGVcIl0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJkZWxldGVcIiwgW2tleV0pO1xufTtcblxuLyoqXG4gKiBJbnZva2VzIGEgbWV0aG9kIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIG1ldGhvZCB0byBpbnZva2VcbiAqIEBwYXJhbSB2YWx1ZSAgICAgYSB2YWx1ZSB0byBwb3N0LCB0eXBpY2FsbHkgYW4gYXJyYXkgb2ZcbiAqICAgICAgICAgICAgICAgICAgaW52b2NhdGlvbiBhcmd1bWVudHMgZm9yIHByb21pc2VzIHRoYXRcbiAqICAgICAgICAgICAgICAgICAgYXJlIHVsdGltYXRlbHkgYmFja2VkIHdpdGggYHJlc29sdmVgIHZhbHVlcyxcbiAqICAgICAgICAgICAgICAgICAgYXMgb3Bwb3NlZCB0byB0aG9zZSBiYWNrZWQgd2l0aCBVUkxzXG4gKiAgICAgICAgICAgICAgICAgIHdoZXJlaW4gdGhlIHBvc3RlZCB2YWx1ZSBjYW4gYmUgYW55XG4gKiAgICAgICAgICAgICAgICAgIEpTT04gc2VyaWFsaXphYmxlIG9iamVjdC5cbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG4vLyBib3VuZCBsb2NhbGx5IGJlY2F1c2UgaXQgaXMgdXNlZCBieSBvdGhlciBtZXRob2RzXG5RLm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5RLnBvc3QgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFyZ3NdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5Qcm9taXNlLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFyZ3NdKTtcbn07XG5cbi8qKlxuICogSW52b2tlcyBhIG1ldGhvZCBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBtZXRob2QgdG8gaW52b2tlXG4gKiBAcGFyYW0gLi4uYXJncyAgIGFycmF5IG9mIGludm9jYXRpb24gYXJndW1lbnRzXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuUS5zZW5kID0gLy8gWFhYIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgcGFybGFuY2VcblEubWNhbGwgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUS5pbnZva2UgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMildKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNlbmQgPSAvLyBYWFggTWFyayBNaWxsZXIncyBwcm9wb3NlZCBwYXJsYW5jZVxuUHJvbWlzZS5wcm90b3R5cGUubWNhbGwgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUHJvbWlzZS5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSldKTtcbn07XG5cbi8qKlxuICogQXBwbGllcyB0aGUgcHJvbWlzZWQgZnVuY3Rpb24gaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgZnVuY3Rpb25cbiAqIEBwYXJhbSBhcmdzICAgICAgYXJyYXkgb2YgYXBwbGljYXRpb24gYXJndW1lbnRzXG4gKi9cblEuZmFwcGx5ID0gZnVuY3Rpb24gKG9iamVjdCwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcmdzXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mYXBwbHkgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJnc10pO1xufTtcblxuLyoqXG4gKiBDYWxscyB0aGUgcHJvbWlzZWQgZnVuY3Rpb24gaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgZnVuY3Rpb25cbiAqIEBwYXJhbSAuLi5hcmdzICAgYXJyYXkgb2YgYXBwbGljYXRpb24gYXJndW1lbnRzXG4gKi9cblFbXCJ0cnlcIl0gPVxuUS5mY2FsbCA9IGZ1bmN0aW9uIChvYmplY3QgLyogLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSldKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZjYWxsID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcnJheV9zbGljZShhcmd1bWVudHMpXSk7XG59O1xuXG4vKipcbiAqIEJpbmRzIHRoZSBwcm9taXNlZCBmdW5jdGlvbiwgdHJhbnNmb3JtaW5nIHJldHVybiB2YWx1ZXMgaW50byBhIGZ1bGZpbGxlZFxuICogcHJvbWlzZSBhbmQgdGhyb3duIGVycm9ycyBpbnRvIGEgcmVqZWN0ZWQgb25lLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBmdW5jdGlvblxuICogQHBhcmFtIC4uLmFyZ3MgICBhcnJheSBvZiBhcHBsaWNhdGlvbiBhcmd1bWVudHNcbiAqL1xuUS5mYmluZCA9IGZ1bmN0aW9uIChvYmplY3QgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgcHJvbWlzZSA9IFEob2JqZWN0KTtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZib3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UuZGlzcGF0Y2goXCJhcHBseVwiLCBbXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSlcbiAgICAgICAgXSk7XG4gICAgfTtcbn07XG5Qcm9taXNlLnByb3RvdHlwZS5mYmluZCA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZib3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UuZGlzcGF0Y2goXCJhcHBseVwiLCBbXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSlcbiAgICAgICAgXSk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogUmVxdWVzdHMgdGhlIG5hbWVzIG9mIHRoZSBvd25lZCBwcm9wZXJ0aWVzIG9mIGEgcHJvbWlzZWRcbiAqIG9iamVjdCBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIGtleXMgb2YgdGhlIGV2ZW50dWFsbHkgc2V0dGxlZCBvYmplY3RcbiAqL1xuUS5rZXlzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJrZXlzXCIsIFtdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJrZXlzXCIsIFtdKTtcbn07XG5cbi8qKlxuICogVHVybnMgYW4gYXJyYXkgb2YgcHJvbWlzZXMgaW50byBhIHByb21pc2UgZm9yIGFuIGFycmF5LiAgSWYgYW55IG9mXG4gKiB0aGUgcHJvbWlzZXMgZ2V0cyByZWplY3RlZCwgdGhlIHdob2xlIGFycmF5IGlzIHJlamVjdGVkIGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtBcnJheSp9IGFuIGFycmF5IChvciBwcm9taXNlIGZvciBhbiBhcnJheSkgb2YgdmFsdWVzIChvclxuICogcHJvbWlzZXMgZm9yIHZhbHVlcylcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzXG4gKi9cbi8vIEJ5IE1hcmsgTWlsbGVyXG4vLyBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1zdHJhd21hbjpjb25jdXJyZW5jeSZyZXY9MTMwODc3NjUyMSNhbGxmdWxmaWxsZWRcblEuYWxsID0gYWxsO1xuZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIHdoZW4ocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICB2YXIgY291bnREb3duID0gMDtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgYXJyYXlfcmVkdWNlKHByb21pc2VzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBwcm9taXNlLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHNuYXBzaG90O1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGlzUHJvbWlzZShwcm9taXNlKSAmJlxuICAgICAgICAgICAgICAgIChzbmFwc2hvdCA9IHByb21pc2UuaW5zcGVjdCgpKS5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXNbaW5kZXhdID0gc25hcHNob3QudmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICsrY291bnREb3duO1xuICAgICAgICAgICAgICAgIHdoZW4oXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1jb3VudERvd24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHByb21pc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeSh7IGluZGV4OiBpbmRleCwgdmFsdWU6IHByb2dyZXNzIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdm9pZCAwKTtcbiAgICAgICAgaWYgKGNvdW50RG93biA9PT0gMCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBXYWl0cyBmb3IgYWxsIHByb21pc2VzIHRvIGJlIHNldHRsZWQsIGVpdGhlciBmdWxmaWxsZWQgb3JcbiAqIHJlamVjdGVkLiAgVGhpcyBpcyBkaXN0aW5jdCBmcm9tIGBhbGxgIHNpbmNlIHRoYXQgd291bGQgc3RvcFxuICogd2FpdGluZyBhdCB0aGUgZmlyc3QgcmVqZWN0aW9uLiAgVGhlIHByb21pc2UgcmV0dXJuZWQgYnlcbiAqIGBhbGxSZXNvbHZlZGAgd2lsbCBuZXZlciBiZSByZWplY3RlZC5cbiAqIEBwYXJhbSBwcm9taXNlcyBhIHByb21pc2UgZm9yIGFuIGFycmF5IChvciBhbiBhcnJheSkgb2YgcHJvbWlzZXNcbiAqIChvciB2YWx1ZXMpXG4gKiBAcmV0dXJuIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgcHJvbWlzZXNcbiAqL1xuUS5hbGxSZXNvbHZlZCA9IGRlcHJlY2F0ZShhbGxSZXNvbHZlZCwgXCJhbGxSZXNvbHZlZFwiLCBcImFsbFNldHRsZWRcIik7XG5mdW5jdGlvbiBhbGxSZXNvbHZlZChwcm9taXNlcykge1xuICAgIHJldHVybiB3aGVuKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgcHJvbWlzZXMgPSBhcnJheV9tYXAocHJvbWlzZXMsIFEpO1xuICAgICAgICByZXR1cm4gd2hlbihhbGwoYXJyYXlfbWFwKHByb21pc2VzLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHdoZW4ocHJvbWlzZSwgbm9vcCwgbm9vcCk7XG4gICAgICAgIH0pKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VzO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuYWxsUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFsbFJlc29sdmVkKHRoaXMpO1xufTtcblxuLyoqXG4gKiBAc2VlIFByb21pc2UjYWxsU2V0dGxlZFxuICovXG5RLmFsbFNldHRsZWQgPSBhbGxTZXR0bGVkO1xuZnVuY3Rpb24gYWxsU2V0dGxlZChwcm9taXNlcykge1xuICAgIHJldHVybiBRKHByb21pc2VzKS5hbGxTZXR0bGVkKCk7XG59XG5cbi8qKlxuICogVHVybnMgYW4gYXJyYXkgb2YgcHJvbWlzZXMgaW50byBhIHByb21pc2UgZm9yIGFuIGFycmF5IG9mIHRoZWlyIHN0YXRlcyAoYXNcbiAqIHJldHVybmVkIGJ5IGBpbnNwZWN0YCkgd2hlbiB0aGV5IGhhdmUgYWxsIHNldHRsZWQuXG4gKiBAcGFyYW0ge0FycmF5W0FueSpdfSB2YWx1ZXMgYW4gYXJyYXkgKG9yIHByb21pc2UgZm9yIGFuIGFycmF5KSBvZiB2YWx1ZXMgKG9yXG4gKiBwcm9taXNlcyBmb3IgdmFsdWVzKVxuICogQHJldHVybnMge0FycmF5W1N0YXRlXX0gYW4gYXJyYXkgb2Ygc3RhdGVzIGZvciB0aGUgcmVzcGVjdGl2ZSB2YWx1ZXMuXG4gKi9cblByb21pc2UucHJvdG90eXBlLmFsbFNldHRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgcmV0dXJuIGFsbChhcnJheV9tYXAocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gUShwcm9taXNlKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlZ2FyZGxlc3MoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UuaW5zcGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihyZWdhcmRsZXNzLCByZWdhcmRsZXNzKTtcbiAgICAgICAgfSkpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDYXB0dXJlcyB0aGUgZmFpbHVyZSBvZiBhIHByb21pc2UsIGdpdmluZyBhbiBvcG9ydHVuaXR5IHRvIHJlY292ZXJcbiAqIHdpdGggYSBjYWxsYmFjay4gIElmIHRoZSBnaXZlbiBwcm9taXNlIGlzIGZ1bGZpbGxlZCwgdGhlIHJldHVybmVkXG4gKiBwcm9taXNlIGlzIGZ1bGZpbGxlZC5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZSBmb3Igc29tZXRoaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byBmdWxmaWxsIHRoZSByZXR1cm5lZCBwcm9taXNlIGlmIHRoZVxuICogZ2l2ZW4gcHJvbWlzZSBpcyByZWplY3RlZFxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYWxsYmFja1xuICovXG5RLmZhaWwgPSAvLyBYWFggbGVnYWN5XG5RW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCByZWplY3RlZCkge1xuICAgIHJldHVybiBRKG9iamVjdCkudGhlbih2b2lkIDAsIHJlamVjdGVkKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZhaWwgPSAvLyBYWFggbGVnYWN5XG5Qcm9taXNlLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIHJlamVjdGVkKTtcbn07XG5cbi8qKlxuICogQXR0YWNoZXMgYSBsaXN0ZW5lciB0aGF0IGNhbiByZXNwb25kIHRvIHByb2dyZXNzIG5vdGlmaWNhdGlvbnMgZnJvbSBhXG4gKiBwcm9taXNlJ3Mgb3JpZ2luYXRpbmcgZGVmZXJyZWQuIFRoaXMgbGlzdGVuZXIgcmVjZWl2ZXMgdGhlIGV4YWN0IGFyZ3VtZW50c1xuICogcGFzc2VkIHRvIGBgZGVmZXJyZWQubm90aWZ5YGAuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2UgZm9yIHNvbWV0aGluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gcmVjZWl2ZSBhbnkgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uc1xuICogQHJldHVybnMgdGhlIGdpdmVuIHByb21pc2UsIHVuY2hhbmdlZFxuICovXG5RLnByb2dyZXNzID0gcHJvZ3Jlc3M7XG5mdW5jdGlvbiBwcm9ncmVzcyhvYmplY3QsIHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLnRoZW4odm9pZCAwLCB2b2lkIDAsIHByb2dyZXNzZWQpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5wcm9ncmVzcyA9IGZ1bmN0aW9uIChwcm9ncmVzc2VkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIHZvaWQgMCwgcHJvZ3Jlc3NlZCk7XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGFuIG9wcG9ydHVuaXR5IHRvIG9ic2VydmUgdGhlIHNldHRsaW5nIG9mIGEgcHJvbWlzZSxcbiAqIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgcHJvbWlzZSBpcyBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQuICBGb3J3YXJkc1xuICogdGhlIHJlc29sdXRpb24gdG8gdGhlIHJldHVybmVkIHByb21pc2Ugd2hlbiB0aGUgY2FsbGJhY2sgaXMgZG9uZS5cbiAqIFRoZSBjYWxsYmFjayBjYW4gcmV0dXJuIGEgcHJvbWlzZSB0byBkZWZlciBjb21wbGV0aW9uLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byBvYnNlcnZlIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlblxuICogcHJvbWlzZSwgdGFrZXMgbm8gYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSB3aGVuXG4gKiBgYGZpbmBgIGlzIGRvbmUuXG4gKi9cblEuZmluID0gLy8gWFhYIGxlZ2FjeVxuUVtcImZpbmFsbHlcIl0gPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIHJldHVybiBRKG9iamVjdClbXCJmaW5hbGx5XCJdKGNhbGxiYWNrKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZpbiA9IC8vIFhYWCBsZWdhY3lcblByb21pc2UucHJvdG90eXBlW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gUShjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gVE9ETyBhdHRlbXB0IHRvIHJlY3ljbGUgdGhlIHJlamVjdGlvbiB3aXRoIFwidGhpc1wiLlxuICAgICAgICByZXR1cm4gY2FsbGJhY2suZmNhbGwoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFRlcm1pbmF0ZXMgYSBjaGFpbiBvZiBwcm9taXNlcywgZm9yY2luZyByZWplY3Rpb25zIHRvIGJlXG4gKiB0aHJvd24gYXMgZXhjZXB0aW9ucy5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZSBhdCB0aGUgZW5kIG9mIGEgY2hhaW4gb2YgcHJvbWlzZXNcbiAqIEByZXR1cm5zIG5vdGhpbmdcbiAqL1xuUS5kb25lID0gZnVuY3Rpb24gKG9iamVjdCwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRvbmUoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykge1xuICAgIHZhciBvblVuaGFuZGxlZEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIC8vIGZvcndhcmQgdG8gYSBmdXR1cmUgdHVybiBzbyB0aGF0IGBgd2hlbmBgXG4gICAgICAgIC8vIGRvZXMgbm90IGNhdGNoIGl0IGFuZCB0dXJuIGl0IGludG8gYSByZWplY3Rpb24uXG4gICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG1ha2VTdGFja1RyYWNlTG9uZyhlcnJvciwgcHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAoUS5vbmVycm9yKSB7XG4gICAgICAgICAgICAgICAgUS5vbmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBgbmV4dFRpY2tgaW5nIHZpYSBhbiB1bm5lY2Vzc2FyeSBgd2hlbmAuXG4gICAgdmFyIHByb21pc2UgPSBmdWxmaWxsZWQgfHwgcmVqZWN0ZWQgfHwgcHJvZ3Jlc3MgP1xuICAgICAgICB0aGlzLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIDpcbiAgICAgICAgdGhpcztcblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICYmIHByb2Nlc3MuZG9tYWluKSB7XG4gICAgICAgIG9uVW5oYW5kbGVkRXJyb3IgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKG9uVW5oYW5kbGVkRXJyb3IpO1xuICAgIH1cblxuICAgIHByb21pc2UudGhlbih2b2lkIDAsIG9uVW5oYW5kbGVkRXJyb3IpO1xufTtcblxuLyoqXG4gKiBDYXVzZXMgYSBwcm9taXNlIHRvIGJlIHJlamVjdGVkIGlmIGl0IGRvZXMgbm90IGdldCBmdWxmaWxsZWQgYmVmb3JlXG4gKiBzb21lIG1pbGxpc2Vjb25kcyB0aW1lIG91dC5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbGxpc2Vjb25kcyB0aW1lb3V0XG4gKiBAcGFyYW0ge1N0cmluZ30gY3VzdG9tIGVycm9yIG1lc3NhZ2UgKG9wdGlvbmFsKVxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSBpZiBpdCBpc1xuICogZnVsZmlsbGVkIGJlZm9yZSB0aGUgdGltZW91dCwgb3RoZXJ3aXNlIHJlamVjdGVkLlxuICovXG5RLnRpbWVvdXQgPSBmdW5jdGlvbiAob2JqZWN0LCBtcywgbWVzc2FnZSkge1xuICAgIHJldHVybiBRKG9iamVjdCkudGltZW91dChtcywgbWVzc2FnZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zLCBtZXNzYWdlKSB7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB2YXIgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChuZXcgRXJyb3IobWVzc2FnZSB8fCBcIlRpbWVkIG91dCBhZnRlciBcIiArIG1zICsgXCIgbXNcIikpO1xuICAgIH0sIG1zKTtcblxuICAgIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUodmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChleGNlcHRpb24pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChleGNlcHRpb24pO1xuICAgIH0sIGRlZmVycmVkLm5vdGlmeSk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBnaXZlbiB2YWx1ZSAob3IgcHJvbWlzZWQgdmFsdWUpLCBzb21lXG4gKiBtaWxsaXNlY29uZHMgYWZ0ZXIgaXQgcmVzb2x2ZWQuIFBhc3NlcyByZWplY3Rpb25zIGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge051bWJlcn0gbWlsbGlzZWNvbmRzXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlIGFmdGVyIG1pbGxpc2Vjb25kc1xuICogdGltZSBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZS5cbiAqIElmIHRoZSBnaXZlbiBwcm9taXNlIHJlamVjdHMsIHRoYXQgaXMgcGFzc2VkIGltbWVkaWF0ZWx5LlxuICovXG5RLmRlbGF5ID0gZnVuY3Rpb24gKG9iamVjdCwgdGltZW91dCkge1xuICAgIGlmICh0aW1lb3V0ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGltZW91dCA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gUShvYmplY3QpLmRlbGF5KHRpbWVvdXQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUGFzc2VzIGEgY29udGludWF0aW9uIHRvIGEgTm9kZSBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkIHdpdGggdGhlIGdpdmVuXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgYXMgYW4gYXJyYXksIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqXG4gKiAgICAgIFEubmZhcHBseShGUy5yZWFkRmlsZSwgW19fZmlsZW5hbWVdKVxuICogICAgICAudGhlbihmdW5jdGlvbiAoY29udGVudCkge1xuICogICAgICB9KVxuICpcbiAqL1xuUS5uZmFwcGx5ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEoY2FsbGJhY2spLm5mYXBwbHkoYXJncyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmFwcGx5ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3MpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBQYXNzZXMgYSBjb250aW51YXRpb24gdG8gYSBOb2RlIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAqIGFyZ3VtZW50cyBwcm92aWRlZCBpbmRpdmlkdWFsbHksIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIEBleGFtcGxlXG4gKiBRLm5mY2FsbChGUy5yZWFkRmlsZSwgX19maWxlbmFtZSlcbiAqIC50aGVuKGZ1bmN0aW9uIChjb250ZW50KSB7XG4gKiB9KVxuICpcbiAqL1xuUS5uZmNhbGwgPSBmdW5jdGlvbiAoY2FsbGJhY2sgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIFEoY2FsbGJhY2spLm5mYXBwbHkoYXJncyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmNhbGwgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFdyYXBzIGEgTm9kZUpTIGNvbnRpbnVhdGlvbiBwYXNzaW5nIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGFuIGVxdWl2YWxlbnRcbiAqIHZlcnNpb24gdGhhdCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIEBleGFtcGxlXG4gKiBRLm5mYmluZChGUy5yZWFkRmlsZSwgX19maWxlbmFtZSkoXCJ1dGYtOFwiKVxuICogLnRoZW4oY29uc29sZS5sb2cpXG4gKiAuZG9uZSgpXG4gKi9cblEubmZiaW5kID1cblEuZGVub2RlaWZ5ID0gZnVuY3Rpb24gKGNhbGxiYWNrIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGJhc2VBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZUFyZ3MgPSBiYXNlQXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICAgICAgUShjYWxsYmFjaykuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uZmJpbmQgPVxuUHJvbWlzZS5wcm90b3R5cGUuZGVub2RlaWZ5ID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICByZXR1cm4gUS5kZW5vZGVpZnkuYXBwbHkodm9pZCAwLCBhcmdzKTtcbn07XG5cblEubmJpbmQgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIHRoaXNwIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGJhc2VBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZUFyZ3MgPSBiYXNlQXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICAgICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpc3AsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgUShib3VuZCkuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uYmluZCA9IGZ1bmN0aW9uICgvKnRoaXNwLCAuLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMCk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIHJldHVybiBRLm5iaW5kLmFwcGx5KHZvaWQgMCwgYXJncyk7XG59O1xuXG4vKipcbiAqIENhbGxzIGEgbWV0aG9kIG9mIGEgTm9kZS1zdHlsZSBvYmplY3QgdGhhdCBhY2NlcHRzIGEgTm9kZS1zdHlsZVxuICogY2FsbGJhY2sgd2l0aCBhIGdpdmVuIGFycmF5IG9mIGFyZ3VtZW50cywgcGx1cyBhIHByb3ZpZGVkIGNhbGxiYWNrLlxuICogQHBhcmFtIG9iamVjdCBhbiBvYmplY3QgdGhhdCBoYXMgdGhlIG5hbWVkIG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgbWV0aG9kIG9mIG9iamVjdFxuICogQHBhcmFtIHtBcnJheX0gYXJncyBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kOyB0aGUgY2FsbGJhY2tcbiAqIHdpbGwgYmUgcHJvdmlkZWQgYnkgUSBhbmQgYXBwZW5kZWQgdG8gdGhlc2UgYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgdmFsdWUgb3IgZXJyb3JcbiAqL1xuUS5ubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblEubnBvc3QgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5ucG9zdChuYW1lLCBhcmdzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUHJvbWlzZS5wcm90b3R5cGUubnBvc3QgPSBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3MgfHwgW10pO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBub2RlQXJnc10pLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBtZXRob2Qgb2YgYSBOb2RlLXN0eWxlIG9iamVjdCB0aGF0IGFjY2VwdHMgYSBOb2RlLXN0eWxlXG4gKiBjYWxsYmFjaywgZm9yd2FyZGluZyB0aGUgZ2l2ZW4gdmFyaWFkaWMgYXJndW1lbnRzLCBwbHVzIGEgcHJvdmlkZWRcbiAqIGNhbGxiYWNrIGFyZ3VtZW50LlxuICogQHBhcmFtIG9iamVjdCBhbiBvYmplY3QgdGhhdCBoYXMgdGhlIG5hbWVkIG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgbWV0aG9kIG9mIG9iamVjdFxuICogQHBhcmFtIC4uLmFyZ3MgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZDsgdGhlIGNhbGxiYWNrIHdpbGxcbiAqIGJlIHByb3ZpZGVkIGJ5IFEgYW5kIGFwcGVuZGVkIHRvIHRoZXNlIGFyZ3VtZW50cy5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9yIGVycm9yXG4gKi9cblEubnNlbmQgPSAvLyBYWFggQmFzZWQgb24gTWFyayBNaWxsZXIncyBwcm9wb3NlZCBcInNlbmRcIlxuUS5ubWNhbGwgPSAvLyBYWFggQmFzZWQgb24gXCJSZWRzYW5kcm8nc1wiIHByb3Bvc2FsXG5RLm5pbnZva2UgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICBRKG9iamVjdCkuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBub2RlQXJnc10pLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5zZW5kID0gLy8gWFhYIEJhc2VkIG9uIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgXCJzZW5kXCJcblByb21pc2UucHJvdG90eXBlLm5tY2FsbCA9IC8vIFhYWCBCYXNlZCBvbiBcIlJlZHNhbmRybydzXCIgcHJvcG9zYWxcblByb21pc2UucHJvdG90eXBlLm5pbnZva2UgPSBmdW5jdGlvbiAobmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIG5vZGVBcmdzXSkuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBJZiBhIGZ1bmN0aW9uIHdvdWxkIGxpa2UgdG8gc3VwcG9ydCBib3RoIE5vZGUgY29udGludWF0aW9uLXBhc3Npbmctc3R5bGUgYW5kXG4gKiBwcm9taXNlLXJldHVybmluZy1zdHlsZSwgaXQgY2FuIGVuZCBpdHMgaW50ZXJuYWwgcHJvbWlzZSBjaGFpbiB3aXRoXG4gKiBgbm9kZWlmeShub2RlYmFjaylgLCBmb3J3YXJkaW5nIHRoZSBvcHRpb25hbCBub2RlYmFjayBhcmd1bWVudC4gIElmIHRoZSB1c2VyXG4gKiBlbGVjdHMgdG8gdXNlIGEgbm9kZWJhY2ssIHRoZSByZXN1bHQgd2lsbCBiZSBzZW50IHRoZXJlLiAgSWYgdGhleSBkbyBub3RcbiAqIHBhc3MgYSBub2RlYmFjaywgdGhleSB3aWxsIHJlY2VpdmUgdGhlIHJlc3VsdCBwcm9taXNlLlxuICogQHBhcmFtIG9iamVjdCBhIHJlc3VsdCAob3IgYSBwcm9taXNlIGZvciBhIHJlc3VsdClcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5vZGViYWNrIGEgTm9kZS5qcy1zdHlsZSBjYWxsYmFja1xuICogQHJldHVybnMgZWl0aGVyIHRoZSBwcm9taXNlIG9yIG5vdGhpbmdcbiAqL1xuUS5ub2RlaWZ5ID0gbm9kZWlmeTtcbmZ1bmN0aW9uIG5vZGVpZnkob2JqZWN0LCBub2RlYmFjaykge1xuICAgIHJldHVybiBRKG9iamVjdCkubm9kZWlmeShub2RlYmFjayk7XG59XG5cblByb21pc2UucHJvdG90eXBlLm5vZGVpZnkgPSBmdW5jdGlvbiAobm9kZWJhY2spIHtcbiAgICBpZiAobm9kZWJhY2spIHtcbiAgICAgICAgdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5vZGViYWNrKG51bGwsIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBub2RlYmFjayhlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcblxuLy8gQWxsIGNvZGUgYmVmb3JlIHRoaXMgcG9pbnQgd2lsbCBiZSBmaWx0ZXJlZCBmcm9tIHN0YWNrIHRyYWNlcy5cbnZhciBxRW5kaW5nTGluZSA9IGNhcHR1cmVMaW5lKCk7XG5cbnJldHVybiBRO1xuXG59KTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIvVXNlcnMvYmxha2VlbWJyZXkvUHJvamVjdHMvYXBpLW5vdGVib29rL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3MsQnVmZmVyKXtcbi8qKlxuICogV3JhcHBlciBmb3IgYnVpbHQtaW4gaHR0cC5qcyB0byBlbXVsYXRlIHRoZSBicm93c2VyIFhNTEh0dHBSZXF1ZXN0IG9iamVjdC5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHdpdGggSlMgZGVzaWduZWQgZm9yIGJyb3dzZXJzIHRvIGltcHJvdmUgcmV1c2Ugb2YgY29kZSBhbmRcbiAqIGFsbG93IHRoZSB1c2Ugb2YgZXhpc3RpbmcgbGlicmFyaWVzLlxuICpcbiAqIFVzYWdlOiBpbmNsdWRlKFwiWE1MSHR0cFJlcXVlc3QuanNcIikgYW5kIHVzZSBYTUxIdHRwUmVxdWVzdCBwZXIgVzNDIHNwZWNzLlxuICpcbiAqIEBhdXRob3IgRGFuIERlRmVsaXBwaSA8ZGFuQGRyaXZlcmRhbi5jb20+XG4gKiBAY29udHJpYnV0b3IgRGF2aWQgRWxsaXMgPGQuZi5lbGxpc0BpZWVlLm9yZz5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbnZhciBVcmwgPSByZXF1aXJlKFwidXJsXCIpXG4gICwgc3Bhd24gPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKS5zcGF3blxuICAsIGZzID0gcmVxdWlyZSgnZnMnKTtcblxuZXhwb3J0cy5YTUxIdHRwUmVxdWVzdCA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICogUHJpdmF0ZSB2YXJpYWJsZXNcbiAgICovXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG4gIHZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5cbiAgLy8gSG9sZHMgaHR0cC5qcyBvYmplY3RzXG4gIHZhciByZXF1ZXN0O1xuICB2YXIgcmVzcG9uc2U7XG5cbiAgLy8gUmVxdWVzdCBzZXR0aW5nc1xuICB2YXIgc2V0dGluZ3MgPSB7fTtcblxuICAvLyBEaXNhYmxlIGhlYWRlciBibGFja2xpc3QuXG4gIC8vIE5vdCBwYXJ0IG9mIFhIUiBzcGVjcy5cbiAgdmFyIGRpc2FibGVIZWFkZXJDaGVjayA9IGZhbHNlO1xuXG4gIC8vIFNldCBzb21lIGRlZmF1bHQgaGVhZGVyc1xuICB2YXIgZGVmYXVsdEhlYWRlcnMgPSB7XG4gICAgXCJVc2VyLUFnZW50XCI6IFwibm9kZS1YTUxIdHRwUmVxdWVzdFwiLFxuICAgIFwiQWNjZXB0XCI6IFwiKi8qXCIsXG4gIH07XG5cbiAgdmFyIGhlYWRlcnMgPSBkZWZhdWx0SGVhZGVycztcblxuICAvLyBUaGVzZSBoZWFkZXJzIGFyZSBub3QgdXNlciBzZXRhYmxlLlxuICAvLyBUaGUgZm9sbG93aW5nIGFyZSBhbGxvd2VkIGJ1dCBiYW5uZWQgaW4gdGhlIHNwZWM6XG4gIC8vICogdXNlci1hZ2VudFxuICB2YXIgZm9yYmlkZGVuUmVxdWVzdEhlYWRlcnMgPSBbXG4gICAgXCJhY2NlcHQtY2hhcnNldFwiLFxuICAgIFwiYWNjZXB0LWVuY29kaW5nXCIsXG4gICAgXCJhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LWhlYWRlcnNcIixcbiAgICBcImFjY2Vzcy1jb250cm9sLXJlcXVlc3QtbWV0aG9kXCIsXG4gICAgXCJjb25uZWN0aW9uXCIsXG4gICAgXCJjb250ZW50LWxlbmd0aFwiLFxuICAgIFwiY29udGVudC10cmFuc2Zlci1lbmNvZGluZ1wiLFxuICAgIFwiY29va2llXCIsXG4gICAgXCJjb29raWUyXCIsXG4gICAgXCJkYXRlXCIsXG4gICAgXCJleHBlY3RcIixcbiAgICBcImhvc3RcIixcbiAgICBcImtlZXAtYWxpdmVcIixcbiAgICBcIm9yaWdpblwiLFxuICAgIFwicmVmZXJlclwiLFxuICAgIFwidGVcIixcbiAgICBcInRyYWlsZXJcIixcbiAgICBcInRyYW5zZmVyLWVuY29kaW5nXCIsXG4gICAgXCJ1cGdyYWRlXCIsXG4gICAgXCJ2aWFcIlxuICBdO1xuXG4gIC8vIFRoZXNlIHJlcXVlc3QgbWV0aG9kcyBhcmUgbm90IGFsbG93ZWRcbiAgdmFyIGZvcmJpZGRlblJlcXVlc3RNZXRob2RzID0gW1xuICAgIFwiVFJBQ0VcIixcbiAgICBcIlRSQUNLXCIsXG4gICAgXCJDT05ORUNUXCJcbiAgXTtcblxuICAvLyBTZW5kIGZsYWdcbiAgdmFyIHNlbmRGbGFnID0gZmFsc2U7XG4gIC8vIEVycm9yIGZsYWcsIHVzZWQgd2hlbiBlcnJvcnMgb2NjdXIgb3IgYWJvcnQgaXMgY2FsbGVkXG4gIHZhciBlcnJvckZsYWcgPSBmYWxzZTtcblxuICAvLyBFdmVudCBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IHt9O1xuXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgdGhpcy5VTlNFTlQgPSAwO1xuICB0aGlzLk9QRU5FRCA9IDE7XG4gIHRoaXMuSEVBREVSU19SRUNFSVZFRCA9IDI7XG4gIHRoaXMuTE9BRElORyA9IDM7XG4gIHRoaXMuRE9ORSA9IDQ7XG5cbiAgLyoqXG4gICAqIFB1YmxpYyB2YXJzXG4gICAqL1xuXG4gIC8vIEN1cnJlbnQgc3RhdGVcbiAgdGhpcy5yZWFkeVN0YXRlID0gdGhpcy5VTlNFTlQ7XG5cbiAgLy8gZGVmYXVsdCByZWFkeSBzdGF0ZSBjaGFuZ2UgaGFuZGxlciBpbiBjYXNlIG9uZSBpcyBub3Qgc2V0IG9yIGlzIHNldCBsYXRlXG4gIHRoaXMub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuICAvLyBSZXN1bHQgJiByZXNwb25zZVxuICB0aGlzLnJlc3BvbnNlVGV4dCA9IFwiXCI7XG4gIHRoaXMucmVzcG9uc2VYTUwgPSBcIlwiO1xuICB0aGlzLnN0YXR1cyA9IG51bGw7XG4gIHRoaXMuc3RhdHVzVGV4dCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgbWV0aG9kc1xuICAgKi9cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHNwZWNpZmllZCBoZWFkZXIgaXMgYWxsb3dlZC5cbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBoZWFkZXIgSGVhZGVyIHRvIHZhbGlkYXRlXG4gICAqIEByZXR1cm4gYm9vbGVhbiBGYWxzZSBpZiBub3QgYWxsb3dlZCwgb3RoZXJ3aXNlIHRydWVcbiAgICovXG4gIHZhciBpc0FsbG93ZWRIdHRwSGVhZGVyID0gZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgcmV0dXJuIGRpc2FibGVIZWFkZXJDaGVjayB8fCAoaGVhZGVyICYmIGZvcmJpZGRlblJlcXVlc3RIZWFkZXJzLmluZGV4T2YoaGVhZGVyLnRvTG93ZXJDYXNlKCkpID09PSAtMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBzcGVjaWZpZWQgbWV0aG9kIGlzIGFsbG93ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJpbmcgbWV0aG9kIFJlcXVlc3QgbWV0aG9kIHRvIHZhbGlkYXRlXG4gICAqIEByZXR1cm4gYm9vbGVhbiBGYWxzZSBpZiBub3QgYWxsb3dlZCwgb3RoZXJ3aXNlIHRydWVcbiAgICovXG4gIHZhciBpc0FsbG93ZWRIdHRwTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgcmV0dXJuIChtZXRob2QgJiYgZm9yYmlkZGVuUmVxdWVzdE1ldGhvZHMuaW5kZXhPZihtZXRob2QpID09PSAtMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBtZXRob2RzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBPcGVuIHRoZSBjb25uZWN0aW9uLiBDdXJyZW50bHkgc3VwcG9ydHMgbG9jYWwgc2VydmVyIHJlcXVlc3RzLlxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nIG1ldGhvZCBDb25uZWN0aW9uIG1ldGhvZCAoZWcgR0VULCBQT1NUKVxuICAgKiBAcGFyYW0gc3RyaW5nIHVybCBVUkwgZm9yIHRoZSBjb25uZWN0aW9uLlxuICAgKiBAcGFyYW0gYm9vbGVhbiBhc3luYyBBc3luY2hyb25vdXMgY29ubmVjdGlvbi4gRGVmYXVsdCBpcyB0cnVlLlxuICAgKiBAcGFyYW0gc3RyaW5nIHVzZXIgVXNlcm5hbWUgZm9yIGJhc2ljIGF1dGhlbnRpY2F0aW9uIChvcHRpb25hbClcbiAgICogQHBhcmFtIHN0cmluZyBwYXNzd29yZCBQYXNzd29yZCBmb3IgYmFzaWMgYXV0aGVudGljYXRpb24gKG9wdGlvbmFsKVxuICAgKi9cbiAgdGhpcy5vcGVuID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIGFzeW5jLCB1c2VyLCBwYXNzd29yZCkge1xuICAgIHRoaXMuYWJvcnQoKTtcbiAgICBlcnJvckZsYWcgPSBmYWxzZTtcblxuICAgIC8vIENoZWNrIGZvciB2YWxpZCByZXF1ZXN0IG1ldGhvZFxuICAgIGlmICghaXNBbGxvd2VkSHR0cE1ldGhvZChtZXRob2QpKSB7XG4gICAgICB0aHJvdyBcIlNlY3VyaXR5RXJyb3I6IFJlcXVlc3QgbWV0aG9kIG5vdCBhbGxvd2VkXCI7XG4gICAgfVxuXG4gICAgc2V0dGluZ3MgPSB7XG4gICAgICBcIm1ldGhvZFwiOiBtZXRob2QsXG4gICAgICBcInVybFwiOiB1cmwudG9TdHJpbmcoKSxcbiAgICAgIFwiYXN5bmNcIjogKHR5cGVvZiBhc3luYyAhPT0gXCJib29sZWFuXCIgPyB0cnVlIDogYXN5bmMpLFxuICAgICAgXCJ1c2VyXCI6IHVzZXIgfHwgbnVsbCxcbiAgICAgIFwicGFzc3dvcmRcIjogcGFzc3dvcmQgfHwgbnVsbFxuICAgIH07XG5cbiAgICBzZXRTdGF0ZSh0aGlzLk9QRU5FRCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc2FibGVzIG9yIGVuYWJsZXMgaXNBbGxvd2VkSHR0cEhlYWRlcigpIGNoZWNrIHRoZSByZXF1ZXN0LiBFbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAqIFRoaXMgZG9lcyBub3QgY29uZm9ybSB0byB0aGUgVzNDIHNwZWMuXG4gICAqXG4gICAqIEBwYXJhbSBib29sZWFuIHN0YXRlIEVuYWJsZSBvciBkaXNhYmxlIGhlYWRlciBjaGVja2luZy5cbiAgICovXG4gIHRoaXMuc2V0RGlzYWJsZUhlYWRlckNoZWNrID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBkaXNhYmxlSGVhZGVyQ2hlY2sgPSBzdGF0ZTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBhIGhlYWRlciBmb3IgdGhlIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJpbmcgaGVhZGVyIEhlYWRlciBuYW1lXG4gICAqIEBwYXJhbSBzdHJpbmcgdmFsdWUgSGVhZGVyIHZhbHVlXG4gICAqL1xuICB0aGlzLnNldFJlcXVlc3RIZWFkZXIgPSBmdW5jdGlvbihoZWFkZXIsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPSB0aGlzLk9QRU5FRCkge1xuICAgICAgdGhyb3cgXCJJTlZBTElEX1NUQVRFX0VSUjogc2V0UmVxdWVzdEhlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgd2hlbiBzdGF0ZSBpcyBPUEVOXCI7XG4gICAgfVxuICAgIGlmICghaXNBbGxvd2VkSHR0cEhlYWRlcihoZWFkZXIpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1JlZnVzZWQgdG8gc2V0IHVuc2FmZSBoZWFkZXIgXCInICsgaGVhZGVyICsgJ1wiJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzZW5kRmxhZykge1xuICAgICAgdGhyb3cgXCJJTlZBTElEX1NUQVRFX0VSUjogc2VuZCBmbGFnIGlzIHRydWVcIjtcbiAgICB9XG4gICAgaGVhZGVyc1toZWFkZXJdID0gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYSBoZWFkZXIgZnJvbSB0aGUgc2VydmVyIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nIGhlYWRlciBOYW1lIG9mIGhlYWRlciB0byBnZXQuXG4gICAqIEByZXR1cm4gc3RyaW5nIFRleHQgb2YgdGhlIGhlYWRlciBvciBudWxsIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICB0aGlzLmdldFJlc3BvbnNlSGVhZGVyID0gZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBoZWFkZXIgPT09IFwic3RyaW5nXCJcbiAgICAgICYmIHRoaXMucmVhZHlTdGF0ZSA+IHRoaXMuT1BFTkVEXG4gICAgICAmJiByZXNwb25zZS5oZWFkZXJzW2hlYWRlci50b0xvd2VyQ2FzZSgpXVxuICAgICAgJiYgIWVycm9yRmxhZ1xuICAgICkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmhlYWRlcnNbaGVhZGVyLnRvTG93ZXJDYXNlKCldO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGFsbCB0aGUgcmVzcG9uc2UgaGVhZGVycy5cbiAgICpcbiAgICogQHJldHVybiBzdHJpbmcgQSBzdHJpbmcgd2l0aCBhbGwgcmVzcG9uc2UgaGVhZGVycyBzZXBhcmF0ZWQgYnkgQ1IrTEZcbiAgICovXG4gIHRoaXMuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA8IHRoaXMuSEVBREVSU19SRUNFSVZFRCB8fCBlcnJvckZsYWcpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gXCJcIjtcblxuICAgIGZvciAodmFyIGkgaW4gcmVzcG9uc2UuaGVhZGVycykge1xuICAgICAgLy8gQ29va2llIGhlYWRlcnMgYXJlIGV4Y2x1ZGVkXG4gICAgICBpZiAoaSAhPT0gXCJzZXQtY29va2llXCIgJiYgaSAhPT0gXCJzZXQtY29va2llMlwiKSB7XG4gICAgICAgIHJlc3VsdCArPSBpICsgXCI6IFwiICsgcmVzcG9uc2UuaGVhZGVyc1tpXSArIFwiXFxyXFxuXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuc3Vic3RyKDAsIHJlc3VsdC5sZW5ndGggLSAyKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhIHJlcXVlc3QgaGVhZGVyXG4gICAqXG4gICAqIEBwYXJhbSBzdHJpbmcgbmFtZSBOYW1lIG9mIGhlYWRlciB0byBnZXRcbiAgICogQHJldHVybiBzdHJpbmcgUmV0dXJucyB0aGUgcmVxdWVzdCBoZWFkZXIgb3IgZW1wdHkgc3RyaW5nIGlmIG5vdCBzZXRcbiAgICovXG4gIHRoaXMuZ2V0UmVxdWVzdEhlYWRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAvLyBAVE9ETyBNYWtlIHRoaXMgY2FzZSBpbnNlbnNpdGl2ZVxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBoZWFkZXJzW25hbWVdKSB7XG4gICAgICByZXR1cm4gaGVhZGVyc1tuYW1lXTtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIjtcbiAgfTtcblxuICAvKipcbiAgICogU2VuZHMgdGhlIHJlcXVlc3QgdG8gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQHBhcmFtIHN0cmluZyBkYXRhIE9wdGlvbmFsIGRhdGEgdG8gc2VuZCBhcyByZXF1ZXN0IGJvZHkuXG4gICAqL1xuICB0aGlzLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPSB0aGlzLk9QRU5FRCkge1xuICAgICAgdGhyb3cgXCJJTlZBTElEX1NUQVRFX0VSUjogY29ubmVjdGlvbiBtdXN0IGJlIG9wZW5lZCBiZWZvcmUgc2VuZCgpIGlzIGNhbGxlZFwiO1xuICAgIH1cblxuICAgIGlmIChzZW5kRmxhZykge1xuICAgICAgdGhyb3cgXCJJTlZBTElEX1NUQVRFX0VSUjogc2VuZCBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFwiO1xuICAgIH1cblxuICAgIHZhciBzc2wgPSBmYWxzZSwgbG9jYWwgPSBmYWxzZTtcbiAgICB2YXIgdXJsID0gVXJsLnBhcnNlKHNldHRpbmdzLnVybCk7XG4gICAgdmFyIGhvc3Q7XG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBzZXJ2ZXJcbiAgICBzd2l0Y2ggKHVybC5wcm90b2NvbCkge1xuICAgICAgY2FzZSAnaHR0cHM6JzpcbiAgICAgICAgc3NsID0gdHJ1ZTtcbiAgICAgICAgLy8gU1NMICYgbm9uLVNTTCBib3RoIG5lZWQgaG9zdCwgbm8gYnJlYWsgaGVyZS5cbiAgICAgIGNhc2UgJ2h0dHA6JzpcbiAgICAgICAgaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2ZpbGU6JzpcbiAgICAgICAgbG9jYWwgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICBjYXNlICcnOlxuICAgICAgICBob3N0ID0gXCJsb2NhbGhvc3RcIjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IFwiUHJvdG9jb2wgbm90IHN1cHBvcnRlZC5cIjtcbiAgICB9XG5cbiAgICAvLyBMb2FkIGZpbGVzIG9mZiB0aGUgbG9jYWwgZmlsZXN5c3RlbSAoZmlsZTovLylcbiAgICBpZiAobG9jYWwpIHtcbiAgICAgIGlmIChzZXR0aW5ncy5tZXRob2QgIT09IFwiR0VUXCIpIHtcbiAgICAgICAgdGhyb3cgXCJYTUxIdHRwUmVxdWVzdDogT25seSBHRVQgbWV0aG9kIGlzIHN1cHBvcnRlZFwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2V0dGluZ3MuYXN5bmMpIHtcbiAgICAgICAgZnMucmVhZEZpbGUodXJsLnBhdGhuYW1lLCAndXRmOCcsIGZ1bmN0aW9uKGVycm9yLCBkYXRhKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBzZWxmLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5zdGF0dXMgPSAyMDA7XG4gICAgICAgICAgICBzZWxmLnJlc3BvbnNlVGV4dCA9IGRhdGE7XG4gICAgICAgICAgICBzZXRTdGF0ZShzZWxmLkRPTkUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gZnMucmVhZEZpbGVTeW5jKHVybC5wYXRobmFtZSwgJ3V0ZjgnKTtcbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IDIwMDtcbiAgICAgICAgICBzZXRTdGF0ZShzZWxmLkRPTkUpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRvIHBvcnQgODAuIElmIGFjY2Vzc2luZyBsb2NhbGhvc3Qgb24gYW5vdGhlciBwb3J0IGJlIHN1cmVcbiAgICAvLyB0byB1c2UgaHR0cDovL2xvY2FsaG9zdDpwb3J0L3BhdGhcbiAgICB2YXIgcG9ydCA9IHVybC5wb3J0IHx8IChzc2wgPyA0NDMgOiA4MCk7XG4gICAgLy8gQWRkIHF1ZXJ5IHN0cmluZyBpZiBvbmUgaXMgdXNlZFxuICAgIHZhciB1cmkgPSB1cmwucGF0aG5hbWUgKyAodXJsLnNlYXJjaCA/IHVybC5zZWFyY2ggOiAnJyk7XG5cbiAgICAvLyBTZXQgdGhlIEhvc3QgaGVhZGVyIG9yIHRoZSBzZXJ2ZXIgbWF5IHJlamVjdCB0aGUgcmVxdWVzdFxuICAgIGhlYWRlcnNbXCJIb3N0XCJdID0gaG9zdDtcbiAgICBpZiAoISgoc3NsICYmIHBvcnQgPT09IDQ0MykgfHwgcG9ydCA9PT0gODApKSB7XG4gICAgICBoZWFkZXJzW1wiSG9zdFwiXSArPSAnOicgKyB1cmwucG9ydDtcbiAgICB9XG5cbiAgICAvLyBTZXQgQmFzaWMgQXV0aCBpZiBuZWNlc3NhcnlcbiAgICBpZiAoc2V0dGluZ3MudXNlcikge1xuICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5wYXNzd29yZCA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHNldHRpbmdzLnBhc3N3b3JkID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIHZhciBhdXRoQnVmID0gbmV3IEJ1ZmZlcihzZXR0aW5ncy51c2VyICsgXCI6XCIgKyBzZXR0aW5ncy5wYXNzd29yZCk7XG4gICAgICBoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IFwiQmFzaWMgXCIgKyBhdXRoQnVmLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIH1cblxuICAgIC8vIFNldCBjb250ZW50IGxlbmd0aCBoZWFkZXJcbiAgICBpZiAoc2V0dGluZ3MubWV0aG9kID09PSBcIkdFVFwiIHx8IHNldHRpbmdzLm1ldGhvZCA9PT0gXCJIRUFEXCIpIHtcbiAgICAgIGRhdGEgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoZGF0YSkge1xuICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtTGVuZ3RoXCJdID0gQnVmZmVyLmlzQnVmZmVyKGRhdGEpID8gZGF0YS5sZW5ndGggOiBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcblxuICAgICAgaWYgKCFoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdKSB7XG4gICAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcInRleHQvcGxhaW47Y2hhcnNldD1VVEYtOFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MubWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgLy8gRm9yIGEgcG9zdCB3aXRoIG5vIGRhdGEgc2V0IENvbnRlbnQtTGVuZ3RoOiAwLlxuICAgICAgLy8gVGhpcyBpcyByZXF1aXJlZCBieSBidWdneSBzZXJ2ZXJzIHRoYXQgZG9uJ3QgbWVldCB0aGUgc3BlY3MuXG4gICAgICBoZWFkZXJzW1wiQ29udGVudC1MZW5ndGhcIl0gPSAwO1xuICAgIH1cblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgaG9zdDogaG9zdCxcbiAgICAgIHBvcnQ6IHBvcnQsXG4gICAgICBwYXRoOiB1cmksXG4gICAgICBtZXRob2Q6IHNldHRpbmdzLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICBhZ2VudDogZmFsc2VcbiAgICB9O1xuXG4gICAgLy8gUmVzZXQgZXJyb3IgZmxhZ1xuICAgIGVycm9yRmxhZyA9IGZhbHNlO1xuXG4gICAgLy8gSGFuZGxlIGFzeW5jIHJlcXVlc3RzXG4gICAgaWYgKHNldHRpbmdzLmFzeW5jKSB7XG4gICAgICAvLyBVc2UgdGhlIHByb3BlciBwcm90b2NvbFxuICAgICAgdmFyIGRvUmVxdWVzdCA9IHNzbCA/IGh0dHBzLnJlcXVlc3QgOiBodHRwLnJlcXVlc3Q7XG5cbiAgICAgIC8vIFJlcXVlc3QgaXMgYmVpbmcgc2VudCwgc2V0IHNlbmQgZmxhZ1xuICAgICAgc2VuZEZsYWcgPSB0cnVlO1xuXG4gICAgICAvLyBBcyBwZXIgc3BlYywgdGhpcyBpcyBjYWxsZWQgaGVyZSBmb3IgaGlzdG9yaWNhbCByZWFzb25zLlxuICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwicmVhZHlzdGF0ZWNoYW5nZVwiKTtcblxuICAgICAgLy8gSGFuZGxlciBmb3IgdGhlIHJlc3BvbnNlXG4gICAgICBmdW5jdGlvbiByZXNwb25zZUhhbmRsZXIocmVzcCkge1xuICAgICAgICAvLyBTZXQgcmVzcG9uc2UgdmFyIHRvIHRoZSByZXNwb25zZSB3ZSBnb3QgYmFja1xuICAgICAgICAvLyBUaGlzIGlzIHNvIGl0IHJlbWFpbnMgYWNjZXNzYWJsZSBvdXRzaWRlIHRoaXMgc2NvcGVcbiAgICAgICAgcmVzcG9uc2UgPSByZXNwO1xuICAgICAgICAvLyBDaGVjayBmb3IgcmVkaXJlY3RcbiAgICAgICAgLy8gQFRPRE8gUHJldmVudCBsb29wZWQgcmVkaXJlY3RzXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDIgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAzIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwNykge1xuICAgICAgICAgIC8vIENoYW5nZSBVUkwgdG8gdGhlIHJlZGlyZWN0IGxvY2F0aW9uXG4gICAgICAgICAgc2V0dGluZ3MudXJsID0gcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbjtcbiAgICAgICAgICB2YXIgdXJsID0gVXJsLnBhcnNlKHNldHRpbmdzLnVybCk7XG4gICAgICAgICAgLy8gU2V0IGhvc3QgdmFyIGluIGNhc2UgaXQncyB1c2VkIGxhdGVyXG4gICAgICAgICAgaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgICAvLyBPcHRpb25zIGZvciB0aGUgbmV3IHJlcXVlc3RcbiAgICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGhvc3RuYW1lOiB1cmwuaG9zdG5hbWUsXG4gICAgICAgICAgICBwb3J0OiB1cmwucG9ydCxcbiAgICAgICAgICAgIHBhdGg6IHVybC5wYXRoLFxuICAgICAgICAgICAgbWV0aG9kOiByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDMgPyAnR0VUJyA6IHNldHRpbmdzLm1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gSXNzdWUgdGhlIG5ldyByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdCA9IGRvUmVxdWVzdChuZXdPcHRpb25zLCByZXNwb25zZUhhbmRsZXIpLm9uKCdlcnJvcicsIGVycm9ySGFuZGxlcik7XG4gICAgICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICAgICAgICAvLyBAVE9ETyBDaGVjayBpZiBhbiBYSFIgZXZlbnQgbmVlZHMgdG8gYmUgZmlyZWQgaGVyZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3BvbnNlLnNldEVuY29kaW5nKFwidXRmOFwiKTtcblxuICAgICAgICBzZXRTdGF0ZShzZWxmLkhFQURFUlNfUkVDRUlWRUQpO1xuICAgICAgICBzZWxmLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7XG5cbiAgICAgICAgcmVzcG9uc2Uub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSdzIHNvbWUgZGF0YVxuICAgICAgICAgIGlmIChjaHVuaykge1xuICAgICAgICAgICAgc2VsZi5yZXNwb25zZVRleHQgKz0gY2h1bms7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIERvbid0IGVtaXQgc3RhdGUgY2hhbmdlcyBpZiB0aGUgY29ubmVjdGlvbiBoYXMgYmVlbiBhYm9ydGVkLlxuICAgICAgICAgIGlmIChzZW5kRmxhZykge1xuICAgICAgICAgICAgc2V0U3RhdGUoc2VsZi5MT0FESU5HKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3BvbnNlLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoc2VuZEZsYWcpIHtcbiAgICAgICAgICAgIC8vIERpc2NhcmQgdGhlICdlbmQnIGV2ZW50IGlmIHRoZSBjb25uZWN0aW9uIGhhcyBiZWVuIGFib3J0ZWRcbiAgICAgICAgICAgIHNldFN0YXRlKHNlbGYuRE9ORSk7XG4gICAgICAgICAgICBzZW5kRmxhZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzcG9uc2Uub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBzZWxmLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEVycm9yIGhhbmRsZXIgZm9yIHRoZSByZXF1ZXN0XG4gICAgICBmdW5jdGlvbiBlcnJvckhhbmRsZXIoZXJyb3IpIHtcbiAgICAgICAgc2VsZi5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IGRvUmVxdWVzdChvcHRpb25zLCByZXNwb25zZUhhbmRsZXIpLm9uKCdlcnJvcicsIGVycm9ySGFuZGxlcik7XG5cbiAgICAgIC8vIE5vZGUgMC40IGFuZCBsYXRlciB3b24ndCBhY2NlcHQgZW1wdHkgZGF0YS4gTWFrZSBzdXJlIGl0J3MgbmVlZGVkLlxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgcmVxdWVzdC53cml0ZShkYXRhKTtcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5lbmQoKTtcblxuICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwibG9hZHN0YXJ0XCIpO1xuICAgIH0gZWxzZSB7IC8vIFN5bmNocm9ub3VzXG4gICAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgZmlsZSBmb3IgY29tbXVuaWNhdGlvbiB3aXRoIHRoZSBvdGhlciBOb2RlIHByb2Nlc3NcbiAgICAgIHZhciBjb250ZW50RmlsZSA9IFwiLm5vZGUteG1saHR0cHJlcXVlc3QtY29udGVudC1cIiArIHByb2Nlc3MucGlkO1xuICAgICAgdmFyIHN5bmNGaWxlID0gXCIubm9kZS14bWxodHRwcmVxdWVzdC1zeW5jLVwiICsgcHJvY2Vzcy5waWQ7XG4gICAgICBmcy53cml0ZUZpbGVTeW5jKHN5bmNGaWxlLCBcIlwiLCBcInV0ZjhcIik7XG4gICAgICAvLyBUaGUgYXN5bmMgcmVxdWVzdCB0aGUgb3RoZXIgTm9kZSBwcm9jZXNzIGV4ZWN1dGVzXG4gICAgICB2YXIgZXhlY1N0cmluZyA9IFwidmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJyksIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKSwgZnMgPSByZXF1aXJlKCdmcycpO1wiXG4gICAgICAgICsgXCJ2YXIgZG9SZXF1ZXN0ID0gaHR0cFwiICsgKHNzbCA/IFwic1wiIDogXCJcIikgKyBcIi5yZXF1ZXN0O1wiXG4gICAgICAgICsgXCJ2YXIgb3B0aW9ucyA9IFwiICsgSlNPTi5zdHJpbmdpZnkob3B0aW9ucykgKyBcIjtcIlxuICAgICAgICArIFwidmFyIHJlc3BvbnNlVGV4dCA9ICcnO1wiXG4gICAgICAgICsgXCJ2YXIgcmVxID0gZG9SZXF1ZXN0KG9wdGlvbnMsIGZ1bmN0aW9uKHJlc3BvbnNlKSB7XCJcbiAgICAgICAgKyBcInJlc3BvbnNlLnNldEVuY29kaW5nKCd1dGY4Jyk7XCJcbiAgICAgICAgKyBcInJlc3BvbnNlLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcIlxuICAgICAgICArIFwiICByZXNwb25zZVRleHQgKz0gY2h1bms7XCJcbiAgICAgICAgKyBcIn0pO1wiXG4gICAgICAgICsgXCJyZXNwb25zZS5vbignZW5kJywgZnVuY3Rpb24oKSB7XCJcbiAgICAgICAgKyBcImZzLndyaXRlRmlsZVN5bmMoJ1wiICsgY29udGVudEZpbGUgKyBcIicsICdOT0RFLVhNTEhUVFBSRVFVRVNULVNUQVRVUzonICsgcmVzcG9uc2Uuc3RhdHVzQ29kZSArICcsJyArIHJlc3BvbnNlVGV4dCwgJ3V0ZjgnKTtcIlxuICAgICAgICArIFwiZnMudW5saW5rU3luYygnXCIgKyBzeW5jRmlsZSArIFwiJyk7XCJcbiAgICAgICAgKyBcIn0pO1wiXG4gICAgICAgICsgXCJyZXNwb25zZS5vbignZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1wiXG4gICAgICAgICsgXCJmcy53cml0ZUZpbGVTeW5jKCdcIiArIGNvbnRlbnRGaWxlICsgXCInLCAnTk9ERS1YTUxIVFRQUkVRVUVTVC1FUlJPUjonICsgSlNPTi5zdHJpbmdpZnkoZXJyb3IpLCAndXRmOCcpO1wiXG4gICAgICAgICsgXCJmcy51bmxpbmtTeW5jKCdcIiArIHN5bmNGaWxlICsgXCInKTtcIlxuICAgICAgICArIFwifSk7XCJcbiAgICAgICAgKyBcIn0pLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycm9yKSB7XCJcbiAgICAgICAgKyBcImZzLndyaXRlRmlsZVN5bmMoJ1wiICsgY29udGVudEZpbGUgKyBcIicsICdOT0RFLVhNTEhUVFBSRVFVRVNULUVSUk9SOicgKyBKU09OLnN0cmluZ2lmeShlcnJvciksICd1dGY4Jyk7XCJcbiAgICAgICAgKyBcImZzLnVubGlua1N5bmMoJ1wiICsgc3luY0ZpbGUgKyBcIicpO1wiXG4gICAgICAgICsgXCJ9KTtcIlxuICAgICAgICArIChkYXRhID8gXCJyZXEud3JpdGUoJ1wiICsgZGF0YS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIikgKyBcIicpO1wiOlwiXCIpXG4gICAgICAgICsgXCJyZXEuZW5kKCk7XCI7XG4gICAgICAvLyBTdGFydCB0aGUgb3RoZXIgTm9kZSBQcm9jZXNzLCBleGVjdXRpbmcgdGhpcyBzdHJpbmdcbiAgICAgIHZhciBzeW5jUHJvYyA9IHNwYXduKHByb2Nlc3MuYXJndlswXSwgW1wiLWVcIiwgZXhlY1N0cmluZ10pO1xuICAgICAgdmFyIHN0YXR1c1RleHQ7XG4gICAgICB3aGlsZShmcy5leGlzdHNTeW5jKHN5bmNGaWxlKSkge1xuICAgICAgICAvLyBXYWl0IHdoaWxlIHRoZSBzeW5jIGZpbGUgaXMgZW1wdHlcbiAgICAgIH1cbiAgICAgIHNlbGYucmVzcG9uc2VUZXh0ID0gZnMucmVhZEZpbGVTeW5jKGNvbnRlbnRGaWxlLCAndXRmOCcpO1xuICAgICAgLy8gS2lsbCB0aGUgY2hpbGQgcHJvY2VzcyBvbmNlIHRoZSBmaWxlIGhhcyBkYXRhXG4gICAgICBzeW5jUHJvYy5zdGRpbi5lbmQoKTtcbiAgICAgIC8vIFJlbW92ZSB0aGUgdGVtcG9yYXJ5IGZpbGVcbiAgICAgIGZzLnVubGlua1N5bmMoY29udGVudEZpbGUpO1xuICAgICAgaWYgKHNlbGYucmVzcG9uc2VUZXh0Lm1hdGNoKC9eTk9ERS1YTUxIVFRQUkVRVUVTVC1FUlJPUjovKSkge1xuICAgICAgICAvLyBJZiB0aGUgZmlsZSByZXR1cm5lZCBhbiBlcnJvciwgaGFuZGxlIGl0XG4gICAgICAgIHZhciBlcnJvck9iaiA9IHNlbGYucmVzcG9uc2VUZXh0LnJlcGxhY2UoL15OT0RFLVhNTEhUVFBSRVFVRVNULUVSUk9SOi8sIFwiXCIpO1xuICAgICAgICBzZWxmLmhhbmRsZUVycm9yKGVycm9yT2JqKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSBmaWxlIHJldHVybmVkIG9rYXksIHBhcnNlIGl0cyBkYXRhIGFuZCBtb3ZlIHRvIHRoZSBET05FIHN0YXRlXG4gICAgICAgIHNlbGYuc3RhdHVzID0gc2VsZi5yZXNwb25zZVRleHQucmVwbGFjZSgvXk5PREUtWE1MSFRUUFJFUVVFU1QtU1RBVFVTOihbMC05XSopLC4qLywgXCIkMVwiKTtcbiAgICAgICAgc2VsZi5yZXNwb25zZVRleHQgPSBzZWxmLnJlc3BvbnNlVGV4dC5yZXBsYWNlKC9eTk9ERS1YTUxIVFRQUkVRVUVTVC1TVEFUVVM6WzAtOV0qLCguKikvLCBcIiQxXCIpO1xuICAgICAgICBzZXRTdGF0ZShzZWxmLkRPTkUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQgdG8gZGVhbCB3aXRoIGl0LlxuICAgKi9cbiAgdGhpcy5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgdGhpcy5zdGF0dXMgPSA1MDM7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gZXJyb3I7XG4gICAgdGhpcy5yZXNwb25zZVRleHQgPSBlcnJvci5zdGFjaztcbiAgICBlcnJvckZsYWcgPSB0cnVlO1xuICAgIHNldFN0YXRlKHRoaXMuRE9ORSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFib3J0cyBhIHJlcXVlc3QuXG4gICAqL1xuICB0aGlzLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH1cblxuICAgIGhlYWRlcnMgPSBkZWZhdWx0SGVhZGVycztcbiAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IFwiXCI7XG4gICAgdGhpcy5yZXNwb25zZVhNTCA9IFwiXCI7XG5cbiAgICBlcnJvckZsYWcgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gdGhpcy5VTlNFTlRcbiAgICAgICAgJiYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gdGhpcy5PUEVORUQgfHwgc2VuZEZsYWcpXG4gICAgICAgICYmIHRoaXMucmVhZHlTdGF0ZSAhPT0gdGhpcy5ET05FKSB7XG4gICAgICBzZW5kRmxhZyA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUodGhpcy5ET05FKTtcbiAgICB9XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gdGhpcy5VTlNFTlQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIuIFByZWZlcnJlZCBtZXRob2Qgb2YgYmluZGluZyB0byBldmVudHMuXG4gICAqL1xuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIShldmVudCBpbiBsaXN0ZW5lcnMpKSB7XG4gICAgICBsaXN0ZW5lcnNbZXZlbnRdID0gW107XG4gICAgfVxuICAgIC8vIEN1cnJlbnRseSBhbGxvd3MgZHVwbGljYXRlIGNhbGxiYWNrcy4gU2hvdWxkIGl0P1xuICAgIGxpc3RlbmVyc1tldmVudF0ucHVzaChjYWxsYmFjayk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBjYWxsYmFjayB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gYm91bmQuXG4gICAqIE9ubHkgd29ya3Mgb24gdGhlIG1hdGNoaW5nIGZ1bmNpdG9uLCBjYW5ub3QgYmUgYSBjb3B5LlxuICAgKi9cbiAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGV2ZW50IGluIGxpc3RlbmVycykge1xuICAgICAgLy8gRmlsdGVyIHdpbGwgcmV0dXJuIGEgbmV3IGFycmF5IHdpdGggdGhlIGNhbGxiYWNrIHJlbW92ZWRcbiAgICAgIGxpc3RlbmVyc1tldmVudF0gPSBsaXN0ZW5lcnNbZXZlbnRdLmZpbHRlcihmdW5jdGlvbihldikge1xuICAgICAgICByZXR1cm4gZXYgIT09IGNhbGxiYWNrO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBhbnkgZXZlbnRzLCBpbmNsdWRpbmcgYm90aCBcIm9uXCIgbWV0aG9kcyBhbmQgZXZlbnRzIGF0dGFjaGVkIHVzaW5nIGFkZEV2ZW50TGlzdGVuZXIuXG4gICAqL1xuICB0aGlzLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICh0eXBlb2Ygc2VsZltcIm9uXCIgKyBldmVudF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgc2VsZltcIm9uXCIgKyBldmVudF0oKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50IGluIGxpc3RlbmVycykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVyc1tldmVudF0ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGlzdGVuZXJzW2V2ZW50XVtpXS5jYWxsKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hhbmdlcyByZWFkeVN0YXRlIGFuZCBjYWxscyBvbnJlYWR5c3RhdGVjaGFuZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBpbnQgc3RhdGUgTmV3IHN0YXRlXG4gICAqL1xuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmIChzZWxmLnJlYWR5U3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICBzZWxmLnJlYWR5U3RhdGUgPSBzdGF0ZTtcblxuICAgICAgaWYgKHNldHRpbmdzLmFzeW5jIHx8IHNlbGYucmVhZHlTdGF0ZSA8IHNlbGYuT1BFTkVEIHx8IHNlbGYucmVhZHlTdGF0ZSA9PT0gc2VsZi5ET05FKSB7XG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChcInJlYWR5c3RhdGVjaGFuZ2VcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnJlYWR5U3RhdGUgPT09IHNlbGYuRE9ORSAmJiAhZXJyb3JGbGFnKSB7XG4gICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChcImxvYWRcIik7XG4gICAgICAgIC8vIEBUT0RPIGZpZ3VyZSBvdXQgSW5zcGVjdG9ySW5zdHJ1bWVudGF0aW9uOjpkaWRMb2FkWEhSKGNvb2tpZSlcbiAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwibG9hZGVuZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIi9Vc2Vycy9ibGFrZWVtYnJleS9Qcm9qZWN0cy9hcGktbm90ZWJvb2svbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qZ2xvYmFsIHVuZXNjYXBlLCBtb2R1bGUsIGRlZmluZSwgd2luZG93LCBnbG9iYWwqL1xyXG5cclxuLypcclxuIFVyaVRlbXBsYXRlIENvcHlyaWdodCAoYykgMjAxMi0yMDEzIEZyYW56IEFudGVzYmVyZ2VyLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gQXZhaWxhYmxlIHZpYSB0aGUgTUlUIGxpY2Vuc2UuXHJcbiovXHJcblxyXG4oZnVuY3Rpb24gKGV4cG9ydENhbGxiYWNrKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciBVcmlUZW1wbGF0ZUVycm9yID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICBmdW5jdGlvbiBVcmlUZW1wbGF0ZUVycm9yIChvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICBVcmlUZW1wbGF0ZUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoSlNPTiAmJiBKU09OLnN0cmluZ2lmeSkge1xyXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5vcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gVXJpVGVtcGxhdGVFcnJvcjtcclxufSgpKTtcclxuXHJcbnZhciBvYmplY3RIZWxwZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gaXNBcnJheSAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcgKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBTdHJpbmddJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIgKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuICh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmdW5jdGlvbiBqb2luIChhcnIsIHNlcGFyYXRvcikge1xyXG4gICAgICAgIHZhclxyXG4gICAgICAgICAgICByZXN1bHQgPSAnJyxcclxuICAgICAgICAgICAgZmlyc3QgPSB0cnVlLFxyXG4gICAgICAgICAgICBpbmRleDtcclxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBhcnIubGVuZ3RoOyBpbmRleCArPSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChmaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzZXBhcmF0b3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0ICs9IGFycltpbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWFwIChhcnIsIG1hcHBlcikge1xyXG4gICAgICAgIHZhclxyXG4gICAgICAgICAgICByZXN1bHQgPSBbXSxcclxuICAgICAgICAgICAgaW5kZXggPSAwO1xyXG4gICAgICAgIGZvciAoOyBpbmRleCA8IGFyci5sZW5ndGg7IGluZGV4ICs9IDEpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobWFwcGVyKGFycltpbmRleF0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmaWx0ZXIgKGFyciwgcHJlZGljYXRlKSB7XHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdLFxyXG4gICAgICAgICAgICBpbmRleCA9IDA7XHJcbiAgICAgICAgZm9yICg7IGluZGV4IDwgYXJyLmxlbmd0aDsgaW5kZXggKz0gMSkge1xyXG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKGFycltpbmRleF0pKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhcnJbaW5kZXhdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRlZXBGcmVlemVVc2luZ09iamVjdEZyZWV6ZSAob2JqZWN0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgIT09IFwib2JqZWN0XCIgfHwgb2JqZWN0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5mcmVlemUob2JqZWN0KTtcclxuICAgICAgICB2YXIgcHJvcGVydHksIHByb3BlcnR5TmFtZTtcclxuICAgICAgICBmb3IgKHByb3BlcnR5TmFtZSBpbiBvYmplY3QpIHtcclxuICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IG9iamVjdFtwcm9wZXJ0eU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgLy8gYmUgYXdhcmUsIGFycmF5cyBhcmUgJ29iamVjdCcsIHRvb1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZXBGcmVlemUocHJvcGVydHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVlcEZyZWV6ZSAob2JqZWN0KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZnJlZXplID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWVwRnJlZXplVXNpbmdPYmplY3RGcmVlemUob2JqZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBpc0FycmF5OiBpc0FycmF5LFxyXG4gICAgICAgIGlzU3RyaW5nOiBpc1N0cmluZyxcclxuICAgICAgICBpc051bWJlcjogaXNOdW1iZXIsXHJcbiAgICAgICAgaXNCb29sZWFuOiBpc0Jvb2xlYW4sXHJcbiAgICAgICAgam9pbjogam9pbixcclxuICAgICAgICBtYXA6IG1hcCxcclxuICAgICAgICBmaWx0ZXI6IGZpbHRlcixcclxuICAgICAgICBkZWVwRnJlZXplOiBkZWVwRnJlZXplXHJcbiAgICB9O1xyXG59KCkpO1xyXG5cclxudmFyIGNoYXJIZWxwZXIgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzQWxwaGEgKGNocikge1xyXG4gICAgICAgIHJldHVybiAoY2hyID49ICdhJyAmJiBjaHIgPD0gJ3onKSB8fCAoKGNociA+PSAnQScgJiYgY2hyIDw9ICdaJykpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzRGlnaXQgKGNocikge1xyXG4gICAgICAgIHJldHVybiBjaHIgPj0gJzAnICYmIGNociA8PSAnOSc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNIZXhEaWdpdCAoY2hyKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzRGlnaXQoY2hyKSB8fCAoY2hyID49ICdhJyAmJiBjaHIgPD0gJ2YnKSB8fCAoY2hyID49ICdBJyAmJiBjaHIgPD0gJ0YnKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlzQWxwaGE6IGlzQWxwaGEsXHJcbiAgICAgICAgaXNEaWdpdDogaXNEaWdpdCxcclxuICAgICAgICBpc0hleERpZ2l0OiBpc0hleERpZ2l0XHJcbiAgICB9O1xyXG59KCkpO1xyXG5cclxudmFyIHBjdEVuY29kZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHV0ZjggPSB7XHJcbiAgICAgICAgZW5jb2RlOiBmdW5jdGlvbiAoY2hyKSB7XHJcbiAgICAgICAgICAgIC8vIHNlZSBodHRwOi8vZWNtYW5hdXQuYmxvZ3Nwb3QuZGUvMjAwNi8wNy9lbmNvZGluZy1kZWNvZGluZy11dGY4LWluLWphdmFzY3JpcHQuaHRtbFxyXG4gICAgICAgICAgICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGNocikpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbnVtQnl0ZXM6IGZ1bmN0aW9uIChmaXJzdENoYXJDb2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChmaXJzdENoYXJDb2RlIDw9IDB4N0YpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKDB4QzIgPD0gZmlyc3RDaGFyQ29kZSAmJiBmaXJzdENoYXJDb2RlIDw9IDB4REYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKDB4RTAgPD0gZmlyc3RDaGFyQ29kZSAmJiBmaXJzdENoYXJDb2RlIDw9IDB4RUYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKDB4RjAgPD0gZmlyc3RDaGFyQ29kZSAmJiBmaXJzdENoYXJDb2RlIDw9IDB4RjQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiA0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG5vIHZhbGlkIGZpcnN0IG9jdGV0XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaXNWYWxpZEZvbGxvd2luZ0NoYXJDb2RlOiBmdW5jdGlvbiAoY2hhckNvZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDB4ODAgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gMHhCRjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogZW5jb2RlcyBhIGNoYXJhY3RlciwgaWYgbmVlZGVkIG9yIG5vdC5cclxuICAgICAqIEBwYXJhbSBjaHJcclxuICAgICAqIEByZXR1cm4gcGN0LWVuY29kZWQgY2hhcmFjdGVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGVuY29kZUNoYXJhY3RlciAoY2hyKSB7XHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnLFxyXG4gICAgICAgICAgICBvY3RldHMgPSB1dGY4LmVuY29kZShjaHIpLFxyXG4gICAgICAgICAgICBvY3RldCxcclxuICAgICAgICAgICAgaW5kZXg7XHJcbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgb2N0ZXRzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xyXG4gICAgICAgICAgICBvY3RldCA9IG9jdGV0cy5jaGFyQ29kZUF0KGluZGV4KTtcclxuICAgICAgICAgICAgcmVzdWx0ICs9ICclJyArIChvY3RldCA8IDB4MTAgPyAnMCcgOiAnJykgKyBvY3RldC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMsIHdoZXRoZXIgdGhlIGdpdmVuIHRleHQgYXQgc3RhcnQgaXMgaW4gdGhlIGZvcm0gJ3BlcmNlbnQgaGV4LWRpZ2l0IGhleC1kaWdpdCcsIGxpa2UgJyUzRidcclxuICAgICAqIEBwYXJhbSB0ZXh0XHJcbiAgICAgKiBAcGFyYW0gc3RhcnRcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW58KnwqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1BlcmNlbnREaWdpdERpZ2l0ICh0ZXh0LCBzdGFydCkge1xyXG4gICAgICAgIHJldHVybiB0ZXh0LmNoYXJBdChzdGFydCkgPT09ICclJyAmJiBjaGFySGVscGVyLmlzSGV4RGlnaXQodGV4dC5jaGFyQXQoc3RhcnQgKyAxKSkgJiYgY2hhckhlbHBlci5pc0hleERpZ2l0KHRleHQuY2hhckF0KHN0YXJ0ICsgMikpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIGEgaGV4IG51bWJlciBmcm9tIHN0YXJ0IHdpdGggbGVuZ3RoIDIuXHJcbiAgICAgKiBAcGFyYW0gdGV4dCBhIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHN0YXJ0IHRoZSBzdGFydCBpbmRleCBvZiB0aGUgMi1kaWdpdCBoZXggbnVtYmVyXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHBhcnNlSGV4MiAodGV4dCwgc3RhcnQpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VJbnQodGV4dC5zdWJzdHIoc3RhcnQsIDIpLCAxNik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBjaGFyIHNlcXVlbmNlIGlzIGEgY29ycmVjdGx5IHBjdC1lbmNvZGVkIHNlcXVlbmNlLlxyXG4gICAgICogQHBhcmFtIGNoclxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNQY3RFbmNvZGVkIChjaHIpIHtcclxuICAgICAgICBpZiAoIWlzUGVyY2VudERpZ2l0RGlnaXQoY2hyLCAwKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmaXJzdENoYXJDb2RlID0gcGFyc2VIZXgyKGNociwgMSk7XHJcbiAgICAgICAgdmFyIG51bUJ5dGVzID0gdXRmOC5udW1CeXRlcyhmaXJzdENoYXJDb2RlKTtcclxuICAgICAgICBpZiAobnVtQnl0ZXMgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBieXRlTnVtYmVyID0gMTsgYnl0ZU51bWJlciA8IG51bUJ5dGVzOyBieXRlTnVtYmVyICs9IDEpIHtcclxuICAgICAgICAgICAgaWYgKCFpc1BlcmNlbnREaWdpdERpZ2l0KGNociwgMypieXRlTnVtYmVyKSB8fCAhdXRmOC5pc1ZhbGlkRm9sbG93aW5nQ2hhckNvZGUocGFyc2VIZXgyKGNociwgMypieXRlTnVtYmVyICsgMSkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhcyBtdWNoIGFzIG5lZWRlZCBmcm9tIHRoZSB0ZXh0LCBlLmcuICclMjAnIG9yICclQzMlQjYnLiBJdCBkb2VzIG5vdCBkZWNvZGUhXHJcbiAgICAgKiBAcGFyYW0gdGV4dFxyXG4gICAgICogQHBhcmFtIHN0YXJ0SW5kZXhcclxuICAgICAqIEByZXR1cm4gdGhlIGNoYXJhY3RlciBvciBwY3Qtc3RyaW5nIG9mIHRoZSB0ZXh0IGF0IHN0YXJ0SW5kZXhcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcGN0Q2hhckF0KHRleHQsIHN0YXJ0SW5kZXgpIHtcclxuICAgICAgICB2YXIgY2hyID0gdGV4dC5jaGFyQXQoc3RhcnRJbmRleCk7XHJcbiAgICAgICAgaWYgKCFpc1BlcmNlbnREaWdpdERpZ2l0KHRleHQsIHN0YXJ0SW5kZXgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB1dGY4Q2hhckNvZGUgPSBwYXJzZUhleDIodGV4dCwgc3RhcnRJbmRleCArIDEpO1xyXG4gICAgICAgIHZhciBudW1CeXRlcyA9IHV0ZjgubnVtQnl0ZXModXRmOENoYXJDb2RlKTtcclxuICAgICAgICBpZiAobnVtQnl0ZXMgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNocjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgYnl0ZU51bWJlciA9IDE7IGJ5dGVOdW1iZXIgPCBudW1CeXRlczsgYnl0ZU51bWJlciArPSAxKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNQZXJjZW50RGlnaXREaWdpdCh0ZXh0LCBzdGFydEluZGV4ICsgMyAqIGJ5dGVOdW1iZXIpIHx8ICF1dGY4LmlzVmFsaWRGb2xsb3dpbmdDaGFyQ29kZShwYXJzZUhleDIodGV4dCwgc3RhcnRJbmRleCArIDMgKiBieXRlTnVtYmVyICsgMSkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0ZXh0LnN1YnN0cihzdGFydEluZGV4LCAzICogbnVtQnl0ZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZW5jb2RlQ2hhcmFjdGVyOiBlbmNvZGVDaGFyYWN0ZXIsXHJcbiAgICAgICAgaXNQY3RFbmNvZGVkOiBpc1BjdEVuY29kZWQsXHJcbiAgICAgICAgcGN0Q2hhckF0OiBwY3RDaGFyQXRcclxuICAgIH07XHJcbn0oKSk7XHJcblxyXG52YXIgcmZjQ2hhckhlbHBlciA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGlmIGFuIGNoYXJhY3RlciBpcyBhbiB2YXJjaGFyIGNoYXJhY3RlciBhY2NvcmRpbmcgMi4zIG9mIHJmYyA2NTcwXHJcbiAgICAgKiBAcGFyYW0gY2hyXHJcbiAgICAgKiBAcmV0dXJuIChCb29sZWFuKVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1ZhcmNoYXIgKGNocikge1xyXG4gICAgICAgIHJldHVybiBjaGFySGVscGVyLmlzQWxwaGEoY2hyKSB8fCBjaGFySGVscGVyLmlzRGlnaXQoY2hyKSB8fCBjaHIgPT09ICdfJyB8fCBwY3RFbmNvZGVyLmlzUGN0RW5jb2RlZChjaHIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpZiBjaHIgaXMgYW4gdW5yZXNlcnZlZCBjaGFyYWN0ZXIgYWNjb3JkaW5nIDEuNSBvZiByZmMgNjU3MFxyXG4gICAgICogQHBhcmFtIGNoclxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNVbnJlc2VydmVkIChjaHIpIHtcclxuICAgICAgICByZXR1cm4gY2hhckhlbHBlci5pc0FscGhhKGNocikgfHwgY2hhckhlbHBlci5pc0RpZ2l0KGNocikgfHwgY2hyID09PSAnLScgfHwgY2hyID09PSAnLicgfHwgY2hyID09PSAnXycgfHwgY2hyID09PSAnfic7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGlmIGNociBpcyBhbiByZXNlcnZlZCBjaGFyYWN0ZXIgYWNjb3JkaW5nIDEuNSBvZiByZmMgNjU3MFxyXG4gICAgICogb3IgdGhlIHBlcmNlbnQgY2hhcmFjdGVyIG1lbnRpb25lZCBpbiAzLjIuMS5cclxuICAgICAqIEBwYXJhbSBjaHJcclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKGNocikge1xyXG4gICAgICAgIHJldHVybiBjaHIgPT09ICc6JyB8fCBjaHIgPT09ICcvJyB8fCBjaHIgPT09ICc/JyB8fCBjaHIgPT09ICcjJyB8fCBjaHIgPT09ICdbJyB8fCBjaHIgPT09ICddJyB8fCBjaHIgPT09ICdAJyB8fCBjaHIgPT09ICchJyB8fCBjaHIgPT09ICckJyB8fCBjaHIgPT09ICcmJyB8fCBjaHIgPT09ICcoJyB8fFxyXG4gICAgICAgICAgICBjaHIgPT09ICcpJyB8fCBjaHIgPT09ICcqJyB8fCBjaHIgPT09ICcrJyB8fCBjaHIgPT09ICcsJyB8fCBjaHIgPT09ICc7JyB8fCBjaHIgPT09ICc9JyB8fCBjaHIgPT09IFwiJ1wiO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaXNWYXJjaGFyOiBpc1ZhcmNoYXIsXHJcbiAgICAgICAgaXNVbnJlc2VydmVkOiBpc1VucmVzZXJ2ZWQsXHJcbiAgICAgICAgaXNSZXNlcnZlZDogaXNSZXNlcnZlZFxyXG4gICAgfTtcclxuXHJcbn0oKSk7XHJcblxyXG4vKipcclxuICogZW5jb2Rpbmcgb2YgcmZjIDY1NzBcclxuICovXHJcbnZhciBlbmNvZGluZ0hlbHBlciA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gZW5jb2RlICh0ZXh0LCBwYXNzUmVzZXJ2ZWQpIHtcclxuICAgICAgICB2YXJcclxuICAgICAgICAgICAgcmVzdWx0ID0gJycsXHJcbiAgICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgICBjaHIgPSAnJztcclxuICAgICAgICBpZiAodHlwZW9mIHRleHQgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHRleHQgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRleHQubGVuZ3RoOyBpbmRleCArPSBjaHIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNociA9IHRleHQuY2hhckF0KGluZGV4KTtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IHJmY0NoYXJIZWxwZXIuaXNVbnJlc2VydmVkKGNocikgfHwgKHBhc3NSZXNlcnZlZCAmJiByZmNDaGFySGVscGVyLmlzUmVzZXJ2ZWQoY2hyKSkgPyBjaHIgOiBwY3RFbmNvZGVyLmVuY29kZUNoYXJhY3RlcihjaHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGVuY29kZVBhc3NSZXNlcnZlZCAodGV4dCkge1xyXG4gICAgICAgIHJldHVybiBlbmNvZGUodGV4dCwgdHJ1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZW5jb2RlTGl0ZXJhbENoYXJhY3RlciAobGl0ZXJhbCwgaW5kZXgpIHtcclxuICAgICAgICB2YXIgY2hyID0gcGN0RW5jb2Rlci5wY3RDaGFyQXQobGl0ZXJhbCwgaW5kZXgpO1xyXG4gICAgICAgIGlmIChjaHIubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2hyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJmY0NoYXJIZWxwZXIuaXNSZXNlcnZlZChjaHIpIHx8IHJmY0NoYXJIZWxwZXIuaXNVbnJlc2VydmVkKGNocikgPyBjaHIgOiBwY3RFbmNvZGVyLmVuY29kZUNoYXJhY3RlcihjaHIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlbmNvZGVMaXRlcmFsIChsaXRlcmFsKSB7XHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnLFxyXG4gICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgY2hyID0gJyc7XHJcbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGl0ZXJhbC5sZW5ndGg7IGluZGV4ICs9IGNoci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY2hyID0gcGN0RW5jb2Rlci5wY3RDaGFyQXQobGl0ZXJhbCwgaW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAoY2hyLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjaHI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gcmZjQ2hhckhlbHBlci5pc1Jlc2VydmVkKGNocikgfHwgcmZjQ2hhckhlbHBlci5pc1VucmVzZXJ2ZWQoY2hyKSA/IGNociA6IHBjdEVuY29kZXIuZW5jb2RlQ2hhcmFjdGVyKGNocik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGVuY29kZTogZW5jb2RlLFxyXG4gICAgICAgIGVuY29kZVBhc3NSZXNlcnZlZDogZW5jb2RlUGFzc1Jlc2VydmVkLFxyXG4gICAgICAgIGVuY29kZUxpdGVyYWw6IGVuY29kZUxpdGVyYWwsXHJcbiAgICAgICAgZW5jb2RlTGl0ZXJhbENoYXJhY3RlcjogZW5jb2RlTGl0ZXJhbENoYXJhY3RlclxyXG4gICAgfTtcclxuXHJcbn0oKSk7XHJcblxyXG5cclxuLy8gdGhlIG9wZXJhdG9ycyBkZWZpbmVkIGJ5IHJmYyA2NTcwXHJcbnZhciBvcGVyYXRvcnMgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIHZhclxyXG4gICAgICAgIGJ5U3ltYm9sID0ge307XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlIChzeW1ib2wpIHtcclxuICAgICAgICBieVN5bWJvbFtzeW1ib2xdID0ge1xyXG4gICAgICAgICAgICBzeW1ib2w6IHN5bWJvbCxcclxuICAgICAgICAgICAgc2VwYXJhdG9yOiAoc3ltYm9sID09PSAnPycpID8gJyYnIDogKHN5bWJvbCA9PT0gJycgfHwgc3ltYm9sID09PSAnKycgfHwgc3ltYm9sID09PSAnIycpID8gJywnIDogc3ltYm9sLFxyXG4gICAgICAgICAgICBuYW1lZDogc3ltYm9sID09PSAnOycgfHwgc3ltYm9sID09PSAnJicgfHwgc3ltYm9sID09PSAnPycsXHJcbiAgICAgICAgICAgIGlmRW1wdHk6IChzeW1ib2wgPT09ICcmJyB8fCBzeW1ib2wgPT09ICc/JykgPyAnPScgOiAnJyxcclxuICAgICAgICAgICAgZmlyc3Q6IChzeW1ib2wgPT09ICcrJyApID8gJycgOiBzeW1ib2wsXHJcbiAgICAgICAgICAgIGVuY29kZTogKHN5bWJvbCA9PT0gJysnIHx8IHN5bWJvbCA9PT0gJyMnKSA/IGVuY29kaW5nSGVscGVyLmVuY29kZVBhc3NSZXNlcnZlZCA6IGVuY29kaW5nSGVscGVyLmVuY29kZSxcclxuICAgICAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN5bWJvbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlKCcnKTtcclxuICAgIGNyZWF0ZSgnKycpO1xyXG4gICAgY3JlYXRlKCcjJyk7XHJcbiAgICBjcmVhdGUoJy4nKTtcclxuICAgIGNyZWF0ZSgnLycpO1xyXG4gICAgY3JlYXRlKCc7Jyk7XHJcbiAgICBjcmVhdGUoJz8nKTtcclxuICAgIGNyZWF0ZSgnJicpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2YWx1ZU9mOiBmdW5jdGlvbiAoY2hyKSB7XHJcbiAgICAgICAgICAgIGlmIChieVN5bWJvbFtjaHJdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnlTeW1ib2xbY2hyXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoXCI9LCFAfFwiLmluZGV4T2YoY2hyKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYnlTeW1ib2xbJyddO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn0oKSk7XHJcblxyXG5cclxuLyoqXHJcbiAqIERldGVjdHMsIHdoZXRoZXIgYSBnaXZlbiBlbGVtZW50IGlzIGRlZmluZWQgaW4gdGhlIHNlbnNlIG9mIHJmYyA2NTcwXHJcbiAqIFNlY3Rpb24gMi4zIG9mIHRoZSBSRkMgbWFrZXMgY2xlYXIgZGVmaW50aW9uczpcclxuICogKiB1bmRlZmluZWQgYW5kIG51bGwgYXJlIG5vdCBkZWZpbmVkLlxyXG4gKiAqIHRoZSBlbXB0eSBzdHJpbmcgaXMgZGVmaW5lZFxyXG4gKiAqIGFuIGFycmF5IChcImxpc3RcIikgaXMgZGVmaW5lZCwgaWYgaXQgaXMgbm90IGVtcHR5IChldmVuIGlmIGFsbCBlbGVtZW50cyBhcmUgbm90IGRlZmluZWQpXHJcbiAqICogYW4gb2JqZWN0IChcIm1hcFwiKSBpcyBkZWZpbmVkLCBpZiBpdCBjb250YWlucyBhdCBsZWFzdCBvbmUgcHJvcGVydHkgd2l0aCBkZWZpbmVkIHZhbHVlXHJcbiAqIEBwYXJhbSBvYmplY3RcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcbmZ1bmN0aW9uIGlzRGVmaW5lZCAob2JqZWN0KSB7XHJcbiAgICB2YXJcclxuICAgICAgICBwcm9wZXJ0eU5hbWU7XHJcbiAgICBpZiAob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKG9iamVjdEhlbHBlci5pc0FycmF5KG9iamVjdCkpIHtcclxuICAgICAgICAvLyBTZWN0aW9uIDIuMzogQSB2YXJpYWJsZSBkZWZpbmVkIGFzIGEgbGlzdCB2YWx1ZSBpcyBjb25zaWRlcmVkIHVuZGVmaW5lZCBpZiB0aGUgbGlzdCBjb250YWlucyB6ZXJvIG1lbWJlcnNcclxuICAgICAgICByZXR1cm4gb2JqZWN0Lmxlbmd0aCA+IDA7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Ygb2JqZWN0ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBvYmplY3QgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgICAgLy8gZmFsc3kgdmFsdWVzIGxpa2UgZW1wdHkgc3RyaW5ncywgZmFsc2Ugb3IgMCBhcmUgXCJkZWZpbmVkXCJcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIGVsc2UgT2JqZWN0XHJcbiAgICBmb3IgKHByb3BlcnR5TmFtZSBpbiBvYmplY3QpIHtcclxuICAgICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkgJiYgaXNEZWZpbmVkKG9iamVjdFtwcm9wZXJ0eU5hbWVdKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbnZhciBMaXRlcmFsRXhwcmVzc2lvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBMaXRlcmFsRXhwcmVzc2lvbiAobGl0ZXJhbCkge1xyXG4gICAgICAgIHRoaXMubGl0ZXJhbCA9IGVuY29kaW5nSGVscGVyLmVuY29kZUxpdGVyYWwobGl0ZXJhbCk7XHJcbiAgICB9XHJcblxyXG4gICAgTGl0ZXJhbEV4cHJlc3Npb24ucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5saXRlcmFsO1xyXG4gICAgfTtcclxuXHJcbiAgICBMaXRlcmFsRXhwcmVzc2lvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBMaXRlcmFsRXhwcmVzc2lvbi5wcm90b3R5cGUuZXhwYW5kO1xyXG5cclxuICAgIHJldHVybiBMaXRlcmFsRXhwcmVzc2lvbjtcclxufSgpKTtcclxuXHJcbnZhciBwYXJzZSA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uIChleHByZXNzaW9uVGV4dCkge1xyXG4gICAgICAgIHZhclxyXG4gICAgICAgICAgICBvcGVyYXRvcixcclxuICAgICAgICAgICAgdmFyc3BlY3MgPSBbXSxcclxuICAgICAgICAgICAgdmFyc3BlYyA9IG51bGwsXHJcbiAgICAgICAgICAgIHZhcm5hbWVTdGFydCA9IG51bGwsXHJcbiAgICAgICAgICAgIG1heExlbmd0aFN0YXJ0ID0gbnVsbCxcclxuICAgICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICAgIGNociA9ICcnO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBjbG9zZVZhcm5hbWUgKCkge1xyXG4gICAgICAgICAgICB2YXIgdmFybmFtZSA9IGV4cHJlc3Npb25UZXh0LnN1YnN0cmluZyh2YXJuYW1lU3RhcnQsIGluZGV4KTtcclxuICAgICAgICAgICAgaWYgKHZhcm5hbWUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7ZXhwcmVzc2lvblRleHQ6IGV4cHJlc3Npb25UZXh0LCBtZXNzYWdlOiBcImEgdmFybmFtZSBtdXN0IGJlIHNwZWNpZmllZFwiLCBwb3NpdGlvbjogaW5kZXh9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXJzcGVjID0ge3Zhcm5hbWU6IHZhcm5hbWUsIGV4cGxvZGVkOiBmYWxzZSwgbWF4TGVuZ3RoOiBudWxsfTtcclxuICAgICAgICAgICAgdmFybmFtZVN0YXJ0ID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGNsb3NlTWF4TGVuZ3RoICgpIHtcclxuICAgICAgICAgICAgaWYgKG1heExlbmd0aFN0YXJ0ID09PSBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVyaVRlbXBsYXRlRXJyb3Ioe2V4cHJlc3Npb25UZXh0OiBleHByZXNzaW9uVGV4dCwgbWVzc2FnZTogXCJhZnRlciBhICc6JyB5b3UgaGF2ZSB0byBzcGVjaWZ5IHRoZSBsZW5ndGhcIiwgcG9zaXRpb246IGluZGV4fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyc3BlYy5tYXhMZW5ndGggPSBwYXJzZUludChleHByZXNzaW9uVGV4dC5zdWJzdHJpbmcobWF4TGVuZ3RoU3RhcnQsIGluZGV4KSwgMTApO1xyXG4gICAgICAgICAgICBtYXhMZW5ndGhTdGFydCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvcGVyYXRvciA9IChmdW5jdGlvbiAob3BlcmF0b3JUZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBvcCA9IG9wZXJhdG9ycy52YWx1ZU9mKG9wZXJhdG9yVGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChvcCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVyaVRlbXBsYXRlRXJyb3Ioe2V4cHJlc3Npb25UZXh0OiBleHByZXNzaW9uVGV4dCwgbWVzc2FnZTogXCJpbGxlZ2FsIHVzZSBvZiByZXNlcnZlZCBvcGVyYXRvclwiLCBwb3NpdGlvbjogaW5kZXgsIG9wZXJhdG9yOiBvcGVyYXRvclRleHR9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb3A7XHJcbiAgICAgICAgfShleHByZXNzaW9uVGV4dC5jaGFyQXQoMCkpKTtcclxuICAgICAgICBpbmRleCA9IG9wZXJhdG9yLnN5bWJvbC5sZW5ndGg7XHJcblxyXG4gICAgICAgIHZhcm5hbWVTdGFydCA9IGluZGV4O1xyXG5cclxuICAgICAgICBmb3IgKDsgaW5kZXggPCBleHByZXNzaW9uVGV4dC5sZW5ndGg7IGluZGV4ICs9IGNoci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY2hyID0gcGN0RW5jb2Rlci5wY3RDaGFyQXQoZXhwcmVzc2lvblRleHQsIGluZGV4KTtcclxuXHJcbiAgICAgICAgICAgIGlmICh2YXJuYW1lU3RhcnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBzcGVjIHNheXM6IHZhcm5hbWUgPSAgdmFyY2hhciAqKCBbXCIuXCJdIHZhcmNoYXIgKVxyXG4gICAgICAgICAgICAgICAgLy8gc28gYSBkb3QgaXMgYWxsb3dlZCBleGNlcHQgZm9yIHRoZSBmaXJzdCBjaGFyXHJcbiAgICAgICAgICAgICAgICBpZiAoY2hyID09PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFybmFtZVN0YXJ0ID09PSBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7ZXhwcmVzc2lvblRleHQ6IGV4cHJlc3Npb25UZXh0LCBtZXNzYWdlOiBcImEgdmFybmFtZSBNVVNUIE5PVCBzdGFydCB3aXRoIGEgZG90XCIsIHBvc2l0aW9uOiBpbmRleH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZmNDaGFySGVscGVyLmlzVmFyY2hhcihjaHIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjbG9zZVZhcm5hbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWF4TGVuZ3RoU3RhcnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gbWF4TGVuZ3RoU3RhcnQgJiYgY2hyID09PSAnMCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7ZXhwcmVzc2lvblRleHQ6IGV4cHJlc3Npb25UZXh0LCBtZXNzYWdlOiBcIkEgOnByZWZpeCBtdXN0IG5vdCBzdGFydCB3aXRoIGRpZ2l0IDBcIiwgcG9zaXRpb246IGluZGV4fSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhckhlbHBlci5pc0RpZ2l0KGNocikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggLSBtYXhMZW5ndGhTdGFydCA+PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcmlUZW1wbGF0ZUVycm9yKHtleHByZXNzaW9uVGV4dDogZXhwcmVzc2lvblRleHQsIG1lc3NhZ2U6IFwiQSA6cHJlZml4IG11c3QgaGF2ZSBtYXggNCBkaWdpdHNcIiwgcG9zaXRpb246IGluZGV4fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2xvc2VNYXhMZW5ndGgoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2hyID09PSAnOicpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YXJzcGVjLm1heExlbmd0aCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcmlUZW1wbGF0ZUVycm9yKHtleHByZXNzaW9uVGV4dDogZXhwcmVzc2lvblRleHQsIG1lc3NhZ2U6IFwib25seSBvbmUgOm1heExlbmd0aCBpcyBhbGxvd2VkIHBlciB2YXJzcGVjXCIsIHBvc2l0aW9uOiBpbmRleH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHZhcnNwZWMuZXhwbG9kZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7ZXhwcmVzc2lvblRleHQ6IGV4cHJlc3Npb25UZXh0LCBtZXNzYWdlOiBcImFuIGV4cGxvZWRlZCB2YXJzcGVjIE1VU1QgTk9UIGJlIHZhcnNwZWNlZFwiLCBwb3NpdGlvbjogaW5kZXh9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1heExlbmd0aFN0YXJ0ID0gaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNociA9PT0gJyonKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFyc3BlYyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcmlUZW1wbGF0ZUVycm9yKHtleHByZXNzaW9uVGV4dDogZXhwcmVzc2lvblRleHQsIG1lc3NhZ2U6IFwiZXhwbG9kZWQgd2l0aG91dCB2YXJzcGVjXCIsIHBvc2l0aW9uOiBpbmRleH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHZhcnNwZWMuZXhwbG9kZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7ZXhwcmVzc2lvblRleHQ6IGV4cHJlc3Npb25UZXh0LCBtZXNzYWdlOiBcImV4cGxvZGVkIHR3aWNlXCIsIHBvc2l0aW9uOiBpbmRleH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHZhcnNwZWMubWF4TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVyaVRlbXBsYXRlRXJyb3Ioe2V4cHJlc3Npb25UZXh0OiBleHByZXNzaW9uVGV4dCwgbWVzc2FnZTogXCJhbiBleHBsb2RlICgqKSBNVVNUIE5PVCBmb2xsb3cgdG8gYSBwcmVmaXhcIiwgcG9zaXRpb246IGluZGV4fSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXJzcGVjLmV4cGxvZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRoZSBvbmx5IGxlZ2FsIGNoYXJhY3RlciBub3cgaXMgdGhlIGNvbW1hXHJcbiAgICAgICAgICAgIGlmIChjaHIgPT09ICcsJykge1xyXG4gICAgICAgICAgICAgICAgdmFyc3BlY3MucHVzaCh2YXJzcGVjKTtcclxuICAgICAgICAgICAgICAgIHZhcnNwZWMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFybmFtZVN0YXJ0ID0gaW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IFVyaVRlbXBsYXRlRXJyb3Ioe2V4cHJlc3Npb25UZXh0OiBleHByZXNzaW9uVGV4dCwgbWVzc2FnZTogXCJpbGxlZ2FsIGNoYXJhY3RlclwiLCBjaGFyYWN0ZXI6IGNociwgcG9zaXRpb246IGluZGV4fSk7XHJcbiAgICAgICAgfSAvLyBmb3IgY2hyXHJcbiAgICAgICAgaWYgKHZhcm5hbWVTdGFydCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjbG9zZVZhcm5hbWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1heExlbmd0aFN0YXJ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNsb3NlTWF4TGVuZ3RoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhcnNwZWNzLnB1c2godmFyc3BlYyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWYXJpYWJsZUV4cHJlc3Npb24oZXhwcmVzc2lvblRleHQsIG9wZXJhdG9yLCB2YXJzcGVjcyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2UgKHVyaVRlbXBsYXRlVGV4dCkge1xyXG4gICAgICAgIC8vIGFzc2VydCBmaWxsZWQgc3RyaW5nXHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgICBjaHIsXHJcbiAgICAgICAgICAgIGV4cHJlc3Npb25zID0gW10sXHJcbiAgICAgICAgICAgIGJyYWNlT3BlbkluZGV4ID0gbnVsbCxcclxuICAgICAgICAgICAgbGl0ZXJhbFN0YXJ0ID0gMDtcclxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB1cmlUZW1wbGF0ZVRleHQubGVuZ3RoOyBpbmRleCArPSAxKSB7XHJcbiAgICAgICAgICAgIGNociA9IHVyaVRlbXBsYXRlVGV4dC5jaGFyQXQoaW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAobGl0ZXJhbFN0YXJ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hyID09PSAnfScpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7dGVtcGxhdGVUZXh0OiB1cmlUZW1wbGF0ZVRleHQsIG1lc3NhZ2U6IFwidW5vcGVuZWQgYnJhY2UgY2xvc2VkXCIsIHBvc2l0aW9uOiBpbmRleH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNociA9PT0gJ3snKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpdGVyYWxTdGFydCA8IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2gobmV3IExpdGVyYWxFeHByZXNzaW9uKHVyaVRlbXBsYXRlVGV4dC5zdWJzdHJpbmcobGl0ZXJhbFN0YXJ0LCBpbmRleCkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbFN0YXJ0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBicmFjZU9wZW5JbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChicmFjZU9wZW5JbmRleCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaGVyZSBqdXN0IHsgaXMgZm9yYmlkZGVuXHJcbiAgICAgICAgICAgICAgICBpZiAoY2hyID09PSAneycpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7dGVtcGxhdGVUZXh0OiB1cmlUZW1wbGF0ZVRleHQsIG1lc3NhZ2U6IFwiYnJhY2UgYWxyZWFkeSBvcGVuZWRcIiwgcG9zaXRpb246IGluZGV4fSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hyID09PSAnfScpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYnJhY2VPcGVuSW5kZXggKyAxID09PSBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7dGVtcGxhdGVUZXh0OiB1cmlUZW1wbGF0ZVRleHQsIG1lc3NhZ2U6IFwiZW1wdHkgYnJhY2VzXCIsIHBvc2l0aW9uOiBicmFjZU9wZW5JbmRleH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHBhcnNlRXhwcmVzc2lvbih1cmlUZW1wbGF0ZVRleHQuc3Vic3RyaW5nKGJyYWNlT3BlbkluZGV4ICsgMSwgaW5kZXgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IucHJvdG90eXBlID09PSBVcmlUZW1wbGF0ZUVycm9yLnByb3RvdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVyaVRlbXBsYXRlRXJyb3Ioe3RlbXBsYXRlVGV4dDogdXJpVGVtcGxhdGVUZXh0LCBtZXNzYWdlOiBlcnJvci5vcHRpb25zLm1lc3NhZ2UsIHBvc2l0aW9uOiBicmFjZU9wZW5JbmRleCArIGVycm9yLm9wdGlvbnMucG9zaXRpb24sIGRldGFpbHM6IGVycm9yLm9wdGlvbnN9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJhY2VPcGVuSW5kZXggPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpdGVyYWxTdGFydCA9IGluZGV4ICsgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVhY2hlZCB1bnJlYWNoYWJsZSBjb2RlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChicmFjZU9wZW5JbmRleCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVXJpVGVtcGxhdGVFcnJvcih7dGVtcGxhdGVUZXh0OiB1cmlUZW1wbGF0ZVRleHQsIG1lc3NhZ2U6IFwidW5jbG9zZWQgYnJhY2VcIiwgcG9zaXRpb246IGJyYWNlT3BlbkluZGV4fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsaXRlcmFsU3RhcnQgPCB1cmlUZW1wbGF0ZVRleHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2gobmV3IExpdGVyYWxFeHByZXNzaW9uKHVyaVRlbXBsYXRlVGV4dC5zdWJzdHIobGl0ZXJhbFN0YXJ0KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFVyaVRlbXBsYXRlKHVyaVRlbXBsYXRlVGV4dCwgZXhwcmVzc2lvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYXJzZTtcclxufSgpKTtcclxuXHJcbnZhciBWYXJpYWJsZUV4cHJlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGlmIEpTT04gaXMgbm90IGF2YWlsYWJsZVxyXG4gICAgZnVuY3Rpb24gcHJldHR5UHJpbnQgKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIChKU09OICYmIEpTT04uc3RyaW5naWZ5KSA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzRW1wdHkgKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JqZWN0SGVscGVyLmlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2JqZWN0SGVscGVyLmlzTnVtYmVyKHZhbHVlKSB8fCBvYmplY3RIZWxwZXIuaXNCb29sZWFuKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYmplY3RIZWxwZXIuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA9PT0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvcGVydHlBcnJheSAob2JqZWN0KSB7XHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdLFxyXG4gICAgICAgICAgICBwcm9wZXJ0eU5hbWU7XHJcbiAgICAgICAgZm9yIChwcm9wZXJ0eU5hbWUgaW4gb2JqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe25hbWU6IHByb3BlcnR5TmFtZSwgdmFsdWU6IG9iamVjdFtwcm9wZXJ0eU5hbWVdfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBWYXJpYWJsZUV4cHJlc3Npb24gKHRlbXBsYXRlVGV4dCwgb3BlcmF0b3IsIHZhcnNwZWNzKSB7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVRleHQgPSB0ZW1wbGF0ZVRleHQ7XHJcbiAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xyXG4gICAgICAgIHRoaXMudmFyc3BlY3MgPSB2YXJzcGVjcztcclxuICAgIH1cclxuXHJcbiAgICBWYXJpYWJsZUV4cHJlc3Npb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlVGV4dDtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gZXhwYW5kU2ltcGxlVmFsdWUodmFyc3BlYywgb3BlcmF0b3IsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAob3BlcmF0b3IubmFtZWQpIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IGVuY29kaW5nSGVscGVyLmVuY29kZUxpdGVyYWwodmFyc3BlYy52YXJuYW1lKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IG9wZXJhdG9yLmlmRW1wdHk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSAnPSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YXJzcGVjLm1heExlbmd0aCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCB2YXJzcGVjLm1heExlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdCArPSBvcGVyYXRvci5lbmNvZGUodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdmFsdWVEZWZpbmVkIChuYW1lVmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gaXNEZWZpbmVkKG5hbWVWYWx1ZS52YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZXhwYW5kTm90RXhwbG9kZWQodmFyc3BlYywgb3BlcmF0b3IsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIGFyciA9IFtdLFxyXG4gICAgICAgICAgICByZXN1bHQgPSAnJztcclxuICAgICAgICBpZiAob3BlcmF0b3IubmFtZWQpIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IGVuY29kaW5nSGVscGVyLmVuY29kZUxpdGVyYWwodmFyc3BlYy52YXJuYW1lKTtcclxuICAgICAgICAgICAgaWYgKGlzRW1wdHkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gb3BlcmF0b3IuaWZFbXB0eTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0ICs9ICc9JztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9iamVjdEhlbHBlci5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICBhcnIgPSB2YWx1ZTtcclxuICAgICAgICAgICAgYXJyID0gb2JqZWN0SGVscGVyLmZpbHRlcihhcnIsIGlzRGVmaW5lZCk7XHJcbiAgICAgICAgICAgIGFyciA9IG9iamVjdEhlbHBlci5tYXAoYXJyLCBvcGVyYXRvci5lbmNvZGUpO1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gb2JqZWN0SGVscGVyLmpvaW4oYXJyLCAnLCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXJyID0gcHJvcGVydHlBcnJheSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGFyciA9IG9iamVjdEhlbHBlci5maWx0ZXIoYXJyLCB2YWx1ZURlZmluZWQpO1xyXG4gICAgICAgICAgICBhcnIgPSBvYmplY3RIZWxwZXIubWFwKGFyciwgZnVuY3Rpb24gKG5hbWVWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yLmVuY29kZShuYW1lVmFsdWUubmFtZSkgKyAnLCcgKyBvcGVyYXRvci5lbmNvZGUobmFtZVZhbHVlLnZhbHVlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBvYmplY3RIZWxwZXIuam9pbihhcnIsICcsJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZXhwYW5kRXhwbG9kZWROYW1lZCAodmFyc3BlYywgb3BlcmF0b3IsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIGlzQXJyYXkgPSBvYmplY3RIZWxwZXIuaXNBcnJheSh2YWx1ZSksXHJcbiAgICAgICAgICAgIGFyciA9IFtdO1xyXG4gICAgICAgIGlmIChpc0FycmF5KSB7XHJcbiAgICAgICAgICAgIGFyciA9IHZhbHVlO1xyXG4gICAgICAgICAgICBhcnIgPSBvYmplY3RIZWxwZXIuZmlsdGVyKGFyciwgaXNEZWZpbmVkKTtcclxuICAgICAgICAgICAgYXJyID0gb2JqZWN0SGVscGVyLm1hcChhcnIsIGZ1bmN0aW9uIChsaXN0RWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IGVuY29kaW5nSGVscGVyLmVuY29kZUxpdGVyYWwodmFyc3BlYy52YXJuYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KGxpc3RFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcCArPSBvcGVyYXRvci5pZkVtcHR5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG1wICs9ICc9JyArIG9wZXJhdG9yLmVuY29kZShsaXN0RWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFyciA9IHByb3BlcnR5QXJyYXkodmFsdWUpO1xyXG4gICAgICAgICAgICBhcnIgPSBvYmplY3RIZWxwZXIuZmlsdGVyKGFyciwgdmFsdWVEZWZpbmVkKTtcclxuICAgICAgICAgICAgYXJyID0gb2JqZWN0SGVscGVyLm1hcChhcnIsIGZ1bmN0aW9uIChuYW1lVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBlbmNvZGluZ0hlbHBlci5lbmNvZGVMaXRlcmFsKG5hbWVWYWx1ZS5uYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KG5hbWVWYWx1ZS52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0bXAgKz0gb3BlcmF0b3IuaWZFbXB0eTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcCArPSAnPScgKyBvcGVyYXRvci5lbmNvZGUobmFtZVZhbHVlLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqZWN0SGVscGVyLmpvaW4oYXJyLCBvcGVyYXRvci5zZXBhcmF0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGV4cGFuZEV4cGxvZGVkVW5uYW1lZCAob3BlcmF0b3IsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIGFyciA9IFtdLFxyXG4gICAgICAgICAgICByZXN1bHQgPSAnJztcclxuICAgICAgICBpZiAob2JqZWN0SGVscGVyLmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGFyciA9IHZhbHVlO1xyXG4gICAgICAgICAgICBhcnIgPSBvYmplY3RIZWxwZXIuZmlsdGVyKGFyciwgaXNEZWZpbmVkKTtcclxuICAgICAgICAgICAgYXJyID0gb2JqZWN0SGVscGVyLm1hcChhcnIsIG9wZXJhdG9yLmVuY29kZSk7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBvYmplY3RIZWxwZXIuam9pbihhcnIsIG9wZXJhdG9yLnNlcGFyYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhcnIgPSBwcm9wZXJ0eUFycmF5KHZhbHVlKTtcclxuICAgICAgICAgICAgYXJyID0gb2JqZWN0SGVscGVyLmZpbHRlcihhcnIsIGZ1bmN0aW9uIChuYW1lVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc0RlZmluZWQobmFtZVZhbHVlLnZhbHVlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGFyciA9IG9iamVjdEhlbHBlci5tYXAoYXJyLCBmdW5jdGlvbiAobmFtZVZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IuZW5jb2RlKG5hbWVWYWx1ZS5uYW1lKSArICc9JyArIG9wZXJhdG9yLmVuY29kZShuYW1lVmFsdWUudmFsdWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IG9iamVjdEhlbHBlci5qb2luKGFyciwgb3BlcmF0b3Iuc2VwYXJhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgVmFyaWFibGVFeHByZXNzaW9uLnByb3RvdHlwZS5leHBhbmQgPSBmdW5jdGlvbiAodmFyaWFibGVzKSB7XHJcbiAgICAgICAgdmFyXHJcbiAgICAgICAgICAgIGV4cGFuZGVkID0gW10sXHJcbiAgICAgICAgICAgIGluZGV4LFxyXG4gICAgICAgICAgICB2YXJzcGVjLFxyXG4gICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgdmFsdWVJc0FycixcclxuICAgICAgICAgICAgb25lRXhwbG9kZWQgPSBmYWxzZSxcclxuICAgICAgICAgICAgb3BlcmF0b3IgPSB0aGlzLm9wZXJhdG9yO1xyXG5cclxuICAgICAgICAvLyBleHBhbmQgZWFjaCB2YXJzcGVjIGFuZCBqb2luIHdpdGggb3BlcmF0b3IncyBzZXBhcmF0b3JcclxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnZhcnNwZWNzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xyXG4gICAgICAgICAgICB2YXJzcGVjID0gdGhpcy52YXJzcGVjc1tpbmRleF07XHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFyaWFibGVzW3ZhcnNwZWMudmFybmFtZV07XHJcbiAgICAgICAgICAgIC8vIGlmICghaXNEZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAvLyBpZiAodmFyaWFibGVzLmhhc093blByb3BlcnR5KHZhcnNwZWMubmFtZSkpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YXJzcGVjLmV4cGxvZGVkKSB7XHJcbiAgICAgICAgICAgICAgICBvbmVFeHBsb2RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFsdWVJc0FyciA9IG9iamVjdEhlbHBlci5pc0FycmF5KHZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgICAgICAgICAgZXhwYW5kZWQucHVzaChleHBhbmRTaW1wbGVWYWx1ZSh2YXJzcGVjLCBvcGVyYXRvciwgdmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2YXJzcGVjLm1heExlbmd0aCAmJiBpc0RlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAyLjQuMSBvZiB0aGUgc3BlYyBzYXlzOiBcIlByZWZpeCBtb2RpZmllcnMgYXJlIG5vdCBhcHBsaWNhYmxlIHRvIHZhcmlhYmxlcyB0aGF0IGhhdmUgY29tcG9zaXRlIHZhbHVlcy5cIlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcmVmaXggbW9kaWZpZXJzIGFyZSBub3QgYXBwbGljYWJsZSB0byB2YXJpYWJsZXMgdGhhdCBoYXZlIGNvbXBvc2l0ZSB2YWx1ZXMuIFlvdSB0cmllZCB0byBleHBhbmQgJyArIHRoaXMgKyBcIiB3aXRoIFwiICsgcHJldHR5UHJpbnQodmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghdmFyc3BlYy5leHBsb2RlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yLm5hbWVkIHx8ICFpc0VtcHR5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZGVkLnB1c2goZXhwYW5kTm90RXhwbG9kZWQodmFyc3BlYywgb3BlcmF0b3IsIHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yLm5hbWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQucHVzaChleHBhbmRFeHBsb2RlZE5hbWVkKHZhcnNwZWMsIG9wZXJhdG9yLCB2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQucHVzaChleHBhbmRFeHBsb2RlZFVubmFtZWQob3BlcmF0b3IsIHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChleHBhbmRlZC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IuZmlyc3QgKyBvYmplY3RIZWxwZXIuam9pbihleHBhbmRlZCwgb3BlcmF0b3Iuc2VwYXJhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBWYXJpYWJsZUV4cHJlc3Npb247XHJcbn0oKSk7XHJcblxyXG52YXIgVXJpVGVtcGxhdGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVXJpVGVtcGxhdGUgKHRlbXBsYXRlVGV4dCwgZXhwcmVzc2lvbnMpIHtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlVGV4dCA9IHRlbXBsYXRlVGV4dDtcclxuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XHJcbiAgICAgICAgb2JqZWN0SGVscGVyLmRlZXBGcmVlemUodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgVXJpVGVtcGxhdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlVGV4dDtcclxuICAgIH07XHJcblxyXG4gICAgVXJpVGVtcGxhdGUucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uICh2YXJpYWJsZXMpIHtcclxuICAgICAgICAvLyB0aGlzLmV4cHJlc3Npb25zLm1hcChmdW5jdGlvbiAoZXhwcmVzc2lvbikge3JldHVybiBleHByZXNzaW9uLmV4cGFuZCh2YXJpYWJsZXMpO30pLmpvaW4oJycpO1xyXG4gICAgICAgIHZhclxyXG4gICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5leHByZXNzaW9ucy5sZW5ndGg7IGluZGV4ICs9IDEpIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuZXhwcmVzc2lvbnNbaW5kZXhdLmV4cGFuZCh2YXJpYWJsZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICBVcmlUZW1wbGF0ZS5wYXJzZSA9IHBhcnNlO1xyXG4gICAgVXJpVGVtcGxhdGUuVXJpVGVtcGxhdGVFcnJvciA9IFVyaVRlbXBsYXRlRXJyb3I7XHJcbiAgICByZXR1cm4gVXJpVGVtcGxhdGU7XHJcbn0oKSk7XHJcblxyXG4gICAgZXhwb3J0Q2FsbGJhY2soVXJpVGVtcGxhdGUpO1xyXG5cclxufShmdW5jdGlvbiAoVXJpVGVtcGxhdGUpIHtcclxuICAgICAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgICAgICAvLyBleHBvcnQgVXJpVGVtcGxhdGUsIHdoZW4gbW9kdWxlIGlzIHByZXNlbnQsIG9yIHBhc3MgaXQgdG8gd2luZG93IG9yIGdsb2JhbFxyXG4gICAgICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gVXJpVGVtcGxhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICBkZWZpbmUoW10sZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVXJpVGVtcGxhdGU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5VcmlUZW1wbGF0ZSA9IFVyaVRlbXBsYXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2xvYmFsLlVyaVRlbXBsYXRlID0gVXJpVGVtcGxhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4pKTtcclxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIi8qKlxuICogQWNjZXB0cyBhbiBhcnJheSBvZiBzdHJpbmdzIHRoYXQgcmVwcmVzZW50IGEgcmVmZXJlbmNlIHRvIGEgdmFsdWUgb24gYW5cbiAqIG9iamVjdC4gU3VwcG9ydHMgcGFzc2luZyBhbiBvcHRpb25hbCBzZXR0ZXIsIHRvIHNldCB0aGUgdmFsdWUuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSAge0FycmF5fSAgcGF0aFxuICogQHBhcmFtICB7Kn0gICAgICBbc2V0dGVyXVxuICogQHJldHVybiB7Kn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBwYXRoLCBzZXR0ZXIpIHtcbiAgdmFyIGlzU2V0dGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSBwYXRoW2ldO1xuXG4gICAgaWYgKGlzU2V0dGVyKSB7XG4gICAgICBpZiAoaSA9PT0gcGF0aC5sZW5ndGggLSAxKSB7XG4gICAgICAgIG9iamVjdFtwcm9wXSA9IHNldHRlcjtcbiAgICAgIH0gZWxzZSBpZiAoIShwcm9wIGluIG9iamVjdCkpIHtcbiAgICAgICAgb2JqZWN0W3Byb3BdID0ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgb2JqZWN0ID0gb2JqZWN0W3Byb3BdO1xuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSB1cGRhdGVkIG9iamVjdCByZWZlcmVuY2UuXG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwiLyogZ2xvYmFsIEFwcCAqL1xudmFyIF8gICAgID0gQXBwLkxpYnJhcnkuXztcbnZhciBhc3luYyA9IEFwcC5MaWJyYXJ5LmFzeW5jO1xuXG4vKipcbiAqIE1hcCBhdXRoZW50aWNhdGlvbiB0eXBlcyB0byBhdXRvbWF0aWMgcHJlZmVyZW5jZS5cbiAqXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbnZhciBPUkRFUl9QUkVGRVJFTkNFID0gWydPQXV0aCAyLjAnLCAnT0F1dGggMS4wJywgJ0Jhc2ljIEF1dGhlbnRpY2F0aW9uJ107XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3Qgb2YgYXZhaWxhYmxlIGtleXMgYW5kIHdoZXRoZXIgdGhleSBhcmUgcmVxdWlyZWQuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBzY2hlbWVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudmFyIHJlcXVpcmVkVG9rZW5zID0gZnVuY3Rpb24gKHNjaGVtZSkge1xuICB2YXIga2V5cyA9IF8uZXh0ZW5kKHt9LCByZXF1aXJlZFRva2Vucy5kZWZhdWx0c1tzY2hlbWUudHlwZV0pO1xuXG4gIC8vIFNwZWNpYWwgY2FzZSBpcyByZXF1aXJlZCBmb3IgT0F1dGgyIGltcGxpY2l0IGF1dGggZmxvdy5cbiAgaWYgKHNjaGVtZS50eXBlID09PSAnT0F1dGggMi4wJykge1xuICAgIGtleXMuY2xpZW50U2VjcmV0ID0gIV8uY29udGFpbnMoXG4gICAgICBzY2hlbWUuc2V0dGluZ3MuYXV0aG9yaXphdGlvbkdyYW50cywgJ3Rva2VuJ1xuICAgICk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn07XG5cbi8qKlxuICogU2FuaXRpemUgc2NvcGVzIHRvIGJlIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSAgeyp9ICAgICBzY29wZXNcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG52YXIgc2FuaXRpemVTY29wZSA9IGZ1bmN0aW9uIChzY29wZXMpIHtcbiAgaWYgKF8uaXNTdHJpbmcoc2NvcGVzKSkge1xuICAgIHJldHVybiBzY29wZXMuc3BsaXQoJyAnKTtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShzY29wZXMpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIHNjb3Blcztcbn07XG5cbi8qKlxuICogUmVxdWlyZWQgYXV0aGVudGljYXRpb24ga2V5cyB1c2VkIHRvIGNoZWNrIHRoZSBvcHRpb25zIG9iamVjdC5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5yZXF1aXJlZFRva2Vucy5kZWZhdWx0cyA9IHtcbiAgJ09BdXRoIDEuMCc6IHtcbiAgICBjb25zdW1lcktleTogICAgdHJ1ZSxcbiAgICBjb25zdW1lclNlY3JldDogdHJ1ZVxuICB9LFxuICAnT0F1dGggMi4wJzoge1xuICAgIGNsaWVudElkOiAgICAgdHJ1ZSxcbiAgICBjbGllbnRTZWNyZXQ6IHRydWVcbiAgfSxcbiAgJ0Jhc2ljIEF1dGhlbnRpY2F0aW9uJzoge1xuICAgIHVzZXJuYW1lOiB0cnVlLFxuICAgIHBhc3N3b3JkOiB0cnVlXG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgdGhlIHRva2VucyBvYmplY3QgYWdhaW5zdCB0aGUgcmVxdWlyZWQgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gIHNjaGVtZVxuICogQHBhcmFtICB7T2JqZWN0fSAgdG9rZW5zXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaGFzUmVxdWlyZWRUb2tlbnMgPSBmdW5jdGlvbiAoc2NoZW1lLCB0b2tlbnMpIHtcbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSByZXF1aXJlZCB0b2tlbnMgYW5kIGNoZWNrIHRoYXQgdGhlIHRva2VuIGlzIGRlZmluZWQuXG4gIHJldHVybiBfLmV2ZXJ5KHJlcXVpcmVkVG9rZW5zKHNjaGVtZSksIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIHZhbHVlID8gdG9rZW5zW2tleV0gOiB0cnVlO1xuICB9KTtcbn07XG5cbi8qKlxuICogUHJvbXB0IHRoZSB1c2VyIGZvciBhdXRoZW50aWNhdGlvbiB0b2tlbnMgYmFzZWQgb24gYSBzY2hlbWUuIFdlIGNhbiBwYXNzIGluXG4gKiB0aGUgY3VycmVudCBvcHRpb25zIG9iamVjdCB0byBoZWxwIGRlY2lkZSB3aGF0IGRhdGEgdG8gZGlzcGxheSB0byB0aGUgdXNlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBzY2hlbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAqL1xudmFyIHByb21wdFRva2VucyA9IGZ1bmN0aW9uIChzY2hlbWUsIG9wdGlvbnMsIGRvbmUpIHtcbiAgdmFyIGNhbmNlbGxlZCAgID0gdHJ1ZTtcbiAgdmFyIG5lZWRzVG9rZW5zID0gcmVxdWlyZWRUb2tlbnMoc2NoZW1lKTtcblxuICAvLyBHZW5lcmF0ZSBhbiBhcnJheSBvZiB0aGUgdG9rZW5zIHRvIHVzZSB3aXRoIG91ciBwcm9tcHQgYW5kIGZpbHRlclxuICAvLyBleHBsaWNpdGx5IG5vdCByZXF1aXJlZCB0b2tlbnMuXG4gIHZhciBwb3NzaWJsZVRva2VucyA9IF8uZmlsdGVyKFxuICAgIHByb21wdFRva2Vucy5wb3NzaWJsZVRva2Vuc1tzY2hlbWUudHlwZV0sXG4gICAgZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICByZXR1cm4gbmVlZHNUb2tlbnNbdG9rZW5dICE9PSBmYWxzZTtcbiAgICB9XG4gICk7XG5cbiAgLy8gTXVsdGlwbGUgd2F5cyBvZiBzZXR0aW5nIHRoZSBzY29wZSBvcHRpb24uXG4gIG9wdGlvbnMuc2NvcGVzID0gc2FuaXRpemVTY29wZShvcHRpb25zLnNjb3BlIHx8IG9wdGlvbnMuc2NvcGVzKTtcbiAgZGVsZXRlIG9wdGlvbnMuc2NvcGU7XG5cbiAgLy8gR2VuZXJhdGUgdGhlIGZvcm0gdG8gcHJvbXB0IHRoZSB1c2VyIHdpdGguXG4gIHZhciBwcm9tcHRGb3JtID0gXy5tYXAocG9zc2libGVUb2tlbnMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoa2V5ID09PSAnc2NvcGVzJykge1xuICAgICAgdmFyIHNjb3BlcyA9IHNhbml0aXplU2NvcGUoc2NoZW1lLnNldHRpbmdzLnNjb3Blcyk7XG5cbiAgICAgIC8vIElnbm9yZSB0aGUgc2NvcGVzIHNlbGVjdGlvbiB3aGVuIG5vdGhpbmcgaXMgYXZhaWxhYmxlIGZvciBzZWxlY3Rpb24uXG4gICAgICBpZiAoIXNjb3Blcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXAgc2NvcGVzIHRvIGNoZWNrYm94IHNlbGVjdGlvbnMuXG4gICAgICB2YXIgc2NvcGVPcHRpb25zID0gXy5tYXAoc2NvcGVzLCBmdW5jdGlvbiAoc2NvcGUpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHNjb3BlIGlzIGFscmVhZHkgaW4gdGhlIHNlbGVjdGVkIHNjb3Blcy4gSWYgdGhlcmUgaXNcbiAgICAgICAgLy8gb25seSBvbmUgcG9zc2libGUgc2NvcGUsIGp1c3Qgc2VsZWN0IGl0IGJ5IGRlZmF1bHQgYW55d2F5LlxuICAgICAgICB2YXIgaGFzU2NvcGUgPSBfLmNvbnRhaW5zKG9wdGlvbnMuc2NvcGVzLCBzY29wZSkgfHwgc2NvcGVzLmxlbmd0aCA9PT0gMTtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiY2hlY2tib3hcIj4nLFxuICAgICAgICAgICc8bGFiZWw+JyxcbiAgICAgICAgICAnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkPVwic2NvcGVzXCIgdmFsdWU9XCInICsgc2NvcGUgKyAnXCIgJyArXG4gICAgICAgICAgICAoaGFzU2NvcGUgPyAnY2hlY2tlZCcgOiAnJykgKyAnPicsXG4gICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgJzwvbGFiZWw+JyxcbiAgICAgICAgICAnPC9kaXY+J1xuICAgICAgICBdLmpvaW4oJycpO1xuICAgICAgfSkuam9pbignXFxuJyk7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPicsXG4gICAgICAgICc8bGFiZWwgY2xhc3M9XCJmb3JtLWxhYmVsXCI+JyArIHByb21wdFRva2Vucy50aXRsZXNba2V5XSArICc8L2xhYmVsPicsXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiZm9ybS1jb250ZW50XCI+JyArIHNjb3BlT3B0aW9ucyArICc8L2Rpdj4nLFxuICAgICAgICAnPC9kaXY+J1xuICAgICAgXS5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0IHdlIHNob3cgdGhlIHVzZXIgYW4gaW5wdXQgZmllbGQgdG8gaW5wdXQgdGhlaXIga2V5cy5cbiAgICByZXR1cm4gW1xuICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+JyxcbiAgICAgICc8bGFiZWwgZm9yPVwiJyArIGtleSArICdcIiBjbGFzcz1cImZvcm0tbGFiZWxcIj4nLFxuICAgICAgcHJvbXB0VG9rZW5zLnRpdGxlc1trZXldLFxuICAgICAgJzwvbGFiZWw+JyxcbiAgICAgICc8ZGl2IGNsYXNzPVwiZm9ybS1jb250ZW50XCI+JyxcbiAgICAgICc8aW5wdXQgaWQ9XCInICsga2V5ICsgJ1wiIHZhbHVlPVwiJyArIChvcHRpb25zW2tleV0gfHwgJycpICsgJ1wiPicsXG4gICAgICAnPC9kaXY+JyxcbiAgICAgICc8L2Rpdj4nXG4gICAgXS5qb2luKCcnKTtcbiAgfSkuam9pbignXFxuJyk7XG5cbiAgcmV0dXJuIEFwcC5taWRkbGV3YXJlLnRyaWdnZXIoJ3VpOm1vZGFsJywge1xuICAgIHRpdGxlOiBwcm9tcHRUb2tlbnMucHJvbXB0c1tzY2hlbWUudHlwZV0sXG4gICAgY29udGVudDogW1xuICAgICAgJzxwPicsXG4gICAgICAnVGhpcyBBUEkgcmVxdWlyZXMgYXV0aGVudGljYXRpb24uIFBsZWFzZSBlbnRlciB5b3VyIGFwcGxpY2F0aW9uIGtleXMuJyxcbiAgICAgICc8L3A+JyxcbiAgICAgICc8cD48ZW0+V2Ugd2lsbCBub3Qgc3RvcmUgeW91ciBrZXlzLjwvZW0+PC9wPicsXG4gICAgICAnPGZvcm0+JyxcbiAgICAgIHByb21wdEZvcm0sXG4gICAgICAnPGRpdiBjbGFzcz1cImZvcm0tZm9vdGVyXCI+JyxcbiAgICAgICc8YnV0dG9uIHR5cGU9XCJzdWJtaXRcIiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiPlN1Ym1pdDwvYnV0dG9uPicsXG4gICAgICAnPC9kaXY+JyxcbiAgICAgICc8L2Zvcm0+J1xuICAgIF0uam9pbignXFxuJyksXG4gICAgc2hvdzogZnVuY3Rpb24gKG1vZGFsKSB7XG4gICAgICBtb2RhbC5lbC5xdWVyeVNlbGVjdG9yKCdmb3JtJylcbiAgICAgICAgLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgXy5lYWNoKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQnKSwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGVsLmdldEF0dHJpYnV0ZSgnaWQnKTtcblxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdzY29wZXMnKSB7XG4gICAgICAgICAgICAgIHZhciBpbmRleE9mID0gXy5pbmRleE9mKG9wdGlvbnMuc2NvcGVzLCBlbC52YWx1ZSk7XG5cbiAgICAgICAgICAgICAgaWYgKGVsLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhPZiA8IDApIHtcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2NvcGVzLnB1c2goZWwudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXhPZiA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICBvcHRpb25zLnNjb3Blcy5zcGxpY2UoaW5kZXhPZiwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvcHRpb25zW25hbWVdID0gZWwudmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgICAgbW9kYWwuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgcmV0dXJuIGRvbmUoZXJyIHx8IChjYW5jZWxsZWQgPyBuZXcgRXJyb3IoJ01vZGFsIGNsb3NlZCcpIDogbnVsbCksIG9wdGlvbnMpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRGVmYXVsdCBhdXRoZW50aWNhdGlvbiBwcm9tcHQgdGl0bGVzLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnByb21wdFRva2Vucy5wcm9tcHRzID0ge1xuICAnT0F1dGggMS4wJzogICAgICAgICAgICAnUGxlYXNlIEVudGVyIFlvdXIgT0F1dGggMS4wIEtleXMnLFxuICAnT0F1dGggMi4wJzogICAgICAgICAgICAnUGxlYXNlIEVudGVyIFlvdXIgT0F1dGggMi4wIEtleXMnLFxuICAnQmFzaWMgQXV0aGVudGljYXRpb24nOiAnUGxlYXNlIEVudGVyIFlvdXIgVXNlcm5hbWUgYW5kIFBhc3N3b3JkJ1xufTtcblxuLyoqXG4gKiBNYXAgb2Ygb2JqZWN0IGtleXMgdG8gdGhlaXIgcmVhZGFibGUgbmFtZXMuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xucHJvbXB0VG9rZW5zLnRpdGxlcyA9IHtcbiAgY29uc3VtZXJLZXk6ICAgICdDb25zdW1lciBLZXknLFxuICBjb25zdW1lclNlY3JldDogJ0NvbnN1bWVyIFNlY3JldCcsXG4gIGNsaWVudElkOiAgICAgICAnQ2xpZW50IElEJyxcbiAgY2xpZW50U2VjcmV0OiAgICdDbGllbnQgU2VjcmV0JyxcbiAgc2NvcGVzOiAgICAgICAgICdQZXJtaXNzaW9ucycsXG4gIHVzZXJuYW1lOiAgICAgICAnVXNlcm5hbWUnLFxuICBwYXNzd29yZDogICAgICAgJ1Bhc3N3b3JkJ1xufTtcblxuLyoqXG4gKiBQb3NzaWJsZSB0b2tlbnMgdG8gYmUgZmlsbGVkIG91dCBieSB0aGUgdXNlci5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5wcm9tcHRUb2tlbnMucG9zc2libGVUb2tlbnMgPSB7XG4gICdPQXV0aCAxLjAnOiAgICAgICAgICAgIFsnY29uc3VtZXJLZXknLCAnY29uc3VtZXJTZWNyZXQnXSxcbiAgJ09BdXRoIDIuMCc6ICAgICAgICAgICAgWydjbGllbnRJZCcsICdjbGllbnRTZWNyZXQnLCAnc2NvcGVzJ10sXG4gICdCYXNpYyBBdXRoZW50aWNhdGlvbic6IFsndXNlcm5hbWUnLCAncGFzc3dvcmQnXVxufTtcblxuLyoqXG4gKiBBdXRoZW50aWNhdGUgdXNpbmcgYW4gYXV0aGVudGljYXRpb24gc2NoZW1lIGFuZCBwYXNzZWQgaW4gb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgc2NoZW1lXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgb3B0aW9uc1xuICogQHBhcmFtICB7RnVuY3Rpb259IGRvbmVcbiAqL1xudmFyIGF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uIChzY2hlbWUsIG9wdGlvbnMsIGRvbmUpIHtcbiAgQXBwLm1pZGRsZXdhcmUudHJpZ2dlcignYXV0aGVudGljYXRlJywgXy5leHRlbmQoe1xuICAgIHR5cGU6IHNjaGVtZS50eXBlXG4gIH0sIHNjaGVtZS5zZXR0aW5ncywgb3B0aW9ucyksIGZ1bmN0aW9uIChlcnIsIHRva2Vucykge1xuICAgIGlmICghdG9rZW5zKSB7XG4gICAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJ0F1dGhlbnRpY2F0aW9uIGZhaWxlZCcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9uZShlcnIsIHNjaGVtZSwgb3B0aW9ucywgdG9rZW5zKTtcbiAgfSwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlcXVlc3QgYXV0aGVudGljYXRpb24gY3JlZGVudGlhbHMgZnJvbSBhIHRoaXJkLXBhcnR5IHNvdXJjZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBzY2hlbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAqL1xudmFyIHJlcXVlc3RUb2tlbnMgPSBmdW5jdGlvbiAoc2NoZW1lLCBkb25lKSB7XG4gIHJldHVybiBBcHAubWlkZGxld2FyZS50cmlnZ2VyKCdyYW1sQ2xpZW50OnRva2VuJywgc2NoZW1lLCBkb25lLCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBwcmVmZXJyZWQgc2NoZW1lIG9wdGlvbiBmcm9tIGFuIG9iamVjdCBvZiBldmVyeSBzY2hlbWUuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBzY2hlbWVzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciBwcmVmZXJyZWRTY2hlbWUgPSBmdW5jdGlvbiAoc2NoZW1lcykge1xuICB2YXIgbWV0aG9kID0gXy5pbnRlcnNlY3Rpb24oT1JERVJfUFJFRkVSRU5DRSwgXy5wbHVjayhzY2hlbWVzLCAndHlwZScpKVswXTtcblxuICAvLyBSZXR1cm4gYW4gZXNzZW50aWFsbHkgcmFuZG9tIGJ1dCBjb25zaXN0ZW50IHNjaGVtZS5cbiAgaWYgKCFtZXRob2QpIHtcbiAgICByZXR1cm4gc2NoZW1lc1tfLmtleXMoc2NoZW1lcylbMF1dO1xuICB9XG5cbiAgLy8gRmluZCB0aGUgc2NoZW1lIHRoYXQgbWF0Y2hlZCBvdXIgcHJlZmVycmVkIG1ldGhvZC5cbiAgcmV0dXJuIF8uZmluZChzY2hlbWVzLCBmdW5jdGlvbiAoc2NoZW1lKSB7XG4gICAgcmV0dXJuIHNjaGVtZS50eXBlID09PSBtZXRob2Q7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBhdXRoZW50aWNhdGlvbiB0b2tlbnMgYW5kIG1ldGhvZCBhbnkgd2F5IHBvc3NpYmxlLiBJdCB3aWxsIGF0dGVtcHRcbiAqIHRvIHJlc29sdmUgYXV0b21hdGljYWxseS4gSWYgdGhhdCBpcyBub3QgcG9zc2libGUsIGl0IHdpbGwgZGVmZXIgdG9cbiAqIHByb21wdGluZyB0aGUgdXNlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBzY2hlbWVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gKi9cbnZhciByZXRyaWV2ZVRva2VucyA9IGZ1bmN0aW9uIChzY2hlbWVzLCBkb25lKSB7XG4gIHZhciB0b2tlbnM7XG5cbiAgLy8gQXR0ZW1wdCB0byBnZXQgdGhlIGZpcnN0IHJlc29sdmluZyBzZXQgb2YgYWNjZXNzIHRva2Vucy5cbiAgYXN5bmMuZGV0ZWN0U2VyaWVzKF8ubWFwKHNjaGVtZXMsIGZ1bmN0aW9uIChzZWN1cmVkLCBtZXRob2QpIHtcbiAgICByZXR1cm4gc2NoZW1lc1ttZXRob2RdO1xuICB9KSwgZnVuY3Rpb24gKHNjaGVtZSwgY2IpIHtcbiAgICByZXR1cm4gcmVxdWVzdFRva2VucyhzY2hlbWUsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChlcnIgfHwgIWRhdGEgfHwgIWhhc1JlcXVpcmVkVG9rZW5zKHNjaGVtZSwgZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIGNiKGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNiKHRva2VucyA9IGRhdGEpO1xuICAgIH0pO1xuICB9LCBmdW5jdGlvbiAoc2NoZW1lKSB7XG4gICAgaWYgKCFzY2hlbWUpIHtcbiAgICAgIHNjaGVtZSA9IHByZWZlcnJlZFNjaGVtZShzY2hlbWVzKTtcblxuICAgICAgcmV0dXJuIHByb21wdFRva2VucyhzY2hlbWUsIHt9LCBmdW5jdGlvbiAoZXJyLCB0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoZXJyLCBzY2hlbWUsIHRva2Vucyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9uZShudWxsLCBzY2hlbWUsIHRva2Vucyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBdHRlbXB0IHRvIG1hZ2ljYWxseSByZXNvbHZlIHRvIHRoZSBmaXJzdCB3b3JraW5nIGF1dGhlbnRpY2F0aW9uIG1ldGhvZC4gSWZcbiAqIHdlIGZhaWwsIHdlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIG1hbnVhbCBhdXRoZW50aWNhdGlvbiBvcHRpb25zIHdpdGggdGhlXG4gKiBvcHRpbWFsIGF1dGhlbnRpY2F0aW9uIHNjaGVtZSBhdmFpbGFibGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9ICAgc2NoZW1lc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG52YXIgcmVzb2x2ZVNjaGVtZSA9IGZ1bmN0aW9uIChzY2hlbWVzLCBkb25lKSB7XG4gIHJldHVybiByZXRyaWV2ZVRva2VucyhzY2hlbWVzLCBmdW5jdGlvbiAoZXJyLCBzY2hlbWUsIHRva2Vucykge1xuICAgIGlmIChlcnIpIHsgcmV0dXJuIGRvbmUoZXJyKTsgfVxuXG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0ZShzY2hlbWUsIHRva2VucywgZG9uZSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFeHBvcnQgYSBmdW5jdGlvbiB0aGF0IHdpbGwgY29udGFpbiBhbGwgdGhlIGxvZ2ljIGZvciBhdXRvbWFnaWNhbGx5XG4gKiBzZWxlY3RpbmcgYW4gYXBwcm9wcmlhdGUgYXV0aGVudGljYXRpb24gbWV0aG9kIGFuZCBwcm9tcHRpbmcgdGhlIHVzZXJcbiAqIGZvciB0aGUgZm9sbG93aW5nIHN0ZXBzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIHNjaGVtZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSAgIG1ldGhvZFxuICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzY2hlbWVzLCBtZXRob2QsIG9wdGlvbnMsIGRvbmUpIHtcbiAgLy8gSWYgbm8gYXV0aGVudGljYXRpb24gbWV0aG9kIGhhcyBiZWVuIHBhc3NlZCBpbiwgYXR0ZW1wdCB0byBwaWNrIG91ciBvd24uXG4gIGlmICghbWV0aG9kKSB7XG4gICAgcmV0dXJuIHJlc29sdmVTY2hlbWUoc2NoZW1lcywgZG9uZSk7XG4gIH1cblxuICAvLyBFbnN1cmUgd2UgYXJlIGF0dGVtcHRpbmcgdG8gYXV0aGVudGljYXRlIHdpdGggYSB2YWxpZCBtZXRob2QuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNjaGVtZXMsIG1ldGhvZCkpIHtcbiAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoXG4gICAgICAnVGhlIG9ubHkgYXZhaWxhYmxlIGF1dGhlbnRpY2F0aW9uIG1ldGhvZHMgYXJlOiAnICtcbiAgICAgIF8ua2V5cyhzY2hlbWVzKS5tYXAoSlNPTi5zdHJpbmdpZnkpLmpvaW4oJywgJylcbiAgICApKTtcbiAgfVxuXG4gIHZhciBzY2hlbWUgPSBzY2hlbWVzW21ldGhvZF07XG4gIHZhciBhdXRoICAgPSBfLmV4dGVuZCh7fSwgb3B0aW9ucyk7XG5cbiAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbGwgdGhlIHJlcXVpcmVkIHRva2VucyBhdmFpbGFibGUsIHByb21wdCB0aGUgdXNlciB0b1xuICAvLyBpbnB1dCB0b2tlbnMgYW5kIGNvbnRpbnVlIGF1dGhlbnRpY2F0aW5nLlxuICBpZiAoIWhhc1JlcXVpcmVkVG9rZW5zKHNjaGVtZSwgYXV0aCkpIHtcbiAgICByZXR1cm4gcmVxdWVzdFRva2VucyhzY2hlbWUsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgIGlmIChlcnIpIHsgcmV0dXJuIGRvbmUoZXJyKTsgfVxuXG4gICAgICAvLyBEb24ndCBwcm9tcHQgZm9yIHRoZSB0b2tlbnMgaWYgd2UgbWFuYWdlZCB0byByZXRyaWV2ZSB0aGVtIGFueXdheS5cbiAgICAgIGlmIChoYXNSZXF1aXJlZFRva2VucyhzY2hlbWUsIF8uZXh0ZW5kKGF1dGgsIGRhdGEpKSkge1xuICAgICAgICByZXR1cm4gYXV0aGVudGljYXRlKHNjaGVtZSwgYXV0aCwgZG9uZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9tcHRUb2tlbnMoc2NoZW1lLCBhdXRoLCBmdW5jdGlvbiAoZXJyLCB0b2tlbnMpIHtcbiAgICAgICAgaWYgKGVycikgeyByZXR1cm4gZG9uZShlcnIpOyB9XG5cbiAgICAgICAgcmV0dXJuIGF1dGhlbnRpY2F0ZShzY2hlbWUsIHRva2VucywgZG9uZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEZpbmFsbHkgd2UgaGF2ZSBldmVyeXRoaW5nIHdlIG5lZWQgYW5kIGNhbiBpbml0aWF0ZSBhdXRoZW50aWNhdGlvbi5cbiAgcmV0dXJuIGF1dGhlbnRpY2F0ZShzY2hlbWUsIGF1dGgsIGRvbmUpO1xufTtcbiIsIi8qIGdsb2JhbCBBcHAgKi9cbnZhciBfICAgICAgICAgICA9IEFwcC5MaWJyYXJ5Ll87XG52YXIgcXMgICAgICAgICAgPSBBcHAuTGlicmFyeS5xcztcbnZhciBtaW1lICAgICAgICA9IHJlcXVpcmUoJ21pbWUtY29tcG9uZW50Jyk7XG52YXIgZXNjYXBlICAgICAgPSByZXF1aXJlKCdlc2NhcGUtcmVnZXhwJyk7XG52YXIgcGFyc2VyICAgICAgPSByZXF1aXJlKCd1cml0ZW1wbGF0ZScpO1xudmFyIHNhbml0aXplQVNUID0gcmVxdWlyZSgnLi9zYW5pdGl6ZS1hc3QnKTtcblxudmFyIENPTkZJR19QUk9QRVJUWSA9ICchY29uZmlnJztcbnZhciBDTElFTlRfUFJPUEVSVFkgPSAnIWNsaWVudCc7XG5cbnZhciBKU09OX1JFR0VYUCA9IC9eYXBwbGljYXRpb25cXC8oW1xcdyEjXFwkJSZcXCpgXFwtXFwuXFxefl0qXFwrKT9qc29uJC9pO1xuXG52YXIgSFRUUF9NRVRIT0RTICAgICAgICAgPSBbJ2dldCcsICdoZWFkJywgJ3B1dCcsICdwb3N0JywgJ3BhdGNoJywgJ2RlbGV0ZSddO1xudmFyIFJFVFVSTl9QUk9QRVJUWSAgICAgID0gJyFyZXR1cm4nO1xudmFyIERFU0NSSVBUSU9OX1BST1BFUlRZID0gJyFkZXNjcmlwdGlvbic7XG52YXIgQ09ORklHX09QVElPTlMgICAgICAgPSBbXG4gICdib2R5JywgJ3Byb3h5JywgJ3VyaVBhcmFtZXRlcnMnLCAnYmFzZVVyaVBhcmFtZXRlcnMnLCAnaGVhZGVycycsICdxdWVyeSdcbl07XG52YXIgT1ZFUlJJREFCTEVfQ09ORklHX09QVElPTlMgPSBfLm9iamVjdChbJ2JvZHknLCAncHJveHknXSwgdHJ1ZSk7XG5cbi8qKlxuICogU3RhdGljIGRlc2NyaXB0aW9uIG9mIHRoZSBtZWRpYSB0eXBlIGV4dGVuc2lvbiBmdW5jdGlvbi5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgRVhURU5TSU9OX0RFU0NSSVBUSU9OID0ge1xuICAnIXR5cGUnOiAnZm4oZXh0ZW5zaW9uKScsXG4gICchYXJncyc6IFt7XG4gICAgJyF0eXBlJzogJ3N0cmluZycsXG4gICAgJyFkb2MnOiAnU2V0IHRoZSBmaWxlIGV4dGVuc2lvbiB3aXRoIHJlbGV2YW50IGBBY2NlcHRgIGhlYWRlci4nXG4gIH1dLFxuICAnIWRvYyc6IFtcbiAgICAnU2V0IHRoZSBwYXRoIGV4dGVuc2lvbiBhbmQgY29ycmVzcG9uZGluZyBhY2NlcHQgaGVhZGVyLidcbiAgXS5qb2luKCcgJylcbn07XG5cbi8qKlxuICogU3RhdGljIGRlc2NyaXB0aW9uIG9mIHRoZSBjbGllbnQgb2JqZWN0LlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBDTElFTlRfREVTQ1JJUFRJT04gPSB7XG4gICchdHlwZSc6ICdmbih1cmwsIGRhdGE/KScsXG4gICchYXJncyc6IFt7XG4gICAgJyF0eXBlJzogJ3N0cmluZycsXG4gICAgJyFkb2MnOiAnUHJvdmlkZSBhIHVybCByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmkuJ1xuICB9LCB7XG4gICAgJyF0eXBlJzogJ29iamVjdCcsXG4gICAgJyFkb2MnOiAnUHJvdmlkZSBhIGRhdGEgb2JqZWN0IHRvIHJlcGxhY2UgdGVtcGxhdGUgdGFncyBpbiB0aGUgYHVybGAuJ1xuICB9XSxcbiAgJyFkb2MnOiBbXG4gICAgJ01ha2UgYW4gQVBJIHJlcXVlc3QgdG8gYSBjdXN0b20gVVJMLidcbiAgXS5qb2luKCcgJylcbn07XG5cbi8qKlxuICogTWFwIHRoZSBzdXBwb3J0ZWQgYXV0aCB0eXBlcyB0byB0aGUga25vd24gdHJpZ2dlcnMuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIGF1dGhNYXAgPSB7XG4gICdPQXV0aCAxLjAnOiAgICAgICAgICAgICdvYXV0aDEnLFxuICAnT0F1dGggMi4wJzogICAgICAgICAgICAnb2F1dGgyJyxcbiAgJ0Jhc2ljIEF1dGhlbnRpY2F0aW9uJzogJ2Jhc2ljQXV0aCdcbn07XG5cbi8qKlxuICogQWNjZXB0cyBhIHBhcmFtcyBvYmplY3QgYW5kIHRyYW5zZm9ybXMgaXQgaW50byBhIHJlZ2V4IGZvciBtYXRjaGluZyB0aGVcbiAqIHRva2VucyBpbiB0aGUgcm91dGUuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBwYXJhbXNcbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqL1xudmFyIHVyaVBhcmFtUmVnZXggPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gIC8vIFRyYW5zZm9ybSB0aGUgcGFyYW1zIGludG8gYSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIG1hdGNoaW5nLlxuICByZXR1cm4gbmV3IFJlZ0V4cCgneygnICsgXy5tYXAoXy5rZXlzKHBhcmFtcyksIGVzY2FwZSkuam9pbignfCcpICsgJyl9JywgJ2cnKTtcbn07XG5cbi8qKlxuICogU2ltcGxlIFwidGVtcGxhdGVcIiBmdW5jdGlvbiBmb3Igd29ya2luZyB3aXRoIHRoZSB1cmkgcGFyYW0gdmFyaWFibGVzLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgdGVtcGxhdGVcbiAqIEBwYXJhbSAge09iamVjdH0gICAgICAgcGFyYW1zXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9IGNvbnRleHRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIHRlbXBsYXRlID0gZnVuY3Rpb24gKHN0cmluZywgcGFyYW1zLCBjb250ZXh0KSB7XG4gIC8vIElmIHRoZSBjb250ZXh0IGlzIGFuIGFycmF5LCB3ZSBuZWVkIHRvIHRyYW5zZm9ybSB0aGUgcmVwbGFjZW1lbnRzIGludG9cbiAgLy8gaW5kZXggYmFzZWQgcG9zaXRpb25zIGZvciB0aGUgdXJpIHRlbXBsYXRlIHBhcnNlci5cbiAgaWYgKF8uaXNBcnJheShjb250ZXh0KSkge1xuICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSh1cmlQYXJhbVJlZ2V4KHBhcmFtcyksIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAneycgKyAoaW5kZXgrKykgKyAnfSc7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VyLnBhcnNlKHN0cmluZykuZXhwYW5kKGNvbnRleHQpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIG1ldGhvZCBpcyBhIHF1ZXJ5IG1ldGhvZCAobm90IGEgYm9keSBhcyB0aGUgYXJndW1lbnQpLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gIG1ldGhvZFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzUXVlcnlNZXRob2QgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gIHJldHVybiBtZXRob2QgPT09ICdnZXQnIHx8IG1ldGhvZCA9PT0gJ2hlYWQnO1xufTtcblxuLyoqXG4gKiBNYXAgb2YgbWV0aG9kcyB0byB0aGVpciB0b29sdGlwIGRlc2NyaXB0aW9uIG9iamVjdHMuXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIE1FVEhPRF9ERVNDUklQVElPTiA9IF8ub2JqZWN0KF8ubWFwKEhUVFBfTUVUSE9EUywgZnVuY3Rpb24gKG1ldGhvZCkge1xuICB2YXIgYXJndW1lbnQgPSBpc1F1ZXJ5TWV0aG9kKG1ldGhvZCkgPyAncXVlcnk/JyA6ICdib2R5Pyc7XG5cbiAgcmV0dXJuIFttZXRob2QsIHtcbiAgICAnIXR5cGUnOiAnZm4oJyArIGFyZ3VtZW50ICsgJywgb3B0aW9ucz8sIGFzeW5jPyknXG4gIH1dO1xufSkpO1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIFJBTUwgZG9jdW1lbnRhdGlvbiB0byBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG52YXIgdG9NYXJrZG93bkRlc2NyaXB0aW9uID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSkge1xuICB2YXIgdGl0bGUgPSAnKionICsgbmFtZSArIChvYmplY3QucmVxdWlyZWQgPyAnJyA6ICc/JykgKyAnOioqICc7XG5cbiAgLy8gSWYgYSB0eXBlIGlzIGF2YWlsYWJsZSwgaXRhbGljaXNlIGFmdGVyIHRoZSBuYW1lLlxuICBpZiAob2JqZWN0LnR5cGUpIHtcbiAgICB0aXRsZSArPSAnKicgKyBvYmplY3QudHlwZSArICcqICc7XG4gIH1cblxuICByZXR1cm4gdGl0bGUgKyAob2JqZWN0LmRlc2NyaXB0aW9uIHx8ICcnKTtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgUkFNTCBtZXRob2Qgb2JqZWN0IGludG8gYSB0b29sdGlwIGRvY3VtZW50YXRpb24gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSAgbm9kZXNcbiAqIEBwYXJhbSAge09iamVjdH0gbWV0aG9kXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciB0b01ldGhvZERlc2NyaXB0aW9uID0gZnVuY3Rpb24gKG5vZGVzLCBtZXRob2QpIHtcbiAgdmFyIGFyZ3MgICAgPSBbXTtcbiAgdmFyIGNvbmZpZyAgPSBbXTtcbiAgdmFyIGJvZHkgICAgPSAnJztcbiAgdmFyIGlzUXVlcnkgPSBpc1F1ZXJ5TWV0aG9kKG1ldGhvZC5tZXRob2QpO1xuICB2YXIgZG9jdW1lbnRhdGlvbjtcblxuICBpZiAobWV0aG9kLnF1ZXJ5UGFyYW1ldGVycykge1xuICAgIGRvY3VtZW50YXRpb24gPSBfLm1hcChtZXRob2QucXVlcnlQYXJhbWV0ZXJzLCBmdW5jdGlvbiAocXVlcnksIG5hbWUpIHtcbiAgICAgIHJldHVybiAnKiAnICsgdG9NYXJrZG93bkRlc2NyaXB0aW9uKHF1ZXJ5LCBuYW1lKTtcbiAgICB9KS5qb2luKCdcXG4nKTtcblxuICAgIGlmIChpc1F1ZXJ5KSB7XG4gICAgICBib2R5ID0gZG9jdW1lbnRhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmlnLnB1c2goJyoqcXVlcnkqKicsIGRvY3VtZW50YXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtZXRob2QuaGVhZGVycykge1xuICAgIGNvbmZpZy5wdXNoKFxuICAgICAgJyoqaGVhZGVyczoqKicsXG4gICAgICBfLm1hcChtZXRob2QuaGVhZGVycywgZnVuY3Rpb24gKGhlYWRlciwgbmFtZSkge1xuICAgICAgICByZXR1cm4gJyogJyArIHRvTWFya2Rvd25EZXNjcmlwdGlvbihoZWFkZXIsIG5hbWUpO1xuICAgICAgfSkuam9pbignXFxuJylcbiAgICApO1xuICB9XG5cbiAgaWYgKG1ldGhvZC5ib2R5KSB7XG4gICAgZG9jdW1lbnRhdGlvbiA9IF8ubWFwKG1ldGhvZC5ib2R5LCBmdW5jdGlvbiAoYm9keSwgY29udGVudFR5cGUpIHtcbiAgICAgIHZhciB0aXRsZSAgPSAnKionICsgY29udGVudFR5cGUgKyAnOioqICc7XG4gICAgICB2YXIgZGVzY3JpcHRpb247XG5cbiAgICAgIC8vIE1hcCBmb3JtIHBhcmFtZXRlcnMgdG8gdGhlaXIgZGVzY3JpcHRpb25zLlxuICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgZGVzY3JpcHRpb24gPSBfLm1hcChcbiAgICAgICAgICBib2R5LmZvcm1QYXJhbWV0ZXJzLCBmdW5jdGlvbiAocGFyYW0sIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnKiAqICcgKyB0b01hcmtkb3duRGVzY3JpcHRpb24ocGFyYW0sIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgKS5qb2luKCdcXG4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcqICcgKyB0aXRsZSArIChkZXNjcmlwdGlvbiA/ICdcXG4nICsgZGVzY3JpcHRpb24gOiAnPycpO1xuICAgIH0pLmpvaW4oJ1xcbicpO1xuXG4gICAgaWYgKGlzUXVlcnkpIHtcbiAgICAgIGNvbmZpZy5wdXNoKCcqKmJvZHkqKicsIGRvY3VtZW50YXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBib2R5ID0gZG9jdW1lbnRhdGlvbjtcbiAgICB9XG4gIH1cblxuICBpZiAobm9kZXMuY2xpZW50LmJhc2VVcmlQYXJhbWV0ZXJzKSB7XG4gICAgY29uZmlnLnB1c2goXG4gICAgICAnKipiYXNlVXJpUGFyYW1ldGVycyoqJyxcbiAgICAgIF8ubWFwKG5vZGVzLmNsaWVudC5iYXNlVXJpUGFyYW1ldGVycywgZnVuY3Rpb24gKHBhcmFtLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiAnKiAnICsgdG9NYXJrZG93bkRlc2NyaXB0aW9uKHBhcmFtLCBuYW1lKTtcbiAgICAgIH0pLmpvaW4oJ1xcbicpXG4gICAgKTtcbiAgfVxuXG4gIGNvbmZpZy5wdXNoKFxuICAgICcqKnByb3h5KionLCAnKmJvb2xlYW4qIERpc2FibGUgdGhlIHByb3h5IGZvciB0aGUgY3VycmVudCByZXF1ZXN0LidcbiAgKTtcblxuICBhcmdzLnB1c2goe1xuICAgICchZG9jJzogYm9keSxcbiAgICAnIXR5cGUnOiAnb2JqZWN0J1xuICB9LCB7XG4gICAgJyFkb2MnOiBjb25maWcuam9pbignXFxuXFxuJyksXG4gICAgJyF0eXBlJzogJ29iamVjdCdcbiAgfSwge1xuICAgICchZG9jJzogJ1Bhc3MgYSBmdW5jdGlvbiB0byBtYWtlIHRoZSByZXF1ZXN0IGV4ZWN1dGUgYXN5bmNob25vdXNseS4nLFxuICAgICchdHlwZSc6ICdmbihlcnJvciwgcmVzcG9uc2UpJ1xuICB9KTtcblxuICByZXR1cm4gXy5leHRlbmQoe1xuICAgICchZG9jJzogbWV0aG9kLmRlc2NyaXB0aW9uLFxuICAgICchYXJncyc6IGFyZ3NcbiAgfSwgTUVUSE9EX0RFU0NSSVBUSU9OW21ldGhvZC5tZXRob2RdKTtcbn07XG5cbi8qKlxuICogTGlzdCBvZiBhbGwgcGxhaW4gSFRUUCBtZXRob2RzIGluIHRoZSBmb3JtYXQgZnJvbSB0aGUgQVNULlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBhbGxIdHRwTWV0aG9kcyA9IF8uY2hhaW4oSFRUUF9NRVRIT0RTKS5tYXAoZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgIHJldHVybiBbbWV0aG9kLCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZFxuICAgIH1dO1xuICB9KS5vYmplY3QoKS52YWx1ZSgpO1xuXG4vKipcbiAqIFBhcnNlIGFuIFhIUiByZXF1ZXN0IGZvciByZXNwb25zZSBoZWFkZXJzIGFuZCByZXR1cm4gYXMgYW4gb2JqZWN0LiBQYXNzIGFuXG4gKiBhZGRpdGlvbmFsIGZsYWcgdG8gZmlsdGVyIGFueSBwb3RlbnRpYWwgZHVwbGljYXRlIGhlYWRlcnMgKEUuZy4gZGlmZmVyZW50XG4gKiBjYXNlcykuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSB4aHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudmFyIGdldEFsbFJlcG9uc2VIZWFkZXJzID0gZnVuY3Rpb24gKHhocikge1xuICB2YXIgcmVzcG9uc2VIZWFkZXJzID0ge307XG5cbiAgXy5lYWNoKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICBoZWFkZXIgPSBoZWFkZXIuc3BsaXQoJzonKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGJvdGggcGFydHMgb2YgdGhlIGhlYWRlci5cbiAgICBpZiAoaGVhZGVyLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBuYW1lICA9IGhlYWRlci5zaGlmdCgpO1xuICAgICAgdmFyIHZhbHVlID0gaGVhZGVyLmpvaW4oJzonKS50cmltKCk7XG5cbiAgICAgIHJlc3BvbnNlSGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzcG9uc2VIZWFkZXJzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHhociByZXNwb25zZSBtaW1lIHR5cGUuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBjb250ZW50VHlwZVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG52YXIgZ2V0TWltZSA9IGZ1bmN0aW9uIChjb250ZW50VHlwZSkge1xuICByZXR1cm4gKGNvbnRlbnRUeXBlIHx8ICcnKS5zcGxpdCgnOycpWzBdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYSBob3N0IG9iamVjdCBhbmQgYXZvaWQgc2VyaWFsaXppbmcuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSAgb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNIb3N0ID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgc3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG5cbiAgc3dpdGNoIChzdHIpIHtcbiAgICBjYXNlICdbb2JqZWN0IEZpbGVdJzpcbiAgICBjYXNlICdbb2JqZWN0IEJsb2JdJzpcbiAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgY2FzZSAnW29iamVjdCBGb3JtRGF0YV0nOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBkYXRhIG9iamVjdCBpbnRvIGEgZm9ybSBkYXRhIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gICBkYXRhXG4gKiBAcmV0dXJuIHtGb3JtRGF0YX1cbiAqL1xudmFyIHRvRm9ybURhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciBldmVyeSBwaWVjZSBvZiBkYXRhIGFuZCBhcHBlbmQgdG8gdGhlIGZvcm0gZGF0YSBvYmplY3QuXG4gIF8uZWFjaChkYXRhLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIGZvcm0uYXBwZW5kKGtleSwgdmFsdWUpO1xuICB9KTtcblxuICByZXR1cm4gZm9ybTtcbn07XG5cbi8qKlxuICogTWFwIG1pbWUgdHlwZXMgdG8gdGhlaXIgcGFyc2Vycy5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgcGFyc2UgPSBbXG4gIFtKU09OX1JFR0VYUCwgSlNPTi5wYXJzZV0sXG4gIFsnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJywgcXMucGFyc2VdXG5dO1xuXG4vKipcbiAqIE1hcCBtaW1lIHR5cGVzIHRvIHRoZWlyIHNlcmlhbGl6ZXJzLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBzZXJpYWxpemUgPSBbXG4gIFtKU09OX1JFR0VYUCwgSlNPTi5zdHJpbmdpZnldLFxuICBbJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsIHFzLnN0cmluZ2lmeV0sXG4gIFsnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsIHRvRm9ybURhdGFdXG5dO1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBhcnJheSBvZiBtYXRjaCBhbmQgcmVzdWx0IHZhbHVlcywgYW5kIHJldHVybiB0aGVcbiAqIGZpcnN0IG1hdGNoaW5nIHZhbHVlLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSAgICBhcnJheVxuICogQHBhcmFtICB7U3RyaW5nfSAgIHRlc3RcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG52YXIgZ2V0TWF0Y2ggPSBmdW5jdGlvbiAoYXJyYXksIHRlc3QpIHtcbiAgdmFyIG1hdGNoID0gXy5maW5kKGFycmF5LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgY2hlY2sgPSB2YWx1ZVswXTtcblxuICAgIGlmIChfLmlzUmVnRXhwKGNoZWNrKSkge1xuICAgICAgcmV0dXJuIGNoZWNrLnRlc3QodGVzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoZWNrID09PSB0ZXN0O1xuICB9KTtcblxuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG59O1xuXG4vKipcbiAqIFNhbml0aXplIGEgc3BlY2lmaWMgY29uZmlndXJhdGlvbiBvcHRpb24uXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIHNhbml0aXplT3B0aW9uID0ge1xuICBxdWVyeTogZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgaWYgKF8uaXNTdHJpbmcocXVlcnkpKSB7XG4gICAgICByZXR1cm4gcXMucGFyc2UocXVlcnkpO1xuICAgIH1cblxuICAgIHJldHVybiBxdWVyeTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXRzIGEgaGVhZGVyIGZyb20gdGhlIGhlYWRlciBvYmplY3QuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSAgaGVhZGVyc1xuICogQHBhcmFtICB7U3RyaW5nfSAgaGVhZGVyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgZmluZEhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXJzLCBoZWFkZXIpIHtcbiAgaGVhZGVyID0gaGVhZGVyLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIF8uZmluZChoZWFkZXJzLCBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpID09PSBoZWFkZXI7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTYW5pdGl6ZSB0aGUgWEhSIHJlcXVlc3QgaW50byB0aGUgZGVzaXJlZCBmb3JtYXQuXG4gKlxuICogQHBhcmFtICB7WE1MSHR0cFJlcXVlc3R9IHhoclxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG52YXIgc2FuaXRpemVYSFIgPSBmdW5jdGlvbiAoeGhyKSB7XG4gIGlmICgheGhyKSB7IHJldHVybiB4aHI7IH1cblxuICB2YXIgbWltZSAgICA9IGdldE1pbWUoeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKSk7XG4gIHZhciBib2R5ICAgID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgdmFyIGhlYWRlcnMgPSBnZXRBbGxSZXBvbnNlSGVhZGVycyh4aHIpO1xuXG4gIC8vIEF1dG9tYXRpY2FsbHkgcGFyc2UgY2VydGFpbiByZXNwb25zZSB0eXBlcy5cbiAgYm9keSA9IChnZXRNYXRjaChwYXJzZSwgbWltZSkgfHwgXy5pZGVudGl0eSkoYm9keSk7XG5cbiAgcmV0dXJuIHtcbiAgICBib2R5OiAgICBib2R5LFxuICAgIHN0YXR1czogIHhoci5zdGF0dXMsXG4gICAgaGVhZGVyczogaGVhZGVyc1xuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBtYWtlIGFqYXggcmVxdWVzdHMuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSAgIHVybFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbnZhciBodHRwUmVxdWVzdCA9IGZ1bmN0aW9uIChub2RlcywgbWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYm9keSwgY29uZmlnLCBkb25lKSB7XG4gICAgLy8gQWxsb3cgY29uZmlnIHRvIGJlIG9taXR0ZWQgZnJvbSBhcmd1bWVudHMuXG4gICAgaWYgKF8uaXNGdW5jdGlvbihhcmd1bWVudHNbMV0pKSB7XG4gICAgICBkb25lICAgPSBhcmd1bWVudHNbMV07XG4gICAgICBjb25maWcgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIE1hcCBjb25maWd1cmF0aW9uIG9wdGlvbnMgYW5kIG1lcmdlIHdpdGggdGhlIHBhc3NlZCBpbiBvYmplY3QuXG4gICAgY29uZmlnID0gXy5vYmplY3QoQ09ORklHX09QVElPTlMsIF8ubWFwKENPTkZJR19PUFRJT05TLCBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICBpZiAoXy5oYXMoT1ZFUlJJREFCTEVfQ09ORklHX09QVElPTlMsIG9wdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZyAmJiBvcHRpb24gaW4gY29uZmlnID9cbiAgICAgICAgICBjb25maWdbb3B0aW9uXSA6IG5vZGVzLmNvbmZpZ1tvcHRpb25dO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZU9wdGlvbiAgID0gbm9kZXMuY29uZmlnW29wdGlvbl07XG4gICAgICB2YXIgY29uZmlnT3B0aW9uID0gY29uZmlnICYmIGNvbmZpZ1tvcHRpb25dO1xuICAgICAgdmFyIHNhbml0aXplICAgICA9IHNhbml0aXplT3B0aW9uW29wdGlvbl0gfHwgXy5pZGVudGl0eTtcblxuICAgICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBzYW5pdGl6ZShub2RlT3B0aW9uKSwgc2FuaXRpemUoY29uZmlnT3B0aW9uKSk7XG4gICAgfSkpO1xuXG4gICAgdmFyIGFzeW5jICAgPSAhIWRvbmU7XG4gICAgdmFyIHJlcXVlc3QgPSAnYWpheCc7XG4gICAgdmFyIG1pbWUgICAgPSBnZXRNaW1lKGZpbmRIZWFkZXIoY29uZmlnLmhlYWRlcnMsICdDb250ZW50LVR5cGUnKSk7XG4gICAgdmFyIGJhc2VVcmkgPSB0ZW1wbGF0ZShub2Rlcy5jbGllbnQuYmFzZVVyaSwge30sIGNvbmZpZy5iYXNlVXJpUGFyYW1ldGVycyk7XG4gICAgdmFyIGZ1bGxVcmkgPSBiYXNlVXJpICsgJy8nICsgbm9kZXMuam9pbignLycpO1xuXG4gICAgLy8gR0VUIGFuZCBIRUFEIHJlcXVlc3RzIGFjY2VwdCB0aGUgcXVlcnkgc3RyaW5nIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICBpZiAoaXNRdWVyeU1ldGhvZChtZXRob2QubWV0aG9kKSkge1xuICAgICAgXy5leHRlbmQoY29uZmlnLnF1ZXJ5LCBzYW5pdGl6ZU9wdGlvbi5xdWVyeShib2R5KSk7XG4gICAgICBib2R5ID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIGNvbmZpZyBvYmplY3QgYm9keSB0byB0aGUgcGFzc2VkIGluIGJvZHkuXG4gICAgaWYgKGJvZHkgIT0gbnVsbCkge1xuICAgICAgY29uZmlnLmJvZHkgPSBib2R5O1xuICAgIH1cblxuICAgIC8vIEFwcGVuZCB0aGUgcXVlcnkgc3RyaW5nIGlmIG9uZSBpcyBhdmFpbGFibGUuXG4gICAgaWYgKF8ua2V5cyhjb25maWcucXVlcnkpLmxlbmd0aCkge1xuICAgICAgZnVsbFVyaSArPSAnPycgKyBxcy5zdHJpbmdpZnkoY29uZmlnLnF1ZXJ5KTtcbiAgICB9XG5cbiAgICAvLyBTZXQgdGhlIGNvcnJlY3QgYENvbnRlbnQtVHlwZWAgaGVhZGVyLCBpZiBub25lIGV4aXN0cy4gS2luZCBvZiByYW5kb20gaWZcbiAgICAvLyBtb3JlIHRoYW4gb25lIGV4aXN0cyAtIGluIHRoYXQgY2FzZSBJIHdvdWxkIHN1Z2dlc3Qgc2V0dGluZyBpdCB5b3Vyc2VsZi5cbiAgICBpZiAoIW1pbWUgJiYgdHlwZW9mIG1ldGhvZC5ib2R5ID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uZmlnLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gbWltZSA9IF8ua2V5cyhtZXRob2QuYm9keSkucG9wKCk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSBubyBhY2NlcHQgaGVhZGVyIHNldCBhbHJlYWR5LCBkZWZhdWx0IHRvIGFjY2VwdGluZ1xuICAgIC8vIGV2ZXJ5dGhpbmcuIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBGaXJlZm94IHNldHMgdGhlIGJhc2UgYWNjZXB0XG4gICAgLy8gaGVhZGVyIHRvIGVzc2VudGlhbGx5IGJlIGBodG1sL3htbGAuXG4gICAgaWYgKCFmaW5kSGVhZGVyKGNvbmZpZy5oZWFkZXJzLCAnYWNjZXB0JykpIHtcbiAgICAgIGNvbmZpZy5oZWFkZXJzLmFjY2VwdCA9ICcqLyonO1xuICAgIH1cblxuICAgIC8vIElmIHdlIHdlcmUgcGFzc2VkIGluIGRhdGEsIGF0dGVtcHQgdG8gc2FuaXRpemUgaXQgdG8gdGhlIGNvcnJlY3QgdHlwZS5cbiAgICBpZiAoIWlzSG9zdChjb25maWcuYm9keSkpIHtcbiAgICAgIHZhciBzZXJpYWxpemVyID0gZ2V0TWF0Y2goc2VyaWFsaXplLCBtaW1lIHx8ICdhcHBsaWNhdGlvbi9qc29uJyk7XG5cbiAgICAgIGlmICghc2VyaWFsaXplcikge1xuICAgICAgICByZXR1cm4gZG9uZShcbiAgICAgICAgICBuZXcgVHlwZUVycm9yKCdDYW4gbm90IHNlcmlhbGl6ZSBjb250ZW50IHR5cGUgb2YgXCInICsgbWltZSArICdcIicpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbmZpZy5ib2R5ID0gc2VyaWFsaXplcihjb25maWcuYm9keSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBkb25lKG5ldyBUeXBlRXJyb3IoJ0NvdWxkIG5vdCBzZXJpYWxpemUgYm9keTogJyArIGUubWVzc2FnZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgdXJsOiAgICAgZnVsbFVyaSxcbiAgICAgIGRhdGE6ICAgIGNvbmZpZy5ib2R5LFxuICAgICAgYXN5bmM6ICAgYXN5bmMsXG4gICAgICBwcm94eTogICBjb25maWcucHJveHksXG4gICAgICBtZXRob2Q6ICBtZXRob2QubWV0aG9kLFxuICAgICAgaGVhZGVyczogY29uZmlnLmhlYWRlcnNcbiAgICB9O1xuXG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGBzZWN1cmVkQnlgIG1ldGhvZHMgYW5kIGFjY2VwdCB0aGUgZmlyc3Qgb25lIHdlIGFyZVxuICAgIC8vIGFscmVhZHkgYXV0aGVudGljYXRlZCBmb3IuXG4gICAgXy5zb21lKG1ldGhvZC5zZWN1cmVkQnkgfHwgbm9kZXMuY2xpZW50LnNlY3VyZWRCeSwgZnVuY3Rpb24gKHNlY3VyZWQsIGtleSkge1xuICAgICAgdmFyIHNjaGVtZSA9IG5vZGVzLmNsaWVudC5zZWN1cml0eVNjaGVtZXNba2V5XTtcblxuICAgICAgLy8gU2NoZW1lIGlzIG5vdCBkb2N1bWVudGVkIGluIHRoZSBSQU1MIHNlY3VyaXR5IHNjaGVtZXMuXG4gICAgICBpZiAoIXNjaGVtZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBhdXRoZW50aWNhdGVkID0gbm9kZXMuY2xpZW50LmF1dGhlbnRpY2F0aW9uW3NjaGVtZS50eXBlXTtcbiAgICAgIHZhciBhdXRoVHlwZSAgICAgID0gYXV0aE1hcFtzY2hlbWUudHlwZV07XG5cbiAgICAgIGlmIChhdXRoZW50aWNhdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbYXV0aFR5cGVdID0gYXV0aGVudGljYXRlZDtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3QgPSAnYWpheDonICsgYXV0aFR5cGU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBJZiB0aGUgcmVxdWVzdCBpcyBhc3luYywgc2V0IHRoZSByZWxldmFudCBmdW5jdGlvbiBjYWxsYmFja3MuXG4gICAgaWYgKGFzeW5jKSB7XG4gICAgICBBcHAuX2V4ZWN1dGVDb250ZXh0LnRpbWVvdXQoSW5maW5pdHkpO1xuXG4gICAgICBpZiAoIV8uaXNGdW5jdGlvbihkb25lKSkge1xuICAgICAgICBkb25lID0gQXBwLl9leGVjdXRlQ29udGV4dC5hc3luYygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEF3a3dhcmQgc3luYyBhbmQgYXN5bmMgY29kZSBtaXhpbmcuXG4gICAgdmFyIHJlc3BvbnNlLCBlcnJvcjtcblxuICAgIC8vIFRyaWdnZXIgdGhlIGFqYXggbWlkZGxld2FyZSBzbyBwbHVnaW5zIGNhbiBob29rIG9udG8gdGhlIHJlcXVlc3RzLiBJZlxuICAgIC8vIHRoZSBmdW5jdGlvbiBpcyBhc3luYyB3ZSBuZWVkIHRvIHJlZ2lzdGVyIGEgY2FsbGJhY2sgZm9yIHRoZSBtaWRkbGV3YXJlLlxuICAgIEFwcC5taWRkbGV3YXJlLnRyaWdnZXIocmVxdWVzdCwgb3B0aW9ucywgZnVuY3Rpb24gKGVyciwgeGhyKSB7XG4gICAgICBlcnJvciA9IGVycjtcblxuICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3BvbnNlID0gc2FuaXRpemVYSFIoeGhyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGVycm9yID0gbmV3IFR5cGVFcnJvcignQ291bGQgbm90IHBhcnNlIHJlc3BvbnNlOiAnICsgZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXN5bmMgJiYgZG9uZShlcnJvciwgcmVzcG9uc2UpO1xuICAgIH0pO1xuXG4gICAgLy8gSWYgdGhlIHJlcXVlc3Qgd2FzIHN5bmNocm9ub3VzLCByZXR1cm4gdGhlIHNhbml0aXplZCBYSFIgcmVzcG9uc2UgZGF0YS5cbiAgICAvLyBUaGlzIGlzIHN1cGVyIGphbmsgZm9yIGhhbmRsaW5nIGVycm9ycywgZXRjLlxuICAgIGlmICghYXN5bmMpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogQXR0YWNoZXMgWEhSIHJlcXVlc3QgbWV0aG9kcyB0byB0aGUgY29udGV4dCBvYmplY3QgZm9yIGVhY2ggYXZhaWxhYmxlIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gIG5vZGVzXG4gKiBAcGFyYW0gIHtPYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSAge09iamVjdH0gbWV0aG9kc1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG52YXIgYXR0YWNoTWV0aG9kcyA9IGZ1bmN0aW9uIChub2RlcywgY29udGV4dCwgbWV0aG9kcykge1xuICAvLyBBdHRhY2ggdGhlIGF2YWlsYWJsZSBtZXRob2RzIHRvIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gIF8uZWFjaChtZXRob2RzLCBmdW5jdGlvbiAobWV0aG9kLCB2ZXJiKSB7XG4gICAgY29udGV4dFt2ZXJiXSA9IGh0dHBSZXF1ZXN0KG5vZGVzLCBtZXRob2QpO1xuICAgIGNvbnRleHRbdmVyYl1bREVTQ1JJUFRJT05fUFJPUEVSVFldID0gdG9NZXRob2REZXNjcmlwdGlvbihub2RlcywgbWV0aG9kKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG4vKipcbiAqIEF0dGFjaCBhIHNwZWNpYWwgbWVkaWEgZXh0ZW5zaW9uIGhhbmRsZXIuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICBub2Rlc1xuICogQHBhcmFtICB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcGFyYW0gIHtPYmplY3R9IHJlc291cmNlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciBhdHRhY2hNZWRpYVR5cGVFeHRlbnNpb24gPSBmdW5jdGlvbiAobm9kZXMsIGNvbnRleHQsIHJlc291cmNlKSB7XG4gIC8qKlxuICAgKiBQdXNoIHRoZSBleHRlbnNpb24gb250byB0aGUgY3VycmVudCByb3V0ZSBhbmQgc2V0IHJlbGV2YW50IGhlYWRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZXh0ZW5zaW9uXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGNvbnRleHQuZXh0ZW5zaW9uID0gZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuICAgIC8vIFByZXBlbmQgYSBwZXJpb2QgdG8gdGhlIGV4dGVuc2lvbiBiZWZvcmUgYWRkaW5nIHRvIHRoZSByb3V0ZS5cbiAgICBpZiAoZXh0ZW5zaW9uLmNoYXJBdCgwKSAhPT0gJy4nKSB7XG4gICAgICBleHRlbnNpb24gPSAnLicgKyBleHRlbnNpb247XG4gICAgfVxuXG4gICAgdmFyIG5ld0NvbnRleHQgID0ge307XG4gICAgdmFyIHJvdXRlTm9kZXMgID0gXy5leHRlbmQoW10sIG5vZGVzKTtcbiAgICB2YXIgY29udGVudFR5cGUgPSBtaW1lLmxvb2t1cChleHRlbnNpb24pO1xuXG4gICAgLy8gQXBwZW5kIHRoZSBleHRlbnNpb24gdG8gdGhlIGN1cnJlbnQgcm91dGUuXG4gICAgcm91dGVOb2Rlc1tyb3V0ZU5vZGVzLmxlbmd0aCAtIDFdICs9IGV4dGVuc2lvbjtcblxuICAgIC8vIEF1dG9tYWdpY2FsbHkgc2V0IHRoZSBjb3JyZWN0IGFjY2VwdHMgaGVhZGVyLiBOZWVkcyB0byBjbG9uZSB0aGUgY29uZmlnXG4gICAgLy8gb2JqZWN0IGFuZCB0aGUgaGVhZGVycyB0byBhdm9pZCBicmVha2luZyByZWZlcmVuY2VzLlxuICAgIGlmIChjb250ZW50VHlwZSkge1xuICAgICAgcm91dGVOb2Rlcy5jb25maWcgPSBfLmV4dGVuZCh7fSwgcm91dGVOb2Rlcy5jb25maWcpO1xuICAgICAgcm91dGVOb2Rlcy5jb25maWcuaGVhZGVycyA9IF8uZXh0ZW5kKHt9LCByb3V0ZU5vZGVzLmNvbmZpZy5oZWFkZXJzKTtcbiAgICAgIHJvdXRlTm9kZXMuY29uZmlnLmhlYWRlcnMuYWNjZXB0ID0gY29udGVudFR5cGU7XG4gICAgfVxuXG4gICAgYXR0YWNoTWV0aG9kcyhyb3V0ZU5vZGVzLCBuZXdDb250ZXh0LCByZXNvdXJjZS5tZXRob2RzKTtcbiAgICBhdHRhY2hSZXNvdXJjZXMocm91dGVOb2RlcywgbmV3Q29udGV4dCwgcmVzb3VyY2UucmVzb3VyY2VzKTtcblxuICAgIHJldHVybiBuZXdDb250ZXh0O1xuICB9O1xuXG4gIC8vIEF0dGFjaCBhIGRlc2NyaXB0aW9uIGFuZCByZXR1cm4gcHJvcGVydHkuXG4gIGNvbnRleHQuZXh0ZW5zaW9uW1JFVFVSTl9QUk9QRVJUWV0gICAgICA9IGNvbnRleHQuZXh0ZW5zaW9uKCcnKTtcbiAgY29udGV4dC5leHRlbnNpb25bREVTQ1JJUFRJT05fUFJPUEVSVFldID0gRVhURU5TSU9OX0RFU0NSSVBUSU9OO1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgZW51bSBvcHRpb25zIGFuZCBhdXRvbWF0aWNhbGx5IGF0dGFjaCB0byB0aGUgY29udGV4dC5cbiAgXy5lYWNoKHJlc291cmNlLnVyaVBhcmFtZXRlcnMubWVkaWFUeXBlRXh0ZW5zaW9uLmVudW0sIGZ1bmN0aW9uIChleHRlbnNpb24pIHtcbiAgICBpZiAoZXh0ZW5zaW9uLmNoYXJBdCgwKSA9PT0gJy4nKSB7XG4gICAgICBleHRlbnNpb24gPSBleHRlbnNpb24uc3Vic3RyKDEpO1xuICAgIH1cblxuICAgIGNvbnRleHRbZXh0ZW5zaW9uXSA9IGNvbnRleHQuZXh0ZW5zaW9uKGV4dGVuc2lvbik7XG4gIH0pO1xuXG4gIHJldHVybiBjb250ZXh0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGNvbnRleHQgb3IgYXR0YWNoIG1ldGhvZHMgYW5kIHJlc291cmNlcyB0byBhbiBleGlzdGluZyBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSAgIG5vZGVzXG4gKiBAcGFyYW0gIHtPYmplY3R9ICByZXNvdXJjZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gaGFzTWVkaWFFeHRlbnNpb25cbiAqIEBwYXJhbSAge09iamVjdH0gIGNvbnRleHRcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudmFyIG5ld0NvbnRleHQgPSBmdW5jdGlvbiAobm9kZXMsIHJlc291cmNlLCBoYXNNZWRpYUV4dGVuc2lvbiwgY29udGV4dCkge1xuICBjb250ZXh0ID0gY29udGV4dCB8fCB7fTtcblxuICBpZiAoaGFzTWVkaWFFeHRlbnNpb24pIHtcbiAgICBhdHRhY2hNZWRpYVR5cGVFeHRlbnNpb24obm9kZXMsIGNvbnRleHQsIHJlc291cmNlKTtcbiAgfSBlbHNlIHtcbiAgICBhdHRhY2hNZXRob2RzKG5vZGVzLCBjb250ZXh0LCByZXNvdXJjZS5tZXRob2RzKTtcbiAgICBhdHRhY2hSZXNvdXJjZXMobm9kZXMsIGNvbnRleHQsIHJlc291cmNlLnJlc291cmNlcyk7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn07XG5cbi8qKlxuICogUmVjdXJzZXMgdGhyb3VnaCBhIHJlc291cmNlIG9iamVjdCBpbiB0aGUgUkFNTCBBU1QsIGdlbmVyYXRpbmcgYSBkeW5hbWljXG4gKiBEU0wgdGhhdCBvbmx5IGFsbG93cyBtZXRob2RzIHRoYXQgd2VyZSBkZWZpbmVkIGluIHRoZSBSQU1MIHNwZWMuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9ICBub2Rlc1xuICogQHBhcmFtICB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcGFyYW0gIHtPYmplY3R9IHJlc291cmNlc1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbi8qIGpzaGludCAtVzAwMyAqL1xudmFyIGF0dGFjaFJlc291cmNlcyA9IGZ1bmN0aW9uIChub2RlcywgY29udGV4dCwgcmVzb3VyY2VzKSB7XG4gIF8uZWFjaChyZXNvdXJjZXMsIGZ1bmN0aW9uIChyZXNvdXJjZSwgcm91dGUpIHtcbiAgICB2YXIgcm91dGVOb2RlcyAgICAgICAgPSBfLmV4dGVuZChbXSwgbm9kZXMpO1xuICAgIHZhciByb3V0ZU5hbWUgICAgICAgICA9IHJvdXRlO1xuICAgIHZhciBoYXNNZWRpYUV4dGVuc2lvbiA9IHJvdXRlLnN1YnN0cigtMjApID09PSAne21lZGlhVHlwZUV4dGVuc2lvbn0nO1xuXG4gICAgLy8gSWdub3JlIG1lZGlhIHR5cGUgZXh0ZW5zaW9ucyBpbiByb3V0ZSBnZW5lcmF0aW9uLlxuICAgIGlmIChoYXNNZWRpYUV4dGVuc2lvbikge1xuICAgICAgcm91dGUgPSByb3V0ZU5hbWUgPSByb3V0ZS5zbGljZSgwLCAtMjApO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHRoZSByb3V0ZSBhZ2FpbnN0IG91ciB2YWxpZCB1cmkgcGFyYW1ldGVycy5cbiAgICB2YXIgdGVtcGxhdGVUYWdzID0gcm91dGUubWF0Y2godXJpUGFyYW1SZWdleChyZXNvdXJjZS51cmlQYXJhbWV0ZXJzKSk7XG5cbiAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHJvdXRlIGludG8gdGhlIHJvdXRlIGFycmF5LlxuICAgIHJvdXRlTm9kZXMucHVzaChyb3V0ZSk7XG5cbiAgICAvLyBJZiB3ZSBoYXZlIHRlbXBsYXRlIHRhZ3MgYXZhaWxhYmxlLCBhdHRhY2ggYSBkeW5hbWljIHJvdXRlLlxuICAgIGlmICh0ZW1wbGF0ZVRhZ3MpIHtcbiAgICAgIHZhciByb3V0ZVN1ZmZpeCA9IHRlbXBsYXRlVGFncy5qb2luKCcnKTtcblxuICAgICAgLy8gVGhlIHJvdXRlIG11c3QgZW5kIHdpdGggdGhlIGNoYWluZWQgdGVtcGxhdGUgdGFncyBhbmQgaGF2ZSBub1xuICAgICAgLy8gdGV4dCBiZXR3ZWVuIHRhZ3MuXG4gICAgICBpZiAocm91dGUuc3Vic3RyKC1yb3V0ZVN1ZmZpeC5sZW5ndGgpICE9PSByb3V0ZVN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSByb3V0ZSBpcyBvbmx5IGEgdGVtcGxhdGUgdGFnIHdpdGggbm8gc3RhdGljIHRleHQsIHVzZSB0aGVcbiAgICAgIC8vIHRlbXBsYXRlIHRhZyB0ZXh0IGFzIHRoZSBtZXRob2QgbmFtZS5cbiAgICAgIGlmICh0ZW1wbGF0ZVRhZ3MubGVuZ3RoID09PSAxICYmIHJvdXRlID09PSB0ZW1wbGF0ZVRhZ3NbMF0pIHtcbiAgICAgICAgcm91dGVOYW1lID0gdGVtcGxhdGVUYWdzWzBdLnNsaWNlKDEsIC0xKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdXRlTmFtZSA9IHJvdXRlLnN1YnN0cigwLCByb3V0ZS5pbmRleE9mKCd7JykpO1xuICAgICAgfVxuXG4gICAgICAvLyBBdm9pZCBhZGRpbmcgZW1wdHkgcm91dGUgbmFtZSBjYXNlcy4gVGhpcyBjYW4gb2NjdXIgd2hlbiB3ZSBoYXZlXG4gICAgICAvLyBtdWx0aXBsZSB0YWcgbmFtZXMgYW5kIG5vIGZyb250IHRleHQuIEZvciBleGFtcGxlLCBge3RoaXN9e3RoYXR9YC5cbiAgICAgIC8vIFRoaXMgY291bGQgYWxzbyBvY2N1ciBpZiBmb3Igc29tZSByZWFzb24gd2UgYXJlIHBhc3NpbmcgaW4gYSByb3V0ZSB0aGF0XG4gICAgICAvLyBpc24ndCBkeW5hbWljLlxuICAgICAgaWYgKCFyb3V0ZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgdGhlIG9yZGVyZWQgdGFnIG5hbWVzIGZvciBjb21wbGV0aW9uLlxuICAgICAgdmFyIHRhZ3MgPSBfLm1hcCh0ZW1wbGF0ZVRhZ3MsIGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICByZXR1cm4gcmVzb3VyY2UudXJpUGFyYW1ldGVyc1twYXJhbS5zbGljZSgxLCAtMSldO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFRoZSByb3V0ZSBpcyBkeW5hbWljLCBzbyB3ZSBzZXQgdGhlIHJvdXRlIG5hbWUgdG8gYmUgYSBmdW5jdGlvblxuICAgICAgLy8gd2hpY2ggYWNjZXB0cyB0aGUgdGVtcGxhdGUgYXJndW1lbnRzIGFuZCB1cGRhdGVzIHRoZSBwYXRoIGZyYWdtZW50LlxuICAgICAgLy8gV2UnbGwgZXh0ZW5kIGFueSByb3V0ZSBhbHJlYWR5IGF0IHRoZSBzYW1lIG5hbWVzcGFjZSBzbyB3ZSBjYW4gZG9cbiAgICAgIC8vIHRoaW5ncyBsaWtlIHVzZSBib3RoIGAve3JvdXRlfWAgYW5kIGAvcm91dGVgLCBpZiBuZWVkZWQuXG4gICAgICBjb250ZXh0W3JvdXRlTmFtZV0gPSBfLmV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICAgIC8vIE1hcCB0aGUgdGFncyB0byB0aGUgYXJndW1lbnRzIG9yIGRlZmF1bHQgYXJndW1lbnRzLlxuICAgICAgICB2YXIgcGFydHMgPSBfLm1hcCh0YWdzLCBmdW5jdGlvbiAodGFnLCBpbmRleCkge1xuICAgICAgICAgIC8vIEluamVjdCBlbnVtIHBhcmFtZXRlcnMgaWYgdGhlcmUgaXMgb25seSBvbmUgYXZhaWxhYmxlIGVudW0uXG4gICAgICAgICAgLy8gVE9ETzogV2hlbi9pZiB3ZSBhZGQgdmFsaWRhdGlvbiBiYWNrLCBoYXZlIHRoZXNlIHJvdXRlc1xuICAgICAgICAgIC8vIGJlIGdlbmVyYXRlZCBpbnN0ZWFkIG9mIHR5cGVkIG91dC5cbiAgICAgICAgICBpZiAoYXJnc1tpbmRleF0gPT0gbnVsbCAmJiB0YWcuZW51bSAmJiB0YWcuZW51bS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWcuZW51bVswXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVc2UgYW55IHBhc3NlZCBpbiBhcmd1bWVudCAtIGV2ZW4gaXQncyBmYWxzeS5cbiAgICAgICAgICBpZiAoaW5kZXggaW4gYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3NbaW5kZXhdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwYXJhbSA9IHRlbXBsYXRlVGFnc1tpbmRleF0uc2xpY2UoMSwgLTEpO1xuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gaW5qZWN0aW5nIHRoZSBmYWxsYmFjayBjb25maWd1cmF0aW9uIHVyaSBwYXJhbWV0ZXIuXG4gICAgICAgICAgcmV0dXJuIHJvdXRlTm9kZXMuY29uZmlnICYmIHJvdXRlTm9kZXMuY29uZmlnLnVyaVBhcmFtZXRlcnNbcGFyYW1dO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDaGFuZ2UgdGhlIGxhc3QgcGF0aCBmcmFnbWVudCB0byB0aGUgcHJvcGVyIHRlbXBsYXRlIHRleHQuXG4gICAgICAgIHJvdXRlTm9kZXNbcm91dGVOb2Rlcy5sZW5ndGggLSAxXSA9IHRlbXBsYXRlKFxuICAgICAgICAgIHJvdXRlLCByZXNvdXJjZS51cmlQYXJhbWV0ZXJzLCBwYXJ0c1xuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBuZXdDb250ZXh0KHJvdXRlTm9kZXMsIHJlc291cmNlLCBoYXNNZWRpYUV4dGVuc2lvbik7XG4gICAgICB9LCBjb250ZXh0W3JvdXRlTmFtZV0pO1xuXG4gICAgICAvLyBHZW5lcmF0ZSB0aGUgZGVzY3JpcHRpb24gb2JqZWN0IGZvciBoZWxwaW5nIHRvb2x0aXAgZGlzcGxheS5cbiAgICAgIGNvbnRleHRbcm91dGVOYW1lXVtERVNDUklQVElPTl9QUk9QRVJUWV0gPSB7XG4gICAgICAgICchdHlwZSc6ICdmbignICsgXy5tYXAodGFncywgZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmFtLmRpc3BsYXlOYW1lICsgKHBhcmFtLnJlcXVpcmVkID8gJycgOiAnPycpO1xuICAgICAgICB9KS5qb2luKCcsICcpICsgJyknLFxuICAgICAgICAnIWFyZ3MnOiBfLm1hcCh0YWdzLCBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJyF0eXBlJzogcGFyYW0udHlwZSxcbiAgICAgICAgICAgICchZG9jJzogcGFyYW0uZGVzY3JpcHRpb25cbiAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgJyFkb2MnOiAnRHluYW1pY2FsbHkgaW5qZWN0IHZhcmlhYmxlcyBpbnRvIHRoZSByZXF1ZXN0IHBhdGguJ1xuICAgICAgfTtcblxuICAgICAgLy8gR2VuZXJhdGUgdGhlIHJldHVybiBwcm9wZXJ0eSBmb3IgaGVscGluZyBhdXRvY29tcGxldGlvbi5cbiAgICAgIGNvbnRleHRbcm91dGVOYW1lXVtSRVRVUk5fUFJPUEVSVFldID0gbmV3Q29udGV4dChcbiAgICAgICAgcm91dGVOb2RlcywgcmVzb3VyY2UsIGhhc01lZGlhRXh0ZW5zaW9uXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gY29udGV4dFtyb3V0ZU5hbWVdO1xuICAgIH1cblxuICAgIGNvbnRleHRbcm91dGVOYW1lXSA9IG5ld0NvbnRleHQoXG4gICAgICByb3V0ZU5vZGVzLCByZXNvdXJjZSwgaGFzTWVkaWFFeHRlbnNpb24sIGNvbnRleHRbcm91dGVOYW1lXVxuICAgICk7XG4gIH0pO1xuXG4gIHJldHVybiBjb250ZXh0O1xufTtcbi8qIGpzaGludCArVzAwMyAqL1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBjbGllbnQgb2JqZWN0IGZyb20gYSBzYW5pdGl6ZWQgQVNUIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGFzdCBQYXNzZWQgdGhyb3VnaCBgc2FuaXRpemVBU1RgXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnZhciBnZW5lcmF0ZUNsaWVudCA9IGZ1bmN0aW9uIChhc3QsIGNvbmZpZykge1xuICAvLyBHZW5lcmF0ZSB0aGUgcm9vdCBub2RlIGFycmF5LiBTZXQgcHJvcGVydGllcyBkaXJlY3RseSBvbiB0aGlzIGFycmF5IHRvIGJlXG4gIC8vIGNvcGllZCB0byB0aGUgbmV4dCBleGVjdXRpb24gcGFydC4gV2UgaGF2ZSBhIGdsb2JhbCBjb25maWd1cmF0aW9uIG9iamVjdFxuICAvLyB3aGljaCBjYW4gYmUgYWx0ZXJlZCBleHRlcm5hbGx5IGF0IGFueSBwb2ludCwgYXMgd2VsbCBhcyB3aGVuIHdlIGZpbmFsbHlcbiAgLy8gbWFrZSBhIHJlcXVlc3QuIEZvciB0aGlzIHJlYXNvbiwgaXQncyBpbXBvcnRhbnQgdGhhdCB3ZSB1c2Ugb2JqZWN0cyB3aGljaFxuICAvLyBhcmUgcGFzc2VkIGJ5IHJlZmVyZW5jZS5cbiAgdmFyIG5vZGVzID0gXy5leHRlbmQoW10sIHtcbiAgICBjb25maWc6IGNvbmZpZyB8fCAoY29uZmlnID0ge30pLFxuICAgIGNsaWVudDoge1xuICAgICAgYmFzZVVyaTogICAgICAgICAgIGFzdC5iYXNlVXJpLnJlcGxhY2UoL1xcLyskLywgJycpLFxuICAgICAgYmFzZVVyaVBhcmFtZXRlcnM6IGFzdC5iYXNlVXJpUGFyYW1ldGVycyxcbiAgICAgIHNlY3VyZWRCeTogICAgICAgICBhc3Quc2VjdXJlZEJ5LFxuICAgICAgYXV0aGVudGljYXRpb246ICAgIHt9LFxuICAgICAgc2VjdXJpdHlTY2hlbWVzOiAgIGFzdC5zZWN1cml0eVNjaGVtZXNcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFNldCB1cCB0aGUgaW5pdGlhbCBiYXNlVXJpUGFyYW1ldGVycyBjb25maWd1cmF0aW9uLlxuICBjb25maWcuYmFzZVVyaVBhcmFtZXRlcnMgPSBfLmV4dGVuZChcbiAgICB7fSwgY29uZmlnLmJhc2VVcmlQYXJhbWV0ZXJzLCBfLnBpY2soYXN0LCAndmVyc2lvbicpXG4gICk7XG5cbiAgLyoqXG4gICAqIFRoZSByb290IGNsaWVudCBpbXBsZW1lbnRhdGlvbiBpcyBzaW1wbHkgYSBmdW5jdGlvbi4gVGhpcyBhbGxvd3MgdXMgdG9cbiAgICogZW50ZXIgYSBjdXN0b20gcGF0aCB0aGF0IG1heSBub3QgYmUgc3VwcG9ydGVkIGJ5IHRoZSBEU0wgYW5kIHJ1biBhbnlcbiAgICogbWV0aG9kIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBpdCB3YXMgZGVmaW5lZCBpbiB0aGUgc3BlYy5cbiAgICpcbiAgICogQHBhcmFtICB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSAge09iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB2YXIgY2xpZW50ID0gZnVuY3Rpb24gKHBhdGgsIGNvbnRleHQpIHtcbiAgICB2YXIgcm91dGUgPSB0ZW1wbGF0ZShcbiAgICAgIHBhdGgsIHt9LCBjb250ZXh0IHx8IHt9XG4gICAgKS5yZXBsYWNlKC9eXFwvKy8sICcnKS5zcGxpdCgnLycpO1xuXG4gICAgcmV0dXJuIGF0dGFjaE1ldGhvZHMoXy5leHRlbmQoW10sIG5vZGVzLCByb3V0ZSksIHt9LCBhbGxIdHRwTWV0aG9kcyk7XG4gIH07XG5cbiAgY2xpZW50W0NPTkZJR19QUk9QRVJUWV0gICAgICA9IG5vZGVzLmNvbmZpZztcbiAgY2xpZW50W0NMSUVOVF9QUk9QRVJUWV0gICAgICA9IG5vZGVzLmNsaWVudDtcbiAgY2xpZW50W0RFU0NSSVBUSU9OX1BST1BFUlRZXSA9IENMSUVOVF9ERVNDUklQVElPTjtcbiAgY2xpZW50W1JFVFVSTl9QUk9QRVJUWV0gICAgICA9IGF0dGFjaE1ldGhvZHMobm9kZXMsIHt9LCBhbGxIdHRwTWV0aG9kcyk7XG5cbiAgYXR0YWNoUmVzb3VyY2VzKG5vZGVzLCBjbGllbnQsIGFzdC5yZXNvdXJjZXMpO1xuXG4gIHJldHVybiBjbGllbnQ7XG59O1xuXG4vKipcbiAqIEV4cG9ydHMgdGhlIGNsaWVudCBnZW5lcmF0b3IsIHdoaWNoIGFjY2VwdHMgdGhlIEFTVCBvZiBhIFJBTUwgZG9jdW1lbnQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBEeW5hbWljIG9iamVjdCBmb3IgY29uc3RydWN0aW5nIEFQSSByZXF1ZXN0cyBmcm9tIHRoZSBBU1QuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFzdCwgY29uZmlnKSB7XG4gIHJldHVybiBnZW5lcmF0ZUNsaWVudChzYW5pdGl6ZUFTVChhc3QpLCBjb25maWcpO1xufTtcbiIsIi8qIGdsb2JhbCBBcHAgKi9cbnZhciBfID0gQXBwLkxpYnJhcnkuXztcblxuLyoqXG4gKiBTYW5pdGl6ZSB0aGUgc2VjdXJlZCBieSBpbnRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gIHNlY3VyZWRcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudmFyIHNhbml0aXplU2VjdXJlZEJ5ID0gZnVuY3Rpb24gKHNlY3VyZWQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHNlY3VyZWQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc2VjdXJlZEJ5ID0ge307XG5cbiAgLy8gU2luY2UgYHNlY3VyZWRCeWAgY2FuIGVpdGhlciBiZSBhbiBhcnJheSBvZiBzdHJpbmdzIG9yIGFycmF5IG9mIG9iamVjdHNcbiAgLy8gd2l0aCBvbmx5IGEgc2luZ2xlIGtleSwgd2UgbWVyZ2UgaXQgZG93biB0byBhbiBvYmplY3QuXG4gIF8uZWFjaChzZWN1cmVkLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgYG51bGxgIGFycmF5IHZhbHVlcywgc2hvdWxkbid0IGJlIHVzZWZ1bCB0byBtZS5cbiAgICB9XG5cbiAgICBpZiAoXy5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBzZWN1cmVkQnlbdmFsdWVdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gXy5leHRlbmQoc2VjdXJlZEJ5LCB2YWx1ZSk7XG4gIH0pO1xuXG4gIHJldHVybiBzZWN1cmVkQnk7XG59O1xuXG4vKipcbiAqIFNhbml0aXplIHRoZSBBU1QgZnJvbSB0aGUgUkFNTCBwYXJzZXIgaW50byBzb21ldGhpbmcgZWFzaWVyIHRvIHdvcmsgd2l0aC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGFzdFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhc3QpIHtcbiAgaWYgKCFfLmlzU3RyaW5nKGFzdC5iYXNlVXJpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQSBiYXNlVXJpIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICAvLyBDcmVhdGUgdGhlIGJhc2Ugc2FuaXRpemVkIGFzdCB3aXRoIG9ubHkgdGhlIHByb3BlcnRpZXMgd2Ugd2FudC5cbiAgdmFyIHNhbml0aXplZEFzdCA9IF8ucGljayhhc3QsIFtcbiAgICAndGl0bGUnLFxuICAgICd2ZXJzaW9uJyxcbiAgICAnYmFzZVVyaScsXG4gICAgJ2Jhc2VVcmlQYXJhbWV0ZXJzJ1xuICBdKTtcblxuICAvLyBNZXJnZSBhbiBhcnJheSBvZiBvYmplY3RzIGludG8gYSBzaW5nbGUgb2JqZWN0IHVzaW5nIGBfLmV4dGVuZGAgYW5kXG4gIC8vIGBhcHBseWAgKHNpbmNlIGBfLmV4dGVuZGAgYWNjZXB0cyB1bmxpbWl0ZWQgbnVtYmVyIG9mIGFyZ3VtZW50cykuXG4gIGlmIChhc3Quc2VjdXJpdHlTY2hlbWVzKSB7XG4gICAgc2FuaXRpemVkQXN0LnNlY3VyaXR5U2NoZW1lcyA9IF8uZXh0ZW5kLmFwcGx5KF8sIGFzdC5zZWN1cml0eVNjaGVtZXMpO1xuICB9XG5cbiAgLy8gU2FuaXRpemUgc2VjdXJlZCBieSB3aGljaCBpcyBhIGJpdCBtb3JlIGNvbXBsaWNhdGVkIHRoYW4gZXh0ZW5kaW5nLlxuICBpZiAoYXN0LnNlY3VyZWRCeSkge1xuICAgIHNhbml0aXplZEFzdC5zZWN1cmVkQnkgPSBzYW5pdGl6ZVNlY3VyZWRCeShhc3Quc2VjdXJlZEJ5KTtcbiAgfVxuXG4gIC8vIFJlY3Vyc2UgdGhyb3VnaCB0aGUgcmVzb3VyY2VzIGFuZCBtb3ZlIFVSSXMgdG8gYmUgdGhlIGtleSBuYW1lcy5cbiAgc2FuaXRpemVkQXN0LnJlc291cmNlcyA9IChmdW5jdGlvbiBmbGF0dGVuUmVzb3VyY2VzIChyZXNvdXJjZXMpIHtcbiAgICB2YXIgbWFwID0ge307XG5cbiAgICAvLyBSZXNvdXJjZXMgYXJlIHByb3ZpZGVkIGFzIGFuIGFycmF5LCB3ZSdsbCBtb3ZlIHRoZW0gdG8gYmUgYW4gb2JqZWN0LlxuICAgIF8uZWFjaChyZXNvdXJjZXMsIGZ1bmN0aW9uIChyZXNvdXJjZSkge1xuICAgICAgdmFyIHNhbml0aXplZFJlc291cmNlID0ge307XG5cbiAgICAgIC8vIE1ldGhvZHMgYXJlIGltcGxlbWVudGVkIGFzIGFycmF5cyBvZiBvYmplY3RzIHRvbywgYnV0IG5vdCByZWN1cnNpdmVseS5cbiAgICAgIC8vIFRPRE86IElmIHRoZSBlbmRwb2ludCBpcyB0aGUgZmluYWwgcm91dGUgYW5kIGhhcyBubyBtZXRob2RzLCBpbXBsZW1lbnRcbiAgICAgIC8vIGJhY2t0cmFja2luZyBhbmQgcmVtb3ZlIGFjY2VzcyB0byBpdCBmcm9tIHRoZSBBU1QuXG4gICAgICBpZiAocmVzb3VyY2UubWV0aG9kcykge1xuICAgICAgICBzYW5pdGl6ZWRSZXNvdXJjZS5tZXRob2RzID0gXy5vYmplY3QoXG4gICAgICAgICAgXy5wbHVjayhyZXNvdXJjZS5tZXRob2RzLCAnbWV0aG9kJyksXG4gICAgICAgICAgXy5tYXAocmVzb3VyY2UubWV0aG9kcywgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBzYW5pdGl6ZWQgbWV0aG9kIGJ5IGluY2x1ZGluZyB0aGUgcHJvcGVydGllcyB3ZSB3YW50LlxuICAgICAgICAgICAgdmFyIHNhbml0aXplZE1ldGhvZCA9IF8ucGljayhtZXRob2QsIFtcbiAgICAgICAgICAgICAgJ21ldGhvZCcsXG4gICAgICAgICAgICAgICdib2R5JyxcbiAgICAgICAgICAgICAgJ2hlYWRlcnMnLFxuICAgICAgICAgICAgICAnZGVzY3JpcHRpb24nLFxuICAgICAgICAgICAgICAncXVlcnlQYXJhbWV0ZXJzJ1xuICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgIC8vIFNhbml0aXplIHRoZSBgc2VjdXJlZEJ5YCBtZXRob2QuXG4gICAgICAgICAgICBpZiAobWV0aG9kLnNlY3VyZWRCeSkge1xuICAgICAgICAgICAgICBzYW5pdGl6ZWRNZXRob2Quc2VjdXJlZEJ5ID0gc2FuaXRpemVTZWN1cmVkQnkobWV0aG9kLnNlY3VyZWRCeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzYW5pdGl6ZWRNZXRob2Q7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc291cmNlLnJlc291cmNlcykge1xuICAgICAgICBzYW5pdGl6ZWRSZXNvdXJjZS5yZXNvdXJjZXMgPSBmbGF0dGVuUmVzb3VyY2VzKHJlc291cmNlLnJlc291cmNlcyk7XG4gICAgICB9XG5cbiAgICAgIChmdW5jdGlvbiBhdHRhY2hSZXNvdXJjZSAobWFwLCBzZWdtZW50cykge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzLnNoaWZ0KCk7XG4gICAgICAgIHZhciBwYXJ0ICAgID0gbWFwW3NlZ21lbnRdID0ge307XG5cbiAgICAgICAgLy8gQ3VycmVudGx5IG9uIHRoZSBsYXN0IHVybCBzZWdtZW50LCBlbWJlZCB0aGUgZnVsbCByZXNvdXJjZS5cbiAgICAgICAgaWYgKCFzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBwYXJ0ID0gbWFwW3NlZ21lbnRdID0gc2FuaXRpemVkUmVzb3VyY2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQdWxsIGFueSBwb3NzaWJsZSB0YWdzIG91dCBvZiB0aGUgcmVsYXRpdmUgdXJpIHBhcnQuXG4gICAgICAgIHZhciB0YWdzID0gXy5tYXAoc2VnbWVudC5tYXRjaCgvXFx7KFteXFx9XSspXFx9L2cpLCBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgICAgcmV0dXJuIHRhZy5zbGljZSgxLCAtMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFkZCBvbmx5IHRoZSB1c2VkIHRhZ3MgdG8gdGhlIGN1cnJlbnQgcmVzb3VyY2Ugc2VnbWVudC5cbiAgICAgICAgaWYgKHRhZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgcGFydC51cmlQYXJhbWV0ZXJzID0gXy5waWNrKHJlc291cmNlLnVyaVBhcmFtZXRlcnMsIHRhZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBtb3JlIHNlZ21lbnQgcGFydHMgbGVmdCwgcmVjdXJzaXZlbHkgZW1iZWQgcmVzb3VyY2VzLlxuICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgcGFydC5yZXNvdXJjZXMgPSBwYXJ0LnJlc291cmNlcyB8fCB7fTtcblxuICAgICAgICAgIHJldHVybiBhdHRhY2hSZXNvdXJjZShwYXJ0LnJlc291cmNlcywgc2VnbWVudHMpO1xuICAgICAgICB9XG4gICAgICB9KShtYXAsIHJlc291cmNlLnJlbGF0aXZlVXJpLnN1YnN0cigxKS5zcGxpdCgnLycpKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBtYXA7XG4gIH0pKGFzdC5yZXNvdXJjZXMpO1xuXG4gIHJldHVybiBzYW5pdGl6ZWRBc3Q7XG59O1xuIiwiLyogZ2xvYmFsIEFwcCAqL1xudmFyIF8gICAgICAgICAgICAgICA9IEFwcC5fO1xudmFyIHJhbWxQYXJzZXIgICAgICA9IHJlcXVpcmUoJ3JhbWwtcGFyc2VyJyk7XG52YXIgYXV0aGVudGljYXRlICAgID0gcmVxdWlyZSgnLi9hdXRoZW50aWNhdGUnKTtcbnZhciBjbGllbnRHZW5lcmF0b3IgPSByZXF1aXJlKCcuL2NsaWVudC1nZW5lcmF0b3InKTtcbnZhciBmcm9tUGF0aCAgICAgICAgPSByZXF1aXJlKCcuLi8uLi9saWIvZnJvbS1wYXRoJyk7XG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gaGVscGVycy5cbiAqL1xucmVxdWlyZSgnLi9pbmplY3QtYXBpLWtleXMnKTtcbnJlcXVpcmUoJy4vaW5zZXJ0LWFwaS1jbGllbnQnKTtcblxuLyoqXG4gKiBQcm92aWRlZCBhIHNwZWNpYWwgZG9jdW1lbnRhdGlvbiBwcm9wZXJ0eSBmb3IgZnVuY3Rpb25zdyB3aXRoIGFub3RoZXIgcGx1Z2luLlxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbnZhciBERVNDUklQVElPTl9QUk9QRVJUWSA9ICchZGVzY3JpcHRpb24nO1xuXG4vKipcbiAqIEN1c3RvbSBmaWxlIHJlYWRlciBmb3IgUkFNTCBzcGVjcy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICB1cmxcbiAqIEByZXR1cm4ge1EuZGVmZXJ9XG4gKi9cbnZhciBjcmVhdGVSZWFkZXIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgcmFtbFBhcnNlci5GaWxlUmVhZGVyKGZ1bmN0aW9uICh1cmwpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSB0aGlzLnEuZGVmZXIoKTtcblxuICAgIEFwcC5taWRkbGV3YXJlLnRyaWdnZXIoJ2FqYXgnLCB7XG4gICAgICB1cmw6IHVybCxcbiAgICAgIHByb3h5OiBjb25maWcucHJveHksXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vcmFtbCt5YW1sLCAqLyonXG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVyciwgeGhyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE1hdGguZmxvb3IoeGhyLnN0YXR1cyAvIDEwMCkgIT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnJlamVjdChcbiAgICAgICAgICBuZXcgRXJyb3IoJ1JlY2VpdmVkIHN0YXR1cyBjb2RlICcgKyB4aHIuc3RhdHVzICsgJyBsb2FkaW5nICcgKyB1cmwpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWZlcnJlZC5yZXNvbHZlKHhoci5yZXNwb25zZVRleHQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBUaGUgQXBpIG9iamVjdCBpcyB1c2VkIGluIHRoZSBleGVjdXRpb24gY29udGV4dC5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgQVBJID0ge307XG5cbi8qKlxuICogUmVzcG9uc2libGUgZm9yIGxvYWRpbmcgUkFNTCBkb2N1bWVudHMgYW5kIHJldHVybiBBUEkgY2xpZW50cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gICBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gICBbdXJsXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG5BUEkuY3JlYXRlQ2xpZW50ID0gZnVuY3Rpb24gKG5hbWUsIHVybCwgY29uZmlnLCBkb25lKSB7XG4gIGlmICghXy5pc1N0cmluZyhuYW1lKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZSBhIG5hbWUgZm9yIHRoZSBnZW5lcmF0ZWQgY2xpZW50Jyk7XG4gIH1cblxuICBpZiAoIV8uaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZSBhIFVSTCBmb3IgdGhlICcgKyBuYW1lICsgJyBSQU1MIGRvY3VtZW50Jyk7XG4gIH1cblxuICAvLyBBbGxvdyB0aGUgY29uZmlnIG9iamVjdCB0byBiZSBza2lwcGVkLlxuICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRvbmUgICA9IGFyZ3VtZW50c1syXTtcbiAgICBjb25maWcgPSB7fTtcbiAgfVxuXG4gIEFwcC5fZXhlY3V0ZUNvbnRleHQudGltZW91dChJbmZpbml0eSk7XG4gIGRvbmUgICA9IGRvbmUgICB8fCBBcHAuX2V4ZWN1dGVDb250ZXh0LmFzeW5jKCk7XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuICAvLyBQYXNzIG91ciB1cmwgdG8gdGhlIFJBTUwgcGFyc2VyIGZvciBwcm9jZXNzaW5nIGFuZCB0cmFuc2Zvcm0gdGhlIHByb21pc2VcbiAgLy8gYmFjayBpbnRvIGEgY2FsbGJhY2sgZm9ybWF0LlxuICByYW1sUGFyc2VyLmxvYWRGaWxlKHVybCwge1xuICAgIHJlYWRlcjogY3JlYXRlUmVhZGVyKGNvbmZpZylcbiAgfSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBjbGllbnQ7XG5cbiAgICB0cnkge1xuICAgICAgY2xpZW50ID0gY2xpZW50R2VuZXJhdG9yKGRhdGEsIGNvbmZpZyk7XG4gICAgICBmcm9tUGF0aChBcHAuX2V4ZWN1dGVXaW5kb3csIG5hbWUuc3BsaXQoJy4nKSwgY2xpZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZG9uZShlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9uZShcbiAgICAgIG51bGwsXG4gICAgICAnQ3JlYXRlIGEgbmV3IGNvZGUgY2VsbCBhbmQgdHlwZSBcXCcnICsgbmFtZSArICcuXFwnICcgK1xuICAgICAgJ3RvIGV4cGxvcmUgdGhpcyBBUEkuJ1xuICAgICk7XG4gIH0sIGRvbmUpO1xufTtcblxuLyoqXG4gKiBEZXNjcmlwdGlvbiBvZiB0aGUgY3JlYXRlIGNsaWVudCBmdW5jdGlvbi5cbiAqL1xuQVBJLmNyZWF0ZUNsaWVudFtERVNDUklQVElPTl9QUk9QRVJUWV0gPSB7XG4gICchdHlwZSc6ICdmbihhbGlhcywgdXJsLCBvcHRpb25zPywgY2I/KScsXG4gICchYXJncyc6IFt7XG4gICAgJyF0eXBlJzogJ3N0cmluZydcbiAgfSwge1xuICAgICchdHlwZSc6ICdzdHJpbmcnXG4gIH0sIHtcbiAgICAnIXR5cGUnOiAnb2JqZWN0JyxcbiAgICAnIWRvYyc6IFtcbiAgICAgICdJbml0aWFsaXplIHRoZSBjbGllbnQgd2l0aCBkZWZhdWx0IGNvbmZpZyBvcHRpb25zLiBWYWxpZCBvcHRpb25zOicsXG4gICAgICAnKiAqKnByb3h5Kio6IFNldCB0byBhIGN1c3RvbSBwcm94eSBvciBgZmFsc2VgIHRvIGRpc2FibGUgZW50aXJlbHknLFxuICAgICAgJyogKipib2R5Kio6IFNldCBhIGZhbGxiYWNrIHJlcXVlc3QgYm9keScsXG4gICAgICAnKiAqKnVyaVBhcmFtZXRlcnMqKjogU2V0IGZhbGxiYWNrIHVyaSBwYXJhbWV0ZXJzIHRvIGluamVjdCcsXG4gICAgICAnKiAqKmJhc2VVcmlQYXJhbWV0ZXJzKio6IEluamVjdCBiYXNlIHVyaSBwYXJhbWV0ZXJzIHRvIG92ZXJyaWRlJyxcbiAgICAgICcqICoqaGVhZGVycyoqOiBTZXQgZGVmYXVsdCBoZWFkZXJzIHRvIHNlbmQgd2l0aCBldmVyeSByZXF1ZXN0JyxcbiAgICAgICcqICoqcXVlcnkqKjogU2V0IGEgZGVmYXVsdCBxdWVyeSBzdHJpbmcgdG8gc2VuZCB3aXRoIGV2ZXJ5IHJlcXVlc3QnXG4gICAgXS5qb2luKCdcXG4nKVxuICB9LCB7XG4gICAgJyF0eXBlJzogJ2ZuKGVycm9yLCBjbGllbnQpJyxcbiAgICAnIWRvYyc6IFtcbiAgICAgICdQYXNzIGluIGEgY3VzdG9tIGNhbGxiYWNrIHRvIHJ1biB3aGVuIHRoZSBjbGllbnQgaGFzIGxvYWRlZC4nXG4gICAgXS5qb2luKCdcXG4nKVxuICB9XSxcbiAgJyFkb2MnOiBbXG4gICAgJ0dlbmVyYXRlIGFuIEFQSSBjbGllbnQgZnJvbSBhIFJBTUwgZG9jdW1lbnQgYW5kIGFsaWFzIGl0IG9uIHRoZSB3aW5kb3cuJ1xuICBdLmpvaW4oJyAnKVxufTtcblxuLyoqXG4gKiBTZXQgYSBjb25maWd1cmF0aW9uIHZhbHVlIG9uIGEgY2xpZW50LlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsaWVudFxuICogQHBhcmFtIHtTdHJpbmd9ICAga2V5XG4gKiBAcGFyYW0geyp9ICAgICAgICB2YWx1ZVxuICovXG5BUEkuc2V0ID0gZnVuY3Rpb24gKGNsaWVudCwga2V5LCB2YWx1ZSkge1xuICAvLyBJZiB3ZSBkb24ndCBoYXZlIGVub3VnaCBhcmd1bWVudHMgZm9yIGEga2V5IGFuZCB2YWx1ZSwgYXNzdW1lIHdlIGhhdmVcbiAgLy8gYSBmcmVzaCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgcmV0dXJuIF8uZXh0ZW5kKGNsaWVudFsnIWNvbmZpZyddLCBrZXkpO1xuICB9XG5cbiAgcmV0dXJuIGNsaWVudFsnIWNvbmZpZyddW2tleV0gPSB2YWx1ZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgQVBJIGNsaWVudCBjb25maWd1cmF0aW9uIHNldHRlci5cbiAqL1xuQVBJLnNldFtERVNDUklQVElPTl9QUk9QRVJUWV0gPSB7XG4gICchdHlwZSc6ICdmbihjbGllbnQsIGtleSwgdmFsdWUpJyxcbiAgJyFhcmdzJzogW3tcbiAgICAnIXR5cGUnOiAnZnVuY3Rpb24nLFxuICAgICchZG9jJzogJ0EgZnVuY3Rpb24gZ2VuZXJhdGVkIGJ5IGBBUEkuY3JlYXRlQ2xpZW50YC4nXG4gIH0sIHtcbiAgICAnIXR5cGUnOiAnc3RyaW5nJ1xuICB9XSxcbiAgJyFkb2MnOiAnU2V0IGEgY29uZmlndXJhdGlvbiBvcHRpb24gb2YgYSBSQU1MIEFQSSBjbGllbnQuJ1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSBhIHZhbHVlIGZyb20gdGhlIGNsaWVudCBjb25maWcgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjbGllbnRcbiAqIEBwYXJhbSAge1N0cmluZ30gICBrZXlcbiAqIEByZXR1cm4geyp9XG4gKi9cbkFQSS5nZXQgPSBmdW5jdGlvbiAoY2xpZW50LCBrZXkpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIGNsaWVudFsnIWNvbmZpZyddO1xuICB9XG5cbiAgcmV0dXJuIGNsaWVudFsnIWNvbmZpZyddW2tleV07XG59O1xuXG4vKipcbiAqIFNldCB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIEFQSSBjbGllbnQgY29uZmlndXJhdGlvbiBnZXR0ZXIuXG4gKi9cbkFQSS5nZXRbREVTQ1JJUFRJT05fUFJPUEVSVFldID0ge1xuICAnIXR5cGUnOiAnZm4oY2xpZW50LCBrZXkpJyxcbiAgJyFhcmdzJzogW3tcbiAgICAnIXR5cGUnOiAnZnVuY3Rpb24nLFxuICAgICchZG9jJzogJ0EgZnVuY3Rpb24gZ2VuZXJhdGVkIGJ5IGBBUEkuY3JlYXRlQ2xpZW50YC4nXG4gIH0sIHtcbiAgICAnIXR5cGUnOiAnc3RyaW5nJ1xuICB9XSxcbiAgJyFkb2MnOiAnR2V0IGEgY29uZmlndXJhdGlvbiBvcHRpb24gZnJvbSBhIFJBTUwgQVBJIGNsaWVudC4nXG59O1xuXG4vKipcbiAqIFVuc2V0IGEga2V5IGZyb20gdGhlIGNsaWVudCBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjbGllbnRcbiAqIEBwYXJhbSAge1N0cmluZ30gICBrZXlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkFQSS51bnNldCA9IGZ1bmN0aW9uIChjbGllbnQsIGtleSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICBfLmVhY2goY2xpZW50WychY29uZmlnJ10sIGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBvYmopIHtcbiAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGRlbGV0ZSBjbGllbnRbJyFjb25maWcnXVtrZXldO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBBUEkgY2xpZW50IGNvbmZpZ3VyYXRpb24gdW5zZXR0ZXIuXG4gKi9cbkFQSS51bnNldFtERVNDUklQVElPTl9QUk9QRVJUWV0gPSB7XG4gICchdHlwZSc6ICdmbihjbGllbnQsIGtleSknLFxuICAnIWFyZ3MnOiBbe1xuICAgICchdHlwZSc6ICdmdW5jdGlvbicsXG4gICAgJyFkb2MnOiAnQSBmdW5jdGlvbiBnZW5lcmF0ZWQgYnkgYEFQSS5jcmVhdGVDbGllbnRgLidcbiAgfSwge1xuICAgICchdHlwZSc6ICdzdHJpbmcnXG4gIH1dLFxuICAnIWRvYyc6ICdVbnNldCBhIGNvbmZpZ3VyYXRpb24gb3B0aW9uIGZyb20gYSBSQU1MIEFQSSBjbGllbnQuJ1xufTtcblxuLyoqXG4gKiBBdXRoZW50aWNhdGUgYSBSQU1MIEFQSSBjbGllbnQgcGFzc2luZyBhbiBvcHRpb25hbCBtZXRob2QgYW5kIGFjY29tcGFueWluZ1xuICogb3B0aW9ucyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xpZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gICBtZXRob2RcbiAqIEBwYXJhbSB7T2JqZWN0fSAgIG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAqL1xuQVBJLmF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uIChjbGllbnQsIG1ldGhvZCwgb3B0aW9ucywgZG9uZSkge1xuICBBcHAuX2V4ZWN1dGVDb250ZXh0LnRpbWVvdXQoMTAgKiA2MCAqIDEwMDApO1xuICBkb25lID0gZG9uZSB8fCBBcHAuX2V4ZWN1dGVDb250ZXh0LmFzeW5jKCk7XG5cbiAgdmFyIGNsaWVudE9wdGlvbiAgICA9IGNsaWVudFsnIWNsaWVudCddO1xuICB2YXIgc2VjdXJpdHlTY2hlbWVzID0gY2xpZW50T3B0aW9uLnNlY3VyaXR5U2NoZW1lcztcblxuICAvKipcbiAgICogVGhlIGNhbGxiYWNrIGlzIHVzZWQgdG8gaGFuZGxlIHRoZSBwZXJzaXN0ZW5jZSBvZiBkYXRhIHRvIHRoZSBjbGllbnQuXG4gICAqXG4gICAqIEBwYXJhbSAge0Vycm9yfSAgICBlcnJcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIHNjaGVtZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgdG9rZW5zXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cbiAgdmFyIGNiID0gZnVuY3Rpb24gKGVyciwgc2NoZW1lLCBvcHRpb25zLCB0b2tlbnMpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgIH1cblxuICAgIC8vIEFsaWFzIG9udG8gdGhlIGNsaWVudCBvYmplY3QgZm9yIGZ1dHVyZSB1c2UuXG4gICAgY2xpZW50T3B0aW9uLmF1dGhlbnRpY2F0aW9uW3NjaGVtZS50eXBlXSA9IF8uZXh0ZW5kKHt9LCBvcHRpb25zLCB0b2tlbnMpO1xuXG4gICAgcmV0dXJuIGRvbmUobnVsbCwgdG9rZW5zKTtcbiAgfTtcblxuICByZXR1cm4gYXV0aGVudGljYXRlKHNlY3VyaXR5U2NoZW1lcywgbWV0aG9kLCBvcHRpb25zLCBjYik7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIEFQSSBjbGllbnQgYXV0aGVudGljYXRvci5cbiAqL1xuQVBJLmF1dGhlbnRpY2F0ZVtERVNDUklQVElPTl9QUk9QRVJUWV0gPSB7XG4gICchdHlwZSc6IFtcbiAgICAnZm4oY2xpZW50LCBtZXRob2Q/LCBvcHRpb25zPywgY2I/KSdcbiAgXS5qb2luKCcnKSxcbiAgJyFhcmdzJzogW3tcbiAgICAnIXR5cGUnOiAnZnVuY3Rpb24nLFxuICAgICchZG9jJzogJ0EgZnVuY3Rpb24gZ2VuZXJhdGVkIGJ5IGBBUEkuY3JlYXRlQ2xpZW50YC4nXG4gIH0sIHtcbiAgICAnIXR5cGUnOiAnc3RyaW5nJyxcbiAgICAnIWRvYyc6ICdTZWxlY3QgYW4gYXV0aGVudGljYXRpb24gbWV0aG9kIGRlZmluZWQgaW4gdGhlIFJBTUwgZmlsZS4nXG4gIH0sIHtcbiAgICAnIXR5cGUnOiAnb2JqZWN0JyxcbiAgICAnIWRvYyc6ICdDb3ZlcnJpZGUgdGhlIGRlZmF1bHQgc2VsZWN0ZWQgYXV0aGVudGljYXRpb24gbWV0aG9kIG9wdGlvbnMuJ1xuICB9LCB7XG4gICAgJyF0eXBlJzogJ2Z1bmN0aW9uJ1xuICB9XSxcbiAgJyFkb2MnOiBbXG4gICAgJ0F1dGhlbnRpY2F0aW9uIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLiBGb3IgcG9wdWxhciBBUElzLCB3ZSBwcm92aWRlJyxcbiAgICAna2V5cy4gSWYgd2UgbmVlZCB5b3VyIGtleXMgd2Ugd2lsbCBwcm9tcHQgeW91IHZpYSBhIG1vZGFsLiBOZXZlciBlbnRlcicsXG4gICAgJ2tleXMgZGlyZWN0bHkgaW50byBhIG5vdGVib29rIHVubGVzcyB5b3UgZXhwbGljaXRseSBpbnRlbmQgdG8gc2hhcmUnLFxuICAgICd0aGVtLiBJZiB5b3Ugd291bGQgbGlrZSB0byBrbm93IG1vcmUgYWJvdXQgYXV0aGVudGljYXRpbmcnLFxuICAgICd3aXRoIHRoaXMgQVBJLCBzZWUgXFwnc2VjdXJpdHlTY2hlbWUuc2V0dGluZ3NcXCcgaW4gdGhlIFJBTUwgZmlsZS4nXG4gIF0uam9pbignICcpXG59O1xuXG4vKipcbiAqIEFsdGVyIHRoZSBjb250ZXh0IHRvIGluY2x1ZGUgdGhlIFJBTUwgY2xpZW50IGdlbmVyYXRvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gKi9cbmV4cG9ydHNbJ3NhbmRib3g6Y29udGV4dCddID0gZnVuY3Rpb24gKGNvbnRleHQsIG5leHQpIHtcbiAgLy8gVGhpcyBpcyBleHRyZW1lbHkgamFua3ksIGJ1dCBpcyByZXF1aXJlZCBmb3IgU2FmYXJpIDcuMCB3aGljaCBzZWVtcyB0b1xuICAvLyBiZSBpZ25vcmluZyBkaXJlY3QgcHJvcGVydHkgYXNzaWdubWVudHMgdW5kZXIgY2VydGFpbiBjb25kaXRpb25zLlxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udGV4dCwgJ0FQSScsIHsgdmFsdWU6IEFQSSB9KTtcbiAgcmV0dXJuIG5leHQoKTtcbn07XG4iLCIvKiBnbG9iYWwgQXBwICovXG52YXIgYXBpS2V5cyA9IHt9LnJhbWxDbGllbnQ7XG5cbi8qKlxuICogQ2hlY2sgYWdhaW5zdCBvdXIgT0F1dGggdG9rZW5zIGFuZCBpbmplY3QgdGhlIHRva2VucyB3ZSBoYXZlIGF2YWlsYWJsZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gICBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0XG4gKi9cbkFwcC5taWRkbGV3YXJlLnJlZ2lzdGVyKCdyYW1sQ2xpZW50OnRva2VuJywgZnVuY3Rpb24gKHNjaGVtZSwgbmV4dCwgZG9uZSkge1xuICB2YXIgYXV0aFVyaSA9IHNjaGVtZS5zZXR0aW5ncy5hdXRob3JpemF0aW9uVXJpO1xuXG4gIGlmIChzY2hlbWUudHlwZSA9PT0gJ09BdXRoIDEuMCcgJiYgYXBpS2V5cy5vYXV0aDFbYXV0aFVyaV0pIHtcbiAgICByZXR1cm4gZG9uZShudWxsLCBhcGlLZXlzLm9hdXRoMVthdXRoVXJpXSk7XG4gIH1cblxuICBpZiAoc2NoZW1lLnR5cGUgPT09ICdPQXV0aCAyLjAnICYmIGFwaUtleXMub2F1dGgyW2F1dGhVcmldKSB7XG4gICAgcmV0dXJuIGRvbmUobnVsbCwgYXBpS2V5cy5vYXV0aDJbYXV0aFVyaV0pO1xuICB9XG5cbiAgcmV0dXJuIG5leHQoKTtcbn0pO1xuIiwiLyogZ2xvYmFsIEFwcCAqL1xudmFyIF8gICAgICAgICAgPSBBcHAuTGlicmFyeS5fO1xudmFyIEJhY2tib25lICAgPSBBcHAuTGlicmFyeS5CYWNrYm9uZTtcbnZhciBjaGFuZ2VDYXNlID0gQXBwLkxpYnJhcnkuY2hhbmdlQ2FzZTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gYXBpIGNsaWVudCBjZWxsIHRoYXQgY2FuIGxvYWQgdGhlIHNlbGVjdGVkIGFwaSBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0gIHtDZWxsfSAgICAgY2VsbFxuICogQHBhcmFtICB7U3RyaW5nfSAgIGludm9rZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbnZhciBjcmVhdGVBcGlDbGllbnRDZWxsID0gZnVuY3Rpb24gKGNlbGwsIGludm9rZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGVyciwgYXBpKSB7XG4gICAgaWYgKGVycikgeyByZXR1cm47IH1cblxuICAgIHZhciB1cmwgICAgICA9IGFwaS5yYW1sVXJsO1xuICAgIHZhciB2YXJpYWJsZSA9IGNoYW5nZUNhc2UuY2FtZWxDYXNlKGFwaS50aXRsZSk7XG4gICAgdmFyIGNvZGUgICAgID0gW1xuICAgICAgJy8vIFJlYWQgYWJvdXQgdGhlICcgKyBhcGkudGl0bGUgKyAnIGF0ICcgKyBhcGkucG9ydGFsVXJsLFxuICAgICAgJ0FQSS5jcmVhdGVDbGllbnQoXFwnJyArIHZhcmlhYmxlICsgJ1xcJywgXFwnJyArIHVybCArICdcXCcpOydcbiAgICBdLmpvaW4oJ1xcbicpO1xuXG4gICAgdmFyIHZpZXcgPSBjZWxsLm5vdGVib29rW2ludm9rZSArICdDb2RlVmlldyddKGNlbGwuZWwsIGNvZGUpLmV4ZWN1dGUoKTtcblxuICAgIGNlbGwuZm9jdXMoKTtcblxuICAgIC8vIFRyaWdnZXIgYSByYW1sIGNsaWVudCBpbnNlcnRpb24gbWVzc2FnZS5cbiAgICBBcHAubWVzc2FnZXMudHJpZ2dlcigncmFtbENsaWVudDppbnNlcnQnKTtcblxuICAgIHJldHVybiB2aWV3O1xuICB9O1xufTtcblxuLyoqXG4gKiBMb2FkIGFsbCB0aGUgQVBJIGRlZmluaXRpb25zIGFuZCByZXR1cm4gdGhlIGl0ZW1zIGFzIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAqL1xudmFyIGxvYWRBUElEZWZpbml0aW9ucyA9IGZ1bmN0aW9uIChkb25lKSB7XG4gIHJldHVybiBBcHAubWlkZGxld2FyZS50cmlnZ2VyKCdhamF4Jywge1xuICAgIHVybDogJ2h0dHA6Ly9hcGkuYXBpaHViLmNvbS92MS9hcGlzP3NwZWNGb3JtYXQ9UkFNTCdcbiAgfSwgZnVuY3Rpb24gKGVyciwgeGhyKSB7XG4gICAgcmV0dXJuIGRvbmUoZXJyLCBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpLml0ZW1zKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFNob3cgUkFNTCBkZWZpbml0aW9ucyB0byB1c2VycyBpbiBhIG1vZGFsLCBhbmQgdXBvbiBzZWxlY3Rpb24gcGFzcyB0aGVcbiAqIHNlbGVjdGVkIGRlZmluaXRpb24gYmFjayB0byB0aGUgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICovXG52YXIgc2VsZWN0QVBJRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIChkb25lKSB7XG4gIC8vIFRyaWdnZXIgbW9kYWwgZGlzcGxheSBtZXNzYWdlcy5cbiAgQXBwLm1lc3NhZ2VzLnRyaWdnZXIoJ3JhbWxDbGllbnQ6bW9kYWwnKTtcblxuICByZXR1cm4gQXBwLm1pZGRsZXdhcmUudHJpZ2dlcigndWk6bW9kYWwnLCB7XG4gICAgdGl0bGU6ICdJbnNlcnQgYW4gQVBJIENsaWVudCcsXG4gICAgY29udGVudDogZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgIHJldHVybiBsb2FkQVBJRGVmaW5pdGlvbnMoZnVuY3Rpb24gKGVyciwgaXRlbXMpIHtcbiAgICAgICAgaWYgKGVycikgeyByZXR1cm4gZG9uZShlcnIpOyB9XG5cbiAgICAgICAgcmV0dXJuIGRvbmUobnVsbCwgJzxkaXYgY2xhc3M9XCJtb2RhbC1pbnN0cnVjdGlvbnNcIj4nICtcbiAgICAgICAgICAnSW5zZXJ0IGFuIEFQSSBjbGllbnQgZnJvbSBhIFJBTUwgc3BlY2lmaWNhdGlvbi4nICtcbiAgICAgICAgICAnIEFuIEFQSSBjbGllbnQgaXMgYSBKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9uIG9mIGFuIEFQSScgK1xuICAgICAgICAgICcgdGhhdCB5b3UgY2FuIHVzZSB0byBleHBsb3JlIGF2YWlsYWJsZSBlbmRwb2ludHMgYW5kJyArXG4gICAgICAgICAgJyB0aGVpciBwYXJhbWV0ZXJzLiAnICtcbiAgICAgICAgICAnPGEgaHJlZj1cImh0dHA6Ly9yYW1sLm9yZy9cIiB0YXJnZXQ9XCJfYmxhbmtcIj4nICtcbiAgICAgICAgICAnTGVhcm4gbW9yZSBhYm91dCBSQU1MPC9hPi4nICtcbiAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCJmb3JtLWdyb3VwXCI+JyArXG4gICAgICAgICAgJzxpbnB1dCBjbGFzcz1cIml0ZW0tc2VhcmNoXCIgcGxhY2Vob2xkZXI9XCJTZWFyY2hcIj4nICtcbiAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgJzx1bCBjbGFzcz1cIml0ZW0tbGlzdFwiPicgK1xuICAgICAgICAgIF8ubWFwKGl0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuICc8bGkgZGF0YS10aXRsZT1cIicgKyBpdGVtLnRpdGxlICsgJ1wiICcgK1xuICAgICAgICAgICAgICAnZGF0YS1yYW1sPVwiJyArIGl0ZW0uc3BlY3MuUkFNTC51cmwgKyAnXCIgJyArXG4gICAgICAgICAgICAgICdkYXRhLXRpdGxlPVwiJyArIGl0ZW0udGl0bGUgKyAnXCIgJyArXG4gICAgICAgICAgICAgICdkYXRhLXBvcnRhbD1cIicgKyBpdGVtLmFwaWh1YlBvcnRhbCArICdcIj4nICtcbiAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJpdGVtLWFjdGlvblwiPicgK1xuICAgICAgICAgICAgICAnPGEgaHJlZj1cIiNcIiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeSBidG4tc21hbGxcIj5BZGQ8L2E+JyArXG4gICAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJpdGVtLWRlc2NyaXB0aW9uXCI+JyArIGl0ZW0udGl0bGUgK1xuICAgICAgICAgICAgICAnPGEgaHJlZj1cIiNcIiBjbGFzcz1cIml0ZW0tZGV0YWlscy1saW5rXCIgZGF0YS1kZXRhaWxzPmRldGFpbHM8L2E+JyArXG4gICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiaXRlbS1kZXRhaWxzXCI+JyArIGl0ZW0uZGVzY3JpcHRpb24gKyAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICAgJzwvbGk+JztcbiAgICAgICAgICB9KS5qb2luKCcnKSArICc8L3VsPicgK1xuICAgICAgICAgICc8cCBjbGFzcz1cImhpZGUgaXRlbS1saXN0LXVuYXZhaWxhYmxlXCI+Tm8gbWF0Y2hpbmcgQVBJcyBmb3VuZC4gJyArXG4gICAgICAgICAgJ1BsZWFzZSBzZWFyY2ggb24gdGhlIDxhICcgK1xuICAgICAgICAgICdocmVmPVwiaHR0cDovL2FwaS1wb3J0YWwuYW55cG9pbnQubXVsZXNvZnQuY29tL1wiIHRhcmdldD1cIl9ibGFua1wiPicgK1xuICAgICAgICAgICdBbnlwb2ludCBBUEkgUG9ydGFsPC9hPiBhbmQgc3VibWl0IGEgcmVxdWVzdCBmb3IgbW9yZSAnICtcbiAgICAgICAgICAnZG9jdW1lbnRhdGlvbiBmb3IgdGhpcyBBUEkuPC9wPidcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2hvdzogZnVuY3Rpb24gKG1vZGFsKSB7XG4gICAgICBCYWNrYm9uZS4kKG1vZGFsLmVsKVxuICAgICAgICAub24oJ2NsaWNrJywgJ1tkYXRhLWRldGFpbHNdJywgZnVuY3Rpb24gKGUsIHRhcmdldCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgdmFyIGNsYXNzTGlzdCA9IHRhcmdldC5wYXJlbnROb2RlLnBhcmVudE5vZGUuY2xhc3NMaXN0O1xuXG4gICAgICAgICAgaWYgKCFjbGFzc0xpc3QuY29udGFpbnMoJ2l0ZW0tZGV0YWlscy12aXNpYmxlJykpIHtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQoJ2l0ZW0tZGV0YWlscy12aXNpYmxlJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoJ2l0ZW0tZGV0YWlscy12aXNpYmxlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAub24oJ2NsaWNrJywgJ1tkYXRhLXJhbWxdJywgZnVuY3Rpb24gKGUsIHRhcmdldCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIC8vIENsb3NlIHRoZSBtb2RhbCBiZWhpbmQgb3Vyc2VsdmVzLlxuICAgICAgICAgIG1vZGFsLmNsb3NlKCk7XG5cbiAgICAgICAgICByZXR1cm4gZG9uZShudWxsLCB7XG4gICAgICAgICAgICB0aXRsZTogICAgIHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGl0bGUnKSxcbiAgICAgICAgICAgIHJhbWxVcmw6ICAgdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1yYW1sJyksXG4gICAgICAgICAgICBwb3J0YWxVcmw6IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcG9ydGFsJylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdrZXl1cCcsICcuaXRlbS1zZWFyY2gnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBsaXN0SXRlbUVscyAgID0gbW9kYWwuZWwucXVlcnlTZWxlY3RvckFsbCgnLml0ZW0tbGlzdCA+IGxpJyk7XG4gICAgICAgICAgdmFyIHVuYXZhaWxhYmxlRWwgPSBtb2RhbC5lbC5xdWVyeVNlbGVjdG9yKCcuaXRlbS1saXN0LXVuYXZhaWxhYmxlJyk7XG5cbiAgICAgICAgICB2YXIgaGFzUmVzdWx0cyA9IF8uZmlsdGVyKGxpc3RJdGVtRWxzLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciB0aXRsZSAgID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXRpdGxlJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gdGl0bGUuaW5kZXhPZihlLnRhcmdldC52YWx1ZS50b0xvd2VyQ2FzZSgpKSA+IC0xO1xuXG4gICAgICAgICAgICBlbC5jbGFzc0xpc3RbbWF0Y2hlcyA/ICdyZW1vdmUnIDogJ2FkZCddKCdoaWRlJyk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgICAgICB9KS5sZW5ndGg7XG5cbiAgICAgICAgICB1bmF2YWlsYWJsZUVsLmNsYXNzTGlzdFtoYXNSZXN1bHRzID8gJ2FkZCcgOiAncmVtb3ZlJ10oJ2hpZGUnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogSW5zZXJ0cyBhIG5ldyBjb2RlIGNlbGwgYWJvdmUgd2l0aCBhIFJBTUwgQVBJIGNsaWVudCBhbmQgZXhlY3V0ZXMgaXQuXG4gKi9cbkFwcC5WaWV3LkVkaXRvckNlbGwucHJvdG90eXBlLm5ld1JBTUxBYm92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHNlbGVjdEFQSURlZmluaXRpb24oY3JlYXRlQXBpQ2xpZW50Q2VsbCh0aGlzLCAncHJlcGVuZCcpKTtcbn07XG5cbi8qKlxuICogSW5zZXJ0cyBhIG5ldyBjb2RlIGNlbGwgYmVsb3cgd2l0aCBhIFJBTUwgQVBJIGNsaWVudCBhbmQgZXhlY3V0ZXMgaXQuXG4gKi9cbkFwcC5WaWV3LkVkaXRvckNlbGwucHJvdG90eXBlLm5ld1JBTUxCZWxvdyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHNlbGVjdEFQSURlZmluaXRpb24oY3JlYXRlQXBpQ2xpZW50Q2VsbCh0aGlzLCAnYXBwZW5kJykpO1xufTtcblxuLyoqXG4gKiBJbnNlcnQgYSBSQU1MIGRvY3VtZW50IGJ5IHVzaW5nIHRoZSBjZWxsIGJvcmRlciBidXR0b25zLlxuICovXG5BcHAuVmlldy5DZWxsQnV0dG9ucy5jb250cm9scy5wdXNoKHtcbiAgbGFiZWw6ICAgJ0luc2VydCBBUEkgQ2xpZW50JyxcbiAgY29tbWFuZDogJ25ld1JBTUwnXG59KTtcblxuLyoqXG4gKiBJbnNlcnQgYSBSQU1MIGRvY3VtZW50IGJ5IHVzaW5nIHRoZSBjZWxsIG1lbnUgYnV0dG9ucy5cbiAqL1xuQXBwLlZpZXcuQ29kZUNlbGwucHJvdG90eXBlLmNlbGxDb250cm9scy5wdXNoKHtcbiAgbGFiZWw6ICAgJ0luc2VydCBBUEkgQ2xpZW50JyxcbiAgY29tbWFuZDogJ25ld1JBTUxCZWxvdydcbn0pO1xuIl19
(61)
});
